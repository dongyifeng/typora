> 给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 
>
> 请你统计并返回 `grid` 中 **负数** 的数目。

**示例 1：**

```python
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
```

**示例 2：**

```python
输入：grid = [[3,2],[1,0]]
输出：0
```

**示例 3：**

```python
输入：grid = [[1,-1],[-1,-1]]
输出：3
```

**示例 3：**

```python
输入：grid = [[-1]]
输出：1
```



**思路：遍历**

**代码：**

时间复杂度：O( n*m )

空间复杂度：O( 1 )

```python
def count_negatives(grid):
    res = 0
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            if grid[i][j] < 0:
                res += 1
    return res
```



**思路：倒序遍历**

遍历没有利用上顺序，可以从后向前遍历，遇到正数直接跳出。

**代码：**

时间复杂度：O( n*m )

空间复杂度：O( 1 )

```python
def count_negatives2(grid):
    res = 0
    for i in range(len(grid)):
        for j in range(len(grid[i]) - 1, -1, -1):
            if grid[i][j] >= 0: break
            if grid[i][j] < 0:
                res += 1
    return res
```





**思路：倒序遍历2**

上边的倒序遍历只利用了行为非递增顺序排列这个条件，没有利用列也为非递增顺序排列的条件。在倒序遍历时，没必要每次从最后一个位置开始，从上一行结束的位子，继续遍历，那么需要记录上一行的结束的位置：m - count - 1 

**代码：**

时间复杂度：O( n*m )

空间复杂度：O( 1 )

```python
def count_negatives2(grid):
    res = 0
    m = len(grid[0])
    count = 0
    last_count = 0
    for i in range(len(grid)):
        count = len([j for j in range(m - count - 1, -1, -1) if grid[i][j] < 0]) + last_count
        res += count
        last_count = count

    return res
```





**思路：二分查找**

由于每行是递减的，使用二分查找到第一个负数的位置 pos，那么这样拥有负数：m - 1 + pos + 1 = m - pos

```python
def count_negatives3(grid):
    m = len(grid[0])
    res = 0
    for i in range(len(grid)):
        left = 0
        right = m - 1
        pos = -1
        while left <= right:
            mid = left + ((right - left) >> 1)
            if grid[i][mid] < 0:
                pos = mid
                right = mid - 1
            else:
                left = mid + 1
        if pos != -1:
            res += m - pos
    return res
```

