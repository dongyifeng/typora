---
typora-root-url: ../../../typora
---

[TOC]

# 悲观锁 VS 乐观锁



> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。





## 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的[关系型数据库](https://www.zhihu.com/search?q=关系型数据库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"40211594"})里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。



![](/images/juc/WX20230218-191759@2x.png)



## 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。



![](/images/juc/WX20230218-191816@2x.png)







# 读写锁

读锁是可以多线程共享的，即共享锁。有读锁时，不能写。

写锁是排他锁，在更改时候不允许其他线程操作。有写锁时，不能读，其他线程也不能写。



```java
public class ReadWriteLockDemo {
    private volatile Map<Integer, Integer> map = new HashMap<>();

    public void put(int key, int value) {
        try {
            System.out.println(Thread.currentThread().getName() + " 线程正在写操作,key:" + key);
            TimeUnit.MICROSECONDS.sleep(300);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 线程写完了,key:" + key);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public Integer get(int key) {
        Integer result = 0;
        try {
            System.out.println(Thread.currentThread().getName() + " 线程正在读操作,key:" + key);
            TimeUnit.MICROSECONDS.sleep(100);
            result = map.get(key);
            System.out.println(Thread.currentThread().getName() + " 线程读完了,key:" + key + "\tresult:" + result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return result;
    }

    public static void main(String[] args) {
        ReadWriteLockDemo demo = new ReadWriteLockDemo();

        for (int i = 0; i < 5; i++) {
            int num = i;
            new Thread(() -> {
                demo.put(num, num);
            }, String.valueOf(i)).start();
        }


        for (int i = 0; i < 5; i++) {
            int num = i;
            new Thread(() -> {
                demo.get(num);
            }, String.valueOf(i)).start();
        }
    }
}
```

 

执行结果如下：没有加锁，有些读在写之前执行，导致没有读取的数据。

<img src="/images/juc/WX20230218-214749@2x.png" style="zoom: 40%;" />





```java
public class ReadWriteLockDemo {
    private volatile Map<Integer, Integer> map = new HashMap<>();

    // 创建读写锁对象
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    public void put(int key, int value) {
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 线程正在写操作,key:" + key);
            TimeUnit.MICROSECONDS.sleep(300);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 线程写完了,key:" + key);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    public Integer get(int key) {
        readWriteLock.readLock().lock();
        Integer result = 0;
        try {
            System.out.println(Thread.currentThread().getName() + " 线程正在读操作,key:" + key);
            TimeUnit.MICROSECONDS.sleep(100);
            result = map.get(key);
            System.out.println(Thread.currentThread().getName() + " 线程读完了,key:" + key + "\tresult:" + result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
        return result;
    }

    public static void main(String[] args) {
        ReadWriteLockDemo demo = new ReadWriteLockDemo();

        for (int i = 0; i < 5; i++) {
            int num = i;
            new Thread(() -> {
                demo.put(num, num);
            }, String.valueOf(i)).start();
        }


        for (int i = 0; i < 5; i++) {
            int num = i;
            new Thread(() -> {
                demo.get(num);
            }, String.valueOf(i)).start();
        }
    }
}
```



执行结果

![](/images/juc/WX20230218-215247@2x.png)