> CC 里面有一个土豪很喜欢一位女直播 kiki 唱歌，平时就经常给她点赞、送礼、私聊。最近 CC 直播平台在举行中秋之星直播唱歌比赛，假设一开始该女主播的初始人气值为 start，能够晋升下一轮人气需要刚好达到 end，土豪给主播增加人气可以采取一下三种方法：
>
> 1. 点赞；花费 x C币，人气 + 2
> 2. 送礼；花费 y C 币，人气 * 2
> 3. 私聊；花费 z C币，人气 - 2
>
> 其中 end 远大于 start 且 end 为偶数，请写一个程序帮助土豪计算一下，最少花费多少 C 币就能帮助该主播 kiki 将人气刚好达到 end，从而能够晋级下一轮？
>
> 限制 $0<x,y,z<=10000 ;\quad 0<start,end<1000000$
>
> 【例如】
>
> 输入：start = 3，end = 100，x = 1，y = 2，z = 6
>
> 输出：6



```python
def min_cost_coins(start, end, x, y, z):
    return process(start, end, x, y, z)

def process(start, end, x, y, z):
  	# basecase 当start 与 end 相等，就满足要求，不需要再花费 C 币了。
    if start == end:
        return 0
    # 尝试点赞
    a = process(start + 2, end, x, y, z) + x
    # 尝试送礼
    b = process(start * 2, end, x, y, z) + y
    # 尝试私聊
    c = process(start - 2, end, x, y, z) + z

    # 决策
    return min(a, b, c)
```

如下图：只靠 start == end 这个basecase 无法使递推收敛。需要根据题意挖掘其他 basecase，进行剪枝。

剪枝：

1. start 的值不能为负数
2. 平凡解：如果我通过只点赞使 start 到达 end，需要 A C币。那么最优解不能大于 A
3. start 的值可以大于 end 的值，然后通过私聊使 start 退回到 end，但是 start 不能大于 2 * end



![](images/screenshot-20220915-233313.png)



```java
    //start偶数，end偶数  start<=end
    public static int minCcoins1(int add, int times, int del, int start, int end) {
        if (start > end) {
            return -1;
        }
        return process(0, start, end, add, times, del, ((end - start) / 2) * add);
    }

    /** start 人气向 end 改变
     * @param cost      之前已经花了多少钱【可变】
     * @param start     起始人气【可变】
     * @param end       目标人气 【固定】
     * @param add       点赞花费 C 币 【固定】
     * @param times     送礼花费 C 币 【固定】
     * @param del       私聊花费 C 币 【固定】
     * @param limitCoin 已经使用的币大到什么程度不需要再尝试了 【固定】
     * @return
     */
    public static int process(int cost, int start, int end, int add, int times, int del,
                              int limitCoin) {
        if (cost > limitCoin) {
            return Integer.MAX_VALUE;
        }
        if (start < 0) {
            return Integer.MAX_VALUE;
        }
        if (start > (2 * end)) {
            return Integer.MAX_VALUE;
        }
        if (start == end) {
            return cost;
        }

        int min = Integer.MAX_VALUE;
        //让人气-2的方式
        int p1 = process(cost + add, start + 2, end, add, times, del, limitCoin);
        if (p1 != Integer.MAX_VALUE) {
            min = p1;
        }
        //让人气+2的方式
        int p2 = process(cost + del, start - 2, end, add, times, del, limitCoin);
        if (p2 != Integer.MAX_VALUE) {
            min = Math.min(min, p2);
        }
        //让人气*2的方式
        int p3 = process(cost + times, start * 2, end, add, times, del, limitCoin);
        if (p3 != Integer.MAX_VALUE) {
            min = Math.min(min, p3);
        }
        return min;
    }

    public static void main(String[] args) {
        int add = 6;
        int times = 5;
        int del = 1;
        int start = 10;
        int end = 30;
        System.out.println(minCcoins1(add, times, del, start, end));
    }
```



![](images/screenshot-20220915-234756.png)



```java
    //start偶数，end偶数  start<=end
    public static int minCcoins1(int add, int times, int del, int start, int end) {
        if (start > end) {
            return -1;
        }
        return process(0, start, end, add, times, del, 2 * end, ((end - start) / 2) * add);
    }

    /**
     * end 人气向 start 改变
     *
     * @param cost      之前已经花了多少钱【可变】
     * @param start     起始人气【固定】
     * @param end       目标人气 【可变】
     * @param add       点赞花费 C 币 【固定】
     * @param times     送礼花费 C 币 【固定】
     * @param del       私聊花费 C 币 【固定】
     * @param limitCoin 已经使用的币大到什么程度不需要再尝试了 【固定】
     * @return
     */
    public static int process(int cost, int start, int end, int add, int times, int del,
                              int limitAim, int limitCoin) {
        if (cost > limitCoin) {
            return Integer.MAX_VALUE;
        }
        if (end < 0) {
            return Integer.MAX_VALUE;
        }
        if (end > limitAim) {
            return Integer.MAX_VALUE;
        }
        if (start == end) {
            return cost;
        }

        int min = Integer.MAX_VALUE;
        //让人气-2的方式
        int p1 = process(cost + add, start, end - 2, add, times, del, limitAim, limitCoin);
        if (p1 != Integer.MAX_VALUE) {
            min = p1;
        }

        //让人气+2的方式
        int p2 = process(cost + del, start, end + 2, add, times, del, limitAim, limitCoin);
        if (p2 != Integer.MAX_VALUE) {
            min = Math.min(min, p2);
        }

        if ((end & 1) == 0) {
            //让人气*2的方式
            int p3 = process(cost + times, start, end / 2, add, times, del, limitAim, limitCoin);
            if (p3 != Integer.MAX_VALUE) {
                min = Math.min(min, p3);
            }
        }
        return min;
    }

    public static void main(String[] args) {
        int add = 6;
        int times = 5;
        int del = 1;
        int start = 10;
        int end = 30;
        System.out.println(minCcoins1(add, times, del, start, end));
    }
```



```java
    public static int minCcoins2(int add, int times, int del, int start, int end) {
        if (start > end) {
            return -1;
        }
        int limitCoin = ((end - start) / 2) * add;
        int limitAim = 2 * end;
        int[][] dp = new int[limitCoin + 1][limitAim + 1];

        for (int cost = 0; cost < limitCoin + 1; cost++) {
            for (int aim = 0; aim < limitAim + 1; aim++) {
                if (aim == end) {
                    dp[cost][aim] = cost;
                } else {
                    dp[cost][aim] = Integer.MAX_VALUE;
                }
            }
        }
        
        for (int cost = limitCoin; cost >= 0; cost--) {
            for (int aim = 0; aim < limitAim + 1; aim++) {
                if (cost + add <= limitCoin && aim + 2 <= limitAim) {
                    dp[cost][aim] = Math.min(dp[cost][aim], dp[cost + add][aim + 2]);
                }

                if (cost + del <= limitCoin && aim - 2 >= 0) {
                    dp[cost][aim] = Math.min(dp[cost][aim], dp[cost + del][aim - 2]);
                }

                if (cost + times <= limitCoin && aim * 2 <= limitAim) {
                    dp[cost][aim] = Math.min(dp[cost][aim], dp[cost + times][aim * 2]);
                }
            }
        }

        return dp[0][start];
    }
```



> 给定数组 arr，arr 中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim 代表要找的钱数，求换钱有多少种方法。
>
> 【例如】arr = [ 5, 10, 25, 1 ] , aim = 0 ；返回 1
>
> 组成 0 元的方法有 1 种，就是所有面值的货币都不用
>
> 
>
> arr = [ 5, 10, 25, 1 ] , aim = 15 ；返回 6
>
> 1. [ 5, 5, 5 ]  
>
> 2. [ 5, 10 ]
>
> 3. [10, 1, 1, 1, 1, 1 ]
>
> 4. [ 5, 5, 1, 1, 1, 1, 1 ] 
>
> 5. [ 5, 1, 1, 1, 1, 1 ,1, 1, 1, 1, 1  ]
>
> 6. [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] 
>
>    
>
> arr = [ 3, 5 ] , aim = 2 ；返回 0
>
> 任何方法都无法组成 2 元。



动态规划模型：L --> R 



每种银币都可以使用 0 ~ n，但是保证 coins[i] * count <= aim

arr = [ 5, 10, 25, 1 ] , aim = 15 ；返回 6

- 使用 0 张 5元的硬币，让 arr = [ 10, 25, 1 ] 组成 aim = 15 ；结果为  res1 
- 使用 1 张 5元的硬币，让 arr = [ 10, 25, 1 ] 组成 aim = 10 ；结果为  res2
- 使用 2 张 5元的硬币，让 arr = [ 10, 25, 1 ] 组成 aim = 5 ；结果为  res3
- 使用 3 张 5元的硬币，让 arr = [ 10, 25, 1 ] 组成 aim = 0 ；结果为  res4
- res = res1 + res2 + res3 + res4 



```python
# index 每次处理使用货币下边【变量】；process1 每次调用处理一个货币
# aim 剩余目标值【变量】
def process1(arr, index, aim):
    if index == len(arr):
        return 1 if aim == 0 else 0
    res = 0
    count = 0
    while arr[index] * count <= aim:
        res += process1(arr, index + 1, aim - arr[index] * count)
        count += 1
    return res

def coins1(arr, aim):
    if not arr or aim < 0:
        return 0
    return process1(arr, 0, aim)

print(coins1[5, 10, 25, 1],15)
```



index, aim 是变量，所以 dp 是个二维表 

```python
def coins2(arr, aim):
    if not arr or aim < 0:
        return 0

    dp = [[0] * (aim + 1) for _ in range(len(arr) + 1)]

    
    for i in range(len(arr) + 1):
        dp[i][0] = 1

    for i in range(len(arr) - 2, -1, -1):
        for j in range(aim + 1):
            count = 0
            while arr[i] * count <= j and (j - arr[i] * count) >= 0:
                dp[i][j] += dp[i + 1][j - arr[i] * count]
                count += 1

    return dp[0][aim]
  
  
 def coins2(arr, aim):
    if not arr or aim < 0:
        return 0

    dp = [[0] * (aim + 1) for _ in range(len(arr))]

    # base case aim = 0 是结果就是 1
    for i in range(len(arr)):
        dp[i][0] = 1

    # base case 只使用 arr[0] 时，只有 aim = arr[0] * i 时 等于 1
    for i in range(1, aim + 1):
        if arr[0] * i < aim + 1:
            dp[0][arr[0] * i] = 1

    # 
    for i in range(1, len(arr)):
        for j in range(1, aim + 1):
            count = 0
            while arr[i] * count <= j:
                dp[i][j] += dp[i - 1][j - arr[i] * count]
                count += 1

    return dp[len(arr) - 1][aim]
```



斜率优化

```python
def coins3(arr, aim):
    if not arr or aim < 0:
        return 0

    dp = [[0] * (aim + 1) for _ in range(len(arr))]

    for i in range(len(arr)):
        dp[i][0] = 1

    for i in range(1, aim + 1):
        if arr[0] * i < aim + 1:
            dp[0][arr[0] * i] = 1

    for i in range(1, len(arr)):
        for j in range(1, aim + 1):
            dp[i][j] = dp[i - 1][j]
            dp[i][j] += dp[i][j - arr[i]] if (j - arr[i]) >= 0 else 0

    return dp[len(arr)-1][aim]
```





> 给定数组 arr，arr 中所有的值都为正整数。每个值代表一种面值的货币，每种面值的货币只可使用一张，再给定一个整数 aim 代表要找的钱数，求换钱有多少种方法。



每种硬币都有两种可能性：

- 使用
- 不使用



暴力递归：

```python
def process2(arr, index, aim):
    if index == len(arr):
        return 1 if aim == 0 else 0

    return process2(arr, index + 1, aim - arr[index]) + process2(arr, index + 1, aim)

def coins2(arr, aim):
    if not arr or aim < 0:
        return 0
    return process2(arr, 0, aim)
```



动态规划：

```python
def coins5(arr, aim):
    if not arr or aim < 0:
        return 0
    dp = [[0] * (aim + 1) for _ in range(len(arr))]

    for i in range(len(arr)):
        dp[i][0] = 1

    # base case 只使用 arr[0] 时，由于只能使用一次，aim == arr[0]时为 1
    if arr[0] <= aim:
        dp[0][arr[0]] = 1

    for i in range(1, len(arr)):
        for j in range(1, aim + 1):
            dp[i][j] = dp[i - 1][j]
            dp[i][j] += dp[i - 1][j - arr[i]] if j - arr[i] >= 0 else 0

    return dp[len(arr) - 1][aim]
```



> 现有 n1 + n2 种面值的硬币，其中前 n1 种为普通币，可以取任意枚，后 n2 种为纪念币，每种最多只能取一枚，每种硬币有一个面值，问能用多少种方法拼出 m 个面值？



可能性分析

arbitrary= [ 2, 3, 5 ] , only_one= [ 1, 2, 4 ] , m = 10

- arbitrary 对 m 贡献 0 元，次数 a  ，only_one 贡献 10 ，次数 b；结果为  res1 = a * b
- arbitrary 对 m 贡献 1 元，次数 c  ，only_one 贡献 9 ，次数 d；结果为  res2 = c * d
- arbitrary 对 m 贡献 2 元，次数 e  ，only_one 贡献 f ，次数 d；结果为  res3 = e * f
- ...
- arbitrary 对 m 贡献 10 元，次数 e  ，only_one 贡献 f ，次数 0；结果为  resk = x * y
- res = res1 + res2 + ...+ resk



为了计算方便，我们提前计算出 arbitrary 的 dp1 和 only_one 的 dp2。在上边尝试时，只需直接查询结果即可。



```python
def coins1(arr, aim):
    if not arr: return
    dp = [[0] * (aim + 1) for _ in range(len(arr))]

    for i in range(len(arr)):
        dp[i][0] = 1

    for i in range(1, aim + 1):
        if arr[0] * i < aim + 1:
            dp[0][arr[0] * i] = 1

    for i in range(1, len(arr)):
        for j in range(1, aim + 1):
            dp[i][j] = dp[i - 1][j]
            dp[i][j] += dp[i][j - arr[i]] if (j - arr[i]) >= 0 else 0

    return dp


def coins2(arr, aim):
    if not arr: return
    dp = [[0] * (aim + 1) for _ in range(len(arr))]

    for i in range(len(arr)):
        dp[i][0] = 1

    if arr[0] <= aim:
        dp[0][arr[0]] = 1

    for i in range(1, len(arr)):
        for j in range(1, aim + 1):
            dp[i][j] = dp[i - 1][j]
            dp[i][j] += dp[i - 1][j - arr[i]] if j - arr[i] >= 0 else 0

    return dp

def money_ways(arbitrary, only_one, money):
    if money < 0: return 0
    if not arbitrary and not only_one:
        return 1 if money == 0 else 0

    dp_1 = coins1(arbitrary, money)
    dp_2 = coins2(only_one, money)
    n_1 = len(arbitrary) - 1
    n_2 = len(arbitrary) - 1
    if not dp_1: return dp_2[n_2][money]
    if not dp_2: return dp_1[n_1][money]

    res = 0
    for i in range(money + 1):
        res += dp_1[n_1][i] * dp_1[n_2][money - i]
    return res
```

