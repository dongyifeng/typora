来源：华为

> 给定两个数组 A 和 B，长度都是 N
>
> A[i] 不可以在 A 中与其他数交换，只可以选择和 B[i] 交换（0<= i < n）
>
> 你的目的是让 A 有序，返回你能不能做到



**思路：递归**

A[i] 只能 B[i] 交换或者不交换，两种选择。可以使用递归，遍历这两选择。



在 index = i 时刻，A[i] 之前的子数组是升序，如果不是升序，之前就已经返回 False 了。

不需要真正交换 A[i] 和 B[i] 要保持升序，只需要知道 pre 和 A[index] 和 B[index] 的大小关系就可以了。

**代码：**

```python
def can_sort(A, B):
    if not A or len(A) < 2:
        return True
    return process(A, B, 1, True) or process(A, B, 1, False)

def process(A, B, index, swap):
    if len(A) == index:
        return True

    pre = B[index - 1] if swap else A[index - 1]
    # 不交换：如果 pre > A[index] 就不是升序了
    p1 = False if pre > A[index] else process(A, B, index + 1, False)
    # 交换：如果 pre > B[index] 就不是升序了
    p2 = False if pre > B[index] else process(A, B, index + 1, True)

    return p1 or p2

print(can_sort([3, 2, 1, 5, 6], [0, 6, 4, 3, 1]))
```



**思路：动态规划**

所有暴力递归，都可以优化为动态规划。

暴力递归，更符合人的思维，方便实现，实现后在优化为动态规划，这是套路。



