---
typora-root-url: ../../../../typora
---

[TOC]

# System.gc() 理解

通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，<font color=green>会显示触发 Full GC</font>，同时对老年代和新生代进行回收，尝试释放垃圾对象占用的内存。

<font color=red>注意：System.gc() 无法保证对垃圾收集器的调用。System.gc() 仅仅是提醒或者建议应该垃圾回收，不一定执行</font>

如下图：在 System.gc() 时，有时执行，有时不执行。

<img src="/images/java/WX20230110-100034@2x.png" style="zoom:40%;" />



 如下图：触发了 Full GC，在 GC 时 buffer 的数据还有指针，不能被回收，最终被放入了老年代。

<img src="/images/java/WX20230110-101340@2x.png" style="zoom:33%;" />



如下图：触发了 Full GC，在 GC 时 buffer 是不可达，被垃圾回收（在 YoungGC 时被回收），回收完毕后，新生代和老年代占用内存小于 10MB。

<img src="/images/java/WX20230110-104258@2x.png" style="zoom:33%;" />



如下图：触发了 Full GC，在 GC 时 buffer 从新生代升级到老年代，并没有被回收。首先 buffer 在代码块中，没有被销毁，存在局部变量表 1 的位置，在 localVarGC3 中执行 GC，此时的局部变量表是有效的，因此不能释放局部变量表位置 1 占用的空间。我们可以使用其他数据覆盖局部变量表位置 1 。

![](/images/java/WX20230110-110529@2x.png)



如下图：触发了 Full GC，在 Young GC 时 buffer 被回收。因为出了代码块后局部变量表位置 1被 value 的数据占用，buffer 的数据就变成不可达的状态，在垃圾回收时，就被回收了。

![](/images/java/WX20230110-111140@2x.png)



如下图：触发了两次 Full GC，在 localVarGC1() 内触发的 Full GC，buffer 所在局部变量表有效，buffer 有有效的引用，在垃圾回收时不会被回收。但是在 localVarGC5() 内触发localVarGC1，buffer 所在局部变量表失效了，buffer 变为不可达的状态，在在垃圾回收时被回收了。

![](/images/java/WX20230110-111949@2x.png)



# 内存溢出与内存泄漏



## 内存溢出（OOM）

在应用程序占用内存增长速度非常快，垃圾回收已经跟不上内存消耗的速度时，容易发生 OOM。

 在 OOM 之前一定会发生一次独占式的 <font color=red>Full GC</font> ，这时候会释放大量的内存空间，供应用程序继续使用。<font color=green>OOM 发生条件：没有空闲内存，并且垃圾收集器也无法提供更多的内存空间。</font>



**JVM 的堆内空间不足，原因有二：**

1. **Java 虚拟机的堆内存设置不够**
   1. 可能存在内存泄漏问题
   2. JVM 堆大小指定数值偏小：通过参数 -Xms、-Xmx 来调整
2. **代码中创建了大量对象，并且长时间不能被垃圾收集器收集（再存被引用）**
   1. 对于老版本的 JDK，永久代的大小是有限的，永久代垃圾回收非常不积极，所以当不断添加新类型时，永久代会出现 OOM 非常多见。<font color=green>java.lang.OutOfMemoryError: PermGen space</font>
      1. 在运行时存在大量动态类型生成的场合
      2. 类似 intern 字符串缓存占用大多空间
   2. 随着元数据区的引用，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观。<font color=green>java.lang.OutOfMemoryError: Metaspace </font>



<font color=orange>注意：当我们要去分配一个超大对象，该对象的大小超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以不进行 Full GC 直接抛出 OutOfMemoryError</font>



## 内存泄漏（Memory Leak）

内存泄漏也称作“存储泄漏”。<font color=red>严格来说：只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</font>

 <font color=red>宽泛意义：由于一些不好的编程习惯，导致一些不必要的对象的生命周期变得很长导致OOM，也可以叫做内存泄漏</font>

内存泄漏有可能导致 OOM，也是必然的。



如下图：忘记了断开没有引用（橙色线），导致一些对象（橙色圆形）无法被垃圾收回

![](/images/java/WX20230110-153714@2x.png)



举例：

1. 单例模式
   1. 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有外部对象的引用的话，那么这个外部对象是不能被回收的，可能会导致内存泄漏的产生。
2. 一些提供 close 的资源未关闭导致内存泄漏
   1. 数据库连接（datasource.getConnection()）,网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。



# Stop The World

Stop-the-World 简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<font color=green>停顿产生时整个应用程序都会被暂停，没有任何响应</font>，有点像卡死的感觉。



场景：可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。

-   分析工作必须在一个能确保一致性的快照中进行。
- 一致性指整个分析期间整个执行系统看起来像冻结在某个时间点上。
- <font color=green>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。</font>

![](/images/java/1000.webp)



被 SWT 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。

- 所有的 GC 都会 SWT，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
- SWT 是 JVM 在<font color=green>后台自动发起和自动完成</font>的。
- 开发中不要使用 System.gc()；会导致 Stop-the-World 的发生。



# 垃圾回收的并行与并发



## 程序的并发(Concurrent)

并发：在操作系统中，同<font color=green>一个时间段中</font>有几个程序都处于运行状态中，且这几个程序都是在<font color=green>同一个处理器</font>上运行。

并发不是真正意义上的”同时进行“，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。

<img src="/images/java/WX20230110-200128@2x.png" style="zoom:50%;" />

## 程序的并行(Parallel)



- 当系统有一个以上的 CPU（CPU 核数） 时，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）
- 适合科学计算，后台处理等若交互场景。



<img src="/images/java/WX20230110-200428@2x.png" style="zoom:50%;" />



## 并发VS并行

并发：**多个事情**，<font color=red>**在同一时间段内同时发生了。**</font>

并行：**多个事情**，<font color=red>**在同一时间点内同时发生了。**</font>



- 并发的多个任务之间<font color=green>相互抢占资源。</font>
- 并行的多个任务之间<font color=green>不相互抢占资源。</font>



## 垃圾回收的并行与并发

- 并行（Parallel）：<font color=green>多条垃圾收集器线程并行工作</font>，此时用户线程仍处于等待状态。
  - ParNew、Parallel Scavenge、Parallel Old
- 串行（Serial）：
  - 相较于并行的概念，单线程执行

<img src="/images/java/WX20230110-204818@2x.png" style="zoom:33%;" />



### 垃圾回收的并发

并发（Concurrent）：指<font color=green>用户线程与垃圾回收线程在同一个时间段同时执行</font>（但不一定是并行，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。



# 安全点与安全区域



## 安全点

程序执行时并非在所有地方都能停顿下来开始执行 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为”安全点（Safepoint）“。



Safe Point 的选择很重要，<font color=green>如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题。</font> 大部分指令的执行时间非常短暂，通常会根据<font color=red>”是否具有让程序长时间执行的特征“</font> 为标准。比如：选择一些执行时间较长的指令作为 Safe Point，比如：<font color=green>方法调用、循环跳转、异常跳转</font>等。



**如果在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？**

- **抢先式中断（目前没有虚拟机采用了）**
  - 首先中断所有线程，如果还有线程不在不在安全点，就恢复该线程，让其跑到安全点。
- **主动式中断**
  - 设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮训这个标志，如果中断标志为真，则将自己进行中断挂起。



## 安全区域

 SafePoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的Safepoint 。但是，程序<font color=green>”不执行“</font>的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，<font color=green>”走“</font> 到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。



<font color=red>**安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。**</font>我们也可以把 Safe Region 看做是 Safepoint 的扩展。



   **实际执行时**

1. 当线程运行到 Safe Region 的代码时，首先标识该线程已经进入 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程（不需要暂停）。
2. 当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止。



# 引用

- <font color=green>**强引用（Strong Reference）**</font>：最传统的”引用“的定义，在程序中普遍存在的引用赋值，即类似”Object obj = new Object()“ 这种引用关系。<font color=red>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</font>
- <font color=green>**软引用（Soft Reference）**</font>：在系统内存溢出之前，会把这些对象列入回收范围之中进行<font color=red>二次回收</font>。如果二次回收之后还是没有足够的内存，才会抛出内存溢出异常。
- <font color=green>**弱引用（Weak Reference）**</font>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<font color=red>无论内存空间是否足够，都会回收掉被弱引用关联的对象。</font>
- <font color=green>**虚引用（Phantom Reference）**</font>：一个对象是否有虚引用的存在，完全不会影响对其生存时间构成影响，也无法通过虚引用来获得一个对象实例。为一个对象<font color=red>设置虚引用关联的唯一目的：能在这个对象被垃圾回收时收到一个系统通知</font>。监控对象被回收。

 

## 强引用（Strong Reference）

- <font color=orange>普通系统 99% 以上都是强引用，也是默认的引用类型。</font>
- <font color=orange>强引用的对象是可触及，垃圾收集器就永远不会回收掉被强引用的对象。</font>
-  <font color=orange>强引用时造成 Java 内存泄漏的主要原因之一。</font>



## 软引用（Soft Reference）

- <font color=red>内存不足及回收（类似缓存），内存足够不回收 </font>
- 软引用时用来描述一些还有用，但非必须的对象。<font color=orange>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，</font> 如果二次回收之后还是没有足够的内存，才会抛出内存溢出异常。
- 软引用通常用来实现内存敏感的缓存，这样保证了使用了缓存的同时，不会耗尽内存。

在 JDK 1.2 之后提供了 java.lang.ref.SoftReference 类来实现软引用

```java
        Object obj = new Object();
        // 创建对象，建立软引用
        SoftReference<Object> softReference = new SoftReference<Object>(obj);
        // 销毁强引用
        obj = null;
```



```java
        // 创建对象，建立软引用
        SoftReference<Object> softReference1 = new SoftReference<Object>(new Object());
```



代码演示软引用对象的垃圾回收

```java
// -Xms10m -Xmx10m
public class SoftReferenceTest {

    public static class User {
        public int id;
        public String name;

        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "[id=" + id + ",name=" + name + "]";
        }
    }


    public static void main(String[] args) {
        // 创建对象，建立软连接
        SoftReference<User> userSoftReference = new SoftReference<>(new User(1, "dyf"));

        // 从软引用中重新获取引用对象
        System.out.println(userSoftReference.get());

        System.gc();
        System.out.println("After GC");
        // 由于堆内空间足够，所以不会回收软引用可达对象
        System.out.println(userSoftReference.get());

        try {
            // 让系统认为内存资源紧张、不够
            byte[] b = new byte[1024 * 1024 * 7];
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 在报 OOM 之前，垃圾回收器会回收软引用的可达对象
            System.out.println(userSoftReference.get());
        }
    }
}
```



![](/images/java/WX20230112-101648@2x.png)



## 弱引用（Weak Reference）

- <font color=red>**发现即回收** </font>
- 软引用时用来描述一些还有用，但非必须的对象。<font color=green>只被弱引用的对象只能生存到下一次垃圾回收为止</font>。在系统 GC 时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象。
-  <font color=green>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</font>
- <font color=green>弱引用对象更容易、更快被 GC 回收</font>（软引用还需一套算法判断内存是否不够，弱引用发现即回收）



在 JDK 1.2 之后提供了 java.lang.ref.WeakReference 类来实现软引用

```java
 WeakReference<Object> wr = new WeakReference<>(new Object());
```



使用 WeakHashMap 存储数据，当 GC 回收时，其内部的对象都会被回收。

```java
WeakHashMap<String, String> weakHashMap = new WeakHashMap<>();
```



代码演示弱引用对象的垃圾回收

```java
    public static class User {
        public int id;
        public String name;

        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "[id=" + id + ",name=" + name + "]";
        }
    }

    public static void main(String[] args) {
        // 构造了弱引用
        WeakReference<User> user = new WeakReference<>(new User(1,"dyf"));

        // 从弱引用中重新获取对象
        System.out.println(user.get());

        System.gc();
        
        // 不管当前内存空间是否足够，都会回收它的内存
        System.out.println("After GC");
        System.out.println(user.get());
    }
```

![](/images/java/WX20230112-104919@2x.png)



## 虚引用（Phantom Reference）

- <font color=red>**对象回收跟踪** </font>
- 虚引用也称 ”幽灵引用“、”幻影引用“，是所有引用类型中最弱的一个。
- 一个对象是否有虚引用的存在，完全不会影响对其生存时间构成影响，也无法通过虚引用来获得一个对象实例。为一个对象<font color=red>设置虚引用关联的唯一目的：能在这个对象被垃圾回收时收到一个系统通知</font>。监控对象被回收。
- 虚引用必须和引用队列一起使用。虚引用在创建时，必须提供一个引用队列作为参数。当垃圾收集器准备回收一个对象时，如果发现它还有一个虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
- <font color=green>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</font>



在 JDK 1.2 之后提供了 java.lang.ref.PhantomReference 类来实现软引用

```java
        ReferenceQueue referenceQueue = new ReferenceQueue();
        PhantomReference<Object> objectPhantomReference = new PhantomReference<Object>(new Object(), referenceQueue);
```



代码演示虚引用对象的垃圾回收

```java
   // 当前类对象的声明
    public static PhantomReferenceTest obj;
    // 引用队列
    static ReferenceQueue<PhantomReferenceTest> referenceQueue = null;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("PhantomReferenceTest.finalize()");
        // 复活
        obj = this;
    }

    public static class CheckRefQueue extends Thread {
        // 监控 PhantomReferenceTest 对象被回收
      	@Override
        public void run() {
            while (true) {
                if (referenceQueue != null) {
                    PhantomReference<PhantomReferenceTest> objt = null;
                    try {
                        objt = (PhantomReference<PhantomReferenceTest>) referenceQueue.remove();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if (objt != null) {
                        System.out.println("追踪垃圾回收过程：PhantomReferenceTest 实例被 GC 了");
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread thread = new CheckRefQueue();
        // 设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束
        thread.setDaemon(true);
        thread.start();


        referenceQueue = new ReferenceQueue<>();
        obj = new PhantomReferenceTest();

        PhantomReference<PhantomReferenceTest> phantomReference = new PhantomReference<>(obj, referenceQueue);
        try {
            // 不可获取虚引用中的对象
            System.out.println(phantomReference.get());

            // 将强引用去除
            obj = null;
            // 第一次进行 GC，由于对象可复活，GC 无法回收该对象
            System.gc();
            Thread.sleep(1000);
            System.out.println(obj == null ? "obj 是 null" : "obj 可用");

            System.out.println("第 2 次 GC");
            obj = null;
            // 一旦将 obj 对象回收，就会将此虚引用存放到引用队列中
            System.gc();
            Thread.sleep(1000);
            System.out.println(obj == null ? "obj 是 null" : "obj 可用");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

![](/images/java/WX20230112-112157@2x.png)

