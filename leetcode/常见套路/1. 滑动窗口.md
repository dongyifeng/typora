[TOC]

# 定义

滑动窗口模式是用于<font color="red">数组或链表</font>上，从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。

窗口大小可以保持恒定，也可以增大或者减小。

![](/Users/dongyifeng/dongyf/git/typora/leetcode/images/v2-dc7225063817b561d916ceca6f5b7477_r.png)

## **算法思想**

1. 在序列中使用双指针中的 `左右指针` 技巧，初始化 `left = right = 0`, 把索引闭区间`[left, right]` 称为一个 `窗口`
2. 先不断地 `增加 right 指针扩大窗口[ left, right]`,直到窗口中的序列符号要求。
3. 此时，停止增加 right，转而 `不断增加 left 指针缩小窗口[left, right]`,直到窗口中的序列不再符合要求。同时，`每次增加 left 前，都要更新一轮结果`。
4. 重复第 2 和第 3 步，直到 right 到达序列的尽头。

思路其实很简单：第 2 步相当于在寻找一个 `可行解`，然后第 3 步在 `优化这个可行解`，最终找到`最优解`。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。



## **算法模板**

1. 单层循环

```python
def template(nums):
    # 初始化窗口两端
    left = right = 0
    n = len(nums)
    # 滑动窗口
    slide_win = []
		# 结果值
    rst = 0

    while right < n:
        slide_win.append(nums[right])
        # 还没找到一个可行解
        if not avaliable(slide_win):
            # 扩大窗口
            right += 1
        else:
            # 找到一个可行解，更新结果值
            rst = update()
            # 缩小窗口
            left += 1
    return rst
```

2. 双层循环

```python
def template(nums):
    # 初始化窗口两端
    left = right = 0
    n = len(nums)
    # 滑动窗口
    slide_win = []
		# 结果值
    rst = 0

    while right < n:
        slide_win.append(nums[right])
        # 还没找到一个可行解
        if not avaliable(slide_win):
            # 扩大窗口
            right += 1
            continue
        # 循环更新可行解
        while avaliable(slide_win):
            # 找到一个可行解，更新结果值
            rst = update()
            # 缩小窗口
            left += 1
    return rst
```



场景：

1. 问题的输入的是线性数据结构：链表，数组，字符串...
2. 要求查找：最长、最短的子字符串，子数组或所需的值。



常见问题：

1. 大小为 K 的子数组的最大和（简单）Leetcode 325
2. 带有 K 个不同字符的最长字符串（中等）
3. 寻找字符相同但排序不一样的字符串（困难）

# Leetcode

## 剑指 Offer 48. 最长不含重复字符的子字符串

> 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

**示例 1:**

```python
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```python
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

```

**示例 3:**

```python
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



```python
from collections import deque

def length_of_longest_substring(s):
    if not s: return 0

    # 初始化窗口右端
    index = 0
    n = len(s)
    # 滑动窗口：需要一端进，一端出，因此考虑采用队列
    slide_win = deque()
    # 因为在滑动过程中需要不断的从窗口中增减元素，因此需要一个变量来保持最大窗口长度
    max_len = 1

    while index < n:
        # 优化点：还没有遍历的元素长度 + 当前的窗口的长度 <= max_len，则直接返回
        if len(slide_win) + (n - index) <= max_len:
            return max_len
        # 如果当前元素没有在滑动窗口中，则加入，并且窗口扩大
        if s[index] not in slide_win:
            slide_win.append(s[index])
            index += 1
        else:
            # 如果当前元素已经在窗口中，则更新最大窗口长度
            max_len = max(max_len, len(slide_win))
            # 窗口缩小，对端不变
            slide_win.popleft()

    return max(max_len, len(slide_win))

print(length_of_longest_substring("abcabcbb"))
```



## 1438. 绝对差不超过限制的最长连续子数组

> 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。
>
> 如果不存在满足条件的子数组，则返回 0 。

**示例 1：**

```python
输入：nums = [8,2,4,7], limit = 4
输出：2 
解释：所有子数组如下：
[8] 最大绝对差 |8-8| = 0 <= 4.
[8,2] 最大绝对差 |8-2| = 6 > 4. 
[8,2,4] 最大绝对差 |8-2| = 6 > 4.
[8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
[2] 最大绝对差 |2-2| = 0 <= 4.
[2,4] 最大绝对差 |2-4| = 2 <= 4.
[2,4,7] 最大绝对差 |2-7| = 5 > 4.
[4] 最大绝对差 |4-4| = 0 <= 4.
[4,7] 最大绝对差 |4-7| = 3 <= 4.
[7] 最大绝对差 |7-7| = 0 <= 4. 
因此，满足题意的最长子数组的长度为 2 。
```


**示例 2：**

```python
输入：nums = [10,1,2,4,7,2], limit = 5
输出：4 
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
```



**示例 3：**

```python
输入：nums = [4,2,2,2,4,4,2,2], limit = 0
输出：3
```



```python
from collections import deque

def longest_sub_array1(nums, limit):
    # 初始化窗口右端
    index = 0
    n = len(nums)
    # 滑动窗口：需要一端进，一端出，因此考虑采用队列
    slide_win = deque()
    # 因为在滑动过程中需要不断的从窗口中增减元素，因此需要一个变量来保持最大窗口长度
    rst = 0

    while index < n:
        if not slide_win:
            slide_win.append(nums[index])
            index += 1
            continue
			 # 获取 max_value 和 min_value 效率低下
        max_value = max(max(slide_win), nums[index])
        min_value = min(min(slide_win), nums[index])
				# 如果当前元素没有在滑动窗口中，则加入，并且窗口扩大
        if max_value - min_value <= limit:
            slide_win.append(nums[index])
            index += 1
        else:
            rst = max(len(slide_win), rst)
            # 窗口缩小，对端不变
            slide_win.popleft()

    return max(len(slide_win), rst)
  
print(longest_sub_array1([8, 2, 4, 7], 4))
print(longest_sub_array1([10, 1, 2, 4, 7, 2], 5))
print(longest_sub_array1([4, 2, 2, 2, 4, 4, 2, 2], 0))
```



<font color=red>上边实现：获取窗口 max_value 和 min_value 效率非常低。可以使用最大堆和最小堆提高效率。</font>

分别用最大堆和最小堆实现两个窗口，提高效率。但是排序后窗口，丢失了原始index 信息，索引在堆中保存原始索引的信息。

需要同时维护（push 和 pop）最大堆和最小堆。



```python
# 优化max 和 min
def longest_sub_array2(nums, limit):
    n = len(nums)
    # 因此采用大顶堆和小顶堆
    max_hq = []
    min_hq = []

    # 因为在滑动过程中需要不断的从窗口中增减元素，因此需要一个变量来保持最大窗口长度
    rst = 1
    right = left = 0
    while right < n:
        if n - left <= rst:
            return rst

        # 将当前元素及其索引放入堆中，因为 python 只有小顶堆，因此这里采用负值来模拟大顶堆
        # pop 时需要根据元素的索引，索引在堆中加入数据对应的索引
        heapq.heappush(max_hq, (-nums[right], right))
        heapq.heappush(min_hq, (nums[right], right))

        # 窗口的最大差值：由于max_hp 中存在负数，索引要取：-max_hq[0][0]
        diff = -max_hq[0][0] - min_hq[0][0]
        # 最大差值在允许范围内，窗口后边向前滑动，左边保持不变
        if diff <= limit:
            right += 1
            continue

        # 最大差值超过范围：
        # 更新最大窗口长度
        rst = max(rst, right - left)

        # 去掉大顶堆中在滑动窗口之外的所有最大元素
        while max_hq[0][1] <= left:
            heapq.heappop(max_hq)
        # 去掉小顶堆中在滑动窗口之外的所有最小元素
        while min_hq[0][1] <= left:
            heapq.heappop(min_hq)
        left += 1

    return max(rst, right - left)

print("-" * 100)
print(longest_sub_array2([8, 2, 4, 7], 4))
print(longest_sub_array2([10, 1, 2, 4, 7, 2], 5))
print(longest_sub_array2([4, 2, 2, 2, 4, 4, 2, 2], 0))
```

