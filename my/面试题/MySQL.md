---
typora-root-url: ../../../typora
---

[TOC]

# 锁

基于所的属性分类

- 共享锁（读锁）：当一个事物为数据加上读锁之后，其他事物只能对该数据加读锁，不能加写锁。共享锁主要为了支持并发读取数据，读取数据时不支持修改。
- 排他锁（写锁）：当一个事物为数据加上写锁之后，其他事物不能再对该数据加任何锁。数据在修改时不允许其他同时修改，也不允许其他人读取。避免出现脏数据和脏读的问题。
  

基于锁的粒度分类：

- 全局锁：Flush tables with read lock。加锁之后整个数据库实例都处于只读状态。所有的数据变更操作都会被挂起。一般由于全库备份的场景。
- 表锁：锁住整张表。
  - 粒度大，加锁简单，容易冲突。
  - 也分为：表共享锁，表排他锁。
- 行锁：锁住一行或者多行。
  - 粒度小，加锁麻烦，不容易冲突。会出现死锁。
  - 表锁速度快，但冲突多；行锁冲突少，但速度慢（需要找到对应的行再加锁）
  - 也分为：行共享锁，行排他锁。
- 页锁：锁住一页。锁的范围介于表锁和行锁之间。
  - 会出现死锁。
  - 也分为：页共享锁，页排他锁。
- 记录锁：锁住一条记录。也属于行锁
  - 精准命中记录，并且命中的条件字段是唯一索引。
- 间隙锁：锁住表记录的某个区间。当表的相邻 ID 之间出现空隙，会形成一个区间，左开右闭。
  - 
- 临建锁：可以认为是记录锁和间隙锁的组合。会锁住查询出来的记录，也会锁住查询内的所有间隙空间。
  
  

<font color=red>注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</font>





如果当事务 A 对表里的行加排他锁成功之后，就设置一个状态告诉后面的人，你们不能对整个表加共享锁或者排他锁了，避免了后面人对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。

基于锁的状态分类

- 意向共享锁：当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。
- 意向排他锁：当一个事务试图对整个表进行加排他锁之前，首先需要获得这个表的意向排他锁。



使用场景：

- 修改数据库表结构会自动加表锁。
- 更新数据使用索引，会使用行锁。
- 更新数据未使用索引，行锁会升级为表锁
- select * from update 会使用行锁。



**死锁：**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种<font color=red>相互等待的现象</font>，若无外力作用，它们都将无法推进下去。



查看死锁：

```mysql
# 查看最近的一次的死锁
show engine innodb status
```



**处理死锁常见的策略**

- 通过 innodb block wait_timeout 来设置超时时间，一直等待直到超时。
- 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事物继续执行。



# 索引

 索引的原理：就是把无序的数据变成有序的查询。



> Mysql 聚簇和非聚簇索引的区别？

答：聚簇和非聚簇索引都是 B+ 树的数据结构。

聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种<font color=red>数据存储方式</font>。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB 的聚簇索引实际上是将索引和数据保存中同一个B+Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

非聚簇索引（NoClustered Index），又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B+Tree查找（）。

 

# 事务

> ACID 靠什么保证？

- A 原子性有 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql
- C 一致性有其他三大特性保证；程序代码要保证业务上的一致性。
- I 隔离性由 MVCC 来保证。
- D 持久性由内存 + redo log 来保证，myslq 修改数据同时和 redo log 记录这次操作，宕机的时候可以从 redo log 中恢复。

```shell
InnoDB redo log 写盘；Inno DB 事务进入 prepare 状态；
如果前边 prepare 成功；binlog 写盘，再继续将事务持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commint 状态(在 redo log 里面写一个 commint 记录)
```



> 什么是 MVCC？

答：MVCC 的全称：Multi-Version Concurrency Control。多版本并发控制。ReadView + 版本链。 



> MySQL 主从同步的原理？

1. 主库将数据库的所有的变更记录到 binlog 中。
2. 主节点 log dump 线程去读 binlog 变更内容发送给从节点。
3. 从节点的 I/O 线程接受 binlog 内容，并将其写入到 repay log 文件中。
4. 从节点的 SQL 线程读取 relay log 文件内容，对数据变更进行重放，最终保持主从数据库的一致性。

注意：主节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收的到偏移量。如果从节点发生宕机，则会自动从 position 位置发起同步。



MySQL 默认的复制方式是yibu

**全同步复制**

​		主库写入 binlog 后，所有的从库都执行完成后才返回给客户端。数据一致性好，性能低。

**半同步复制**

​		从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

<img src="/images/mysql/WX20230301-155327@2x.png" style="zoom:50%;" />

# 慢 SQL

> 对慢查询都怎么优化？

答：三个方向

- 分析 SQL，是否 load 多余的数据，对 SQL 语句分析重写。比如 Select * from table 改为 select id from table
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句尽可能的命中索引。
- 如果对 SQL 已经无法优化了，可以考虑表中的数据量是否过大，如果是的话，可以考虑横向或者纵向分表。

 

# 索引二叉树，B-树， B+树的区别?

常规数据库引擎都是采用 B- 树或者 B+树 来实现的。因为 B- 树是一种多路平衡树。用这种结构来存储大量数据的时候，<font color=red>整棵树的高度相比二叉树来说会矮很多。</font>对于数据库来说所有的数据都是存在磁盘上的，而磁盘的 IO 效率是比较低的。特别是随机磁盘IO 的情况下，效率就更低了。 所以树的高度能就能够决定磁盘IO 的次数。磁盘IO 的次数越小，那么对于性能提升就越大。这也是为什么采用 B- 树采用索引存储结构。



在 Mysql InnoDB 的存储引擎中，它用到了一种增强的 B-树结构，也就是 B+树，来作为索引和数据的存储结构。相比于 B-树的结构来说，B+ 树做了几个方面的优势。

- B+ 树的所有数据都存储在叶子节点，非叶子节点只存储索引。
- 叶子节点的数据，使用双向链表的方式进行关联。



使用 B+ 树作为索引的原因

1. B+树的非叶子节点不存储数据，所以每一层能够存储的索引数据量会增加，意味着B+树在层高相同的情况下，存储的数量比B树更多。使得磁盘 IO 次数更少。
2. 在 Mysql 中<font color=red>范围查询</font>时一个比较常用的操作，而 B+树的所有存储在叶子节点上的数据，使用了双向链表的方式来关联，所以在查询时只需要<font color=red>查询两个节点，进行遍历</font>就可以了。而 B-树需要获取所有节点。B+树在范围上查询效率更高。
3. 在数据的检索方面，由于所有的数据都存在叶子节点，所以 B+树的 IO次数会更加稳定。
4. 因为叶子节点存储了所有数据，所以B+树的全局扫描能力更加强。因为它只需要扫描叶子节点即可，而B-树需要遍历整棵树。



另外基于 B+树这样的数据结构，如果采用自增的整型数据作为主键，还能更好的避免数据增加的时候，带来的叶子节点的分裂，导致大量运算的问题。





# 聚簇索引、二级索引的主键 id 能不能由数据地址来替代，为什么？