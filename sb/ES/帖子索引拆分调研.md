帖子索引拆分调研

## 一、背景



## 二、方案

#### 1、rollover api

通过rollover api实现索引自动更新

rollover可以基于创建时间、文档大小、文档数自动生成新索引。当创建新索引之后，写入操作会以别名的方式指向新索引，后续的更新操作都会写入新索引。

可以指定一个或多个条件来触发自动更新操作：

- **max_size**:允许索引的主分片增长到的最大估计大小
- **max_docs**:索引应包含的最大文档数
- **max_age**:索引最大的年龄

```Java
POST /test-status-time/_rollover 

{

  "conditions": {

    "max_age":  "10m"

  }

}
```

该策略定义了一个触发条件，如果最大年龄超过10分钟的时候会自动新建一个索引

新建的索引会以原索引为基础做一个编号累加的操作，所以规定初始索引需要以"-"加上数字结尾，也就是需要满足正则**'^.\*-\\d+$'** 

例如:"status_time-000001"



#### 2、ILM策略

rollover操作必须调用api触发，通过ilm策略来配置自动触发

```Java
PUT /_ilm/policy/status_policy_time

{

  "policy": {

    "phases": {

      "hot": {

        "actions": {

          "rollover": {

            "max_age": "10m"

          }

        }

      }

    }

  }

}
```

ES 定义的一个索引从生到死的过程, Hot -> Warm -> Cold -> Delete 4 个阶段

- **hot:**  索引正在被积极地更新和查询。
- **warm：**索引不再被更新，但仍在被查询。
- **cold:** 索引不再被更新，并且很少被查询。这些信息仍然需要可搜索，但如果查询速度较慢也没关系。
- **delete:** 索引不再需要，可以安全地删除。

索引的ILM策略指定了适用的阶段、每个阶段执行什么操作以及何时在阶段之间进行转换

例如：上述代码指定了该策略使用在hot阶段，执行rollover操作，当最大年龄超过10m时执行



#### 3、index template

自动新建的索引不会继承旧索引的配置，会以默认的配置新建索引，所以需要配合index template使用

```Java
PUT _template/status_template_time

{

  "index_patterns": ["status_time-*"], 

  "settings": {

    "number_of_shards": 5,

    "number_of_replicas": 1,

    "index.lifecycle.name": "status_policy_time", 

    "index.lifecycle.rollover_alias": "test-status-time"

  }

}
```

定义了一个名称为"status_template_time"的索引模板，所有新建的索引只要满足"index_patterns"参数的匹配规则，就会以此模板创建索引。同时绑定了"status_policy_time"策略，只要满足该策略设置的rollover条件，则会自动以此模板新建索引。



执行"GET test-status-time" 命令可以看到

![](/Users/dongyifeng/dongyf/git/typora/images/sb/a1a5811c-b673-4f9d-96d9-535e161eaffe.png)



## 三、执行步骤：

1. 建立 Lifecycle 策略
2. 建立索引模版
3. 创建索引
4. 写入数据
5. 配置 Lifecycle 自动 Rollover 的时间间隔

## 四、可视化管理

![](/Users/dongyifeng/dongyf/git/typora/images/sb/29b59fbd-f53a-402e-9444-dd3a868260c8.png)

![](/Users/dongyifeng/dongyf/git/typora/images/sb/56ea1553-6a0f-4498-a0b6-80b2e62cb40a.png)





## 五、问题

1、半年一个索引的话，目前雪球最早的帖子为2010年，距今需要建立24个索引，后续还会不断增加，查询性能评测困难

2、目前索引更新采用的都是直接走create操作，通过es自身的同id覆盖机制实现更新。但是通过rollover自动更新索引之后，执行create操作会在两个索引出现同id的数据，造成数据的不准确性。

解决方案：可通过区分create和update消息，然后修改update操作，以update_by_query的方式更新。

3、由于 ES 是一个准实时系统，很多操作都不能实时生效，Lifecycle 的 rollover 之所以不用每次手动执行 rollover 操作是因为 ES 会隔一段时间判断一次索引是否满足 rollover 的条件， ES 检测 ILM 策略的时间默认为 10min。ILM定期运行，检查索引是否满足策略标准，并执行所需的步骤。为了避免竞争条件，ILM可能需要运行不止一次来执行完成一个操作所需的所有步骤。例如，如果ILM确定一个索引满足roll标准，它就开始执行完成roll操作所需的步骤。如果它到达不安全的点，向前推进下一个步骤，执行停止。下一次ILM运行时，ILM将从它中断的地方继续执行。这意味着即使indices.lifecycle.poll_interval被设置为10分钟，并且索引满足roll标准，在完成roll之前可能需要20分钟。

解决方案：对于我们的业务需求来说，目前看不会受到此问题影响





## 相关文档：

[Rollover Index | Elasticsearch Guide [6.8\] | Elastic](https://www.elastic.co/guide/en/elasticsearch/reference/6.8/indices-rollover-index.html)

https://www.elastic.co/guide/en/elasticsearch/reference/6.8/using-policies-rollover.html

https://blog.csdn.net/wjandy0211/article/details/109782397

https://cloud.tencent.com/developer/article/1708334