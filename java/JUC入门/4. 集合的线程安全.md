---
typora-root-url: ../../../typora
---

[TOC]

# ArrayList 线程不安全

 多线程一边向 List 添加数据，一边向读取数据。

```java
public class NotSafeDemo {
    public static void main(String[] args) {
        List list = new ArrayList();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" +   i).start();
        }
    }
}
```

报错：<font color=red>Exception in thread "线程59" java.util.ConcurrentModificationException</font>

问题：为什么出现并发修改异常？ 

```java
 public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```





![](/images/juc/WX20230216-195413@2x.png)



如何解决 List 类型线程安全问题？



## 方案一：使用 Vector

Vector 是矢量队列，是 JDK1.0 版本添加的类。

```java
    public static void main(String[] args) {
        List list = new Vector();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```

Vector 的 add 方法（ synchronized ）

```java
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
```

Vector 的 add 效率较低。



## 方案二：Collections

Collections.synchronizedList 保证 list 的同步线程安全

```java
   public static void main(String[] args) {
        List list = Collections.synchronizedList(new ArrayList<>());

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```

查看源码

```java
public boolean add(E e) {
            synchronized (mutex) {return c.add(e);}
        }
```



## 方案三：CopyOnWriteArrayList（重点）



CopyOnWriteArrayList 相当于线程安全的 ArrayList。<font color=red>**写时复制技术**</font>。

```java
    public static void main(String[] args) {
        List list = new CopyOnWriteArrayList();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```



CopyOnWriteArrayList 特性

- 线程安全
- CopyOnWriteArrayList 适合场景：List 大小很小，读远大于写，需要在遍历时防止线程间冲突。
- add()，set()，remove() 等操作开销很大，因为需要复制整个基础数组。
- 使用迭代器遍历时速度很快，且不会与其他线程发生冲突，迭代器依赖不变的数组快照。
- 迭代器支持 hasNext()，next() 等不可变操作，不支持可变操作：如 remove()



CopyOnWriteArrayList 的复制思想：<font color=green>当我们向容器中添加一个元素时，不是直接向当前容器中添加，而是先将当前容器 Copy，向 Copy 出来的容器中添加元素，添加完毕后，再将原容器的引用指向新容器。</font>

CopyOnWriteArrayList Add 源码

```java
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

<img src="/images/juc/WX20230216-202053@2x.png" style="zoom:40%;" />



CopyOnWriteArrayList  内部有个” volatile 数组 “（array）来保存数据，在”添加、修改、删除“ 数据时，都会 Copy 出一个新数组，对新数组操作完毕后，最后再将新数组复制给 “  volatile 数组  ”。<font color=red>效率很低</font>

 



# HashSep 线程不安全

 多线程一边向 HashSet 添加数据，一边向读取数据。

```java
     public static void main(String[] args) {
        Set<String> set= new HashSet<>();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                String key = UUID.randomUUID().toString().substring(0, 8);
                set.add(key);
                System.out.println(set);
            }).start();
        }
    }
```

报错：<font color=red>Exception in thread "线程59" java.util.ConcurrentModificationException</font>



使用 CopyOnWriteArraySet 替换 HashSet

```java
    public static void main(String[] args) {
	      Set<String> set = new CopyOnWriteArraySet<>();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                String key = UUID.randomUUID().toString().substring(0, 8);
                set.add(key);
                System.out.println(set);
            }).start();
        }
    }
```



# HashMap 线程不安全

 多线程一边向 HashMap 添加数据，一边向读取数据。

```java
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                String key = UUID.randomUUID().toString().substring(0, 8);
                map.put(key, key);
                System.out.println(map);
            }).start();
        }
    }
```

报错：<font color=red>Exception in thread "线程59" java.util.ConcurrentModificationException</font>



```java
    public static void main(String[] args) {
        Map<String, String> map = new ConcurrentHashMap<>();
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                String key = UUID.randomUUID().toString().substring(0, 8);
                map.put(key, key);
                System.out.println(map);
            }).start();
        }
    }
```

