

> 给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度 O(N)，且要求不能用非基于比较的排序。

算法难度：<font color=red>困难</font>



例如数组：【9	0	17	4	63	72	65	67	99】

排序后：	【0	4	9	17	63	65	67	72	99】

相邻两数的最大差值：17，63 之间的差值为：46



步骤

1. 遍历数组，获取最大值和最小值。如果最大值等于最小值，说明数组中的数全部相等，最大差值为 0
2. 设置 n + 1 个桶，每个桶的数据范围，是均分最大值和最小值。所以第一个桶和最后一个桶一定有数据。有 n 个数据，n + 1 个桶，至少有一个桶是空的，<font color=red>那么在同一个桶里的数据相差不会大于一个桶的范围，所以最大差值一定在桶与桶之间。</font>
3. 由于最大值一定在桶与桶之间，那么桶内不没有存所以的数据，只需要存最大值和最小值。
4. 遍历所以数据，计算出桶内的最大值和最小值。
5. 遍历桶，对于有数据的桶，计算桶间距（ 当前桶的min - 上一个桶 max ）。



![](images/screenshot-20220720-151852.png)



```python
def max_gap(nums):
    if not nums or len(nums) < 2: return 0
    min_value = min(nums)
    max_value = max(nums)

    if min_value == max_value: return 0
    n = len(nums)

    bucket_empty = [True] * (n + 1)
    bucket_min = [0] * (n + 1)
    bucket_max = [0] * (n + 1)

    for num in nums:
        # num 所属的桶号
        bid = get_bucket_id(num, min_value, max_value, n)
        bucket_min[bid] = num if bucket_empty[bid] else min(bucket_min[bid], num)
        bucket_max[bid] = num if bucket_empty[bid] else max(bucket_max[bid], num)
        bucket_empty[bid] = False

    # 注意第一个桶和最后一个桶必定有值
    last_max = bucket_max[0]
    res = 0
    for i in range(1, n + 1):
        if bucket_empty[i]:
            continue

        res = max(res, bucket_min[i] - last_max)
        last_max = bucket_max[i]

    return res


def get_bucket_id(num, min_value, max_value, count):
    return int((num - min_value) * count / (max_value - min_value))


def max_gap2(nums):
    if not nums or len(nums) < 2: return 0
    nums.sort()
    res = 0
    last_value = nums[0]
    for i in range(1, len(nums)):
        res = max(res, nums[i] - last_value)
        last_value = nums[i]
    return res

import random

def random_array_generator(max_size, max_value):
    size = int(random.random() * max_size)
    # 通过相减可以随机生成负数
    return [int(random.random() * max_value) - int(random.random() * max_value) for _ in range(size)]

def test():
    n = 50000
    test_max_size = 100
    test_max_value = 100

    for _ in range(n):
        nums = random_array_generator(test_max_size, test_max_value)
        if max_gap(nums) != max_gap(nums):
            print(nums)
            break
    print("Over")
```





> 给定一个数组 arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水?
>
> 比如，arr=【3，1，2，5，2，4】，根据值画出的直方图就是容器形状，该容器可以装下 5 格水。
>
> 再比如：arr=【4，5，1，3，2】，该容器可以装下 2 格水。



![](images/screenshot-20220809-203256.png)



```python
def get_water(arr):
    if not arr or len(arr) < 3: return 0
    n = len(arr)

    left_max_value = [0] * n
    right_max_value = [0] * n

    for i in range(n):
        left_max_value[i] = max(left_max_value[i - 1], arr[i])

    max_value = 0
    for i in range(n - 1, -1, -1):
        max_value = max(max_value, arr[i])
        right_max_value[i] = max_value

    res = 0
    for i in range(n):
        res += max(min(left_max_value[i], right_max_value[i]) - arr[i], 0)
    return res


def get_water2(arr):
    if not arr or len(arr) < 3: return 0
    n = len(arr)

    left_max_value = [0] * n
    right_max_value = [0] * (n + 1)

    for i in range(n):
        left_max_value[i] = max(left_max_value[i - 1], arr[i])
        right_max_value[n - 1 - i] = max(right_max_value[n - i], arr[n - 1 - i])

    res = 0
    for i in range(n):
        res += max(min(left_max_value[i], right_max_value[i]) - arr[i], 0)
    return res
```





```python

def get_water3(arr):
    if not arr or len(arr) < 3: return 0
    n = len(arr)

    left = 1
    right = n - 2
    left_max_value = arr[0]
    right_max_value = arr[-1]

    res = 0
    while left <= right:
        if left_max_value < right_max_value:
            res += max(left_max_value - arr[left], 0)
            left_max_value = max(left_max_value, arr[left])
            left += 1
        else:
            res += max(right_max_value - arr[right], 0)
            right_max_value = max(right_max_value, arr[right])
            right -= 1

    return res
```



对数器

```python
import random

def random_array_generator(max_value, max_size):
    return [int(random.random() * max_value + 1) for _ in range(int(random.random() * max_size))]

def check():
    n = 1000
    max_value = 100
    max_size = 100

    for _ in range(n):
        arr = random_array_generator(max_value, max_size)
        res1 = get_water(arr)
        res2 = get_water2(arr)
        res3 = get_water3(arr)

        if res1 != res2 or res1 != res3:
            print("Error", arr, res1, res2, res3)
    print("Game Over!")

check()
```

