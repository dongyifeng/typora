---
typora-root-url: ../../../../typora
---



[TOC]

# 基本特性

- String 字符串，使用一对 “” 引起来表示
  - String s1 = "dyf";   // 字面量的定义方式
  - String s2 = new String("hello");
- String 类声明为 final 的，不可被继承
- String 实现的接口
  - Serializable 接口：表示字符串是支持序列化的
  - Comparable 接口：表示 String 可以比较大小
- String 在 JDK 8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK 9 时改为 byte []
  - String 是堆空间中主要存储的对象，大部分 String 对象存储的都是拉丁字符，这些字符使用一个 byte 就可以存储，使用 char 存储，有一半的空间浪费了。
  - StringBuffer 和 StringBuilder 内置的 char[] 也改为 byte[]

String 中的数据使用数组存储，数组的大小一旦初始化完毕后，就不可更改，所以 String 具有不可变性。



![](/images/java/QQ20221223-101454@2x.png)





<font color=red>**字符串常量池中是不会存储相同内容的字符串的。**</font>



- 字符串常量池（String Pool）是一个固定大小的 HashTable，默认大小长度是 1009。如果放进 String Pool 非常多，就会造成严重的 Hash 冲突，从而导致链表会很长，从而降低性能。

- 使用 -XX:StringTableSize 可以设置 StringTable 的长度。
-  JDK 6 中 StringTable 默认大小为 1009
-  JDK 7 中 StringTable 默认大小为 60013
-  JDK 8 中 StringTable 默认大小为 60013，1009 是可设置的最小值，如果设置值小于1009，报错。



# 内存分配

将数据写入 String 类型常量池的两种方式

- 直接使用双引号声明出来的 String 对象会直接存储在常量池中：String info = “dyf”;
- 使用 intern() 方法。

Java 6之前，字符串常量池存在在永久代。

Java 7 将字符串常量池的位置调整到 Java 堆内。



![](/images/java/WX20221208-224955@2x.png)

![](/images/java/WX20221208-225006@2x.png)



![](/images/java/WX20221208-225021@2x.png)



# 基本操作

Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列，并且必须是指向同一个 String 实例。



```java
    public static void main(String[] args) {
        System.out.println();
        System.out.println("1");//1311
        System.out.println("2");
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");

        // 下面的字符"1" 到 "10" 不会再次加载
        System.out.println("1");
        System.out.println("2");// 1321
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");// 1321
    }
```



![](/images/java/screenshot-20221226-155431.png)





```java
    public static void main(String[] args) {
        int i = 1;
        Object obj = new Object();
        Memory memory = new Memory();
        memory.foo(obj);
    }

    private void foo(Object param) {
        String str = param.toString();
        System.out.println(str);
    }
}
```



![](/images/java/screenshot-20221226-163223.png)



# 字符串拼接操作



- 常量与常量的拼接结果在常量池：原理是编译期优化
- 常量池中不会存在相同内容的常量。
- 只要其中有一个是变量，结果就在堆中（不在字符串常量池中）相当于在堆空间中 new String 对象。变量拼接的原理是StringBuilder
- 如果拼接的结果调用 intern() 方法，则主动将常量池还没有的字符串对象方法放入池中，并返回此对象地址。



```java
    @Test
    public void test1() {
        String s1 = "a" + "b" + "c";
        String s2 = "abc";

        /**
         * 最终.java 编译成.class, 再执行.class
         * String s1 = "abc";
         * String s2 = "abc";
         */

        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
```



.class 反编译的结果

![](/images/java/screenshot-20221226-170710.png)







```java
    @Test
    public void test2() {
        String s1 = "javaEE";
        String s2 = "hadoop";
        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";
      	// 只要其中有一个是变量，结果就在堆中（不在字符串常量池中）
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        // true
        System.out.println(s3 == s4);
        // false
        System.out.println(s3 == s5);
        // false
        System.out.println(s3 == s6);
        // false
        System.out.println(s3 == s7);
        // false
        System.out.println(s5 == s6);
        // false
        System.out.println(s5 == s7);
        // false
        System.out.println(s6 == s7);

      	// 如果拼接的结果调用 intern() 方法，则主动将常量池还没有的字符串对象方法放入池中，并返回此对象地址
      	// s8 获取到字符串常量池中值为：javaEEhadoop 的地址，所以 s3==s8 为 true
        String s8 = s6.intern();
        // true
        System.out.println(s3 == s8);
    }
```



![](/images/java/WX20221226-201107@2x.png)

![](/images/java/WX20221226-201226@2x.png)



字段被 final 修饰



```java
    @Test
    public void test4() {
        final String s1 = "a";
        final String s2 = "b";
        String s3 = "ab";

        String s4 = s1 + s2;
        // true
        System.out.println(s3 == s4);
    }
```

![](/images/java/WX20221226-201741@2x.png)

针对于 final 修饰类、方法、基本数据类型、引用数据类型时，能使用 final 尽量使用。



字符串拼接性能 VS StringBuilder.append

1. StringBuilder.append 方式：自始至终只创建了一个 StringBuilder 对象
2. String 拼接方式：创建很多 StringBuilder 和 String 对象，内存占用更大，如果进行 GC，需要花费额外的时间。

 ```java
     @Test
     public void test5() {
         long start = System.currentTimeMillis();
         int highLevel = 100000;
         // 耗时：3987
 //        method1(highLevel);
         // 耗时：8
         method2(highLevel);
         long end = System.currentTimeMillis();
 
         System.out.println("cost:" + (end - start));
     }
 
     public void method1(int highLevel) {
         String src = "";
         for (int i = 0; i < highLevel; i++) {
             src += "a";
         }
     }
 
     public void method2(int highLevel) {
         StringBuilder src = new StringBuilder(highLevel);
         for (int i = 0; i < highLevel; i++) {
             src.append("a");
         }
     }
 ```

<font color=green>注意：StringBuilder 对象初始时，如果已知使用内存大小，最好给初始容量，避免频繁扩容。</font>



# intern() 的使用

![](/images/java/WX20221226-205807@2x.png)







# StringTable 的垃圾回收





# G1 中的String 去重操作