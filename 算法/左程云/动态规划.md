[TOC]

# 递归尝试套路

暴力递归到动态规划的演进路线：

<img src="images/screenshot-20220804-202437.png" height=500>





递归尝试套路

1. 从左向右尝试
2. 范围尝试：left，right



递归尝试策略评价标准

1. 单可变参数的维度
   1. 尽量使用一维参数，如果但可变参数是个数组，那么它的变化就超级多。
   2. 取值范围尽可能小
2. 可变参数的个数越少越好。

上边两个评价标准，是为了然后续 dp 表占用的空间越小越好。





# 例题

## 多少走法

> 给定一个正整数 n，一个正整数 s（1 <= s <=n）,一个正整数 e（1 <= e <=n）,一个正整数 k （k > 0）
>
> 表示从 s 点出发，走 k 步到 e 点，一共有多少走法?
>
> 【例子】n = 5；s = 2；e = 4；k = 4
>
> 1	2	3	4	5	
>
> ​	  s		  e
>
> 路径1：2 --> 3 --> 4 --> 5 --> 4
>
> 路径2：2 --> 3 --> 4 --> 3 --> 4
>
> 路径3：2 --> 3 --> 2 --> 3 --> 4
>
> 路径4：2 --> 1 --> 2 --> 3 --> 4
>
> 返回 4



递归尝试策略：从左向右策略

![](images/screenshot-20220804-204928.png)

```python
def walk_ways(n, e, k, s):
    return process(n, e, k, s)

# n 和 e 是常量
# rest 剩余步数
# cur 当前位置
def process(n, e, rest, cur):
    # base case:如果没有剩余步数了，如果刚好走到 e 位置，说明这条路是正确的返回 1，否则返回 0
    if rest == 0:
        return 1 if cur == e else 0

    # 如果 cur 在起始位置(边界)，那么只能向右走
    if cur == 1:
        return process(n, e, rest - 1, cur + 1)
    # 如果 cur 在终止位置（边界），那么只能向左走
    if cur == n:
        return process(n, e, rest - 1, cur - 1)
    # cur 既可以向左走，也可以向右走。将向左走的路径条数 + 向右走的路径条数，就是总的路径条数
    return process(n, e, rest - 1, cur - 1) + process(n, e, rest - 1, cur + 1)

print(walk_ways(5, 4, 4, 2))
```







记忆化搜索：没有位置依赖

```python
def walk_ways2(n, e, s, k):
    dp = [[-1] * (n + 1) for _ in range(k + 1)]
    return process2(n, e, k, s, dp)

#
# n 和 e 是常量
# rest 剩余步数
# cur 当前位置
def process2(n, e, rest, cur, dp):
    if dp[rest][cur] != -1:
        return dp[rest][cur]

    if rest == 0:
        dp[rest][cur] = 1 if cur == e else 0

    elif cur == 1:
        dp[rest][cur] = process(n, e, rest - 1, cur + 1)
    elif cur == n:
        dp[rest][cur] = process(n, e, rest - 1, cur - 1)
    else:
        dp[rest][cur] = process(n, e, rest - 1, cur - 1) + process(n, e, rest - 1, cur + 1)
    return dp[rest][cur]
```



严格表格的动态规划：位置依赖



<font color=green>**从递归尝试改成严格表格的动态规划步骤：**</font>

1. **分析可变参数个数：（一个可变参数需要一维表存储，两个可变参数需要二维表存储...）**
2. **标出计算终止位置**
3. **根据 basecase 确定不需要计算就可以得到答案的位置**
4. **确定普通位置的位置依赖**
5. **确定依次计算的顺序**



1. 分析可变参数个数：n 与 e 是常量，rest 与 cur 为变量，需要二维表，rest 的范围是【1~k】cur 的范围是【1~ n】因此二维表格可以使用：k + 1 行，n + 1 列

```python
def walk_ways(n, e, k, s):
    return process(n, e, k, s)
```

2. 标出计算终止位置：process(n, e, k, s) k = 4, s = 2 ,dp\[4][2]（n 与 e 常量），下图中青色节点res

3. 根据 basecase 确定不需要计算就可以得到答案的位置：basecase 为 e = 4，cur == e 时为1，其他为 0，粉色节点

   ```python
       if rest == 0:
           return 1 if cur == e else 0
   ```

4. 确定普通位置的位置依赖：

   1. 起始节点：只能向左走：黄色节点
   2. 终止节点：只能向右走：绿色节点
   3. 中间节点：可向左，可向右走：蓝色节点
   4. 箭头指向就是依赖

   ```python
   						# 起始节点
     					if j == 1:
                   dp[i][j] = dp[i - 1][j + 1]
               elif j == n:	#终止节点
                   dp[i][j] = dp[i - 1][j - 1]
               else:	# 中间节点
                   dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
   ```

5. 确定依次计算的顺序：下一行的节点依赖上一行的节点，所以是从上向下填充数据。同一行中无论是从左向右还是从右向左均可。

![](images/screenshot-20220804-224031.png)

```python
def walk_ways3(n, e, s, k):
    # 创建二维表
    dp = [[-1] * (n + 1) for _ in range(k + 1)]

     # 填充 basecase
    for i in range(n + 1):
        dp[0][i] = 1 if i == e else 0

    # 填充普通方格
    for i in range(1, k + 1):
        for j in range(1, n + 1):
          	# 此处判断，与暴力递归处理逻辑一致：拷贝过来直接改写
            # 起始节点
            if j == 1:
                dp[i][j] = dp[i - 1][j + 1]
            elif j == n:# 终止节点
                dp[i][j] = dp[i - 1][j - 1]
            else:# 中间结点
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]

    return dp[e][s]

print(walk_ways3(5, 4, 2, 4))
```



## 最少硬币数



> 给一个正整数数组 arr=【2,7,3，5,3】，每一个数表示一枚硬币，硬币可以重复。再一个 aim=10，求用硬币组成 aim，使用最少的硬币是多个？



递归尝试策略：从左向右策略

```python
def min_coins_count2(array, aim):
    return f2(array, aim, 0)


def f2(array, aim, cur):
  	# 钱不够了
    if aim < 0: return -1
  	# 上一步刚等于 aim，此时不需要硬币了
    if aim == 0: return 0
    # aim > 0 没有硬币可用了
    if cur == len(array):
        return -1

    # aim > 0 并且有硬币
    # 由于返回值有 -1，-1 会干扰求 min
    # min( f2(array, aim, cur + 1), f2(array, aim - array[cur], cur + 1))
    p1 = f2(array, aim, cur + 1)
    p2 = f2(array, aim - array[cur], cur + 1)

    if p1 == -1 and p2 == -1:
        return -1
    elif p1 == -1 or p2 == -1:
        return max(p1, p2 + 1)

    return min(p1, p2 + 1)

array = [2, 7, 3, 5, 3]
aim = 10
print(min_coins_count2(array, aim))
```

1. 分析可变参数个数：两个：aim 和 cur：aim in 【0，aim】，cur in 【0，len(array)】
2. 标出计算终止位置：dp\[ 0 ][ aim ]
3. 根据 basecase 确定不需要计算就可以得到答案的位置：aim == 0 return = 0 dp\[i][0]=0
4. 确定普通位置的位置依赖：
5. 确定依次计算的顺序：上下方向：从下向上。左右方向：均可。由于只依赖下一行的数据，不依赖同一行的数据。



```python
def min_coins_count3(array, aim):
    n = len(array)
    dp = [[-1] * (aim + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = 0
        
    for cur in range(n - 1, -1, -1):
        for rest in range(1, aim + 1):
            p1 = dp[cur + 1][rest]
            p2 = dp[cur + 1][rest - array[cur]] if rest - array[cur] >= 0 else -1
            if p1 == -1 and p2 == -1:
                dp[cur][rest] = -1
            elif p1 == -1 or p2 == -1:
                dp[cur][rest] = max(p1, p2 + 1)
            else:
                dp[cur][rest] = min(p1, p2 + 1)

    return dp[0][aim]
```







> 给一个正整数数组 arr=【2,7,3，5,3】，每一个数表示一枚硬币，硬币可以重复。再一个 aim=10，求用硬币组成 aim，有多少种硬币的组合数？

```python
def coins(array, aim):
    return f(array, aim, 0, 0)

def f(array, aim, cur, s):
    if cur == len(array):
        return 1 if s == aim else 0

    return f(array, aim, cur + 1, s) + f(array, aim, cur + 1, s + array[cur])

array = [2, 7, 3, 5]
aim = 10
print(coins(array, aim))
```



1. 分析可变参数个数：两个：s 和 cur：s in 【0，sum(array)】，cur in 【0，len(array)】
2. 标出计算终止位置：dp\[ 0 ][ 0 ]
3. 根据 basecase 确定不需要计算就可以得到答案的位置：dp\[cur][i] = 1 if s == aim else 0
4. 确定普通位置的位置依赖：
5. 确定依次计算的顺序：上下方向：从下向上。左右方向：均可。由于只依赖下一行的数据，不依赖同一行的数据。



```python
def coins2(array, aim):
    n = len(array)
    dp = [[0] * (aim + 1) for _ in range(n + 1)]
    dp[-1][-1] = 1

    for cur in range(n - 1, -1, -1):
        for rest in range(aim + 1):
            dp[cur][rest] = dp[cur + 1][rest] + (0 if rest + array[cur] > aim else dp[cur + 1][rest + array[cur]])

    return dp[0][0]
```



对数器

```python
import random

def random_array_generator(max_value, max_size):
    return [int(random.random() * max_value + 1) for _ in range(int(random.random() * max_size + 1))]

def check():
    n = 100
    max_value = 10
    max_size = 10

    for i in range(n):
        array = random_array_generator(max_size, max_value)
        aim = int(random.random() * sum(array))
        if coins(array, aim) != coins2(array, aim):
            print("ERROR", aim, array, coins(array, aim), coins2(array, aim))
    print("Game Over!")
```





