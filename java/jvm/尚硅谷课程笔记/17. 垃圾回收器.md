---
typora-root-url: ../../../../typora
---



[TOC]

# GC 分类与性能指标



## GC 分类

 按<font color=green>**线程数(垃圾回收的线程)**</font>分

- **串行垃圾回收器**：在同一段时间内只允许一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束
  - 使用场景：单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。<font color=green>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</font>
  - 在并发能力较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。
- **并行垃圾回收器**：多运用与多个 CPU 同时执行垃圾回收，提升了应用的<font color=green>吞吐量</font>。

![](/images/java/WX20230112-115255@2x.png)





按<font color=green>**工作模式**</font>分

- **独占式垃圾回收器**：独占式垃圾回收器（Stop-the-world）一旦运行，就停止应用程序中所有的用户线程，直至垃圾收集工作结束
- **并发式垃圾回收器**：并发式垃圾回收器与应用程序线程交替工作，以尽可能<font color=green>减少应用程序的停顿时间。</font>



![](/images/java/WX20230112-120018@2x.png)



按<font color=green>**碎片处理方式**</font>分

- **压缩式垃圾回收器**：
  - 压缩式垃圾回收器会在垃圾回收完成后，对存活对象进行压缩整理，消除回收后的内存碎片。
  - 再分配对象空间时使用：指针碰撞
- **非压缩式垃圾回收器**：
  - 非压缩式垃圾回收器对内存不进行压缩整理。
    - 再分配对象空间时使用：空闲列表



按<font color=green>**工作的内存区间**</font>分

- **年轻代垃圾回收器**
- **老年代垃圾回收器**



## 性能指标

- <font color=red>吞吐量：运行用户代码的时间占总运行时间的比例</font>
  - 总运行时间 = 程序的运行时间 + 内存回收的时间
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间占总运行时间的比例。
- <font color=red size=4>**暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。**</font>
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- <font color=red>内存占用：Java 堆区所占的内存大小</font>
- 快速：一个对象从诞生到被回收所经历的时间。



内存占用随着硬件的提升，内存越来越大，垃圾回收不需要频繁执行。内存增加吞吐量也随之增加，最难优化的也是最重要的的指标就成了：暂停时间。  

以上指标重点关注

- 暂停时间
- 吞吐量



## 吞吐量(throughput) VS 暂停时间

$吞吐量 = \frac{运行用户代码时间}{运行用户代码时间 \\+ GC 时间}$

吞吐量优先，意味着在单位时间内，STW 的时间最短

 

![](/images/java/WX20230112-150948@2x.png)





- 吞吐量越高，运用程序运行越快。
- 低暂停时间（低延迟）越好，用户体验越好。<font color=green>200ms 的暂停可能打断中断用户体验</font>。具有低延迟是非常重要的，提别是对于一个交互式应用程序。
- ”高吞吐量“和”低延迟“ 是一对相互竞争的目标。（就像算法中：时间复杂度和空间复杂度一样）。 
  - 如果选择以吞吐量优先，那么<font color=green>必然需要降低内存回收的执行效率</font> ，但是这样会导致一次 GC 需要更长的暂停时间来执行内存回收。
  - 相反，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收的暂停时间，也<font color=green>只能频繁地执行内存回收</font>，但这又引起年轻代内存的缩减和导致程序吞吐量的下降。



G1 垃圾回收器的标准：<font color=red>在最大吞吐量优先的情况下，降低停顿时间</font>



# 不同的垃圾回收器概述

## 垃圾收集器发展史

有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品就是我们称为：Garbage Collector。

- 1999 年随着 JDK 1.3.1 一起来的是串行方式的 Serial GC，它是第一款 GC。ParNew 垃圾收集器时 Serial 收集器的多线程版本。
- 2002 年 2 月 26 日，Parallel GC 和Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布
- Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC
- 2012 年在 JDK 1.7 版本中，引入 G1
- 2017 年在 JDK9 中 G1 变成默认的垃圾收集器，以替换 CMS。
- 2018 年 3 月，JDK10 中 G1 垃圾收集器的并行完整垃圾回收，实现并行来完善最坏情况下的延迟。
- 2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 ”No-Op（无操作）“回收器。同时引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）
- 2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）
- 2019 年 9 月，JDK13 发布。增加 ZGC，自动返回未用堆内存给操作系统。
- 2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macOS 和 Windows 上的应用。



在上述发展历史中提到：7 款经典垃圾收集器

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1



![](/images/java/WX20230112-171934@2x.png)



7 款经典垃圾收集器与分代之间的关系

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CSM
- 整堆收集器：G1

![](/images/java/WX20230112-172915@2x.png)





7 款经典垃圾收集器直接的组合

- JDK 版本小于 8，下图中所有的线都是实线。
- CMS GC 的后备方案是 Serial Old GC。CMS GC 不能在老年代空间满时回收，CMS GC 回收线程与用户线程同时进行，有可能导致垃圾回收失败，此时需要使用 Serial Old GC 进行兜底。
- 在 JDK 8 中取消类两根红色虚线的组合，在 JDK 9 中彻底将两根红色虚线删除。
- 在 JDK 14 中弃用了蓝色虚线。
- CMS GC 在 JDK 14 中被删除了。
- Parallel Scavenge GC 之所以不能跟 CMS GC 搭配，是因为 Parallel 与 CMS 框架不兼容。
- Parallel Scavenge GC 与 ParNew GC 性能差不多。 

![](/images/java/WX20230112-184921@2x.png)



- -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）
- 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID



![](/images/java/WX20230112-202701@2x.png)



![](/images/java/WX20230112-203009@2x.png)



# Serial 回收器：串行回收

- Serial 收集器是最基本、最悠久的垃圾收集器。
- Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。
- <font color=green>Serial 收集器采用复制算法（新生代）、串行回收和”Stop-the-world“ 机制的方式执行内存回收</font>。
- <font color=green>Serial Old 收集器采用标记-压缩算法、串行回收和”Stop-the-world“ 机制的方式执行内存回收</font>。
  - 运行在 Client 模式下，Serial Old 默认的老年代垃圾回收器
  -  运行在 Server 模式下
    - Serial Old 与新生代的 Parallel Scavenge 配合使用
    - Serial Old 作为老年代 CMS 收集器的兜底方案

![](/images/java/WX20230112-184921@2x.png)



Serial 收集器是一个单线程的收集器，”单线程“的意义：<font color=green>它只会使用一个 CPU 或或者一个收集线程去完成垃圾收集工作。在垃圾收集时，必须暂停其他所有的工作线程</font>，直到它收集结束（STW）。



![](/images/java/WX20230112-210036@2x.png)

 

Serial 收集器优势：<font color=red>简单而高效（与其他收集器在单线程比）</font>。在单个 CPU 环境中，Serial 收集器由于没有线程交互的开销，专心做垃圾收集，从而获得最好的效率。



使用场景：在用户的桌面应用场景中，可用的内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器也是可以接受的。



使用 -XX:+UseSerialGC 参数指定年轻代和老年代使用串行收集器。



一般在 Java Web 应用程序中不会采用串行垃圾收集器。



# ParNew 回收器：并行回收

ParNew 收集是 Serial 收集器的多线程版本。<font color=green>采用复制算法、”Stop-the-world“ 机制</font>

- Par 是 Parallel 的缩写
- New：只能处理新生代

![](/images/java/WX20230112-212501@2x.png)



# Parallel 回收器：吞吐量优先





# CMS 回收器：低延迟





# G1 回收器：区域化分代式





# 垃圾回收器总结





# GC 日志分析





# 垃圾回收器的新发展