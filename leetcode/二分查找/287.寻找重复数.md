难度：<font color=orange>中等</font>

> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
>
> 假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。
>
> 你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。

**示例 1：**

```python
输入：nums = [1,3,4,2,2]
输出：2
```



**示例 2：**

```python
输入：nums = [3,1,3,4,2]
输出：3
```



**示例 3：**

```python
输入：nums = [1,1]
输出：1
```



**示例 4：**

```python
输入：nums = [1,1,2]
输出：1
```



**思路：排序+遍历**

**代码：**

时间复杂度：O(nlogn)

时间复杂度：O(1)

<font color=red>不满足不修改变数组：不能排序</font>

```python
def findDuplicate(nums):
    nums = sorted(nums)
    for i in range(1, len(nums)):
        if nums[i - 1] == nums[i]:
            return nums[i]
```

**思路：排序 + set**

**代码：**

时间复杂度：O(n)

<font color=red>时间复杂度：O(n)</font> 。不满足要求

<font color=red>不满足不修改变数组：不能排序</font>

```python
def findDuplicate3(nums):
    nums_set = set()
    for i in range(len(nums)):
        if nums[i] in nums_set:
            return nums[i]
        nums_set.add(nums[i])
```

**思路：排序 + bitArray**

**代码：**

时间复杂度：O(n)

时间复杂度：O(1) 。不满足要求

<font color=red>不满足不修改变数组：不能排序</font>

```python
# 将二进制数据：bit 的 index 位设置为 1
def bitAdd(bit, index):
    return bit | 1 << (index - 1)


# 判断二进制数据：bit 的 index 位是否是 1
def exit(bit, index):
    return (bit >> (index - 1)) & 1 == 1
  
def findDuplicate(nums):
    bit = 0
    for i in range(len(nums)):
        if (bit >> (nums[i] - 1)) & 1 == 1:
            return nums[i]
        bit |= 1 << (nums[i] - 1)
```



**思路：排序 + 二分查找**

- 排序
- 如果当前值 nums[i] < i + 1，那么重复的数据在左边，否则在右边。

**代码：**

时间复杂度：O(nlogn)

时间复杂度：O(1) 。

<font color=red>不满足不修改变数组：不能排序</font>

```python
def findDuplicate(nums):
    left = 0
    right = len(nums) - 1
    nums = sorted(nums)
    print(nums)
    while left < right:
        mid = (left + right) >> 1
        if nums[mid] < mid + 1:
            right=mid-1
        else:
            left=mid+1

    return nums[left]
```



**思路：二分查找**

- 关键点：mid 是“数”，不是索引。
- 以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，遍历整个数组，统计小于 4 的整数的个数，
  至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 [1,4) （注意：左闭右开）中；否则，重复的数存在于区间 [4,7]（注意：左右都是闭）中。这里小于
  4 的整数有 4 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。

**代码：**

时间复杂度：O(nlogn)

时间复杂度：O(1) 。

```python
def findDuplicate7(nums):
    low = 0
    high = len(nums)-1

    print(nums)
    while low < high:
        mid = (low + high) >> 1
        cut = get_count(mid, nums)
        if cut > mid:
            high = mid
        else:
            low = mid + 1

    return low

# 统计 nums 中小于等于 target 的个数
def get_count(target, nums):
    res = 0
    for item in nums:
        if item <= target:
            res += 1
    return res
```



**思路：快慢指针**

