# 寻找旋转排序数组中的最小值

> 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
> 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
> 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
> 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
>
> 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

**示例 1：**

```python
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```



**示例 2：**

```python
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```



**示例 3：**

```python
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```



**思路：**



**代码：暴力算法**

- 判断是否旋转，并找到旋转点

```python
def find_min(nums):
    rotation_index = 0
    last = nums[0]
    # 判断是否旋转
    for i in range(1, len(nums)):
        if last > nums[i]:
            rotation_index = i
            break
        last = nums[i]
    return min(nums[0], nums[rotation_index])


print(find_min([3, 4, 5, 1, 2]))
```



**思路：二分查找**

有旋转的数组，如下图。最小值的位置就是我们要找的。

最小值在数组中间，所以我们的搜索范围是从两端向中间收敛：low 和 high 向值更更小的方向移动。

![](images/1.png)



如果nums[mid] < num[high] 则 high = mid

![](images/2.png)



如果 nums[mid] >= nums[high]  则：low = mid + 1

![](images/3.png)

```python
def find_min2(nums):
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) >> 1
        if nums[mid] > nums[high]:
            low = mid + 1
        elif nums[mid] < nums[high]:
            high = mid

    return nums[low]

print(find_min2([3, 4, 5, 1, 2]))
```



# 扩展

如果数组中有重复数据，找最小数据

<font color=red>当 nums[mid]  == nums[hight] 时，改如何选择？</font>

```python
def find_min(nums):
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) >> 1
        if nums[mid] > nums[high]:
            low = mid + 1
        elif nums[mid] < nums[high]:
            high = mid
        else:
            high -= 1

    return nums[low]

print(find_min([3, 4, 5,1, 2]))
```

