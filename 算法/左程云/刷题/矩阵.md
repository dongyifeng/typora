[TOC]

# 打印矩阵

## zigzag 的方式打印矩阵

> 用 zigzag 的方式打印矩阵，比如如下的矩阵：
>
> 0   1   2    3
>
> 4   5    6    7
>
> 8   9   10  11
>
> 打印顺序为：0  1  4  8  5  2  3  6 9  10  7  11

**分析**

如下图，zigzag 打印方式无论是不是方阵都可以。

这种类型的题，不能纠结在路径如何走的细节上。关键在于状态的控制。将路径拆分成规律的几组简单，然后循环处理。

本题：每次关注对角线上两个节点：比如：

节点 1 和 节点 4 ，有两个节点，那么剩下的就是打印从节点 1 到结点 4

节点 8 和 节点 2 ，有两个节点，那么剩下的就是打印从节点 8 到结点 2

节点 3 和 节点 12 ，有两个节点，那么剩下的就是打印从节点 3 到结点 12

节点 13 和 节点 7，有两个节点，那么剩下的就是打印从节点 13 到结点 7

节点 11 和 节点 14，有两个节点，那么剩下的就是打印从节点 11 到结点 14

节点 15 和 节点 15，有两个节点，那么剩下的就是打印从节点 15



从 A = 节点 1 和 B = 节点 4  到 节点 8 和 节点 42 就是一次状态转移。

状态转移：

- A 转移策略：优先向下转移，如果向下越界，那就就向右转移。
- B 转移策略：优先向右转移，如果向右越界，那就就向下转移。



![](images/screenshot-20220711-094421.png)



```python
def print_matrix_zigzag(M):
    n = len(M)
    m = len(M[0])
    a_row = a_col = b_row = b_col = 0
    direction = False
    while a_row < n and a_col < m and b_row < n and b_col < m:
        print_level(M, a_row, a_col, b_row, b_col, direction)

        a_row = a_row + 1 if a_col == m - 1 else a_row
        a_col = a_col if a_col == m - 1 else a_col + 1
        b_col = b_col + 1 if b_row == n - 1 else b_col
        b_row = b_row if b_row == n - 1 else b_row + 1
        direction = not direction
    print("")

def print_level(M, a_row, a_col, b_row, b_col, direction):
    n = len(M)
    m = len(M[0])
    if direction:
        while a_row < n and a_col > -1:
            print(M[a_row][a_col], end=" ")
            a_row += 1
            a_col -= 1
    else:
        while b_row > -1 and b_col < m:
            print(M[b_row][b_col], end=" ")
            b_row -= 1
            b_col += 1

M = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
print_matrix_zigzag(M)
print("-" * 10)
M = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14]]
print_matrix_zigzag(M)
print("-" * 10)
M = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]
print_matrix_zigzag(M)
```



## 旋转矩阵

> 用螺旋方式打印矩阵，比如如下矩阵
>
> 0	1	2	3
>
> 4	5	6	7
>
> 8	9   10  11
>
> 打印顺序：0	1	2	3	7	11	10	9	8	4	5	6

分析：像剥洋葱一样，一层一层打印。要确定当前的圈层，需要节点 a 和 节点 b。然后分别打印上边，右边，下边，左边（注意：边的连接点别打印重复）。一层打印完毕，向内层递进：a _row += 1 、a_col +=1 ，b_row -= 1 、b_col -= 1



![](images/screenshot-20220711-144059.png)





```python
def spiral_order_print(M):
    a_row = a_col = 0
    b_row = len(M) - 1
    b_col = len(M[0]) - 1

    while a_row <= b_row and a_col <= b_col:
        print_edge(M, a_row, a_col, b_row, b_col)
        a_row += 1
        a_col += 1
        b_row -= 1
        b_col -= 1
    print()


def print_edge(M, a_row, a_col, b_row, b_col):
    # 打印上边
    for i in range(a_col, b_col + 1):
        print(M[a_row][i], end=" ")

    # 打印右边
    for i in range(a_row + 1, b_row):
        print(M[i][b_col], end=" ")

    # 打印下边
    for i in range(b_col, a_col, -1):
        print(M[b_row][i], end=" ")

    # 打印左边
    for i in range(b_row, a_row, -1):
        print(M[i][a_col], end=" ")


M = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]

print_edge(M, 0, 0, 3, 3)
print("-" * 10)
spiral_order_print(M)
```



## 方阵旋转

> 给定一个正方形矩阵，只用有限几个变量，实现矩阵中每个位置的数顺时针转动 90 度，比如如下矩阵
>
> 0	1	2	3
>
> 4	5	6	7
>
> 8	9   10  11
>
> 12 13  14  15
>
> 矩阵应该被调整为：
>
> 12	8	4	0
>
> 13	9	5	1
>
> 14  10    6	2
>
> 15  11	7	3

如图：状态转移规则：

1. 外层旋转完毕后，还在外层，内层旋转后还在内层。不会突破层级。
2. 同层旋转，可以分为 m - 1 组数据，依次交换数据。



![](images/screenshot-20220711-180042.png)

```python
def rotate(M):
    a_row = 0
    b_row = len(M) - 1
    while a_row < b_row:
        rotate_edge(M, a_row, b_row)
        a_row += 1
        b_row -= 1

def rotate_edge(M, a_row, b_row):
    for i in range(b_row - a_row):
        tmp = M[a_row][a_row + i]
        M[a_row][a_row + i] = M[b_row - i][a_row]
        M[b_row - i][a_row] = M[b_row][b_row - i]
        M[b_row][b_row - i] = M[a_row + i][b_row]
        M[a_row + i][b_row] = tmp

M = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
rotate(M)
for item in M:
    print(item)
```

本题更好展示了，程序实现的打印路径，和直观感受上的不一样。更好体现了状态的转移。



如果本题不限制空间的使用。我们可以使用一个临时矩阵，更加直观的将数据转移到tmp 矩阵，再将 tmp 中的数据拷贝到 M 矩阵中。

```python
def rotate2(M):
    n = len(M)
    tmp = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            tmp[j][n - i - 1] = M[i][j]

    for i in range(n):
        for j in range(n):
            M[i][j] = tmp[i][j]


M = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
print(rotate2(M))
for item in M:
    print(item)
```







