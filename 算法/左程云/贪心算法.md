<font color=red>**贪心算法在笔试时的解题套路**</font>

1. <font color=red>实现一个不依靠贪心策略的解法 X，可以用暴力的尝试</font>
2. <font color=red>脑补出贪心策略 A，贪心策略B，贪心策略C...</font>
3. <font color=red>用解法 X 和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确</font>
4. <font color=red>不要去纠结贪心策略的证明</font>



> 给一个数组，将数组中字符串拼接起来，字典序最小的字符串是什么？

将一个字符串想想成一个数字，abc < bac 。比较从高位比较每一位字典序的大小。

如果字符串不一样长，字符串 b 和 apple 字典序：apple < b。那么先用 0 补成一样长。

apple < b0000



猜测贪心策略：将数组按照字典序排序（升序），依次结合这些字符串。

数组【“ba”、“b”】 排序后【“b”、“ba”】 ，res = “bba”  但是 “bab” 的字典序更小，所以此策略有问题。



猜测贪心策略：如果 a * b < b * a （字典序）那么就用 a * b 否则就 b * a

```python
from functools import cmp_to_key

def lowest_lexicography(strs):
    strs.sort(key=cmp_to_key(lambda x, y: 1 if x + y >= y + x else -1))
    return "".join(strs)

def lowest_lexicography2(strs):
    return permute(strs)
  
def permute(nums):
    if not nums: return ""
    # 栈：好回溯
    path = []
    # 在一条路径上，节点是否访问过。
    used = [False] * len(nums)
    res = "".join(nums)
    return dfs(nums, len(nums), 0, path, used, res)

def dfs(nums, length, depth, path, used, res):
    # 遍历到根节点
    if depth == length:
        # 数据拷贝，后续遍历会修改path 中的值
        # res.append(path[::])
        return min(res, "".join(path))

    # 所有节点都需要作为开头
    for i in range(length):
        if used[i]: continue
        path.append(nums[i])
        used[i] = True
        res = min(dfs(nums, length, depth + 1, path, used, res), res)
        # 回到 dfs 上一层，状态恢复
        path.pop()
        used[i] = False
    return res

import random
def random_array_generator(max_size, max_value):
    ascii_case = "abcdefghijklmnopqrstuvwxyz"
    return ["".join(random.sample(ascii_case, int(1 + random.random() * max_value))) for _ in
            range(int(random.random() * max_size))]

def check():
    n = 100
    max_value = 5
    max_size = 10

    for _ in range(n):
        strs = random_array_generator(max_size, max_value)
        strs3 = strs[:]
        strs2 = strs[:]

        actual = lowest_lexicography(strs3)
        expect = lowest_lexicography2(strs2)
        if actual != expect:
            print("error:", strs3, strs2, strs, "actual:", actual, "expect:", expect)
    print("Game Over!")

check()
```





> 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为 20 的金条，不管切成长度多大的两半，都要花费 20 个铜板。
>
> 一群人想整分整块金条，怎么划分最省铜板。
