#### **索引的优缺点**

索引的优点主要体现在以下几个方面：

1. 索引可以减少服务器需要扫描的数据量，从而大大提高查询效率。

2. 唯一索引能保证表中数据的唯一性。

索引的缺点主要体现在以下几个方面：

1. 索引的创建和维护会造成工作量的增加，新增删除操作需要维护索引

2. 除了数据表中数据占数据空间之外，每一个索引还要占一定的物理空间。 

#### **索引的存储分类**

BTree 索引

最常见的索引类型，大部分引擎都支持B树索引。

B+tree 索引

与单纯的算法不同，磁盘IO次数才是更大的影响因素。B树与AVL的时间复杂度是相同的，但由于B树的层数少，磁盘IO次数少，实践中B树的性能要优于AVL等二叉树。

B树和B+树的区别

- B+树的叶子节点冗余了全部的非叶子节点
- B+树中所有叶子节点都是通过指针连接在一起，而B树不会。
- B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有

Hash索引

全文索引

#### 聚集索引和非聚集索引

##### 聚集索引

是一种数据存储方式。一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。 如果一个主键被定义了，那么这个主键就是作为聚集索引。

Innodb如何选择一个聚集索引

1. 如果一个主键被定义了，那么这个主键就是作为聚集索引

2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引

3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。

   <img src="./img/index1.png" alt="image-20221020143424864" style="zoom: 33%;" />

​                                                  

##### 非聚集索引

  一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

<img src="./img/index2.png" alt="0" style="zoom: 33%;" />

#### 索引按功能分类

##### 普通索引

这是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建：

- 创建索引: CREATE INDEX 索引名 ON 表名(列名1，列名2,...);
- 修改表: ALTER TABLE 表名ADD INDEX 索引名 (列名1，列名2,...);
- 创建表时指定索引：CREATE TABLE 表名 ( [...], INDEX 索引名 (列名1，列名 2,...) );

##### 唯一索引

表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique：

- 创建索引：CREATE UNIQUE INDEX 索引名 ON 表名(列的列表);
- 修改表：ALTER TABLE 表名ADD UNIQUE 索引名 (列的列表);
- 创建表时指定索引：CREATE TABLE 表名( [...], UNIQUE 索引名 (列的列表) )

##### 主键索引

主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。

##### 联合索引

联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2，联合索引根据第一个字段进行排序，第二个字段在第一个字段的基础上进行排序，所有查询a是可以用到索引的，但是直接查询b是不能用到索引的

select * from table where a = 1 order by b 使用联合索引可以减少一次 filesort

<img src="https://img-blog.csdnimg.cn/20210802171307298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psbDEyNg==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

##### 前缀索引

选取列的一部分做索引（身份证倒叙取前几位）

#### 优化

##### 最左前缀

针对联合索引,将选择性最高的列放到索引的最前列,如果不是按照索引的最左列开始查找，则无法使用索引,不能跳过索引中的列（a,b,c 查询a、c只能用到a）,如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查询（a,b,c a=1 && b>2 && c=3 ==> c=3用不到） 

##### 回表查询

先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。

##### 索引覆盖

只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

例如：select id,age from user where age = 10;

如何实现覆盖索引

常见的方法是：将被查询的字段，建立到联合索引里去。

1、如实现：select id,age from user where age = 10;

explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引

​    ![0](/Users/lihongda/Documents/lihd2199.github.io/MySQL/img/索引6.webp)

2、实现：select id,age,name from user where age = 10;

explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询    ![0](/Users/lihongda/Documents/lihd2199.github.io/MySQL/img/索引7.webp)

为了实现索引覆盖，需要建组合索引idx_age_name(age,name)

#### 索引层级的计算

表的记录数是N

每一个BTREE节点平均有B个索引KEY

那么B+TREE索引树的高度就是logN/logB

log1000M/log(16K/(8+4)*8)





七字口诀：模型数空运最快
  模：代表模糊查询的意思，我们在使用like关键字的时候，如果是%开头，那么索引就会失效。
  型：代表数据类型，如果数据类型错误了，索引也会失效。（类型转换）
  数：代表函数的意思，对索引的字段使用内部函数，索引也会失效，这种情况应该建立基于函数的索引。
  空：代表英文的 null 的意思，索引不存储空值，如果不限制索引列是 Not Null，数据库会认为索引列有可能存在空值，所以也不会按照索引进行计算。
  运：代表运算的意思，对索引列进行加、减、乘、除等运算，会导致索引失效。
  最：代表最左原则的意思，在复合索引中，索引列的顺序非常重要，如果不是按照索引列最左列开始进行查找，则无法使用索引。
  快：代表全表扫描更快的意思，如果数据库预计使用全表扫描比使用索引更快的话，就不会使用索引。
