---
typora-root-url: ../../../typora

---

[TOC]

# 减少计数 CountDownLatch

- CountDownLatch 的构造方法传入一个初始值
- countDown() 方法，每次调用减一。
- await()：使当前线程等待，直到 CountDownLatch 中的数减至为 0



```java
    public static void main(String[] args) {
        // 6 个同学陆陆续续离开教室
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 号同学离开了教室");
            }, String.valueOf(i)).start();
        }
        // 这些需要阻塞，等待上边所有线程执行完毕。
        System.out.println(Thread.currentThread().getName() + " 班长锁门走人了");
    }
```

执行结果：

<img src="/images/juc/WX20230218-175939@2x.png" style="zoom:50%;" />



```java
    public static void main(String[] args) throws InterruptedException {
        // 创建 CountDownLatch 对象，设置初始值
        CountDownLatch countDownLatch = new CountDownLatch(6);


        // 6 个同学陆陆续续离开教室
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 号同学离开了教室");
                //计数器 -1
                countDownLatch.countDown();

            }, String.valueOf(i)).start();
        }

        countDownLatch.await();
        // 这些需要阻塞，等待上边所有线程执行完毕。
        System.out.println(Thread.currentThread().getName() + " 班长锁门走人了");
    }
```

执行结果：

<img src="/images/juc/WX20230218-175840@2x.png" style="zoom:50%;" />





# 循环栅栏 CyclicBarrier

允许一组线程相互等待，直到等待线程数达到 parties 时，执行 barrierAction，并释放等待线程。



- CyclicBarrier 构造函数：parties：设置初始值。
- await：使线程等待，当等待线程数达到 parties 时，执行 barrierAction，并释放等待线程。

CyclicBarrier 的构造函数

```java
   public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
```



例子：集齐 7 颗龙珠，方可召唤神龙

```java
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("集齐 7 颗龙珠，方可召唤神龙");
        });
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 颗龙珠搜集到");
                    cyclicBarrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }
    }
```



CyclicBarrier 是 ++ 的计数器，CountDownLatch 是 -- 的计数器。

```java
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(6, () -> {
            System.out.println(" 班长锁门走人了");
        });
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 号同学离开了教室");
                    cyclicBarrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }
    }
```



# 信号灯 Semaphore

Semaphore 是一个计数的信号量，信号量维护了一个许可集。在许可前会阻塞每一个 acquire()。每个 release() 添加一个许可，从而能释放一个正在阻塞的获取者。



```java
    // 6 辆汽车，停 3 个停车位
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);

        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    // 抢占：如果抢不到阻塞在这里
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + " 号车抢到了车位");

                    // 设置随机停车时间
                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));
                    System.out.println(Thread.currentThread().getName() + " 号车离开了车位---------------");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放
                    semaphore.release();
                }
            }, String.valueOf(i)).start();
        }
    }
```



执行结果：

<img src="/images/juc/WX20230218-183851@2x.png" style="zoom:50%;" />



