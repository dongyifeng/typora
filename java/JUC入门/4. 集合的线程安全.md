多线程向 List 添加数据

```java
public class NotSafeDemo {
    public static void main(String[] args) {
        List list = new ArrayList();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
}
```

报错：<font color=red>Exception in thread "线程59" java.util.ConcurrentModificationException</font>

问题：为什么出现并发修改异常？

```java
 public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```



如何解决 List 类型线程安全问题？

# 方案一：使用 Vector

Vector 是矢量队列，是 JDK1.0 版本添加的类。

```java
    public static void main(String[] args) {
        List list = new Vector();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```

Vector 的 add 方法（ synchronized ）

```java
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
```

Vector 的 add 效率较低。



# 方案二：Collections

Collections.synchronizedList 保证 list 的同步线程安全

```java
   public static void main(String[] args) {
        List list = Collections.synchronizedList(new ArrayList<>());

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```

查看源码

```java
public boolean add(E e) {
            synchronized (mutex) {return c.add(e);}
        }
```



# 方案三：CopyOnWriteArrayList（重点）

CopyOnWriteArrayList 相当于线程安全的 ArrayList

```java
    public static void main(String[] args) {
        List list = new CopyOnWriteArrayList();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, "线程" + i).start();
        }
    }
```



CopyOnWriteArrayList 特性

- 线程安全
- CopyOnWriteArrayList 适合场景：List 大小很小，读远大于写，需要在遍历时防止线程间冲突。
- add()，set()，remove() 等操作开销很大，因为需要复制整个基础数组。
- 使用迭代器遍历时速度很快，且不会与其他线程发生冲突，迭代器依赖不变的数组快照。
- 迭代器支持 hasNext()，next() 等不可变操作，不支持可变操作：如 remove()



CopyOnWriteArrayList 的复制思想：当我们向容器中添加一个元素时，不是直接向当前容器中添加，而是先将当前容器Copy，向Copy 出来的容器中添加元素，添加完毕后，再将原容器的引用指向新容器。

CopyOnWriteArrayList Add 源码

```java
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```



CopyOnWriteArrayList  内部有个” volatile 数组 “（array）来保存数据，在”添加、修改、删除“ 数据时，都会 Copy 出一个新数组，对新数组操作完毕后，最后再将新数组复制给 “  volatile 数组  ”。<font color=red>效率很低</font>

