SkipLists

- 跳表是一个随机化的搜索数据结构



跳表的 NB 之处：

1. 思想先进：跳表不再使用硬规则来数据的平衡性，而是使用概率保证。
2. 由于使用概率随机生成数据层，与用户输入的数据无关。



跳表时间复杂度评估

第 0 层：N 个节点（每个节点必在第 0 层）

第 1 层：$\frac{N}{2}$ 个节点

第 2 层：$\frac{N}{4}$ 个节点

第 3 层：$\frac{N}{8}$ 个节点

...

第 k 层：$\frac{N}{2^k}$ 个节点

类似满二叉树



跳表图

![](images/screenshot-20220809-205313.png)

查找数据

![](images/screenshot-20220809-210827.png)



添加数据

![](images/screenshot-20220809-210742.png)

删除数据













```python
import random

class Node:
    def __init__(self, value, level):
        self.value = value
        self.next_nodes = [None] * level

    def __lt__(self, other):
        return self.key < other

    def __eq__(self, other):
        return self.key == other

    def __ge__(self, other):
        return self.key > other

class SkipList:
    def __init__(self):
      	# 类似前缀树的 root 节点
        # head 拥有最高的层
        # 只有 head 的层可以扩展，其他节点的层，在初始化时就决定了
        self.head = Node(-1, 1)

    def find(self, value):
        p = self.head
        for i in range(len(self.head.next_nodes) - 1, -1, -1):
            while p.next_nodes[i] and p.next_nodes[i].value < value:
                p = p.next_nodes[i]

        if p.next_nodes[0] and p.next_nodes[0].value == value:
            return p.next_nodes[0].value

    def insert(self, value):
        self.insert_level(value, self.get_random_level())

    def insert_level(self, value, level):
        self.expand_head(level)

        new_node = Node(value, level)
        update_arr = [self.head] * len(self.head.next_nodes)
        p = self.head

        n = len(self.head.next_nodes)
        for i in range(n - 1, -1, -1):
            while p.next_nodes[i] and p.next_nodes[i].value < value:
                p = p.next_nodes[i]
            update_arr[i] = p

        # 加入 new_node
        for i in range(level):
            new_node.next_nodes[i] = update_arr[i].next_nodes[i]
            update_arr[i].next_nodes[i] = new_node

    def delete(self, value):
        n = len(self.head.next_nodes)
        update_arr = [None] * n
        p = self.head
        # 查找需要更新结点
        for i in range(n - 1, -1, -1):
            while p.next_nodes[i] and p.next_nodes[i].value < value:
                p = p.next_nodes[i]
            update_arr[i] = p

        # 删除节点
        if p.next_nodes and p.next_nodes[0].value != value: return

        # 删除节点
        for i in range(n - 1, -1, -1):
            if update_arr[i].next_nodes[i] and update_arr[i].next_nodes[i].value == value:
                update_arr[i].next_nodes[i] = update_arr[i].next_nodes[i].next_nodes[i]

    def expand_head(self, level):
        n = len(self.head.next_nodes)
        if level < n:
            return
        for _ in range(level - n):
            self.head.next_nodes.append(None)

    def get_random_level(self):
        res = 1
        while int(random.random() * 2) != 0:
            res += 1
        return res

    def more(self, value):
        pass

    def less(self, value):
        pass

skipList = SkipList()
skipList.insert_level(3, 3)
skipList.insert_level(10, 2)
skipList.insert_level(15, 4)
skipList.insert_level(20, 6)
skipList.insert_level(30, 1)
skipList.insert_level(40, 4)
skipList.insert_level(50, 5)
skipList.insert_level(70, 2)
skipList.insert_level(100, 6)

skipList.delete(50)

print("aaa")
```

