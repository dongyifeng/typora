---
typora-root-url: ../../../typora
---

[TOC]

常见的锁

- 公平锁和非公平锁
- 可重复锁（递归锁）
- 写锁（独占锁）、读锁（共享锁）
- 自旋锁 SpinLock
- 无锁 --> 独占锁 --> 读写锁 --> 邮戳锁
- 无锁 --> 偏向锁 --> 轻量锁 --> 重量锁

# 锁的问题

结论：

- <font color=red>synchronized 修饰在方法上，锁的是当前类 this 对象，只要调用同一个实例的 synchronized 方法，都需要串行。</font>
- <font color=red>synchronized 修饰在静态方法上，锁的是当前类 Class 对象，这个类的所有静态方法，都需要串行。</font>



资源类

```java
class Phone {
    // synchronized 方法
    public synchronized void sendSMS() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("------------sendSMS");
    }

    // synchronized 方法
    public synchronized void sendEmail() throws InterruptedException {
        System.out.println("------------sendEmail");
    }

    // 普通方法
    public void getHello() throws InterruptedException {
        System.out.println("------------getHello");
    }
}
```



目的：验证两个线程是不是同一把锁，以及锁的范围。

**实验一**

```java
    // synchronized 方法
    public synchronized void sendSMS() throws InterruptedException {
        System.out.println("------------sendSMS");
    }

    // synchronized 方法
    public synchronized void sendEmail() throws InterruptedException {
        System.out.println("------------sendEmail");
    }

public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();
        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AA").start();

        Thread.sleep(100);

        new Thread(() -> {
            try {
                phone.sendEmail();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BB").start();
    }

// 输出
// ------------sendSMS
// ------------sendEmail
```



实验二：

与实验一相比 sendSMS 多了 4 秒的停顿。由于 synchronized 锁住了 this，所以 sendEmail 方法必须等待 sendSMS 执行完毕后才能执行。

```java
    // synchronized 方法
    public synchronized void sendSMS() throws InterruptedException {
      	TimeUnit.SECONDS.sleep(4);
        System.out.println("------------sendSMS");
    }

    // synchronized 方法
    public synchronized void sendEmail() throws InterruptedException {
        System.out.println("------------sendEmail");
    }

// 输出
// ------------sendSMS
// ------------sendEmail
```



实验三：

由于 getHello() 是普通方法，与锁无关，所以不需要等待 sendSMS。

```java
    public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();
        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AA").start();

        Thread.sleep(100);

        new Thread(() -> {
            try {
                phone.getHello();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BB").start();
    }

// 输出
// ------------getHello
// ------------sendSMS
```



实验四：

有两个 Phone 实例， 线程 AA 锁住的是 phone1 ，而 线程 BB 锁住的是 phone2。相互独立，不会彼此影响，因而 sendEmail 无需等待。

```java
    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();
        new Thread(() -> {
            try {
                phone1.sendSMS();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AA").start();

        Thread.sleep(100);

        new Thread(() -> {
            try {
                phone2.sendEmail();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BB").start();
    }

// 输出
// ------------sendEmail
// ------------sendSMS
```



实验五：

将 sendSMS 和 sendEmail 都改为静态方法。synchronized 的静态方法，锁住Phone 类的Class 对象，所有静态方法都需要串行，所以 sendEmail 需要等待 sendSMS 方法执行完毕后才能执行。

```java
    // synchronized 方法
    public static synchronized void sendSMS() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("------------sendSMS");
    }

    // synchronized 方法
    public static synchronized void sendEmail() throws InterruptedException {
        System.out.println("------------sendEmail");
    }

    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
        new Thread(() -> {
            try {
                phone1.sendSMS();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AA").start();

        Thread.sleep(100);

        new Thread(() -> {
            try {
                phone1.sendEmail();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BB").start();
    }

// 输出
------------sendSMS
------------sendEmail
```



实验六：

与实验五相比，sendSMS 和 sendEmail 分别有两个不同实例调用，由于是静态方法，已经与实例无关了，所以与实验五结果一样。

```java
    public static void main(String[] args) throws InterruptedException {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();
        new Thread(() -> {
            try {
                phone1.sendSMS();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AA").start();

        Thread.sleep(100);

        new Thread(() -> {
            try {
                phone2.sendEmail();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BB").start();
    }

// 输出
// ------------sendSMS
// ------------sendEmail
```





实验七：

sendSMS() 方法是静态方法，sendEmail() 是非静态方法。静态方法锁的是 Phone 的Class 对象，实例方法 sendEmail 锁的是 this，不是同一把锁，所以不相互影响。

```java
    // synchronized 方法
    public static synchronized void sendSMS() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("------------sendSMS");
    }

    // synchronized 方法
    public synchronized void sendEmail() throws InterruptedException {
        System.out.println("------------sendEmail");
    }

// 输出
// ------------sendEmail
// ------------sendSMS
```



结论：

- <font color=red>synchronized 对于普通方法（实例方法），锁的是当前实例对象。</font>
- <font color=red>synchronized 对于静态方法（类方法），锁的是当前类的 Class 对象。</font>
- <font color=red>synchronized 对于同步方法块，锁的 synchronized 括号里配置的对象。</font>



# 公平锁和非公平锁

非公平锁特点

- 会有线程饿死的问题
- 执行效率高，不需要来回切换



公平锁

- 阳光普照，雨露均沾
- 效率相对低



售票的例子：非公平锁：new ReentrantLock();

```java
class LockTicket {
    // 票数
    private int number = 30;

    // 创建可重入锁(非公平锁)
    private final ReentrantLock lock = new ReentrantLock();

    // 售票
    public void sale() {
        // 上锁
        lock.lock();
        try {
            if (number > 0) {
                System.out.println(Thread.currentThread().getName() + ":卖出" + (number--) + "\t剩余：" + number);
            }
        } finally {
            // 解锁
            lock.unlock();
        }
    }
}

public class LockSaleTicket {
    public static void main(String[] args) {
        LockTicket ticket = new LockTicket();

        // 三个售票点
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "AA");

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "BB");

        Thread thread3 = new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
        }, "CC");

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

<img src="/images/juc/WX20230217-111149@2x.png" style="zoom:33%;" />





售票的例子：公平锁：new ReentrantLock(true);

<img src="/images/juc/WX20230217-111132@2x.png" style="zoom:33%;" />



# 可重入锁（递归锁）

synchronized  和 Lock 都是可重入锁。

如下图：三重锁嵌套，如果一个线程拿到最外层的锁，那么不在受内层的可重入锁的限制，畅通无阻。 

<img src="/images/juc/WX20230217-112749@2x.png" style="zoom:50%;" />

# 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

<img src="/images/juc/WX20230217-115037@2x.png" style="zoom:50%;" />



**产生死锁的原因**

1. 系统资源不足
2. 进程运行推进顺序不合适
3. 资源分配不当

```java
public class DeadLock {
    static Object a = new Object();

    static Object b = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (a) {
                System.out.println(Thread.currentThread().getName() + "持有锁 a，试图获取锁 b");
                synchronized (b) {
                    System.out.println(Thread.currentThread().getName() + "持有锁 b");
                }
            }
        }, "AA");

        Thread thread2 = new Thread(() -> {
            synchronized (b) {
                System.out.println(Thread.currentThread().getName() + "持有锁 b，试图获取锁 a");
                synchronized (a) {
                    System.out.println(Thread.currentThread().getName() + "持有锁 a");
                }
            }
        }, "BB");

        thread1.start();
        thread2.start();
    }
}
```



<img src="/images/juc/WX20230217-115953@2x.png" style="zoom:50%;" />





**验证是否是死锁**

1. jsp -l

   <img src="/images/juc/WX20230217-120857@2x.png" style="zoom:50%;" />

2.  jstack 42166

<img src="/images/juc/WX20230217-121038@2x.png" style="zoom:50%;" />
