---
typora-root-url: ../../../typora
---

[TOC]

<img src="/images/mysql/WX20230306-154041@2x.png" style="zoom:30%;" />

# 锁

基于所的属性分类

- 共享锁（读锁）：当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，不能加写锁。共享锁主要为了支持并发读取数据，读取数据时不支持修改。
- 排他锁（写锁）：当一个事务为数据加上写锁之后，其他事务不能再对该数据加任何锁。数据在修改时不允许其他同时修改，也不允许其他人读取。避免出现脏数据和脏读的问题。
  

基于锁的粒度分类：

- 全局锁：Flush tables with read lock。加锁之后整个数据库实例都处于只读状态。所有的数据变更操作都会被挂起。一般由于全库备份的场景。
- 表锁：锁住整张表。
  - 粒度大，加锁简单，容易冲突。
  - 也分为：表共享锁，表排他锁。
- 行锁：锁住一行或者多行。
  - 粒度小，加锁麻烦，不容易冲突。会出现死锁。
  - 表锁速度快，但冲突多；行锁冲突少，但速度慢（需要找到对应的行再加锁）
  - 也分为：行共享锁，行排他锁。
- 页锁：锁住一页。锁的范围介于表锁和行锁之间。
  - 会出现死锁。
  - 也分为：页共享锁，页排他锁。
- 记录锁：锁住一条记录。也属于行锁
  - 精准命中记录，并且命中的条件字段是唯一索引。
- 间隙锁：锁住表记录的某个区间。当表的相邻 ID 之间出现空隙，会形成一个区间，左开右闭。
  - 
- 临建锁：可以认为是记录锁和间隙锁的组合。会锁住查询出来的记录，也会锁住查询内的所有间隙空间。
  
  

<font color=red>注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</font>





如果当事务 A 对表里的行加排他锁成功之后，就设置一个状态告诉后面的人，你们不能对整个表加共享锁或者排他锁了，避免了后面人对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。

基于锁的状态分类

- 意向共享锁：当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。
- 意向排他锁：当一个事务试图对整个表进行加排他锁之前，首先需要获得这个表的意向排他锁。



使用场景：

- 修改数据库表结构会自动加表锁。
- 更新数据使用索引，会使用行锁。
- 更新数据未使用索引，行锁会升级为表锁
- select * from update 会使用行锁。



**死锁：**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种<font color=red>相互等待的现象</font>，若无外力作用，它们都将无法推进下去。



查看死锁：

```mysql
# 查看最近的一次的死锁
show engine innodb status
```



**处理死锁常见的策略**

- 通过 innodb block wait_timeout 来设置超时时间，一直等待直到超时。
- 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。



# 索引

 索引的原理：就是把无序的数据变成有序的查询。



> Mysql 聚簇和非聚簇索引的区别？

答：聚簇和非聚簇索引都是 B+ 树的数据结构。

聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种<font color=red>数据存储方式</font>。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB 的聚簇索引实际上是将索引和数据保存中同一个B+Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

非聚簇索引（NoClustered Index），又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B+Tree查找（）。

 



# MySQL 脏读、幻读、不可重复读？

- 脏读：指事务读取到了其他事务<font color=red>还未提交的数据</font>。
- 不可重复读：指<font color=red>并发跟新</font>时，另一个事务前后<font color=red>查询相同数据</font>时，数据不合符预期。
- 幻读：指并发<font color=red>新增、删除</font>这种会产生<font color=red>数据量</font>变化的操作时，另一个事务前后查询相同数据时，数据不符合预期。（不该出来的出来了，改出来的出不来了）



**脏读**

**脏读是指事务读取到了其他事务<font color=red>还未提交的数据</font>。**

如下图：事务B 将 id = 1的数据name有 ”A“ 改为 ”B“，还未提交。而此时事务 A，读取了 id =1 的数据，获得name = B。此后事务 B 回滚。id =1 的name 又变为 A。而此时事务 A 读的数据就是脏读。

<img src="/images/mysql/WX20230306-160124@2x.png" style="zoom:40%;" />



**不可重复读**

不可重复读是指在<font color=red>同一次事务中</font>前后查询的数据是<font color=red>不一致</font>的。

如下图：事务A 读取 id = 1的数据name 为 ”A“ 后去处理其他 SQL。而此时事务 B，将 id = 1 的name 由 A 改为  B，并且已经提交。之后事务 A 又一次读取 id = 1的数据发现 name 变为 ”B“，事务A 一脸懵逼，同一个事务中两次读取的数据不一致。

<img src="/images/mysql/WX20230306-160947@2x.png" style="zoom:40%;" />



**可重复读**：是指在<font color=red>同一次事务中</font>前后查询的数据是<font color=red>一致</font>的。



**幻读：**一次事务中前后数据量发生了变化，用户产生了不可预留的问题。

如下图：事务A 清空 user 全表数据后，事务 B 向 user 表中插入了一条数据。事务 A 的预期 user 是空的，但是现在多了一条数据，事务 A 搞不清了自己是否执行成功了。



<img src="/images/mysql/WX20230306-161732@2x.png" style="zoom:40%;" />

# 事务隔离级别

为了解决：脏读、幻读、不可重复读，的问题，提出来事务隔离级别。



|          | 隔离级           | 脏读 | 不可重复读 | 幻读                      | 加读锁 |
| -------- | ---------------- | ---- | ---------- | ------------------------- | ------ |
| 读未提交 | READ_UNCOMMITTED | 是   | 是         | 是                        | 否     |
| 读已提交 | READ_COMMITTED   | 否   | 是         | 是                        | 否     |
| 可重复读 | Repeatable_read  | 否   | 否         | 是（innodb 不会出现幻读） | 否     |
| 串行化   | serializable     | 否   | 否         | 否                        | 是     |



# MVCC

MVCC是什么？

MVCC 是为了解决事务操作中<font color=red>多线程并发安全问题</font>的<font color=red>无锁并发控制</font>技术。它的全称为：多版本并发控制。



为什么需要MVCC？

我们可以根据数据库三种并发场景来分析：

1. 读读并发，不会产生并发问题，也不需要并发控制。
2. 读写并发，会造成事务隔离问题，造成脏读、幻读、不可重复读的问题。
3. 写写并发，可能出现数据更新丢失的问题。

MVCC 为每个修改保存一个版本，版本与事务时间戳关联，读操作只读事务开始前的数据库的快照。它是通过 Undo 日志和ReadView 来实现的。



MVCC 为数据库解决一下问题：

1. 并发并发读写数据库时，读操作时不用去阻塞写操作，而写操作也不用去阻塞读操作，提高数据库的并发读写的处理能力。
2. 实现一致性，解决脏读、幻读、不可重复读等事务隔离问题。但是它不经解决写写并发时，数据丢失问题。
3. 采用乐观锁或者悲观锁来解决写写冲突。



MVCC 的全称：Multi-Version Concurrency Control。多版本并发控制。ReadView + 版本链。 

在 MySQL InnoDB 引擎下，RC、RR 基于MVCC 进行并发事务控制的。

MVCC 是基于 ”数据版本“ 对并发事务进行访问控制的。



如下图：

- 事务 A 将 id = 1 的 name 改为 ”A“
- 事务 A 提交后，事务 B 将 id = 1 的 name 改为 ”B“。
- 事务 B 提交后，事务 C 将 id = 1 的 name 改为 ”C“。
- 事务 D 两次读取的时机非常特殊：
  - 第一次读取在事务 A 提交后和 事务 B 修改后未提交之间。
  - 第二次读取在事务 B 提交后和 事务 C 修改后未提交之间。

那么事务D 两次读取分别读的 name 是多少？

- 如果数据库的隔离级别是：RR（Repeatable_read：可重复读），那么在同一个事务（D）中两次读取的结果应该是一样的。由于事务A 已经提交，那么事务D 两次读取 name 都是 A。
- 如果数据库的隔离级别是：RC(READ_COMMITTED：读已提交)，
  - 事务 D 第一次读取，事务 A 已提交，那么此次读取的 name 是 A
  - 事务 D 第二次读取，事务 B 已提交，那么此次读取的 name 是 B



<img src="/images/mysql/WX20230306-172827@2x.png" style="zoom:50%;" />



**MVCC 实现机制：基于 undo_log 的版本链**

如下图：就是上边事务生成 undo_log 的版本链。

- id：user 的主键
- name：修改的字段
- trx_id：事务ID，作为版本进行标识。
- dp_roll_ptr：表示改行回滚段的指针。

<img src="/images/mysql/WX20230306-175722@2x.png" style="zoom:40%;" />

注意：undo_log 日志是不是会被删除？中间数据万一被删除了版本链不就断了？

undo_log 版本链在回滚完毕后，不是立即删除，MySQL 确保版本链数据不再被 ”引用“ 后，再进行删除。



## ReadView 是什么？

ReadView 是 <font color=red>”快照读“</font> SQL 执行时 MVCC 提取数据的依据。

- <font color=red>”快照读“</font>：就是最普通的 Select 查询 SQL  语句。
- <font color=red>”当前读“</font>：执行下列语句时进行的数据读取的方式
  - Insert、Update、Delete（在这些操作前，需要先读取数据）。
  - Select ... for update
  - Select ... lock in share mode



**ReadView 是一个数据结构**

- m_ids：当前活跃的事务编号集合
- min_trx_id：最小活跃事务编号
- max_trx_id：预分配事务编号，当前最大事务编号 + 1
- creator_trx_id：ReadView 创建者的事务编号



### ReadView 生成过程



#### 读已提交（RC）



读已提交（RC）：<font color=red>在每一次执行快照读是生成 ReadView</font>

如下图：第一次 Select（快照读）生一个 ReadView

- m_ids：当前活跃的事务编号集合：【2,3,4】
- min_trx_id：最小活跃事务编号：2
- max_trx_id：预分配事务编号，当前最大事务编号 + 1：5
- creator_trx_id：ReadView 创建者的事务编号：4

第二次 Select（快照读）生一个 ReadView

- m_ids：当前活跃的事务编号集合：【3,4】
- min_trx_id：最小活跃事务编号：3
- max_trx_id：预分配事务编号，当前最大事务编号 + 1：5
- creator_trx_id：ReadView 创建者的事务编号：4

<img src="/images/mysql/WX20230306-181929@2x.png" style="zoom:50%;" />



### 数据提取过程

验证 trx_id = 3 这一行的数据是否满足访问规则：

1. trx_id = 3，不等于 creator_trx_id ，不满足第一条规则
2. trx_id = 3，不小于 min_trx_id = 2，不满足第二条规则
3. trx_id = 3，不大于 max_trx_id = 5，不满足第三条规则
4. trx_id = 3，大于 min_trx_id = 2 小于 max_trx_id = 5 满足第一层判断，trx_id 存在 m_ids 集合，说明 trx_id 还未提交，本次的隔离级别是 RC，所以不能读取 trx_id = 3 这行数据。

同理：判断 trx_id = 2 这一行数据（由 db_roll_ptr 找到 trx_id 这条数据），不满足。在 trx_id = 1 这一行数据满足。那么读取到 A。

![](/images/mysql/WX20230306-184133@2x.png)



结合下图：是不是第一个 ReadView 只有 trx_id = 1的事务提交。只能读取 trx_id = 1 的数据。

<img src="/images/mysql/WX20230306-181929@2x.png" style="zoom:50%;" />





#### 可重复读（RR）

可重复读（RR）：<font color=red>**仅在第一次执行快照读时生成 ReadView，后续快照读复用之前的ReadView（有例外）。**</font>

如下图：第二次快照读复用了第一次的 ReadView，ReadView 就是去 undo_log 的版本链中的查询条件，查询条件相同，所以查到的结果也是相同的。

<img src="/images/mysql/WX20230306-185902@2x.png" style="zoom:50%;" />



**RR 级别下使用 MVCC 能避免幻读吗？**

答：能，但不完全能。MVCC 不是通过锁的机制来对事务数据进行隔离，而是通过版本控制变现的解决了幻读功能。

连续多次快照读，ReadView 会产生复用，没有幻读的问题。



<font color=red>特例：当两次<font color=blue>快照读</font>之间存在<font color=blue>当前读</font>，ReadView 会重新生成，会产生幻读。</font>

如下图：

- 事务 B 先查询，获取到 id =1，name = B，age = 18 这条数据。这是<font color=red>快照读</font>，生成 ReadView2

- 事务 A 插入条数据：id = 2，name = B，age = 20，

- 事务 B 将 user 表中的所有 age 都更新为 25。此时有一次<font color=red>当前读</font>。

- 事务 B 再次<font color=red>快照读</font>。由于之前的有一次<font color=red>当前读</font>，因此重新生成 ReadView2。此时的 ReadView2 与 ReadView2 数据总量不同，<font color=red>产生了幻读。</font>

  

<img src="/images/mysql/WX20230306-193600@2x.png" style="zoom:50%;" />



# 事务

> ACID 靠什么保证？

- A 原子性有 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql
- C 一致性有其他三大特性保证；程序代码要保证业务上的一致性。
- I 隔离性由 MVCC 来保证。
- D 持久性由内存 + redo log 来保证，myslq 修改数据同时和 redo log 记录这次操作，宕机的时候可以从 redo log 中恢复。

```shell
InnoDB redo log 写盘；Inno DB 事务进入 prepare 状态；
如果前边 prepare 成功；binlog 写盘，再继续将事务持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commint 状态(在 redo log 里面写一个 commint 记录)
```



> 什么是 MVCC？

答：MVCC 的全称：Multi-Version Concurrency Control。多版本并发控制。ReadView + 版本链。 



> MySQL 主从同步的原理？

1. 主库将数据库的所有的变更记录到 binlog 中。
2. 主节点 log dump 线程去读 binlog 变更内容发送给从节点。
3. 从节点的 I/O 线程接受 binlog 内容，并将其写入到 repay log 文件中。
4. 从节点的 SQL 线程读取 relay log 文件内容，对数据变更进行重放，最终保持主从数据库的一致性。

注意：主节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收的到偏移量。如果从节点发生宕机，则会自动从 position 位置发起同步。



MySQL 默认的复制方式是yibu

**全同步复制**

​		主库写入 binlog 后，所有的从库都执行完成后才返回给客户端。数据一致性好，性能低。

**半同步复制**

​		从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

<img src="/images/mysql/WX20230301-155327@2x.png" style="zoom:50%;" />

# 慢 SQL

> 对慢查询都怎么优化？

答：三个方向

- 分析 SQL，是否 load 多余的数据，对 SQL 语句分析重写。比如 Select * from table 改为 select id from table
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句尽可能的命中索引。
- 如果对 SQL 已经无法优化了，可以考虑表中的数据量是否过大，如果是的话，可以考虑横向或者纵向分表。

 

# 索引二叉树，B-树， B+树的区别?





<font color=red>树越高查询速度越慢。</font> 

B-树解决了二叉树的树的高度问题。

在范围查找时，B-树也是存在回旋查找的问题。

常规数据库引擎都是采用 B- 树或者 B+树 来实现的。因为 B-树是一种<font color=red>多路平衡树</font>。用这种结构来存储大量数据的时候，<font color=red>整棵树的高度相比二叉树来说会矮很多。</font>对于数据库来说所有的数据都是存在磁盘上的，而磁盘的 IO 效率是比较低的。特别是随机磁盘 IO 的情况下，效率就更低了。 所以树的高度能就能够决定磁盘IO 的次数。磁盘IO 的次数越小，那么对于性能提升就越大。这也是为什么采用 B- 树采用索引存储结构。



在 Mysql InnoDB 的存储引擎中，它用到了一种增强的 B-树结构，也就是 B+树，来作为索引和数据的存储结构。相比于 B-树的结构来说，B+ 树做了几个方面的优势。

- B+ 树的所有数据都存储在叶子节点，非叶子节点只存储索引。
- 叶子节点的数据，使用双向链表的方式进行关联。



使用 B+ 树作为索引的原因

1. B+树的非叶子节点不存储数据，所以每一层能够存储的索引数据量会增加，意味着B+树在层高相同的情况下，存储的数量比B树更多。使得磁盘 IO 次数更少。
2. 在 Mysql 中<font color=red>范围查询</font>时一个比较常用的操作，而 B+树的所有存储在叶子节点上的数据，使用了双向链表的方式来关联，所以在查询时只需要<font color=red>查询两个节点，进行遍历</font>就可以了。而 B-树需要获取所有节点。B+树在范围上查询效率更高。
3. 在数据的检索方面，由于所有的数据都存在叶子节点，所以 B+树的 IO次数会更加稳定。
4. 因为叶子节点存储了所有数据，所以 B+树的全局扫描能力更加强。因为它只需要扫描叶子节点即可，而B-树需要遍历整棵树。



另外基于 B+树这样的数据结构，如果采用自增的整型数据作为主键，还能更好的避免数据增加的时候，带来的叶子节点的分裂，导致大量运算的问题。





为什么 HashMap 不能作为索引?

- HashMap 中的数据是无序，<font color=red>不支持范围</font>查找。

- 不能排序
- 出现大量 Hash 冲突，那么查询效率低下。





B-树

如下图 B-Tree 的数据是以磁盘块（数据页）存储在磁盘。每次从磁盘读取数据，至少读取一个磁盘块。在 B-Tree 的磁盘块中，存储着数据，相比键值和指针，data 所占的空间非常大。而 B+树 数据只存储在叶子节点，所以非叶子的磁盘块可以存储更多的键值和指针。所以相同的数据 B+ 树的高度低。

在查找数据过程中，B-树 查找路径上加载的磁盘块，也将不需要的数据加载到内存中，这是浪费的。

<img src="/images/tmp/WX20230312-153257@2x.png" style="zoom:30%;" />



B+树

<img src="/images/tmp/WX20230312-153515@2x.png" style="zoom:30%;" />



# 索引为什么会失效？

七字口诀：模型数空运最快

- 模：模糊查询，以 like 时，使用 "%xxxx"，索引失效。
- 型：数据类型，
- 数：函数，对索引字段使用内部函数，索引也会失效。应该建立基于函数的索引。
- 空：null，索引不存储空值，如果不限制索引列 not null，数据库会认为索引列有可能存在空值，不会按照索引进行计算。
- 运：运算。对索引列进行加、减、乘、除等运算，索引也会失效。
- 最：最左原则，在复合索引中，索引列的顺序很重要，如果不是按照索引列最左列开始查找，则无法使用索引。
- 快：如果全表扫描比使用索引更快的话，就不会使用索引。（走B+ 树叶子节点的链表）



# SQL 优化

1. 根据查询分析器适当优化SQL的结构，比如是否全表扫描，避免子查询。
2. 增加索引：简单高效，选择合适的列，同时避免索引失效的操作：like、函数。
3. 避免返回不必要的数据列，提升查询效率。
4. 分库分表：在单表数据量比较大或者并发连接数过高的情况下，通过这种方式可以有效提升查询效率
5. 读写分离 ：针对读多写少的场景，这样可以保证写操作的数据库承受更小的压力，也可以缓解独占锁和共享锁的竞争。