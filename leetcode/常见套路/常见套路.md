[TOC]

# 1. 滑动窗口

滑动窗口模式是用于<font color="red">数组或链表</font>上，从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。

窗口大小可以保持恒定，也可以增大或者减小。

![](/Users/dongyifeng/dongyf/git/typora/leetcode/images/v2-dc7225063817b561d916ceca6f5b7477_r.png)

**算法思想**

1. 在序列中使用双指针中的 `左右指针` 技巧，初始化 `left = right = 0`, 把索引闭区间`[left, right]` 称为一个 `窗口`
2. 先不断地 `增加 right 指针扩大窗口[ left, right]`,直到窗口中的序列符号要求。
3. 此时，停止增加 right，转而 `不断增加 left 指针缩小窗口[left, right]`,直到窗口中的序列不再符合要求。同时，`每次增加 left 前，都要更新一轮结果`。
4. 重复第 2 和第 3 步，直到 right 到达序列的尽头。

思路其实很简单：第 2 步相当于在寻找一个 `可行解`，然后第 3 步在 `优化这个可行解`，最终找到`最优解`。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。



**算法模板**

1. 单层循环

```python
def template(nums):
    # 初始化窗口两端
    left = right = 0
    n = len(nums)
    # 滑动窗口
    slide_win = []
		# 结果值
    rst = 0

    while right < n:
        slide_win.append(nums[right])
        # 还没找到一个可行解
        if not avaliable(slide_win):
            # 扩大窗口
            right += 1
        else:
            # 找到一个可行解，更新结果值
            rst = update()
            # 缩小窗口
            left += 1
    return rst
```

2. 双层循环

```python
def template(nums):
    # 初始化窗口两端
    left = right = 0
    n = len(nums)
    # 滑动窗口
    slide_win = []
		# 结果值
    rst = 0

    while right < n:
        slide_win.append(nums[right])
        # 还没找到一个可行解
        if not avaliable(slide_win):
            # 扩大窗口
            right += 1
            continue
        # 循环更新可行解
        while avaliable(slide_win):
            # 找到一个可行解，更新结果值
            rst = update()
            # 缩小窗口
            left += 1
    return rst
```



场景：

1. 问题的输入的是线性数据结构：链表，数组，字符串...
2. 要求查找：最长、最短的子字符串，子数组或所需的值。



常见问题：

1. 大小为 K 的子数组的最大和（简单）Leetcode 325
2. 带有 K 个不同字符的最长字符串（中等）
3. 寻找字符相同但排序不一样的字符串（困难）

# 2. 二指针或迭代器



# 3. 快慢指针或迭代器



# 4. 合并区间



# 5. 循环排序



# 6. 原地反转链表



# 7. 树的宽度优先搜索（Tree BFS）



# 8. 树的深度优先搜索（Tree DFS）



# 9. Two Heaps



# 10. 子集



# 11. 经过修改的二叉搜索



# 12. 前 K 个元素



# 13. K 路合并



# 14. 拓扑排序

