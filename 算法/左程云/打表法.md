[TOC]

面试题技巧

1. 滑动窗口
2. 打表法
3. 预处理数组



# 滑动窗口

> 给定一个数组 arr，代表数轴上从左到右有 n 个点，arr[0]、arr[1]、arr[2]、....、arr[0]。给定一个正数 L，代表一根长度为的绳子，求绳子最多能覆盖其中的几个点。





# 打表法

能用打表法的题目特征

1. 问题返回值不太多，可以用 hardcode 的方式列出，作为程序的一部分
2. 一个大问题解决时，底层频繁使用规模不大的小问题的解，如果小问题的返回值满足条件 1，可以把小问题的解列成一张表，作为程序的一部分。
3. 打表找规律



这样的大概有四成可以使用打表法



打表法步骤

1. 写出暴力解法
2. 多次调用暴力解法，将输入和出入打印出来。
3. 从结果中找规律，根据归纳出的规律直接返回结果



## 小虎买苹果

> 小虎去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供 6 个每袋和 8 个每袋的包装，包装不可拆分。可是小虎现在只想购买恰好 n 个苹果，小虎想购买尽量少的袋数方便携带。如果不能购买恰好 n 个苹果，小虎将不会购买。输入一个整数 n ,表示小虎想购买的苹果，返回最少使用多少袋子。如果无论如何都不能正好装下，返回 -1.



**暴力解法**

**分析**

最终要求的结果是<font color=red>最少</font>使用多少个袋子。那么尽可能多使用能装 8 苹果的大袋子。

最多能使用 bg8 = int( n / 8 ) 大袋子，剩下的苹果（rest = n - int(n/8) * 8）使用小袋子（6个苹果）去装，

如果剩下的苹果刚好能够装满 k 个小袋子（rest % 6 ==0）,那么返回 bg8 + int( rest / 6 )。

如果  rest % 6 !=0，说明不能用 int(n/8) 个大袋子，可以尝试 int(n/8) - 1个大袋子，然后再尝试小袋子。



24 是 8 和 6 最大公约数。如果大袋子装完后，剩余苹果大于 24，比如 rest = 27，那么 rest = 24 + 3，剩余的 24 可以用 3 个大袋子，而现在没有用大袋子，说明在之前用了 3 个大袋子后，小袋子不能装满，已经计算过了，不需要再计算了。



```python
# 如果剩余苹果 rest 可以装满小袋子，返回小袋子树
# 否则返回 -1
def min_bag_base6(rest):
    return int(rest / 6) if rest % 6 == 0 else -1

def min_bags(apple):
    if apple < 0: return -1
    bg6 = -1
    bg8 = int(apple / 8)
    rest = apple - 8 * bg8
    while bg8 >= 0 and rest < 24:
        rest_use6 = min_bag_base6(rest)
        if rest_use6 != -1:
            bg6 = rest_use6
            break
        bg8 -= 1
        rest = apple - 8 * bg8

    return -1 if bg6 == -1 else bg6 + bg8

for i in range(100):
    print(i, min_bags(i))
```



输出结果：

<font color=green>0 0</font>
1 -1
2 -1
3 -1
4 -1
5 -1
<font color=green>6 1</font>
7 -1
<font color=green>8 1</font>
9 -1
10 -1
11 -1
<font color=green>12 2</font>
13 -1
<font color=green>14 2</font>
15 -1
<font color=green>16 2</font>
17 -1
<font color=orange>18 3</font>
<font color=red>19 -1</font>
<font color=orange>20 3</font>
<font color=red>21 -1</font>
<font color=orange>22 3</font>
<font color=red>23 -1</font>
<font color=orange>24 3</font>
<font color=red>25 -1</font>
<font color=blue>26 4</font>
<font color=red>27 -1</font>
<font color=blue>28 4</font>
<font color=red>29 -1</font>
<font color=blue>30 4</font>
<font color=red>31 -1</font>
<font color=blue>32 4</font>
<font color=red>33 -1</font>
<font color=orange>34 5</font>
<font color=red>35 -1</font>
<font color=orange>36 5</font>
<font color=red>37 -1</font>
<font color=orange>38 5</font>
<font color=red>39 -1</font>
<font color=orange>40 5</font>
<font color=red>41 -1</font>

从暴力解中得到规律：

1. 奇数个苹果，返回 -1
2. 苹果数 > 18后，每 8 个数是一组，这一组中的偶数苹果使用的袋子袋子数从 3 开始，每组加 1。即：：int((apple - 18) / 8) + 3
3. 单独处理前 18 个数据



**打表法**

时间复杂度：O(1)

空间复杂度：O(1)

```python
def min_bags2(apple):
    if apple < 0 or apple % 2 != 0: return -1
    if apple < 18:
        tmp = {0: 0, 6: 1, 8: 1, 12: 2, 14: 2, 16: 2}
        return tmp[apple] if apple in tmp else -1
    return int((apple - 18) / 8) + 3
```



## 牛羊吃草

> 给定一个正整数 N，表示有 N 份青草统一堆放在仓库里。有一只牛和一只羊，牛先吃，羊后吃，他两个轮流吃草。不管是牛还是羊，每一轮能吃的草量必须是：1,4,16,64...(4的某次方)。谁最先把草吃完，谁获胜。假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。
>
> 根据唯一的参数 N，返回谁会盈。



**暴力解法**

**分析**

当 n 确定后，谁输谁赢就定了。

先手可以从 1 进行尝试：base = 1，那么剩下的就是 n - base 就是后手的，如果先手能赢，直接返回。

否则先手从 4 进行尝试：base = 4，那么剩下的就是 n - base 就是后手的，如果先手能赢，直接返回。

否则先手从 16 进行尝试：base = 16，那么剩下的就是 n - base 就是后手的，如果先手能赢，直接返回。

...

否则：后手赢

```python
def winner1(n):
    # n: 0  1  2  3  4
    # 赢 后 先  后 先 先
    if n < 5: return "后手" if n == 0 or n == 2 else "先手"
    # n > 5
    base = 1  # 先手决定吃的草

    while base <= n:
        # 当前一共 n 份草，先手吃掉的是 base 份，n - base 是留个后手的草
        # 母过程中的先手，在子过程里就是 后手
        if winner1(n - base) == "后手":
            return "先手"
        # 防止 base*4 溢出：当 n 接近系统溢出值，base*4 很用可能就溢出了。
        if base > int(n / 4):
            break
        # 这是不断调整 base 进行尝试
        base *= 4
    return "后手"
```



<font color=green>0 后手</font>
<font color=green>1 先手</font>
<font color=green>2 后手</font>
<font color=green>3 先手</font>
<font color=green>4 先手</font>
<font color=orange>5 后手</font>
<font color=orange>6 先手</font>
<font color=orange>7 后手</font>
<font color=orange>8 先手</font>
<font color=orange>9 先手</font>
<font color=green>10 后手</font>
<font color=green>11 先手</font>
<font color=green>12 后手</font>
<font color=green>13 先手</font>
<font color=green>14 先手</font>



从暴力解中得到规律：

1. 每 5 个一组
2. 每组中第一个和第三个是”后手“，其他都是”先手“



**打表法**

时间复杂度：O(1)

空间复杂度：O(1)

```python
def winner2(n):
    if n % 5 == 0 or n % 5 == 2:
        return "后手"
    return "先手"

for i in range(50):
    print(i, winner1(i), winner2(i))
```



## 例3

> 定义一种树：可以表示成若干（数量 > 1）连续正数和的数，给一个参数 n，返回是不是可以表示成若干连续正整数和的数。

```python
5 = 2 + 3
12 = 3 + 4 + 5
1 不是，因为要求数量大于 1 个、连续正数和
2 = 1 + 1 不是，因为等号右边不是连续正数
```

**暴力解法**

```python
def is_m_sum(n):
    for i in range(1, n):
        res = i
        tmp = [i]
        for j in range(i + 1, n):
            res += j
            tmp.append(j)
            if res == n:
                return True
            if res > n:
                break
    return False
```

<font color=red>0 False</font>
<font color=red>1 False</font>
<font color=red>2 False</font>
3 True
<font color=red>4 False</font>
5 True
6 True
7 True
<font color=red>8 False</font>
9 True
10 True
11 True
12 True
13 True
14 True
15 True
<font color=red>16 False</font>
17 True
18 True
19 True
20 True
21 True
22 True
23 True
24 True
25 True
26 True
27 True
28 True
29 True
30 True
31 True
<font color=red>32 False</font>
33 True
34 True

从 False 的 n:[0 , 1, 2 , 4 , 8 , 16 , 32]

规律：除了 0 外，都是 2 的 k 次方

 

```python
def is_m_sum2(n):
    if n == 0: return False
    tmp = math.log(n, 2)
    return tmp != int(tmp)
  
# 通过位运算判断 n 是不是 2 的几次方
def is_m_sum3(n):
    if n == 0: return False
    return (n & (n - 1)) != 0
  
# 对数器
expect = []
actual = []

for i in range(200):
    expect.append(is_m_sum(i))
    actual.append(is_m_sum2(i))
print("result", actual == expect)
```







# 预处理数组

## 数组质数因子个数和

> 在一个数组 arr 中，每个数的大小都不超过 1000，例如：[10,9,6,12]，求所有数质数因子的个数求和。

```python
10 = 2 * 5
9  = 3 * 3
6  = 2 * 3
12 = 3 * 2 * 2
```





```python
# 给一个正整数 n ，返回 n 的质数因子个数
def count_primes(n):
    res = 0
    for i in range(2, round(pow(n, 0.5)) + 1):
      	# 这里不需要判断 i 是否是质数。
        # 如果 i 是合数，i = j * k，在 i = j 或者 i = k 时，while 已经除完了。
        while n % i == 0:
            res += 1
            n /= i
    if n != 1:
        res += 1
    return res

res = []
for i in range(1001):
    res.append(count_primes(i))
    
print(res)
```

计算出 0 ~ 1000 所有的质数因子个数，在计算 arr 质数因子个数之和时，直接查表



时间复杂度：O(n)

空间复杂度：O(1000)

```python
def sum_primes(arr):
    bd = [1, 0, 1, 1, 2, 1, 2, 1, 3, 2, 2, 1, 3, 1, 2, 2, 4, 1, 3, 1, 3, 2, 2, 1, 4, 2, 2, 3, 3, 1, 3, 1, 5, 2, 2, 2, 4,
          1, 2, 2, 4, 1, 3, 1, 3, 3, 2, 1, 5, 2, 3, 2, 3, 1, 4, 2, 4, 2, 2, 1, 4, 1, 2, 3, 6, 2, 3, 1, 3, 2, 3, 1, 5, 1,
          2, 3, 3, 2, 3, 1, 5, 4, 2, 1, 4, 2, 2, 2, 4, 1, 4, 2, 3, 2, 2, 2, 6, 1, 3, 3, 4, 1, 3, 1, 4, 3, 2, 1, 5, 1, 3,
          2, 5, 1, 3, 2, 3, 3, 2, 2, 5, 2, 2, 2, 3, 3, 4, 1, 7, 2, 3, 1, 4, 2, 2, 4, 4, 1, 3, 1, 4, 2, 2, 2, 6, 2, 2, 3,
          3, 1, 4, 1, 4, 3, 3, 2, 4, 1, 2, 2, 6, 2, 5, 1, 3, 3, 2, 1, 5, 2, 3, 3, 3, 1, 3, 3, 5, 2, 2, 1, 5, 1, 3, 2, 4,
          2, 3, 2, 3, 4, 3, 1, 7, 1, 2, 3, 4, 1, 4, 1, 5, 2, 2, 2, 4, 2, 2, 3, 5, 2, 4, 1, 3, 2, 2, 2, 6, 2, 2, 2, 4, 2,
          3, 1, 6, 4, 2, 1, 4, 1, 3, 3, 4, 1, 4, 2, 3, 2, 3, 1, 6, 1, 3, 5, 3, 3, 3, 2, 4, 2, 4, 1, 5, 2, 2, 3, 8, 1, 3,
          2, 4, 3, 2, 1, 5, 2, 3, 2, 3, 1, 5, 1, 5, 3, 2, 3, 4, 1, 2, 3, 5, 1, 3, 1, 3, 3, 3, 2, 7, 2, 3, 2, 3, 1, 4, 2,
          4, 4, 2, 2, 5, 2, 2, 2, 5, 2, 4, 1, 4, 2, 3, 1, 5, 1, 2, 4, 3, 1, 3, 2, 7, 2, 3, 2, 6, 3, 2, 2, 4, 2, 4, 1, 3,
          3, 2, 2, 6, 1, 3, 2, 4, 2, 4, 3, 4, 3, 2, 1, 4, 1, 4, 4, 6, 1, 3, 2, 3, 3, 2, 1, 6, 2, 2, 3, 4, 2, 3, 1, 5, 3,
          3, 2, 4, 1, 3, 4, 4, 2, 5, 1, 4, 2, 2, 1, 8, 3, 2, 3, 3, 1, 4, 2, 5, 2, 2, 2, 5, 1, 2, 3, 6, 1, 3, 2, 3, 5, 3,
          2, 5, 1, 3, 2, 3, 2, 4, 2, 6, 2, 3, 1, 5, 1, 2, 3, 4, 3, 3, 2, 3, 3, 3, 1, 7, 1, 3, 3, 3, 2, 3, 1, 5, 4, 3, 1,
          4, 2, 2, 2, 7, 1, 5, 2, 3, 2, 2, 3, 5, 1, 2, 4, 4, 1, 4, 1, 5, 3, 2, 1, 5, 2, 3, 2, 4, 2, 3, 3, 4, 3, 2, 1, 7,
          2, 2, 3, 4, 2, 6, 1, 4, 2, 4, 1, 4, 2, 3, 4, 5, 2, 3, 1, 5, 2, 2, 1, 6, 2, 3, 3, 3, 1, 4, 2, 9, 4, 2, 2, 4, 2,
          3, 2, 5, 1, 4, 1, 3, 4, 2, 2, 6, 2, 3, 3, 4, 2, 3, 2, 4, 2, 2, 3, 6, 1, 2, 2, 6, 2, 4, 1, 3, 3, 4, 2, 5, 2, 2,
          3, 3, 1, 4, 2, 6, 3, 2, 1, 4, 2, 2, 5, 4, 1, 4, 1, 4, 2, 3, 3, 8, 1, 3, 2, 4, 2, 3, 2, 4, 4, 2, 1, 5, 2, 3, 2,
          5, 1, 5, 3, 3, 2, 3, 1, 6, 1, 3, 3, 3, 3, 3, 1, 6, 3, 3, 2, 5, 1, 2, 3, 5, 1, 3, 1, 4, 4, 2, 2, 6, 4, 2, 3, 3,
          2, 5, 1, 4, 2, 2, 2, 4, 3, 3, 3, 8, 1, 3, 1, 4, 3, 3, 1, 7, 2, 4, 3, 3, 1, 3, 2, 5, 3, 3, 1, 5, 1, 2, 3, 4, 3,
          4, 2, 3, 2, 3, 2, 7, 1, 2, 5, 4, 1, 3, 2, 5, 2, 3, 1, 5, 2, 4, 2, 5, 2, 4, 1, 3, 4, 2, 2, 5, 2, 2, 2, 5, 1, 5,
          2, 7, 3, 2, 2, 4, 1, 3, 3, 4, 2, 4, 3, 3, 2, 2, 1, 7, 2, 3, 2, 3, 3, 4, 1, 5, 6, 3, 2, 4, 1, 2, 4, 6, 2, 4, 1,
          4, 3, 3, 1, 5, 2, 2, 3, 4, 2, 5, 1, 5, 2, 3, 2, 6, 1, 2, 3, 5, 1, 3, 2, 3, 4, 2, 2, 9, 1, 4, 2, 3, 1, 4, 3, 4,
          3, 2, 2, 5, 2, 3, 4, 6, 2, 3, 1, 3, 2, 3, 2, 6, 2, 2, 3, 3, 1, 4, 2, 7, 3, 2, 2, 4, 3, 3, 2, 4, 1, 6, 1, 4, 2,
          3, 2, 6, 2, 2, 4, 4, 1, 3, 1, 4, 4, 3, 1, 5, 1, 3, 2, 7, 3, 3, 2, 4, 4, 2, 1, 6, 2, 2, 2, 3, 3, 4, 3, 5, 2, 4,
          2, 4, 1, 3, 4, 4, 1, 4, 1, 4, 3, 2, 1, 8, 2, 2, 3, 4, 2, 4, 2, 4, 3, 3, 4, 4, 1, 2, 2, 6, 1, 5, 1, 4, 3, 2, 1,
          5, 2, 3, 5, 3, 2, 3, 2, 8, 3, 2, 2, 6, 2, 3, 3, 4, 2, 3, 1, 3, 3, 4, 1, 6, 2, 2, 3, 3, 2, 5, 1, 5, 2, 2, 2, 5,
          3, 2, 3, 6, 1, 4, 3, 3, 2, 2, 3, 6, 1, 3, 2, 4, 1, 3, 2, 5, 5, 3, 1, 4, 2, 4, 2, 5, 1, 4, 2, 3, 3, 2, 2, 8, 2,
          3, 3, 3, 2, 4, 1, 5, 3, 3, 1, 7, 2, 2, 4, 5, 1, 3, 2, 5, 3, 2, 1, 5, 2, 3, 3, 4, 2, 5, 1, 6, 2, 3, 2, 4, 1, 2,
          4, 6]
    res = 0
    for item in arr:
        res += bd[item]
    return res

print(sum_primes([180, 180]))
```

