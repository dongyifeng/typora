WRMCB=function(e){var c=console;if(c&&c.log&&c.error){c.log('Error running batched script.');c.error(e);}}
;
try {
/* module-key = 'com.atlassian.auiplugin:internal-src-js-vendor-jquery-plugins-jquery-select2', location = 'src/js-vendor/jquery/plugins/jquery.select2.js' */
("undefined"===typeof window?global:window).__63e2d0d906dfc9cc19eb6e8389c4f5a3=function(){var y=jQuery;"undefined"==typeof y.fn.each2&&y.extend(y.fn,{each2:function(a){for(var b=y([0]),c=-1,d=this.length;++c<d&&(b.context=b[0]=this[c])&&!1!==a.call(b[0],c,b););return this}});var e=jQuery,w=function(a){var b,c,d,g;if(!a||1>a.length)return a;b="";c=0;for(d=a.length;c<d;c++)g=a.charAt(c),b+=O[g]||g;return b},k=function(a,b){for(var c=0,d=b.length;c<d;c+=1)if(m(a,b[c]))return c;return-1},m=function(a,
b){return a===b?!0:void 0===a||void 0===b||null===a||null===b?!1:a.constructor===String?a+""===b+"":b.constructor===String?b+""===a+"":!1},B=function(a,b){var c,d,g;if(null===a||1>a.length)return[];c=a.split(b);d=0;for(g=c.length;d<g;d+=1)c[d]=e.trim(c[d]);return c},G=function(a){a.on("keydown",function(){void 0===e.data(a,"keyup-change-value")&&e.data(a,"keyup-change-value",a.val())});a.on("keyup",function(){var b=e.data(a,"keyup-change-value");void 0!==b&&a.val()!==b&&(e.removeData(a,"keyup-change-value"),
a.trigger("keyup-change"))})},H=function(a,b,c){var c=c||void 0,d;return function(){var g=arguments;window.clearTimeout(d);d=window.setTimeout(function(){b.apply(c,g)},a)}},j=function(a){a.preventDefault();a.stopPropagation()},z=function(a,b,c){var d,g=[],h;(d=a.attr("class"))&&e((""+d).split(" ")).each2(function(){0===this.indexOf("select2-")&&g.push(this)});(d=b.attr("class"))&&e((""+d).split(" ")).each2(function(){0!==this.indexOf("select2-")&&(h=c(this))&&g.push(h)});a.attr("class",g.join(" "))},
I=function(a,b,c,d){var g=w(a.toUpperCase()).indexOf(w(b.toUpperCase())),b=b.length;0>g?c.push(d(a)):(c.push(d(a.substring(0,g))),c.push("<span class='select2-match'>"),c.push(d(a.substring(g,g+b))),c.push("</span>"),c.push(d(a.substring(g+b,a.length))))},J=function(a){var b={"\\":"&#92;","&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#47;"};return String(a).replace(/[&<>"'\/\\]/g,function(a){return b[a]})},K=function(a){var b,c=null,d=a.quietMillis||100,g=a.url,h=this;return function(l){window.clearTimeout(b);
b=window.setTimeout(function(){var b=a.data,d=g,t=a.transport||e.fn.select2.ajaxDefaults.transport,f=e.extend({},e.fn.select2.ajaxDefaults.params,{type:a.type||"GET",cache:a.cache||!1,jsonpCallback:a.jsonpCallback||void 0,dataType:a.dataType||"json"}),b=b?b.call(h,l.term,l.page,l.context):null,d="function"===typeof d?d.call(h,l.term,l.page,l.context):d;c&&c.abort();a.params&&(e.isFunction(a.params)?e.extend(f,a.params.call(h)):e.extend(f,a.params));e.extend(f,{url:d,dataType:a.dataType,data:b,success:function(b){b=
a.results(b,l.page);l.callback(b)}});c=t.call(h,f)},d)}},L=function(a){var b=a,c,d,g=function(a){return""+a.text};e.isArray(b)&&(d=b,b={results:d});!1===e.isFunction(b)&&(d=b,b=function(){return d});a=b();a.text&&(g=a.text,e.isFunction(g)||(c=a.text,g=function(a){return a[c]}));return function(a){var c=a.term,d={results:[]},n;if(c==="")a.callback(b());else{n=function(b,d){var i,f,b=b[0];if(b.children){i={};for(f in b)b.hasOwnProperty(f)&&(i[f]=b[f]);i.children=[];e(b.children).each2(function(a,b){n(b,
i.children)});(i.children.length||a.matcher(c,g(i),b))&&d.push(i)}else a.matcher(c,g(b),b)&&d.push(b)};e(b().results).each2(function(a,b){n(b,d.results)});a.callback(d)}}},M=function(a){var b=e.isFunction(a);return function(c){var d=c.term,g={results:[]};e(b?a():a).each(function(){var a=void 0!==this.text,b=a?this.text:this;if(""===d||c.matcher(d,b))g.results.push(a?this:{id:this,text:this})});c.callback(g)}},r=function(a,b){if(e.isFunction(a))return!0;if(!a)return!1;throw Error(b+" must be a function or a falsy value");
},o=function(a){return e.isFunction(a)?a():a},N=function(a){var b=0;e.each(a,function(a,d){d.children?b+=N(d.children):b++});return b},P=function(a,b,c,d){var g=a,h=!1,e,i,f,t;if(d.createSearchChoice&&d.tokenSeparators&&!(1>d.tokenSeparators.length)){for(;;){h=-1;i=0;for(f=d.tokenSeparators.length;i<f&&!(t=d.tokenSeparators[i],h=a.indexOf(t),0<=h);i++);if(0>h)break;e=a.substring(0,h);a=a.substring(h+t.length);if(0<e.length&&(e=d.createSearchChoice.call(this,e,b),void 0!==e&&null!==e&&void 0!==d.id(e)&&
null!==d.id(e))){h=!1;i=0;for(f=b.length;i<f;i++)if(m(d.id(e),d.id(b[i]))){h=!0;break}h||c(e)}}if(g!==a)return a}},C=function(a,b){var c=function(){};c.prototype=new a;c.prototype.constructor=c;c.prototype.parent=a.prototype;c.prototype=e.extend(c.prototype,b);return c};if(void 0===window.Select2){var f,s,D,E,A,v,x={x:0,y:0},F;f={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,isArrow:function(a){a=
a.which?a.which:a;switch(a){case f.LEFT:case f.RIGHT:case f.UP:case f.DOWN:return!0}return!1},isControl:function(a){switch(a.which){case f.SHIFT:case f.CTRL:case f.ALT:return!0}return a.metaKey?!0:!1},isFunctionKey:function(a){a=a.which?a.which:a;return 112<=a&&123>=a}};var O={"\u24b6":"A","\uff21":"A","\u00c0":"A","\u00c1":"A","\u00c2":"A","\u1ea6":"A","\u1ea4":"A","\u1eaa":"A","\u1ea8":"A","\u00c3":"A","\u0100":"A","\u0102":"A","\u1eb0":"A","\u1eae":"A","\u1eb4":"A","\u1eb2":"A","\u0226":"A","\u01e0":"A",
"\u00c4":"A","\u01de":"A","\u1ea2":"A","\u00c5":"A","\u01fa":"A","\u01cd":"A","\u0200":"A","\u0202":"A","\u1ea0":"A","\u1eac":"A","\u1eb6":"A","\u1e00":"A","\u0104":"A","\u023a":"A","\u2c6f":"A","\ua732":"AA","\u00c6":"AE","\u01fc":"AE","\u01e2":"AE","\ua734":"AO","\ua736":"AU","\ua738":"AV","\ua73a":"AV","\ua73c":"AY","\u24b7":"B","\uff22":"B","\u1e02":"B","\u1e04":"B","\u1e06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24b8":"C","\uff23":"C","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C",
"\u00c7":"C","\u1e08":"C","\u0187":"C","\u023b":"C","\ua73e":"C","\u24b9":"D","\uff24":"D","\u1e0a":"D","\u010e":"D","\u1e0c":"D","\u1e10":"D","\u1e12":"D","\u1e0e":"D","\u0110":"D","\u018b":"D","\u018a":"D","\u0189":"D","\ua779":"D","\u01f1":"DZ","\u01c4":"DZ","\u01f2":"Dz","\u01c5":"Dz","\u24ba":"E","\uff25":"E","\u00c8":"E","\u00c9":"E","\u00ca":"E","\u1ec0":"E","\u1ebe":"E","\u1ec4":"E","\u1ec2":"E","\u1ebc":"E","\u0112":"E","\u1e14":"E","\u1e16":"E","\u0114":"E","\u0116":"E","\u00cb":"E","\u1eba":"E",
"\u011a":"E","\u0204":"E","\u0206":"E","\u1eb8":"E","\u1ec6":"E","\u0228":"E","\u1e1c":"E","\u0118":"E","\u1e18":"E","\u1e1a":"E","\u0190":"E","\u018e":"E","\u24bb":"F","\uff26":"F","\u1e1e":"F","\u0191":"F","\ua77b":"F","\u24bc":"G","\uff27":"G","\u01f4":"G","\u011c":"G","\u1e20":"G","\u011e":"G","\u0120":"G","\u01e6":"G","\u0122":"G","\u01e4":"G","\u0193":"G","\ua7a0":"G","\ua77d":"G","\ua77e":"G","\u24bd":"H","\uff28":"H","\u0124":"H","\u1e22":"H","\u1e26":"H","\u021e":"H","\u1e24":"H","\u1e28":"H",
"\u1e2a":"H","\u0126":"H","\u2c67":"H","\u2c75":"H","\ua78d":"H","\u24be":"I","\uff29":"I","\u00cc":"I","\u00cd":"I","\u00ce":"I","\u0128":"I","\u012a":"I","\u012c":"I","\u0130":"I","\u00cf":"I","\u1e2e":"I","\u1ec8":"I","\u01cf":"I","\u0208":"I","\u020a":"I","\u1eca":"I","\u012e":"I","\u1e2c":"I","\u0197":"I","\u24bf":"J","\uff2a":"J","\u0134":"J","\u0248":"J","\u24c0":"K","\uff2b":"K","\u1e30":"K","\u01e8":"K","\u1e32":"K","\u0136":"K","\u1e34":"K","\u0198":"K","\u2c69":"K","\ua740":"K","\ua742":"K",
"\ua744":"K","\ua7a2":"K","\u24c1":"L","\uff2c":"L","\u013f":"L","\u0139":"L","\u013d":"L","\u1e36":"L","\u1e38":"L","\u013b":"L","\u1e3c":"L","\u1e3a":"L","\u0141":"L","\u023d":"L","\u2c62":"L","\u2c60":"L","\ua748":"L","\ua746":"L","\ua780":"L","\u01c7":"LJ","\u01c8":"Lj","\u24c2":"M","\uff2d":"M","\u1e3e":"M","\u1e40":"M","\u1e42":"M","\u2c6e":"M","\u019c":"M","\u24c3":"N","\uff2e":"N","\u01f8":"N","\u0143":"N","\u00d1":"N","\u1e44":"N","\u0147":"N","\u1e46":"N","\u0145":"N","\u1e4a":"N","\u1e48":"N",
"\u0220":"N","\u019d":"N","\ua790":"N","\ua7a4":"N","\u01ca":"NJ","\u01cb":"Nj","\u24c4":"O","\uff2f":"O","\u00d2":"O","\u00d3":"O","\u00d4":"O","\u1ed2":"O","\u1ed0":"O","\u1ed6":"O","\u1ed4":"O","\u00d5":"O","\u1e4c":"O","\u022c":"O","\u1e4e":"O","\u014c":"O","\u1e50":"O","\u1e52":"O","\u014e":"O","\u022e":"O","\u0230":"O","\u00d6":"O","\u022a":"O","\u1ece":"O","\u0150":"O","\u01d1":"O","\u020c":"O","\u020e":"O","\u01a0":"O","\u1edc":"O","\u1eda":"O","\u1ee0":"O","\u1ede":"O","\u1ee2":"O","\u1ecc":"O",
"\u1ed8":"O","\u01ea":"O","\u01ec":"O","\u00d8":"O","\u01fe":"O","\u0186":"O","\u019f":"O","\ua74a":"O","\ua74c":"O","\u01a2":"OI","\ua74e":"OO","\u0222":"OU","\u24c5":"P","\uff30":"P","\u1e54":"P","\u1e56":"P","\u01a4":"P","\u2c63":"P","\ua750":"P","\ua752":"P","\ua754":"P","\u24c6":"Q","\uff31":"Q","\ua756":"Q","\ua758":"Q","\u024a":"Q","\u24c7":"R","\uff32":"R","\u0154":"R","\u1e58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1e5a":"R","\u1e5c":"R","\u0156":"R","\u1e5e":"R","\u024c":"R","\u2c64":"R",
"\ua75a":"R","\ua7a6":"R","\ua782":"R","\u24c8":"S","\uff33":"S","\u1e9e":"S","\u015a":"S","\u1e64":"S","\u015c":"S","\u1e60":"S","\u0160":"S","\u1e66":"S","\u1e62":"S","\u1e68":"S","\u0218":"S","\u015e":"S","\u2c7e":"S","\ua7a8":"S","\ua784":"S","\u24c9":"T","\uff34":"T","\u1e6a":"T","\u0164":"T","\u1e6c":"T","\u021a":"T","\u0162":"T","\u1e70":"T","\u1e6e":"T","\u0166":"T","\u01ac":"T","\u01ae":"T","\u023e":"T","\ua786":"T","\ua728":"TZ","\u24ca":"U","\uff35":"U","\u00d9":"U","\u00da":"U","\u00db":"U",
"\u0168":"U","\u1e78":"U","\u016a":"U","\u1e7a":"U","\u016c":"U","\u00dc":"U","\u01db":"U","\u01d7":"U","\u01d5":"U","\u01d9":"U","\u1ee6":"U","\u016e":"U","\u0170":"U","\u01d3":"U","\u0214":"U","\u0216":"U","\u01af":"U","\u1eea":"U","\u1ee8":"U","\u1eee":"U","\u1eec":"U","\u1ef0":"U","\u1ee4":"U","\u1e72":"U","\u0172":"U","\u1e76":"U","\u1e74":"U","\u0244":"U","\u24cb":"V","\uff36":"V","\u1e7c":"V","\u1e7e":"V","\u01b2":"V","\ua75e":"V","\u0245":"V","\ua760":"VY","\u24cc":"W","\uff37":"W","\u1e80":"W",
"\u1e82":"W","\u0174":"W","\u1e86":"W","\u1e84":"W","\u1e88":"W","\u2c72":"W","\u24cd":"X","\uff38":"X","\u1e8a":"X","\u1e8c":"X","\u24ce":"Y","\uff39":"Y","\u1ef2":"Y","\u00dd":"Y","\u0176":"Y","\u1ef8":"Y","\u0232":"Y","\u1e8e":"Y","\u0178":"Y","\u1ef6":"Y","\u1ef4":"Y","\u01b3":"Y","\u024e":"Y","\u1efe":"Y","\u24cf":"Z","\uff3a":"Z","\u0179":"Z","\u1e90":"Z","\u017b":"Z","\u017d":"Z","\u1e92":"Z","\u1e94":"Z","\u01b5":"Z","\u0224":"Z","\u2c7f":"Z","\u2c6b":"Z","\ua762":"Z","\u24d0":"a","\uff41":"a",
"\u1e9a":"a","\u00e0":"a","\u00e1":"a","\u00e2":"a","\u1ea7":"a","\u1ea5":"a","\u1eab":"a","\u1ea9":"a","\u00e3":"a","\u0101":"a","\u0103":"a","\u1eb1":"a","\u1eaf":"a","\u1eb5":"a","\u1eb3":"a","\u0227":"a","\u01e1":"a","\u00e4":"a","\u01df":"a","\u1ea3":"a","\u00e5":"a","\u01fb":"a","\u01ce":"a","\u0201":"a","\u0203":"a","\u1ea1":"a","\u1ead":"a","\u1eb7":"a","\u1e01":"a","\u0105":"a","\u2c65":"a","\u0250":"a","\ua733":"aa","\u00e6":"ae","\u01fd":"ae","\u01e3":"ae","\ua735":"ao","\ua737":"au","\ua739":"av",
"\ua73b":"av","\ua73d":"ay","\u24d1":"b","\uff42":"b","\u1e03":"b","\u1e05":"b","\u1e07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24d2":"c","\uff43":"c","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u00e7":"c","\u1e09":"c","\u0188":"c","\u023c":"c","\ua73f":"c","\u2184":"c","\u24d3":"d","\uff44":"d","\u1e0b":"d","\u010f":"d","\u1e0d":"d","\u1e11":"d","\u1e13":"d","\u1e0f":"d","\u0111":"d","\u018c":"d","\u0256":"d","\u0257":"d","\ua77a":"d","\u01f3":"dz","\u01c6":"dz","\u24d4":"e","\uff45":"e",
"\u00e8":"e","\u00e9":"e","\u00ea":"e","\u1ec1":"e","\u1ebf":"e","\u1ec5":"e","\u1ec3":"e","\u1ebd":"e","\u0113":"e","\u1e15":"e","\u1e17":"e","\u0115":"e","\u0117":"e","\u00eb":"e","\u1ebb":"e","\u011b":"e","\u0205":"e","\u0207":"e","\u1eb9":"e","\u1ec7":"e","\u0229":"e","\u1e1d":"e","\u0119":"e","\u1e19":"e","\u1e1b":"e","\u0247":"e","\u025b":"e","\u01dd":"e","\u24d5":"f","\uff46":"f","\u1e1f":"f","\u0192":"f","\ua77c":"f","\u24d6":"g","\uff47":"g","\u01f5":"g","\u011d":"g","\u1e21":"g","\u011f":"g",
"\u0121":"g","\u01e7":"g","\u0123":"g","\u01e5":"g","\u0260":"g","\ua7a1":"g","\u1d79":"g","\ua77f":"g","\u24d7":"h","\uff48":"h","\u0125":"h","\u1e23":"h","\u1e27":"h","\u021f":"h","\u1e25":"h","\u1e29":"h","\u1e2b":"h","\u1e96":"h","\u0127":"h","\u2c68":"h","\u2c76":"h","\u0265":"h","\u0195":"hv","\u24d8":"i","\uff49":"i","\u00ec":"i","\u00ed":"i","\u00ee":"i","\u0129":"i","\u012b":"i","\u012d":"i","\u00ef":"i","\u1e2f":"i","\u1ec9":"i","\u01d0":"i","\u0209":"i","\u020b":"i","\u1ecb":"i","\u012f":"i",
"\u1e2d":"i","\u0268":"i","\u0131":"i","\u24d9":"j","\uff4a":"j","\u0135":"j","\u01f0":"j","\u0249":"j","\u24da":"k","\uff4b":"k","\u1e31":"k","\u01e9":"k","\u1e33":"k","\u0137":"k","\u1e35":"k","\u0199":"k","\u2c6a":"k","\ua741":"k","\ua743":"k","\ua745":"k","\ua7a3":"k","\u24db":"l","\uff4c":"l","\u0140":"l","\u013a":"l","\u013e":"l","\u1e37":"l","\u1e39":"l","\u013c":"l","\u1e3d":"l","\u1e3b":"l","\u017f":"l","\u0142":"l","\u019a":"l","\u026b":"l","\u2c61":"l","\ua749":"l","\ua781":"l","\ua747":"l",
"\u01c9":"lj","\u24dc":"m","\uff4d":"m","\u1e3f":"m","\u1e41":"m","\u1e43":"m","\u0271":"m","\u026f":"m","\u24dd":"n","\uff4e":"n","\u01f9":"n","\u0144":"n","\u00f1":"n","\u1e45":"n","\u0148":"n","\u1e47":"n","\u0146":"n","\u1e4b":"n","\u1e49":"n","\u019e":"n","\u0272":"n","\u0149":"n","\ua791":"n","\ua7a5":"n","\u01cc":"nj","\u24de":"o","\uff4f":"o","\u00f2":"o","\u00f3":"o","\u00f4":"o","\u1ed3":"o","\u1ed1":"o","\u1ed7":"o","\u1ed5":"o","\u00f5":"o","\u1e4d":"o","\u022d":"o","\u1e4f":"o","\u014d":"o",
"\u1e51":"o","\u1e53":"o","\u014f":"o","\u022f":"o","\u0231":"o","\u00f6":"o","\u022b":"o","\u1ecf":"o","\u0151":"o","\u01d2":"o","\u020d":"o","\u020f":"o","\u01a1":"o","\u1edd":"o","\u1edb":"o","\u1ee1":"o","\u1edf":"o","\u1ee3":"o","\u1ecd":"o","\u1ed9":"o","\u01eb":"o","\u01ed":"o","\u00f8":"o","\u01ff":"o","\u0254":"o","\ua74b":"o","\ua74d":"o","\u0275":"o","\u01a3":"oi","\u0223":"ou","\ua74f":"oo","\u24df":"p","\uff50":"p","\u1e55":"p","\u1e57":"p","\u01a5":"p","\u1d7d":"p","\ua751":"p","\ua753":"p",
"\ua755":"p","\u24e0":"q","\uff51":"q","\u024b":"q","\ua757":"q","\ua759":"q","\u24e1":"r","\uff52":"r","\u0155":"r","\u1e59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1e5b":"r","\u1e5d":"r","\u0157":"r","\u1e5f":"r","\u024d":"r","\u027d":"r","\ua75b":"r","\ua7a7":"r","\ua783":"r","\u24e2":"s","\uff53":"s","\u00df":"s","\u015b":"s","\u1e65":"s","\u015d":"s","\u1e61":"s","\u0161":"s","\u1e67":"s","\u1e63":"s","\u1e69":"s","\u0219":"s","\u015f":"s","\u023f":"s","\ua7a9":"s","\ua785":"s","\u1e9b":"s",
"\u24e3":"t","\uff54":"t","\u1e6b":"t","\u1e97":"t","\u0165":"t","\u1e6d":"t","\u021b":"t","\u0163":"t","\u1e71":"t","\u1e6f":"t","\u0167":"t","\u01ad":"t","\u0288":"t","\u2c66":"t","\ua787":"t","\ua729":"tz","\u24e4":"u","\uff55":"u","\u00f9":"u","\u00fa":"u","\u00fb":"u","\u0169":"u","\u1e79":"u","\u016b":"u","\u1e7b":"u","\u016d":"u","\u00fc":"u","\u01dc":"u","\u01d8":"u","\u01d6":"u","\u01da":"u","\u1ee7":"u","\u016f":"u","\u0171":"u","\u01d4":"u","\u0215":"u","\u0217":"u","\u01b0":"u","\u1eeb":"u",
"\u1ee9":"u","\u1eef":"u","\u1eed":"u","\u1ef1":"u","\u1ee5":"u","\u1e73":"u","\u0173":"u","\u1e77":"u","\u1e75":"u","\u0289":"u","\u24e5":"v","\uff56":"v","\u1e7d":"v","\u1e7f":"v","\u028b":"v","\ua75f":"v","\u028c":"v","\ua761":"vy","\u24e6":"w","\uff57":"w","\u1e81":"w","\u1e83":"w","\u0175":"w","\u1e87":"w","\u1e85":"w","\u1e98":"w","\u1e89":"w","\u2c73":"w","\u24e7":"x","\uff58":"x","\u1e8b":"x","\u1e8d":"x","\u24e8":"y","\uff59":"y","\u1ef3":"y","\u00fd":"y","\u0177":"y","\u1ef9":"y","\u0233":"y",
"\u1e8f":"y","\u00ff":"y","\u1ef7":"y","\u1e99":"y","\u1ef5":"y","\u01b4":"y","\u024f":"y","\u1eff":"y","\u24e9":"z","\uff5a":"z","\u017a":"z","\u1e91":"z","\u017c":"z","\u017e":"z","\u1e93":"z","\u1e95":"z","\u01b6":"z","\u0225":"z","\u0240":"z","\u2c6c":"z","\ua763":"z"};s=e(document);var Q=1;A=function(){return Q++};s.on("mousemove",function(a){x.x=a.pageX;x.y=a.pageY});s=C(Object,{bind:function(a){var b=this;return function(){a.apply(b,arguments)}},init:function(a){var b,c;this.opts=a=this.prepareOpts(a);
this.id=a.id;void 0!==a.element.data("select2")&&null!==a.element.data("select2")&&a.element.data("select2").destroy();this.container=this.createContainer();this.containerId="s2id_"+(a.element.attr("id")||"autogen"+A());this.containerSelector="#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g,"\\$1");this.container.attr("id",this.containerId);var d=!1,g;this.body=function(){!1===d&&(g=a.element.closest("body"),d=!0);return g};z(this.container,this.opts.element,this.opts.adaptContainerCssClass);
this.container.attr("style",a.element.attr("style"));this.container.css(o(a.containerCss));this.container.addClass(o(a.containerCssClass));this.elementTabIndex=this.opts.element.attr("tabindex");this.opts.element.data("select2",this).attr("tabindex","-1").before(this.container).on("click.select2",j);this.container.data("select2",this);this.dropdown=this.container.find(".select2-drop");z(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass);this.dropdown.addClass(o(a.dropdownCssClass));
this.dropdown.data("select2",this);this.dropdown.on("click",j);this.results=b=this.container.find(".select2-results");this.search=c=this.container.find("input.select2-input");this.resultsPage=this.queryCount=0;this.context=null;this.initContainer();this.container.on("click",j);this.results.on("mousemove",function(a){(void 0===x||x.x!==a.pageX||x.y!==a.pageY)&&e(a.target).trigger("mousemove-filtered",a)});this.dropdown.on("mousemove-filtered touchstart touchmove touchend",".select2-results",this.bind(this.highlightUnderEvent));
var h=this.results,l=H(80,function(a){h.trigger("scroll-debounced",a)});h.on("scroll",function(a){0<=k(a.target,h.get())&&l(a)});this.dropdown.on("scroll-debounced",".select2-results",this.bind(this.loadMoreIfNeeded));e(this.container).on("change",".select2-input",function(a){a.stopPropagation()});e(this.dropdown).on("change",".select2-input",function(a){a.stopPropagation()});e.fn.mousewheel&&b.mousewheel(function(a,c,d,g){c=b.scrollTop();0<g&&0>=c-g?(b.scrollTop(0),j(a)):0>g&&b.get(0).scrollHeight-
b.scrollTop()+g<=b.height()&&(b.scrollTop(b.get(0).scrollHeight-b.height()),j(a))});G(c);c.on("keyup-change input paste",this.bind(this.updateResults));c.on("focus",function(){c.addClass("select2-focused")});c.on("blur",function(){c.removeClass("select2-focused")});this.dropdown.on("mouseup",".select2-results",this.bind(function(a){0<e(a.target).closest(".select2-result-selectable").length&&(this.highlightUnderEvent(a),this.selectHighlighted(a))}));this.dropdown.on("click mouseup mousedown",function(a){a.stopPropagation()});
e.isFunction(this.opts.initSelection)&&(this.initSelection(),this.monitorSource());null!==a.maximumInputLength&&this.search.attr("maxlength",a.maximumInputLength);var i=a.element.prop("disabled");void 0===i&&(i=!1);this.enable(!i);i=a.element.prop("readonly");void 0===i&&(i=!1);this.readonly(i);if(!(i=F)){i=e("<div class='select2-measure-scrollbar'></div>");i.appendTo("body");var f={width:i.width()-i[0].clientWidth,height:i.height()-i[0].clientHeight};i.remove();i=f}F=i;this.autofocus=a.element.prop("autofocus");
a.element.prop("autofocus",!1);this.autofocus&&this.focus();this.nextSearchTerm=void 0},destroy:function(){var a=this.opts.element,b=a.data("select2");this.close();this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null);void 0!==b&&(b.container.remove(),b.dropdown.remove(),a.removeClass("select2-offscreen").removeData("select2").off(".select2").prop("autofocus",this.autofocus||!1),this.elementTabIndex?a.attr({tabindex:this.elementTabIndex}):a.removeAttr("tabindex"),a.show())},
optionToData:function(a){if(a.is("option"))return{id:a.prop("value"),text:a.text(),element:a.get(),css:a.attr("class"),disabled:a.prop("disabled"),locked:m(a.attr("locked"),"locked")||m(a.data("locked"),!0)};if(a.is("optgroup"))return{text:a.attr("label"),children:[],element:a.get(),css:a.attr("class")}},prepareOpts:function(a){var b,c,d,g=this;b=a.element;"select"===b.get(0).tagName.toLowerCase()&&(this.select=c=a.element);c&&e.each("id multiple ajax query createSearchChoice initSelection data tags".split(" "),
function(){if(this in a)throw Error("Option '"+this+"' is not allowed for Select2 when attached to a <select> element.");});a=e.extend({},{populateResults:function(b,c,d){var f,t=this.opts.id;f=function(b,c,h){var l,j,m,k,o,u,q,b=a.sortResults(b,c,d);l=0;for(j=b.length;l<j;l=l+1){m=b[l];o=m.disabled===true;k=!o&&t(m)!==void 0;u=m.children&&m.children.length>0;q=e("<li></li>");q.addClass("select2-results-dept-"+h);q.addClass("select2-result");q.addClass(k?"select2-result-selectable":"select2-result-unselectable");
o&&q.addClass("select2-disabled");u&&q.addClass("select2-result-with-children");q.addClass(g.opts.formatResultCssClass(m));k=e(document.createElement("div"));k.addClass("select2-result-label");o=a.formatResult(m,k,d,g.opts.escapeMarkup);o!==void 0&&k.html(o);q.append(k);if(u){u=e("<ul></ul>");u.addClass("select2-result-sub");f(m.children,u,h+1);q.append(u)}q.data("select2-data",m);c.append(q)}};f(c,b,0)}},e.fn.select2.defaults,a);"function"!==typeof a.id&&(d=a.id,a.id=function(a){return a[d]});if(e.isArray(a.element.data("select2Tags"))){if("tags"in
a)throw"tags specified as both an attribute 'data-select2-tags' and in options of Select2 "+a.element.attr("id");a.tags=a.element.data("select2Tags")}if(c)a.query=this.bind(function(a){var c={results:[],more:false},d=a.term,e,f,p;p=function(b,c){var e;if(b.is("option"))a.matcher(d,b.text(),b)&&c.push(g.optionToData(b));else if(b.is("optgroup")){e=g.optionToData(b);b.children().each2(function(a,b){p(b,e.children)});e.children.length>0&&c.push(e)}};e=b.children();if(this.getPlaceholder()!==void 0&&
e.length>0)(f=this.getPlaceholderOption())&&(e=e.not(f));e.each2(function(a,b){p(b,c.results)});a.callback(c)}),a.id=function(a){return a.id},a.formatResultCssClass=function(a){return a.css};else if(!("query"in a))if("ajax"in a){if((c=a.element.data("ajax-url"))&&0<c.length)a.ajax.url=c;a.query=K.call(a.element,a.ajax)}else if("data"in a)a.query=L(a.data);else if("tags"in a&&(a.query=M(a.tags),void 0===a.createSearchChoice&&(a.createSearchChoice=function(a){return{id:e.trim(a),text:e.trim(a)}}),void 0===
a.initSelection))a.initSelection=function(b,c){var d=[];e(B(b.val(),a.separator)).each(function(){var b={id:this,text:this},c=a.tags;e.isFunction(c)&&(c=c());e(c).each(function(){if(m(this.id,b.id)){b=this;return false}});d.push(b)});c(d)};if("function"!==typeof a.query)throw"query function not defined for Select2 "+a.element.attr("id");return a},monitorSource:function(){var a=this.opts.element,b,c;a.on("change.select2",this.bind(function(){!0!==this.opts.element.data("select2-change-triggered")&&
this.initSelection()}));b=this.bind(function(){var b=a.prop("disabled");void 0===b&&(b=!1);this.enable(!b);b=a.prop("readonly");void 0===b&&(b=!1);this.readonly(b);z(this.container,this.opts.element,this.opts.adaptContainerCssClass);this.container.addClass(o(this.opts.containerCssClass));z(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass);this.dropdown.addClass(o(this.opts.dropdownCssClass))});a.on("propertychange.select2",b);void 0===this.mutationCallback&&(this.mutationCallback=function(a){a.forEach(b)});
c=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;void 0!==c&&(this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),this.propertyObserver=new c(this.mutationCallback),this.propertyObserver.observe(a.get(0),{attributes:!0,subtree:!1}))},triggerSelect:function(a){a=e.Event("select2-selecting",{val:this.id(a),object:a});this.opts.element.trigger(a);return!a.isDefaultPrevented()},triggerChange:function(a){a=a||{};a=e.extend({},a,{type:"change",
val:this.val()});this.opts.element.data("select2-change-triggered",!0);this.opts.element.trigger(a);this.opts.element.data("select2-change-triggered",!1);this.opts.element.click();this.opts.blurOnChange&&this.opts.element.blur()},isInterfaceEnabled:function(){return!0===this.enabledInterface},enableInterface:function(){var a=this._enabled&&!this._readonly;if(a===this.enabledInterface)return!1;this.container.toggleClass("select2-container-disabled",!a);this.close();this.enabledInterface=a;return!0},
enable:function(a){void 0===a&&(a=!0);this._enabled!==a&&(this._enabled=a,this.opts.element.prop("disabled",!a),this.enableInterface())},disable:function(){this.enable(!1)},readonly:function(a){void 0===a&&(a=!1);if(this._readonly===a)return!1;this._readonly=a;this.opts.element.prop("readonly",a);this.enableInterface();return!0},opened:function(){return this.container.hasClass("select2-dropdown-open")},positionDropdown:function(){var a=this.dropdown,b=this.container.offset(),c=this.container.outerHeight(!1),
d=this.container.outerWidth(!1),g=a.outerHeight(!1),h=e(window),f=h.width(),i=h.height(),n=h.scrollLeft()+f,j=h.scrollTop()+i,c=b.top+c,p=b.left,j=c+g<=j,m=b.top-g>=this.body().scrollTop(),k=a.outerWidth(!1),r=p+k<=n,s;a.hasClass("select2-drop-above")?(g=!0,!m&&j&&(s=!0,g=!1)):(g=!1,!j&&m&&(g=s=!0));s&&(a.hide(),b=this.container.offset(),c=this.container.outerHeight(!1),d=this.container.outerWidth(!1),a.outerHeight(!1),n=h.scrollLeft()+f,h.scrollTop(),c=b.top+c,p=b.left,k=a.outerWidth(!1),r=p+k<=
n,a.show());this.opts.dropdownAutoWidth?(h=e(".select2-results",a)[0],a.addClass("select2-drop-auto-width"),a.css("width",""),k=a.outerWidth(!1)+(h.scrollHeight===h.clientHeight?0:F.width),k>d?d=k:k=d,r=p+k<=n):this.container.removeClass("select2-drop-auto-width");"static"!==this.body().css("position")&&(n=this.body().offset(),c-=n.top,p-=n.left);r||(p=b.left+d-k);d={left:p,width:d};g?(d.bottom=i-b.top,d.top="auto",this.container.addClass("select2-drop-above"),a.addClass("select2-drop-above")):(d.top=
c,d.bottom="auto",this.container.removeClass("select2-drop-above"),a.removeClass("select2-drop-above"));d=e.extend(d,o(this.opts.dropdownCss));a.css(d)},shouldOpen:function(){var a;if(this.opened()||!1===this._enabled||!0===this._readonly)return!1;a=e.Event("select2-opening");this.opts.element.trigger(a);return!a.isDefaultPrevented()},clearDropdownAlignmentPreference:function(){this.container.removeClass("select2-drop-above");this.dropdown.removeClass("select2-drop-above")},open:function(){if(!this.shouldOpen())return!1;
this.opening();return!0},opening:function(){var a=this.containerId,b="scroll."+a,c="resize."+a,d="orientationchange."+a;this.container.addClass("select2-dropdown-open").addClass("select2-container-active");this.clearDropdownAlignmentPreference();this.dropdown[0]!==this.body().children().last()[0]&&this.dropdown.detach().appendTo(this.body());a=e("#select2-drop-mask");0==a.length&&(a=e(document.createElement("div")),a.attr("id","select2-drop-mask").attr("class","select2-drop-mask"),a.hide(),a.appendTo(this.body()),
a.on("mousedown touchstart click",function(a){var b=e("#select2-drop");0<b.length&&(b=b.data("select2"),b.opts.selectOnBlur&&b.selectHighlighted({noFocus:!0}),b.close({focus:!0}),a.preventDefault(),a.stopPropagation())}));this.dropdown.prev()[0]!==a[0]&&this.dropdown.before(a);e("#select2-drop").removeAttr("id");this.dropdown.attr("id","select2-drop");a.show();this.positionDropdown();this.dropdown.show();this.positionDropdown();this.dropdown.addClass("select2-drop-active");var g=this;this.container.parents().add(window).each(function(){e(this).on(c+
" "+b+" "+d,function(){g.positionDropdown()})})},close:function(){if(this.opened()){var a=this.containerId,b="scroll."+a,c="resize."+a,d="orientationchange."+a;this.container.parents().add(window).each(function(){e(this).off(b).off(c).off(d)});this.clearDropdownAlignmentPreference();e("#select2-drop-mask").hide();this.dropdown.removeAttr("id");this.dropdown.hide();this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");this.results.empty();this.clearSearch();this.search.removeClass("select2-active");
this.opts.element.trigger(e.Event("select2-close"))}},externalSearch:function(a){this.open();this.search.val(a);this.updateResults(!1)},clearSearch:function(){},getMaximumSelectionSize:function(){return o(this.opts.maximumSelectionSize)},ensureHighlightVisible:function(){var a=this.results,b,c,d,g;c=this.highlight();0>c||(0==c?a.scrollTop(0):(b=this.findHighlightableChoices().find(".select2-result-label"),d=e(b[c]),g=d.offset().top+d.outerHeight(!0),c===b.length-1&&(b=a.find("li.select2-more-results"),
0<b.length&&(g=b.offset().top+b.outerHeight(!0))),b=a.offset().top+a.outerHeight(!0),g>b&&a.scrollTop(a.scrollTop()+(g-b)),g=d.offset().top-a.offset().top,0>g&&"none"!=d.css("display")&&a.scrollTop(a.scrollTop()+g)))},findHighlightableChoices:function(){return this.results.find(".select2-result-selectable:not(.select2-disabled, .select2-selected)")},moveHighlight:function(a){for(var b=this.findHighlightableChoices(),c=this.highlight();-1<c&&c<b.length;){var c=c+a,d=e(b[c]);if(d.hasClass("select2-result-selectable")&&
!d.hasClass("select2-disabled")&&!d.hasClass("select2-selected")){this.highlight(c);break}}},highlight:function(a){var b=this.findHighlightableChoices();if(0===arguments.length)return k(b.filter(".select2-highlighted")[0],b.get());a>=b.length&&(a=b.length-1);0>a&&(a=0);this.removeHighlight();b=e(b[a]);b.addClass("select2-highlighted");this.ensureHighlightVisible();(b=b.data("select2-data"))&&this.opts.element.trigger({type:"select2-highlight",val:this.id(b),choice:b})},removeHighlight:function(){this.results.find(".select2-highlighted").removeClass("select2-highlighted")},
countSelectableResults:function(){return this.findHighlightableChoices().length},highlightUnderEvent:function(a){a=e(a.target).closest(".select2-result-selectable");if(0<a.length&&!a.is(".select2-highlighted")){var b=this.findHighlightableChoices();this.highlight(b.index(a))}else 0==a.length&&this.removeHighlight()},loadMoreIfNeeded:function(){var a=this.results,b=a.find("li.select2-more-results"),c,d=this.resultsPage+1,e=this,h=this.search.val(),f=this.context;0!==b.length&&(c=b.offset().top-a.offset().top-
a.height(),c<=this.opts.loadMorePadding&&(b.addClass("select2-active"),this.opts.query({element:this.opts.element,term:h,page:d,context:f,matcher:this.opts.matcher,callback:this.bind(function(c){e.opened()&&(e.opts.populateResults.call(this,a,c.results,{term:h,page:d,context:f}),e.postprocessResults(c,!1,!1),!0===c.more?(b.detach().appendTo(a).text(e.opts.formatLoadMore(d+1)),window.setTimeout(function(){e.loadMoreIfNeeded()},10)):b.remove(),e.positionDropdown(),e.resultsPage=d,e.context=c.context,
this.opts.element.trigger({type:"select2-loaded",items:c}))})})))},tokenize:function(){},updateResults:function(a){function b(){d.removeClass("select2-active");i.positionDropdown()}function c(a){g.html(a);b()}var d=this.search,g=this.results,h=this.opts,f,i=this;f=d.val();var n=e.data(this.container,"select2-last-term"),j;if(!(!0!==a&&n&&m(f,n))&&(e.data(this.container,"select2-last-term",f),!(!0!==a&&(!1===this.showSearchInput||!this.opened())))){j=++this.queryCount;n=this.getMaximumSelectionSize();
if(1<=n&&(f=this.data(),e.isArray(f)&&f.length>=n&&r(h.formatSelectionTooBig,"formatSelectionTooBig"))){c("<li class='select2-selection-limit'>"+h.formatSelectionTooBig(n)+"</li>");return}d.val().length<h.minimumInputLength?(r(h.formatInputTooShort,"formatInputTooShort")?c("<li class='select2-no-results'>"+h.formatInputTooShort(d.val(),h.minimumInputLength)+"</li>"):c(""),a&&this.showSearch&&this.showSearch(!0)):h.maximumInputLength&&d.val().length>h.maximumInputLength?r(h.formatInputTooLong,"formatInputTooLong")?
c("<li class='select2-no-results'>"+h.formatInputTooLong(d.val(),h.maximumInputLength)+"</li>"):c(""):(h.formatSearching&&0===this.findHighlightableChoices().length&&c("<li class='select2-searching'>"+h.formatSearching()+"</li>"),d.addClass("select2-active"),this.removeHighlight(),f=this.tokenize(),void 0!=f&&null!=f&&d.val(f),this.resultsPage=1,h.query({element:h.element,term:d.val(),page:this.resultsPage,context:null,matcher:h.matcher,callback:this.bind(function(f){var l;j==this.queryCount&&(this.opened()?
(this.context=void 0===f.context?null:f.context,this.opts.createSearchChoice&&""!==d.val()&&(l=this.opts.createSearchChoice.call(i,d.val(),f.results),void 0!==l&&null!==l&&void 0!==i.id(l)&&null!==i.id(l)&&0===e(f.results).filter(function(){return m(i.id(this),i.id(l))}).length&&f.results.unshift(l)),0===f.results.length&&r(h.formatNoMatches,"formatNoMatches"))?c("<li class='select2-no-results'>"+h.formatNoMatches(d.val())+"</li>"):(g.empty(),i.opts.populateResults.call(this,g,f.results,{term:d.val(),
page:this.resultsPage,context:null}),!0===f.more&&r(h.formatLoadMore,"formatLoadMore")&&(g.append("<li class='select2-more-results'>"+i.opts.escapeMarkup(h.formatLoadMore(this.resultsPage))+"</li>"),window.setTimeout(function(){i.loadMoreIfNeeded()},10)),this.postprocessResults(f,a),b(),this.opts.element.trigger({type:"select2-loaded",items:f})):this.search.removeClass("select2-active"))})}))}},cancel:function(){this.close()},blur:function(){this.opts.selectOnBlur&&this.selectHighlighted({noFocus:!0});
this.close();this.container.removeClass("select2-container-active");this.search[0]===document.activeElement&&this.search.blur();this.clearSearch();this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus")},focusSearch:function(){var a=this.search;a[0]!==document.activeElement&&window.setTimeout(function(){var b=a[0],c=a.val().length;a.focus();a.is(":visible")&&b===document.activeElement&&(b.setSelectionRange?b.setSelectionRange(c,c):b.createTextRange&&(b=b.createTextRange(),
b.collapse(!1),b.select()))},0)},selectHighlighted:function(a){var b=this.highlight(),c=this.results.find(".select2-highlighted").closest(".select2-result").data("select2-data");c?(this.highlight(b),this.onSelect(c,a)):a&&a.noFocus&&this.close()},getPlaceholder:function(){var a;return this.opts.element.attr("placeholder")||this.opts.element.attr("data-placeholder")||this.opts.element.data("placeholder")||this.opts.placeholder||(void 0!==(a=this.getPlaceholderOption())?a.text():void 0)},getPlaceholderOption:function(){if(this.select){var a=
this.select.children("option").first();if(void 0!==this.opts.placeholderOption)return"first"===this.opts.placeholderOption&&a||"function"===typeof this.opts.placeholderOption&&this.opts.placeholderOption(this.select);if(""===a.text()&&""===a.val())return a}},initContainerWidth:function(){var a=function(){var a,c,d,g;if("off"===this.opts.width)return null;if("element"===this.opts.width)return 0===this.opts.element.outerWidth(!1)?"auto":this.opts.element.outerWidth(!1)+"px";if("copy"===this.opts.width||
"resolve"===this.opts.width){a=this.opts.element.attr("style");if(void 0!==a){a=a.split(";");d=0;for(g=a.length;d<g;d+=1)if(c=a[d].replace(/\s/g,""),c=c.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i),null!==c&&1<=c.length)return c[1]}return"resolve"===this.opts.width?(a=this.opts.element.css("width"),0<a.indexOf("%")?a:0===this.opts.element.outerWidth(!1)?"auto":this.opts.element.outerWidth(!1)+"px"):null}return e.isFunction(this.opts.width)?this.opts.width():this.opts.width}.call(this);
null!==a&&this.container.css("width",a)}});D=C(s,{createContainer:function(){return e(document.createElement("div")).attr({"class":"select2-container"}).html("<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>   <span class='select2-chosen'>&nbsp;</span><abbr class='select2-search-choice-close'></abbr>   <span class='select2-arrow'><b></b></span></a><input class='select2-focusser select2-offscreen' type='text'/><div class='select2-drop select2-display-none'>   <div class='select2-search'>       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'/>   </div>   <ul class='select2-results'>   </ul></div>")},
enableInterface:function(){this.parent.enableInterface.apply(this,arguments)&&this.focusser.prop("disabled",!this.isInterfaceEnabled())},opening:function(){var a,b;0<=this.opts.minimumResultsForSearch&&this.showSearch(!0);this.parent.opening.apply(this,arguments);!1!==this.showSearchInput&&this.search.val(this.focusser.val());this.search.focus();a=this.search.get(0);a.createTextRange?(a=a.createTextRange(),a.collapse(!1),a.select()):a.setSelectionRange&&(b=this.search.val().length,a.setSelectionRange(b,
b));""===this.search.val()&&void 0!=this.nextSearchTerm&&(this.search.val(this.nextSearchTerm),this.search.select());this.focusser.prop("disabled",!0).val("");this.updateResults(!0);this.opts.element.trigger(e.Event("select2-open"))},close:function(a){this.opened()&&(this.parent.close.apply(this,arguments),a=a||{focus:!0},this.focusser.removeAttr("disabled"),a.focus&&this.focusser.focus())},focus:function(){this.opened()?this.close():(this.focusser.removeAttr("disabled"),this.focusser.focus())},isFocused:function(){return this.container.hasClass("select2-container-active")},
cancel:function(){this.parent.cancel.apply(this,arguments);this.focusser.removeAttr("disabled");this.focusser.focus()},destroy:function(){e("label[for='"+this.focusser.attr("id")+"']").attr("for",this.opts.element.attr("id"));this.parent.destroy.apply(this,arguments)},initContainer:function(){var a,b=this.container,c=this.dropdown;0>this.opts.minimumResultsForSearch?this.showSearch(!1):this.showSearch(!0);this.selection=a=b.find(".select2-choice");this.focusser=b.find(".select2-focusser");this.focusser.attr("id",
"s2id_autogen"+A());e("label[for='"+this.opts.element.attr("id")+"']").attr("for",this.focusser.attr("id"));this.focusser.attr("tabindex",this.elementTabIndex);this.search.on("keydown",this.bind(function(a){if(this.isInterfaceEnabled())if(a.which===f.PAGE_UP||a.which===f.PAGE_DOWN)j(a);else switch(a.which){case f.UP:case f.DOWN:this.moveHighlight(a.which===f.UP?-1:1);j(a);break;case f.ENTER:this.selectHighlighted();j(a);break;case f.TAB:this.selectHighlighted({noFocus:!0});break;case f.ESC:this.cancel(a),
j(a)}}));this.search.on("blur",this.bind(function(){document.activeElement===this.body().get(0)&&window.setTimeout(this.bind(function(){this.search.focus()}),0)}));this.focusser.on("keydown",this.bind(function(a){if(this.isInterfaceEnabled()&&!(a.which===f.TAB||f.isControl(a)||f.isFunctionKey(a)||a.which===f.ESC))if(!1===this.opts.openOnEnter&&a.which===f.ENTER)j(a);else if(a.which==f.DOWN||a.which==f.UP||a.which==f.ENTER&&this.opts.openOnEnter)!a.altKey&&(!a.ctrlKey&&!a.shiftKey&&!a.metaKey)&&(this.open(),
j(a));else if(a.which==f.DELETE||a.which==f.BACKSPACE)this.opts.allowClear&&this.clear(),j(a)}));G(this.focusser);this.focusser.on("keyup-change input",this.bind(function(a){0<=this.opts.minimumResultsForSearch&&(a.stopPropagation(),this.opened()||this.open())}));a.on("mousedown","abbr",this.bind(function(a){this.isInterfaceEnabled()&&(this.clear(),a.preventDefault(),a.stopImmediatePropagation(),this.close(),this.selection.focus())}));a.on("mousedown",this.bind(function(a){this.container.hasClass("select2-container-active")||
this.opts.element.trigger(e.Event("select2-focus"));this.opened()?this.close():this.isInterfaceEnabled()&&this.open();j(a)}));c.on("mousedown",this.bind(function(){this.search.focus()}));a.on("focus",this.bind(function(a){j(a)}));this.focusser.on("focus",this.bind(function(){this.container.hasClass("select2-container-active")||this.opts.element.trigger(e.Event("select2-focus"));this.container.addClass("select2-container-active")})).on("blur",this.bind(function(){this.opened()||(this.container.removeClass("select2-container-active"),
this.opts.element.trigger(e.Event("select2-blur")))}));this.search.on("focus",this.bind(function(){this.container.hasClass("select2-container-active")||this.opts.element.trigger(e.Event("select2-focus"));this.container.addClass("select2-container-active")}));this.initContainerWidth();this.opts.element.addClass("select2-offscreen");this.setPlaceholder()},clear:function(a){var b=this.selection.data("select2-data");if(b){var c=e.Event("select2-clearing");this.opts.element.trigger(c);c.isDefaultPrevented()||
(c=this.getPlaceholderOption(),this.opts.element.val(c?c.val():""),this.selection.find(".select2-chosen").empty(),this.selection.removeData("select2-data"),this.setPlaceholder(),!1!==a&&(this.opts.element.trigger({type:"select2-removed",val:this.id(b),choice:b}),this.triggerChange({removed:b})))}},initSelection:function(){if(this.isPlaceholderOptionSelected())this.updateSelection(null),this.close(),this.setPlaceholder();else{var a=this;this.opts.initSelection.call(null,this.opts.element,function(b){void 0!==
b&&null!==b&&(a.updateSelection(b),a.close(),a.setPlaceholder())})}},isPlaceholderOptionSelected:function(){var a;return!this.getPlaceholder()?!1:void 0!==(a=this.getPlaceholderOption())&&a.prop("selected")||""===this.opts.element.val()||void 0===this.opts.element.val()||null===this.opts.element.val()},prepareOpts:function(){var a=this.parent.prepareOpts.apply(this,arguments),b=this;"select"===a.element.get(0).tagName.toLowerCase()?a.initSelection=function(a,d){var e=a.find("option").filter(function(){return this.selected});
d(b.optionToData(e))}:"data"in a&&(a.initSelection=a.initSelection||function(b,d){var g=b.val(),f=null;a.query({matcher:function(b,c,d){(b=m(g,a.id(d)))&&(f=d);return b},callback:!e.isFunction(d)?e.noop:function(){d(f)}})});return a},getPlaceholder:function(){return this.select&&void 0===this.getPlaceholderOption()?void 0:this.parent.getPlaceholder.apply(this,arguments)},setPlaceholder:function(){var a=this.getPlaceholder();this.isPlaceholderOptionSelected()&&void 0!==a&&!(this.select&&void 0===this.getPlaceholderOption())&&
(this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(a)),this.selection.addClass("select2-default"),this.container.removeClass("select2-allowclear"))},postprocessResults:function(a,b,c){var d=0,e=this;this.findHighlightableChoices().each2(function(a,b){if(m(e.id(b.data("select2-data")),e.opts.element.val()))return d=a,!1});!1!==c&&(!0===b&&0<=d?this.highlight(d):this.highlight(0));!0===b&&(b=this.opts.minimumResultsForSearch,0<=b&&this.showSearch(N(a.results)>=b))},showSearch:function(a){this.showSearchInput!==
a&&(this.showSearchInput=a,this.dropdown.find(".select2-search").toggleClass("select2-search-hidden",!a),this.dropdown.find(".select2-search").toggleClass("select2-offscreen",!a),e(this.dropdown,this.container).toggleClass("select2-with-searchbox",a))},onSelect:function(a,b){if(this.triggerSelect(a)){var c=this.opts.element.val(),d=this.data();this.opts.element.val(this.id(a));this.updateSelection(a);this.opts.element.trigger({type:"select2-selected",val:this.id(a),choice:a});this.nextSearchTerm=
this.opts.nextSearchTerm(a,this.search.val());this.close();(!b||!b.noFocus)&&this.focusser.focus();m(c,this.id(a))||this.triggerChange({added:a,removed:d})}},updateSelection:function(a){var b=this.selection.find(".select2-chosen"),c;this.selection.data("select2-data",a);b.empty();null!==a&&(c=this.opts.formatSelection(a,b,this.opts.escapeMarkup));void 0!==c&&b.append(c);a=this.opts.formatSelectionCssClass(a,b);void 0!==a&&b.addClass(a);this.selection.removeClass("select2-default");this.opts.allowClear&&
void 0!==this.getPlaceholder()&&this.container.addClass("select2-allowclear")},val:function(){var a,b=!1,c=null,d=this,e=this.data();if(0===arguments.length)return this.opts.element.val();a=arguments[0];1<arguments.length&&(b=arguments[1]);if(this.select)this.select.val(a).find("option").filter(function(){return this.selected}).each2(function(a,b){c=d.optionToData(b);return!1}),this.updateSelection(c),this.setPlaceholder(),b&&this.triggerChange({added:c,removed:e});else if(!a&&0!==a)this.clear(b);
else{if(void 0===this.opts.initSelection)throw Error("cannot call val() if initSelection() is not defined");this.opts.element.val(a);this.opts.initSelection(this.opts.element,function(a){d.opts.element.val(!a?"":d.id(a));d.updateSelection(a);d.setPlaceholder();b&&d.triggerChange({added:a,removed:e})})}},clearSearch:function(){this.search.val("");this.focusser.val("")},data:function(a){var b,c=!1;if(0===arguments.length)return b=this.selection.data("select2-data"),void 0==b&&(b=null),b;1<arguments.length&&
(c=arguments[1]);a?(b=this.data(),this.opts.element.val(!a?"":this.id(a)),this.updateSelection(a),c&&this.triggerChange({added:a,removed:b})):this.clear(c)}});E=C(s,{createContainer:function(){return e(document.createElement("div")).attr({"class":"select2-container select2-container-multi"}).html("<ul class='select2-choices'>  <li class='select2-search-field'>    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>  </li></ul><div class='select2-drop select2-drop-multi select2-display-none'>   <ul class='select2-results'>   </ul></div>")},
prepareOpts:function(){var a=this.parent.prepareOpts.apply(this,arguments),b=this;"select"===a.element.get(0).tagName.toLowerCase()?a.initSelection=function(a,d){var e=[];a.find("option").filter(function(){return this.selected}).each2(function(a,c){e.push(b.optionToData(c))});d(e)}:"data"in a&&(a.initSelection=a.initSelection||function(b,d){var g=B(b.val(),a.separator),f=[];a.query({matcher:function(b,c,d){(b=e.grep(g,function(b){return m(b,a.id(d))}).length)&&f.push(d);return b},callback:!e.isFunction(d)?
e.noop:function(){for(var b=[],c=0;c<g.length;c++)for(var e=g[c],j=0;j<f.length;j++){var k=f[j];if(m(e,a.id(k))){b.push(k);f.splice(j,1);break}}d(b)}})});return a},selectChoice:function(a){var b=this.container.find(".select2-search-choice-focus");if(!b.length||!(a&&a[0]==b[0]))b.length&&this.opts.element.trigger("choice-deselected",b),b.removeClass("select2-search-choice-focus"),a&&a.length&&(this.close(),a.addClass("select2-search-choice-focus"),this.opts.element.trigger("choice-selected",a))},destroy:function(){e("label[for='"+
this.search.attr("id")+"']").attr("for",this.opts.element.attr("id"));this.parent.destroy.apply(this,arguments)},initContainer:function(){var a;this.searchContainer=this.container.find(".select2-search-field");this.selection=a=this.container.find(".select2-choices");var b=this;this.selection.on("click",".select2-search-choice:not(.select2-locked)",function(){b.search[0].focus();b.selectChoice(e(this))});this.search.attr("id","s2id_autogen"+A());e("label[for='"+this.opts.element.attr("id")+"']").attr("for",
this.search.attr("id"));this.search.on("input paste",this.bind(function(){this.isInterfaceEnabled()&&(this.opened()||this.open())}));this.search.attr("tabindex",this.elementTabIndex);this.keydowns=0;this.search.on("keydown",this.bind(function(b){var d,g;if(this.isInterfaceEnabled()){++this.keydowns;var h=a.find(".select2-search-choice-focus"),l=h.prev(".select2-search-choice:not(.select2-locked)"),i=h.next(".select2-search-choice:not(.select2-locked)");d=this.search;d=e(d)[0];var k=0;g=0;"selectionStart"in
d?(k=d.selectionStart,g=d.selectionEnd-k):"selection"in document&&(d.focus(),k=document.selection.createRange(),g=document.selection.createRange().text.length,k.moveStart("character",-d.value.length),k=k.text.length-g);d=k;if(h.length&&(b.which==f.LEFT||b.which==f.RIGHT||b.which==f.BACKSPACE||b.which==f.DELETE||b.which==f.ENTER))g=h,b.which==f.LEFT&&l.length?g=l:b.which==f.RIGHT?g=i.length?i:null:b.which===f.BACKSPACE?(this.unselect(h.first()),this.search.width(10),g=l.length?l:i):b.which==f.DELETE?
(this.unselect(h.first()),this.search.width(10),g=i.length?i:null):b.which==f.ENTER&&(g=null),this.selectChoice(g),j(b),(!g||!g.length)&&this.open();else if((b.which===f.BACKSPACE&&1==this.keydowns||b.which==f.LEFT)&&0==d&&!g)this.selectChoice(a.find(".select2-search-choice:not(.select2-locked)").last()),j(b);else{this.selectChoice(null);if(this.opened())switch(b.which){case f.UP:case f.DOWN:this.moveHighlight(b.which===f.UP?-1:1);j(b);return;case f.ENTER:this.selectHighlighted();j(b);return;case f.TAB:this.selectHighlighted({noFocus:!0});
this.close();return;case f.ESC:this.cancel(b);j(b);return}b.which===f.TAB||f.isControl(b)||f.isFunctionKey(b)||b.which===f.BACKSPACE||b.which===f.ESC||b.which===f.ENTER&&(!1===this.opts.openOnEnter||b.altKey||b.ctrlKey||b.shiftKey||b.metaKey)||(this.open(),(b.which===f.PAGE_UP||b.which===f.PAGE_DOWN)&&j(b),b.which===f.ENTER&&j(b))}}}));this.search.on("keyup",this.bind(function(){this.keydowns=0;this.resizeSearch()}));this.search.on("blur",this.bind(function(a){this.container.removeClass("select2-container-active");
this.search.removeClass("select2-focused");this.selectChoice(null);this.opened()||this.clearSearch();a.stopImmediatePropagation();this.opts.element.trigger(e.Event("select2-blur"))}));this.container.on("click",".select2-choices",this.bind(function(a){this.isInterfaceEnabled()&&!(0<e(a.target).closest(".select2-search-choice").length)&&(this.selectChoice(null),this.clearPlaceholder(),this.container.hasClass("select2-container-active")||this.opts.element.trigger(e.Event("select2-focus")),this.open(),
this.focusSearch(),a.preventDefault())}));this.container.on("focus",".select2-choices",this.bind(function(){this.isInterfaceEnabled()&&(this.container.hasClass("select2-container-active")||this.opts.element.trigger(e.Event("select2-focus")),this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"),this.clearPlaceholder())}));this.initContainerWidth();this.opts.element.addClass("select2-offscreen");this.clearSearch()},enableInterface:function(){this.parent.enableInterface.apply(this,
arguments)&&this.search.prop("disabled",!this.isInterfaceEnabled())},initSelection:function(){""===this.opts.element.val()&&""===this.opts.element.text()&&(this.updateSelection([]),this.close(),this.clearSearch());if(this.select||""!==this.opts.element.val()){var a=this;this.opts.initSelection.call(null,this.opts.element,function(b){if(b!==void 0&&b!==null){a.updateSelection(b);a.close();a.clearSearch()}})}},clearSearch:function(){var a=this.getPlaceholder(),b=this.getMaxSearchWidth();void 0!==a&&
0===this.getVal().length&&!1===this.search.hasClass("select2-focused")?(this.search.val(a).addClass("select2-default"),this.search.width(0<b?b:this.container.css("width"))):this.search.val("").width(10)},clearPlaceholder:function(){this.search.hasClass("select2-default")&&this.search.val("").removeClass("select2-default")},opening:function(){this.clearPlaceholder();this.resizeSearch();this.parent.opening.apply(this,arguments);this.focusSearch();this.updateResults(!0);this.search.focus();this.opts.element.trigger(e.Event("select2-open"))},
close:function(){this.opened()&&this.parent.close.apply(this,arguments)},focus:function(){this.close();this.search.focus()},isFocused:function(){return this.search.hasClass("select2-focused")},updateSelection:function(a){var b=[],c=[],d=this;e(a).each(function(){0>k(d.id(this),b)&&(b.push(d.id(this)),c.push(this))});a=c;this.selection.find(".select2-search-choice").remove();e(a).each(function(){d.addSelectedChoice(this)});d.postprocessResults()},tokenize:function(){var a=this.search.val(),a=this.opts.tokenizer.call(this,
a,this.data(),this.bind(this.onSelect),this.opts);null!=a&&void 0!=a&&(this.search.val(a),0<a.length&&this.open())},onSelect:function(a,b){this.triggerSelect(a)&&(this.addSelectedChoice(a),this.opts.element.trigger({type:"selected",val:this.id(a),choice:a}),(this.select||!this.opts.closeOnSelect)&&this.postprocessResults(a,!1,!0===this.opts.closeOnSelect),this.opts.closeOnSelect?(this.close(),this.search.width(10)):0<this.countSelectableResults()?(this.search.width(10),this.resizeSearch(),0<this.getMaximumSelectionSize()&&
this.val().length>=this.getMaximumSelectionSize()&&this.updateResults(!0),this.positionDropdown()):(this.close(),this.search.width(10)),this.triggerChange({added:a}),(!b||!b.noFocus)&&this.focusSearch())},cancel:function(){this.close();this.focusSearch()},addSelectedChoice:function(a){var b=!a.locked,c=e("<li class='select2-search-choice'>    <div></div>    <a href='#' class='select2-search-choice-close' tabindex='-1'></a></li>"),d=e("<li class='select2-search-choice select2-locked'><div></div></li>"),
c=b?c:d,d=this.id(a),f=this.getVal(),h;h=this.opts.formatSelection(a,c.find("div"),this.opts.escapeMarkup);void 0!=h&&c.find("div").replaceWith("<div>"+h+"</div>");h=this.opts.formatSelectionCssClass(a,c.find("div"));void 0!=h&&c.addClass(h);if(b)c.find(".select2-search-choice-close").on("mousedown",j).on("click dblclick",this.bind(function(a){this.isInterfaceEnabled()&&(e(a.target).closest(".select2-search-choice").fadeOut("fast",this.bind(function(){this.unselect(e(a.target));this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
this.close();this.focusSearch()})).dequeue(),j(a))})).on("focus",this.bind(function(){this.isInterfaceEnabled()&&(this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"))}));c.data("select2-data",a);c.insertBefore(this.searchContainer);f.push(d);this.setVal(f)},unselect:function(a){var b=this.getVal(),c,d,a=a.closest(".select2-search-choice");if(0===a.length)throw"Invalid argument: "+a+". Must be .select2-search-choice";if(c=a.data("select2-data")){for(;0<=
(d=k(this.id(c),b));)b.splice(d,1),this.setVal(b),this.select&&this.postprocessResults();b=e.Event("select2-removing");b.val=this.id(c);b.choice=c;this.opts.element.trigger(b);b.isDefaultPrevented()||(a.remove(),this.opts.element.trigger({type:"select2-removed",val:this.id(c),choice:c}),this.triggerChange({removed:c}))}},postprocessResults:function(a,b,c){var d=this.getVal(),b=this.results.find(".select2-result"),e=this.results.find(".select2-result-with-children"),f=this;b.each2(function(a,b){var c=
f.id(b.data("select2-data"));0<=k(c,d)&&(b.addClass("select2-selected"),b.find(".select2-result-selectable").addClass("select2-selected"))});e.each2(function(a,b){!b.is(".select2-result-selectable")&&0===b.find(".select2-result-selectable:not(.select2-selected)").length&&b.addClass("select2-selected")});-1==this.highlight()&&!1!==c&&f.highlight(0);!this.opts.createSearchChoice&&0<!b.filter(".select2-result:not(.select2-selected)").length&&(!a||a&&!a.more&&0===this.results.find(".select2-no-results").length)&&
r(f.opts.formatNoMatches,"formatNoMatches")&&this.results.append("<li class='select2-no-results'>"+f.opts.formatNoMatches(f.search.val())+"</li>")},getMaxSearchWidth:function(){return this.selection.width()-(this.search.outerWidth(!1)-this.search.width())},resizeSearch:function(){var a,b,c,d,f=this.search.outerWidth(!1)-this.search.width();a=this.search;v||(c=a[0].currentStyle||window.getComputedStyle(a[0],null),v=e(document.createElement("div")).css({position:"absolute",left:"-10000px",top:"-10000px",
display:"none",fontSize:c.fontSize,fontFamily:c.fontFamily,fontStyle:c.fontStyle,fontWeight:c.fontWeight,letterSpacing:c.letterSpacing,textTransform:c.textTransform,whiteSpace:"nowrap"}),v.attr("class","select2-sizer"),e("body").append(v));v.text(a.val());a=v.width()+10;b=this.search.offset().left;c=this.selection.width();d=this.selection.offset().left;b=c-(b-d)-f;b<a&&(b=c-f);40>b&&(b=c-f);0>=b&&(b=a);this.search.width(Math.floor(b))},getVal:function(){var a;if(this.select)return a=this.select.val(),
null===a?[]:a;a=this.opts.element.val();return B(a,this.opts.separator)},setVal:function(a){var b;this.select?this.select.val(a):(b=[],e(a).each(function(){0>k(this,b)&&b.push(this)}),this.opts.element.val(0===b.length?"":b.join(this.opts.separator)))},buildChangeDetails:function(a,b){for(var b=b.slice(0),a=a.slice(0),c=0;c<b.length;c++)for(var d=0;d<a.length;d++)m(this.opts.id(b[c]),this.opts.id(a[d]))&&(b.splice(c,1),0<c&&c--,a.splice(d,1),d--);return{added:b,removed:a}},val:function(a,b){var c,
d=this;if(0===arguments.length)return this.getVal();c=this.data();c.length||(c=[]);if(!a&&0!==a)this.opts.element.val(""),this.updateSelection([]),this.clearSearch(),b&&this.triggerChange({added:this.data(),removed:c});else{this.setVal(a);if(this.select)this.opts.initSelection(this.select,this.bind(this.updateSelection)),b&&this.triggerChange(this.buildChangeDetails(c,this.data()));else{if(void 0===this.opts.initSelection)throw Error("val() cannot be called if initSelection() is not defined");this.opts.initSelection(this.opts.element,
function(a){var f=e.map(a,d.id);d.setVal(f);d.updateSelection(a);d.clearSearch();b&&d.triggerChange(d.buildChangeDetails(c,d.data()))})}this.clearSearch()}},onSortStart:function(){if(this.select)throw Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");this.search.width(0);this.searchContainer.hide()},onSortEnd:function(){var a=[],b=this;this.searchContainer.show();this.searchContainer.appendTo(this.searchContainer.parent());this.resizeSearch();
this.selection.find(".select2-search-choice").each(function(){a.push(b.opts.id(e(this).data("select2-data")))});this.setVal(a);this.triggerChange()},data:function(a,b){var c=this,d,f;if(0===arguments.length)return this.selection.find(".select2-search-choice").map(function(){return e(this).data("select2-data")}).get();f=this.data();a||(a=[]);d=e.map(a,function(a){return c.opts.id(a)});this.setVal(d);this.updateSelection(a);this.clearSearch();b&&this.triggerChange(this.buildChangeDetails(f,this.data()))}});
e.fn.select2=function(){var a=Array.prototype.slice.call(arguments,0),b,c,d,f,h,j="val destroy opened open close focus isFocused container dropdown onSortStart onSortEnd enable disable readonly positionDropdown data search".split(" "),i=["opened","isFocused","container","dropdown"],m=["val","data"],o={search:"externalSearch"};this.each(function(){if(0===a.length||"object"===typeof a[0])b=0===a.length?{}:e.extend({},a[0]),b.element=e(this),"select"===b.element.get(0).tagName.toLowerCase()?h=b.element.prop("multiple"):
(h=b.multiple||!1,"tags"in b&&(b.multiple=h=!0)),c=h?new E:new D,c.init(b);else if("string"===typeof a[0]){if(0>k(a[0],j))throw"Unknown method: "+a[0];f=void 0;c=e(this).data("select2");if(void 0!==c&&(d=a[0],"container"===d?f=c.container:"dropdown"===d?f=c.dropdown:(o[d]&&(d=o[d]),f=c[d].apply(c,a.slice(1))),0<=k(a[0],i)||k(a[0],m)&&1==a.length))return!1}else throw"Invalid arguments to select2 plugin: "+a;});return void 0===f?this:f};e.fn.select2.defaults={width:"copy",loadMorePadding:0,closeOnSelect:!0,
openOnEnter:!0,containerCss:{},dropdownCss:{},containerCssClass:"",dropdownCssClass:"",formatResult:function(a,b,c,d){b=[];I(a.text,c.term,b,d);return b.join("")},formatSelection:function(a,b,c){return a?c(a.text):void 0},sortResults:function(a){return a},formatResultCssClass:function(){},formatSelectionCssClass:function(){},formatNoMatches:function(){return"No matches found"},formatInputTooShort:function(a,b){var c=b-a.length;return"Please enter "+c+" more character"+(1==c?"":"s")},formatInputTooLong:function(a,
b){var c=a.length-b;return"Please delete "+c+" character"+(1==c?"":"s")},formatSelectionTooBig:function(a){return"You can only select "+a+" item"+(1==a?"":"s")},formatLoadMore:function(){return"Loading more results..."},formatSearching:function(){return"Searching..."},minimumResultsForSearch:0,minimumInputLength:0,maximumInputLength:null,maximumSelectionSize:0,id:function(a){return a.id},matcher:function(a,b){return 0<=w(""+b).toUpperCase().indexOf(w(""+a).toUpperCase())},separator:",",tokenSeparators:[],
tokenizer:P,escapeMarkup:J,blurOnChange:!1,selectOnBlur:!1,adaptContainerCssClass:function(a){return a},adaptDropdownCssClass:function(){return null},nextSearchTerm:function(){}};e.fn.select2.ajaxDefaults={transport:e.ajax,params:{type:"GET",cache:!1,dataType:"json"}};window.Select2={query:{ajax:K,local:L,tags:M},util:{debounce:H,markMatch:I,escapeMarkup:J,stripDiacritics:w},"class":{"abstract":s,single:D,multi:E}}}return{}}.call(this);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.auiplugin:internal-src-js-aui-select2', location = 'src/js/aui/select2.js' */
("undefined"===typeof window?global:window).__7dc2a1c33ff678de05f5aa1a9414d108=function(){"use strict";var b=__700a145ba3db9966cc95664c892049f8,d=b&&b.__esModule?b:{"default":b};__63e2d0d906dfc9cc19eb6e8389c4f5a3;var e=d.default.fn.select2;d.default.fn.auiSelect2=function(b){var c;if(d.default.isPlainObject(b)){var a=d.default.extend({},b);c=a.hasAvatar?" aui-has-avatar":"";a.containerCssClass="aui-select2-container"+c+(a.containerCssClass?" "+a.containerCssClass:"");a.dropdownCssClass="aui-select2-drop aui-dropdown2 aui-style-default"+
c+(a.dropdownCssClass?" "+a.dropdownCssClass:"");c=Array.prototype.slice.call(arguments,1);c.unshift(a)}else c=arguments.length?arguments:[{containerCssClass:"aui-select2-container",dropdownCssClass:"aui-select2-drop aui-dropdown2 aui-style-default"}];return e.apply(this,c)};return{}}.call(this);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-ui-plugins-pre-Conf70', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.ui.position.js' */

/*
 * jQuery UI Position 1.8.1
 *
 * Copyright (c) 2010 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $ ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	horizontalDefault = "center",
	verticalPositions = /top|center|bottom/,
	verticalDefault = "center",
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( options.of.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	} else if ( options.of.scrollTo && options.of.document ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( options.of.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [verticalDefault] ) :
				verticalPositions.test( pos[0] ) ?
					[ horizontalDefault ].concat( pos ) :
					[ horizontalDefault, verticalDefault ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : horizontalDefault;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : verticalDefault;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if (options.at[0] === horizontalDefault ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === verticalDefault ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			position = $.extend( {}, basePosition );

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === horizontalDefault ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === verticalDefault ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions (see #5280)
		position.left = parseInt( position.left );
		position.top = parseInt( position.top );

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = position.left + data.elemWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( 0, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = position.top + data.elemHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( 0, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === "center" ) {
				return;
			}
			var win = $( window ),
				over = position.left + data.elemWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				offset = -2 * data.offset[ 0 ];
			position.left += position.left < 0 ?
				myOffset + data.targetWidth + offset :
				over > 0 ?
					myOffset - data.targetWidth + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === "center" ) {
				return;
			}
			var win = $( window ),
				over = position.top + data.elemHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += position.top < 0 ?
				myOffset + data.targetHeight + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};

		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) {
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

}( jQuery ));

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-ui-plugins-pre-Conf70', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.ui.resizable.js' */

/*
 * jQuery UI Resizable 1.8.1
 *
 * Copyright (c) 2010 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function($) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Opera fix for relative positioning
			if (/relative/.test(this.element.css('position')) && $.browser.opera)
				this.element.css({ position: 'relative', top: 'auto', left: 'auto' });

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// increase zIndex of sw, se, ne, nw axis
				//TODO : this modifies original option
				if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.hover(function() {
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				},
				function(){
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		//Opera fixing relative position
		if ($.browser.opera && (/relative/).test(el.css('position')))
			el.css({ position: 'relative', top: 'auto', left: 'auto' });

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
						soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
							soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (data.height) data.width = (csize.height * this.aspectRatio);
		else if (data.width) data.height = (csize.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this.options, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "1.8.1"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options;

		var _store = function(exp) {
			$(exp).each(function() {
				$(this).data("resizable-alsoresize", {
					width: parseInt($(this).width(), 10), height: parseInt($(this).height(), 10),
					left: parseInt($(this).css('left'), 10), top: parseInt($(this).css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0];	_store(o.alsoResize); }
			else { $.each(o.alsoResize, function(exp, c) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function(exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, css = c && c.length ? c : ['width', 'height', 'top', 'left'];

				$.each(css || ['width', 'height', 'top', 'left'], function(i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				//Opera fixing relative position
				if (/relative/.test(el.css('position')) && $.browser.opera) {
					self._revertToRelativePosition = true;
					el.css({ position: 'absolute', top: 'auto', left: 'auto' });
				}

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function(exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable");

		//Opera fixing relative position
		if (self._revertToRelativePosition && $.browser.opera) {
			self._revertToRelativePosition = false;
			el.css({ position: 'relative' });
		}

		$(this).removeData("resizable-alsoresize-start");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / o.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * o.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);


}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-ui-plugins', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.ThreeDots.js' */
/******************************************************************************************************

	jQuery.ThreeDots

	Author Jeremy Horn
	Version 1.0.10 (Developed in Aptana Studio 1.5.1)
	Date: 1/25/2010

	Copyright (c) 2010 Jeremy Horn- jeremydhorn(at)gmail(dot)c0m | http://tpgblog.com
	Dual licensed under MIT and GPL.

	For more detailed documentation, including the latest updates and links to more usage and 
	examples, go to:
	
			http://tpgblog.com/ThreeDots/

	KNOWN BUGS
		None

	DESCRIPTION

		Sometimes the text ...
			... is too long ...
			... won't fit within the number of rows you have available.
		
		Sometimes all you need is ... ThreeDots!
		
		ThreeDots is a customizable jQuery plugin for the smart truncation of text.  It shortens 
		provided text to fit specified dimensions and appends the desired ellipsis style
		if/when truncation occurs.  		
		
		For example ---
		
			This:
				There was once a brown fox
				that liked to eat chocolate
				pudding.
			
			When restricted to 2 lines by ThreeDots, can become:
				There was once a brown fox
				that liked to eat ...
				
			Or:
				There was once a brown fox
				that liked to (click for more)

			... and most any other permutation you desire.


	BY DEFAULT
		The three dots ellipsis ("...") is used, as shown in the prior example, and limits
		text to a maximum of 2 lines.  These and many other characteristics are fully customizable,
		and fully itemized and explained below.


	IMPLEMENTATION

		HTML:		<div class='text_here'><span class='ellipsis_text'>TEXT</span></div>
		JS:			$('.text_here').ThreeDots(); // USE DEFAULTS
					$('.text_here2').ThreeDots({ { max_rows:3 });
		

	COMPATIBILITY

		Tested in FF3.5, IE7, Chrome
		With jQuery 1.3.x, 1.4

	METHODS

		ThreeDots()
		
		When intialized the ThreeDots plugin creates and assigns the full set of provided text 
		to each container element as a publically accessible attribute, 'threedots'.  Method 
		implementation supports chaining and returns jQuery object.

		Note that to implement, the text that you wish to ellipsize must be wrapped in a span
		assigned either the default class 'ellipsis_text' or other custom class of your 
		preference -- customizable via the options/settings.
		
		If the text becomes truncated to fit within the constrained space defined by the 
		container element that holds the 'ellipsis_text' span then an additional span is
		appended within the container object, and after the 'ellipsis_text' span.
		
		Note, that the span class of 'threedots_ellipsis' can also be customized via the 
		options/settings and have it's own CSS/jQuery styles/actions/etc. applied to it as
		desired.
		
		If any of the specified settings are invalid or the 'ellipsis_text' span is missing
		nothing will happen.

		IMPORTANT:	The horizontal constrains placed upon each row are controled by the 
					container object.  The container object is the object specified in the 
					primary selector.
					
						e.g. $('container_object').ThreeDots();
					
					So, remember to set container_object's WIDTH.
						
		ThreeDots.update()
			Refreshes the contents of the text within the target object inline with the
			options provided. Note, that the current implementation of options/settings
			are destructive.  This means that whenever OPTIONS are specified they are
			merged with the DEFAULT options and applied to the current object(s), and 
			destroy/override any previously specified options/settings.
			
				example:
					var obj = $('.text_here').ThreeDots();  // uses DEFAULT: max_rows = 2
					obj.update({max_rows:3});				// update the text with max_rows = 3

	CUSTOMIZATION

		ThreeDots(OPTIONS)
		e.g. $('.text_here').ThreeDots({ max_rows: 4 });
					
		
		valid_delimiters:	character array of special characters upon which the text string may be broken up;
							defines what characters can be used to express the bounds of a word
							
							all elements in this array must be 1 character in length; any delimiter less than 
							or greater than	1 character will be ignored
														
							
		ellipsis_string: 	defines what to display at the tail end of the text provided if the text becomes 
							truncated to fit within the space defined by the container object
												
							
		max_rows:			specifies the upper limit for the number of rows that the object's text can use
				
		
		text_span_class:	by default ThreeDots will look within the specified object(s) for a span
							of the class 'ellipsis_text'
							
		
		e_span_class:		if an ellipsis_string is displayed at the tail end of the selected object's
							text due to truncation of that text then it will be displayed wrapped within
							a span associated with the class defined by e_span_class and immediately
							following the text_span_class' span
		
		
		whole_word:			when fitting the provided text to the max_rows within the container object
							this boolean setting defines whether or not the 
							
								if true
									THEN	don't truncate any words; ellipsis can ONLY be placed after 
											the last whole word that fits within the provided space, OR
											
								if false
									THEN	maximuze the text within the provided space, allowing the 
											PARTIAL display of words before the ellipsis
		
		
		allow_dangle:		a dangling ellipsis is an ellipsis that typically occurs due to words that
							are longer than a single row of text, resulting, upon text truncation in
							the ellipsis being displayed on a row all by itself
													
							if allow_dangle is set to false, whole_words is overridden ONLY in the 
							circumstances where a dangling ellipsis occurs and the displayed text
							is adjusted to minimize the occurence of such dangling
									
		
		alt_text_e: 		alt_text_e is a shortcut to enabling the user of the product that 
							made use of ThreeDots to see the full text, prior to truncation
							
							if the value is set to true, then the ellipsis span's title property
							is set to the full, original text (pre-truncation)
		
		
		alt_text_t: 		alt_text_t is a shortcut to enabling the user of the product that 
							made use of ThreeDots to see the full text, prior to truncation
							
							if the value is set to true AND the ellipsis is displayed, then the 
							text span's title property is set to the full, original text 
							(pre-truncation) 
	

	MORE

		For latest updates and links to more usage and examples, go to:
			http://tpgblog.com/ThreeDots/
			
	FUTURE NOTE
	
		Do not write any code dependent on the c_settings variable.  If you don't know what this is
		cool -- you don't need to. ;-)  c_settings WILL BE DEPRECATED.
		
		Further optimizations in progress...

******************************************************************************************************/


(function($) {

	/**********************************************************************************

		METHOD
			ThreeDots {PUBLIC}

		DESCRIPTION
			ThreeDots method constructor
			
			allows for the customization of ellipsis, delimiters, etc., and smart 
			truncation of provided objects' text
					
				e.g. $(something).ThreeDots();

	**********************************************************************************/

	$.fn.ThreeDots = function(options) {
		var return_value = this;

		// check for new & valid options
		if ((typeof options == 'object') || (options == undefined)) {
			$.fn.ThreeDots.the_selected = this;

			var return_value = $.fn.ThreeDots.update(options);

		}
		
		return return_value;
	};


	/**********************************************************************************

		METHOD
			ThreeDots.update {PUBLIC}

		DESCRIPTION
			applies the core logic of ThreeDots
			
			allows for the customization of ellipsis, delimiters, etc., and smart 
			truncation of provided objects' text
			
			updates the objects' visible text to fit within its container(s)
		
		TODO
			instead of having all options/settings calls be constructive have 
			settings associated w/ object returned also accessible from HERE 
			[STATIC settings, associated w/ the initial call] 

	**********************************************************************************/

	$.fn.ThreeDots.update = function(options) {
		// initialize local variables
		var curr_this, last_word = null;
		var lineh, paddingt, paddingb, innerh, temp_height;
		var curr_text_span, lws; /* last word structure */
		var last_text, three_dots_value, last_del;

		// check for new & valid options
		if ((typeof options == 'object') || (options == undefined)) {

			// then update the settings
			// CURRENTLY, settings are not CONSTRUCTIVE, but merged with the DEFAULTS every time
			$.fn.ThreeDots.c_settings = $.extend({}, $.fn.ThreeDots.settings, options);
			var max_rows = $.fn.ThreeDots.c_settings.max_rows;
			if (max_rows < 1) {
				return $.fn.ThreeDots.the_selected;
			}

			// make sure at least 1 valid delimiter
			var valid_delimiter_exists = false;
			jQuery.each($.fn.ThreeDots.c_settings.valid_delimiters, function(i, curr_del) {
				if (((new String(curr_del)).length == 1)) {
					valid_delimiter_exists = true; 
				}
			});
			if (valid_delimiter_exists == false) {
				return $.fn.ThreeDots.the_selected;
			}
			
			// process all provided objects
			$.fn.ThreeDots.the_selected.each(function() {

				// element-specific code here
				curr_this = $(this);
		
				// obtain the text span
				if ($(curr_this).children('.'+$.fn.ThreeDots.c_settings.text_span_class).length == 0) { 
					// if span doesnt exist, then go to next
					return true;
				}
				curr_text_span = $(curr_this).children('.'+$.fn.ThreeDots.c_settings.text_span_class).get(0);

				// pre-calc fixed components of num_rows
				var nr_fixed = num_rows(curr_this, true);

				// remember where it all began so that we can see if we ended up exactly where we started
				var init_text_span = $(curr_text_span).text();

				// preprocessor
				the_bisector(curr_this, curr_text_span, nr_fixed);
				var init_post_b = $(curr_text_span).text();

				// if the object has been initialized, then user must be calling UPDATE
				// THEREFORE refresh the text area before re-operating
				if ((three_dots_value = $(curr_this).attr('threedots')) != undefined) {
					$(curr_text_span).text(three_dots_value);						
					$(curr_this).children('.'+$.fn.ThreeDots.c_settings.e_span_class).remove();
				}

				last_text = $(curr_text_span).text();
				if (last_text.length <= 0) {
					last_text = '';
				}
				$(curr_this).attr('threedots', init_text_span);

				if (num_rows(curr_this, nr_fixed) > max_rows) {
					// append the ellipsis span & remember the original text
					curr_ellipsis = $(curr_this).append('<span style="white-space:nowrap" class="'	
														+ $.fn.ThreeDots.c_settings.e_span_class + '">'
														+ $.fn.ThreeDots.c_settings.ellipsis_string 
														+ '</span>');
	
					// remove 1 word at a time UNTIL max_rows
					while (num_rows(curr_this, nr_fixed) > max_rows) {
						
						lws = the_last_word($(curr_text_span).text());// HERE
						$(curr_text_span).text(lws.updated_string);
						last_word = lws.word;
						last_del = lws.del;

						if (last_del == null) {
							break;					
						}
					} // while (num_rows(curr_this, nr_fixed) > max_rows)

					// check for super long words
					if (last_word != null) {
						var is_dangling = dangling_ellipsis(curr_this, nr_fixed);

						if ((num_rows(curr_this, nr_fixed) <= max_rows - 1) 
							|| (is_dangling) 
							|| (!$.fn.ThreeDots.c_settings.whole_word)) {

							last_text = $(curr_text_span).text();
							if (lws.del != null) {
								$(curr_text_span).text(last_text + last_del);
							}
									
							if (num_rows(curr_this, nr_fixed) > max_rows) {
								// undo what i just did and stop
								$(curr_text_span).text(last_text);
							} else {
								// keep going
								$(curr_text_span).text($(curr_text_span).text() + last_word);
								
								// break up the last word IFF (1) word is longer than a line, OR (2) whole_word == false
								if ((num_rows(curr_this, nr_fixed) > max_rows + 1) 
									|| (!$.fn.ThreeDots.c_settings.whole_word)
									|| (init_post_b == last_word)
									|| is_dangling) {
									// remove 1 char at a time until it all fits
									while ((num_rows(curr_this, nr_fixed) > max_rows)) {
										if ($(curr_text_span).text().length > 0) {
											$(curr_text_span).text(
												$(curr_text_span).text().substr(0, $(curr_text_span).text().length - 1)
											);
										} else {
											/* 
											 there is no hope for you; you are crazy;
											 either pick a shorter ellipsis_string OR
											 use a wider object --- geeze!
											 */
											break;
										}
									}							
								}
							}
						}
					}
				}	
				
				// if nothing has changed, remove the ellipsis
				if (init_text_span == $($(curr_this).children('.' + $.fn.ThreeDots.c_settings.text_span_class).get(0)).text()) {
					$(curr_this).children('.' + $.fn.ThreeDots.c_settings.e_span_class).remove();
				} else {				
					// only add any title text if the ellipsis is visible
					if (($(curr_this).children('.' + $.fn.ThreeDots.c_settings.e_span_class)).length > 0) {
						if ($.fn.ThreeDots.c_settings.alt_text_t) {
							$(curr_this).children('.' + $.fn.ThreeDots.c_settings.text_span_class).attr('title', init_text_span);
						}
						
						if ($.fn.ThreeDots.c_settings.alt_text_e) {
							$(curr_this).children('.' + $.fn.ThreeDots.c_settings.e_span_class).attr('title', init_text_span);
						}
						
					}
				}
			}); // $.fn.ThreeDots.the_selected.each(function() 
		}

		return $.fn.ThreeDots.the_selected;
	};


	/**********************************************************************************

		METHOD
			ThreeDots.settings {PUBLIC}

		DESCRIPTION
			data structure containing the max_rows, ellipsis string, and other
			behavioral settings
			
			can be directly accessed by '$.fn.ThreeDots.settings = ...... ;'

	**********************************************************************************/

	$.fn.ThreeDots.settings = {
		valid_delimiters: 	[' ', ',', '.'],		// what defines the bounds of a word to you?
		ellipsis_string: 	'...',
		max_rows:			2,
		text_span_class:	'ellipsis_text',
		e_span_class:		'threedots_ellipsis',
		whole_word:			true,
		allow_dangle:		false,
		alt_text_e: 		false,					// if true, mouse over of ellipsis displays the full text
		alt_text_t: 		false  					// if true & if ellipsis displayed, mouse over of text displays the full text
	};


	/**********************************************************************************

		METHOD
			dangling_ellipsis {private}

		DESCRIPTION
			determines whether or not the currently calculated ellipsized text
			is displaying a dangling ellipsis (= an ellipsis on a line by itself)
			
			returns true if ellipsis is dangling, otherwise false

	**********************************************************************************/

	function dangling_ellipsis(obj, nr_fixed){
		if ($.fn.ThreeDots.c_settings.allow_dangle == true) {
			return false; // why do when no doing need be done?
		}

		// initialize variables
		var ellipsis_obj 		= $(obj).children('.'+$.fn.ThreeDots.c_settings.e_span_class).get(0);
		var remember_display 	= $(ellipsis_obj).css('display');
		var num_rows_before 	= num_rows(obj, nr_fixed);

		// temporarily hide ellipsis
		$(ellipsis_obj).css('display','none');
		var num_rows_after 		= num_rows(obj, nr_fixed);

		// restore ellipsis
		$(ellipsis_obj).css('display',remember_display);
		
		if (num_rows_before > num_rows_after) {
			return true; 	// ASSUMPTION: 	removing the ellipsis changed the height
							// 				THEREFORE the ellipsis was on a row all by its lonesome
		} else {
			return false;	// nothing dangling here
		}
	}


	/**********************************************************************************

		METHOD
			num_rows {private}

		DESCRIPTION
			returns the number of rows/lines that the current object's text covers if
			cstate is an object
			
			this function can be initially called to pre-calculate values that will 
			stay fixed throughout the truncation process for the current object so
			that the values do not have to be called every time; to do this the
			num_rows function is called with a boolean value within the cstate
			
			when boolean cstate, an object is returned containing padding and line
			height information that is then passed in as the cstate object on
			subsequent calls to the function

	**********************************************************************************/

	function num_rows(obj, cstate){	
		var the_type = typeof cstate;
	
		if (	(the_type == 'object') 
			||	(the_type == undefined)	) {

			// do the math & return
			return $(obj).height() / cstate.lh;
			
		} else if (the_type == 'boolean') {
			var lineheight	= lineheight_px($(obj));

			return {
				lh: lineheight
			};
		} 
	}

	
	/**********************************************************************************

		METHOD
			the_last_word {private}

		DESCRIPTION
			return a data structure containing...
			 
				[word] 				the last word within the specified text	defined 
									by the specified valid_delimiters, 
				[del] 				the delimiter occurring	directly before the 
									word, and 
				[updated_string] 	the updated text minus the last word 
			
			[del] is null if the last word is the first and/or only word in the text 
			string

	**********************************************************************************/

	function the_last_word(str){
		var temp_word_index;
		var v_del = $.fn.ThreeDots.c_settings.valid_delimiters;
		
		// trim the string
		str = jQuery.trim(str);
		
		// initialize variables
		var lastest_word_idx = -1;
		var lastest_word = null;
		var lastest_del = null;

		// for all given delimiters, determine which delimiter results in the smallest word cut
		jQuery.each(v_del, function(i, curr_del){
			if (((new String(curr_del)).length != 1)
				|| (curr_del == null)) {  // implemented to handle IE NULL condition; if only typeof could say CHAR :(
				return false; // INVALID delimiter; must be 1 character in length
			}

			var tmp_word_index = str.lastIndexOf(curr_del);
			if (tmp_word_index != -1) {
				if (tmp_word_index > lastest_word_idx) {
					lastest_word_idx 	= tmp_word_index;
					lastest_word 		= str.substring(lastest_word_idx+1);
					lastest_del			= curr_del;
				}
			}
		});
		
		// return data structure of word reduced string and the last word
		if (lastest_word_idx > 0) {
			return {
				updated_string:	jQuery.trim(str.substring(0, lastest_word_idx/*-1*/)),
				word: 			lastest_word,
				del: 			lastest_del
			};
		} else { // the lastest word
			return {
				updated_string:	'',
				word: 			jQuery.trim(str),
				del: 			null
			};
		}
	}

			
	/**********************************************************************************

		METHOD
			lineheight_px {private}

		DESCRIPTION
			returns the line height of a row of the provided text (within the text 
			span) in pixels

	**********************************************************************************/

	function lineheight_px(obj) {
		// shhhh... show
		$(obj).append("<div id='temp_ellipsis_div' style='position:absolute; visibility:hidden'>H</div>");
		// measure
		var temp_height = $('#temp_ellipsis_div').height();
		// cut
		$('#temp_ellipsis_div').remove();

		return temp_height;
	}
	
	/**********************************************************************************

		METHOD
			the_bisector (private)

		DESCRIPTION
			updates the target objects current text to shortest overflowing string 
			length (if overflowing is occurring) by adding/removing halves (like
			binary search)

			because...
				taking some bigger steps at the beginning should save us some real 
				time in the end

	**********************************************************************************/
	
	function the_bisector(obj, curr_text_span, nr_fixed){
		var init_text = $(curr_text_span).text();
		var curr_text = init_text;
		var max_rows = $.fn.ThreeDots.c_settings.max_rows;
		var front_half, back_half, front_of_back_half, middle, back_middle;
		var start_index;
		
		if (num_rows(obj, nr_fixed) <= max_rows) {
			// do nothing
			return;
		} else {
			// zero in on the solution
			start_index = 0;
			curr_length = curr_text.length;

			curr_middle = Math.floor((curr_length - start_index) / 2);
			front_half = init_text.substring(start_index, start_index+curr_middle);
			back_half = init_text.substring(start_index + curr_middle);
				
			while (curr_middle != 0) {
				$(curr_text_span).text(front_half);
				
				if (num_rows(obj, nr_fixed) <= (max_rows)) {
					// text = text + front half of back-half
					back_middle 		= Math.floor(back_half.length/2);
					front_of_back_half 	= back_half.substring(0, back_middle);
					
					start_index = front_half.length;
					curr_text 	= front_half+front_of_back_half;
					curr_length = curr_text.length;

					$(curr_text_span).text(curr_text);
				} else {
					// text = front half (which it already is)
					curr_text = front_half;
					curr_length = curr_text.length;
				}
				
				curr_middle = Math.floor((curr_length - start_index) / 2);
				front_half = init_text.substring(0, start_index+curr_middle);
				back_half = init_text.substring(start_index + curr_middle);
			}
		}
	}
	
})(jQuery);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-ui-plugins', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.ui.autocomplete.js' */

/*
 * jQuery UI Autocomplete 1.8.1
 *
 * Copyright (c) 2010 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */

/* ATLASSIAN
 * So as not to conflict with an ancient version of this widget in Confluence we name it
 * autocompleteTC. Once CONFDEV-10384 is resolved we should be able to remove this file completely and
 * just use the version included in AUI.
 */
(function( $ ) {

if (!$.fn.zIndex) {
	$.fn.extend({
		zIndex: function (zIndex) {
			if (zIndex !== undefined) {
				return this.css("zIndex", zIndex);
			}

			if (this.length) {
				var elem = $(this[0]), position, value;
				while (elem.length && elem[0] !== document) {
					// Ignore z-index if position is set to a value where z-index is ignored by the browser
					// This makes behavior of this function consistent across browsers
					// WebKit always returns auto if the element is positioned
					position = elem.css("position");
					if (position === "absolute" || position === "relative" || position === "fixed") {
						// IE returns 0 when zIndex is not specified
						// other browsers return a string
						// we ignore the case of nested elements with an explicit value of 0
						// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
						value = parseInt(elem.css("zIndex"), 10);
						if (!isNaN(value) && value !== 0) {
							return value;
						}
					}
					elem = elem.parent();
				}
			}

			return 0;
		}
	});
}

$.widget( "ui.autocompleteTC", {
	options: {
		minLength: 1,
		delay: 300
	},
	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument;
		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" )
			// TODO verify these actually work as intended
			.attr({
				role: "textbox",
				"aria-autocomplete": "list",
				"aria-haspopup": "true"
			})
			.bind( "keydown.autocomplete", function( event ) {
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( "nextPage", event );
					break;
				case keyCode.UP:
					self._move( "previous", event );
					// prevent moving cursor to beginning of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.DOWN:
					self._move( "next", event );
					// prevent moving cursor to end of text field in some browsers
					event.preventDefault();
					break;
				case keyCode.ENTER:
					// when menu is open or has focus
					if ( self.menu.active ) {
						event.preventDefault();
					}
					//passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				case keyCode.LEFT:
				case keyCode.RIGHT:
				case keyCode.SHIFT:
				case keyCode.CONTROL:
				case keyCode.ALT:
					// ignore metakeys (shift, ctrl, alt)
					break;
				default:
					// keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						self.search( null, event );
					}, self.options.delay );
					break;
				}
			})
			.bind( "focus.autocomplete", function() {
				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( "blur.autocomplete", function( event ) {
				clearTimeout( self.searching );
				// clicks on the menu (or a button to trigger a search) will cause a blur event
				// TODO try to implement this without a timeout, see clearTimeout in search()
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.response = function() {
			return self._response.apply( self, arguments );
		};
		this.menu = $( "<ul></ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( "body", doc )
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" );
					if ( false !== self._trigger( "focus", null, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( /^key/.test(event.originalEvent.type) ) {
							self.element.val( item.value );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" );
					if ( false !== self._trigger( "select", event, { item: item } ) ) {
						self.element.val( item.value );
					}
					self.close( event );
					// only trigger when focus was lost (click on menu)
					var previous = self.previous;
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
					}
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					if ( self.menu.element.is(":visible") ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( "menu" );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
	},

	destroy: function() {
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-autocomplete" )
			.removeAttr( "aria-haspopup" );
		this.menu.element.remove();
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "source" ) {
			this._initSource();
		}
	},

	_initSource: function() {
		var array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocompleteTC.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				$.getJSON( url, request, response );
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();
		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger("search") === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.term = this.element
			.addClass( "ui-autocomplete-loading" )
			// always save the actual value, not the one passed as an argument
			.val();

		this.source( { term: value }, this.response );
	},

	_response: function( content ) {
		if ( content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( "open" );
		} else {
			this.close();
		}
		this.element.removeClass( "ui-autocomplete-loading" );
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(":visible") ) {
			this._trigger( "close", event );
			this.menu.element.hide();
			this.menu.deactivate();
		}
	},

	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
				.empty()
				.zIndex( this.element.zIndex() + 1 ),
			menuWidth,
			textWidth;
		this._renderMenu( ul, items );
		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();
		this.menu.element.show().position({
			my: "left top",
			at: "left bottom",
			of: this.element,
			collision: "none"
		});

		menuWidth = ul.width( "" ).width();
		textWidth = this.element.width();
		ul.width( Math.max( menuWidth, textWidth ) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
		return $( "<li></li>" )
			.data( "item.autocomplete", item )
			.append( "<a>" + item.label + "</a>" )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(":visible") ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() && /^previous/.test(direction) ||
				this.menu.last() && /^next/.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	}
});

$.extend( $.ui.autocompleteTC, {
	escapeRegex: function( value ) {
		return value.replace( /([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1" );
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocompleteTC.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 *
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright (c) 2010 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget("ui.menu", {
	_create: function() {
		var self = this;
		this.element
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.attr({
				role: "listbox",
				"aria-activedescendant": "ui-active-menuitem"
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( ".ui-menu-item a" ).length ) {
					return;
				}
				// temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},

	refresh: function() {
		var self = this;

		// don't refresh list items that are already adapted
		var items = this.element.children("li:not(.ui-menu-item):has(a)")
			.addClass("ui-menu-item")
			.attr("role", "menuitem");

		items.children("a")
			.addClass("ui-corner-all")
			.attr("tabindex", -1)
			// mouseenter doesn't work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.attr("scrollTop"),
				elementHeight = this.element.height();
			if (offset < 0) {
				this.element.attr("scrollTop", scroll + offset);
			} else if (offset > elementHeight) {
				this.element.attr("scrollTop", scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children("a")
				.addClass("ui-state-hover")
				.attr("id", "ui-active-menuitem")
			.end();
		this._trigger("focus", event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children("a")
			.removeClass("ui-state-hover")
			.removeAttr("id");
		this._trigger("blur");
		this.active = null;
	},

	next: function(event) {
		this.move("next", ".ui-menu-item:first", event);
	},

	previous: function(event) {
		this.move("prev", ".ui-menu-item:last", event);
	},

	first: function() {
		return this.active && !this.active.prev().length;
	},

	last: function() {
		return this.active && !this.active.next().length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + "All"](".ui-menu-item").eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	// TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(":first"));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children("li").filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(":last");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(!this.active || this.last() ? ":first" : ":last"));
		}
	},

	// TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(":last"));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height();
				result = this.element.children("li").filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(":first");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(!this.active || this.first() ? ":last" : ":first"));
		}
	},

	hasScroll: function() {
		return this.element.height() < this.element.attr("scrollHeight");
	},

	select: function( event ) {
		this._trigger("selected", event, { item: this.active });
	}
});

}(jQuery));

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-ui-plugins', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.tourbus.js' */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//# sourceMappingURL=jquery-tourbus.map
(function() {
  var $, Bus, Leg, methods, tourbus,
    __slice = [].slice;

  $ = jQuery;

  Bus = require('./modules/bus');

  Leg = require('./modules/leg');

  tourbus = $.tourbus = function() {
    var args, method;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    method = args[0];
    if (methods.hasOwnProperty(method)) {
      args = args.slice(1);
    } else if (method instanceof $) {
      method = 'build';
    } else if (typeof method === 'string') {
      method = 'build';
      args[0] = $(args[0]);
    } else {
      $.error("Unknown method of $.tourbus --", args);
    }
    return methods[method].apply(this, args);
  };

  $.fn.tourbus = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.each(function() {
      args.unshift($(this));
      tourbus.apply(null, ['build'].concat(__slice.call(args)));
      return this;
    });
  };

  methods = {
    build: function(el, options) {
      var built;
      if (options == null) {
        options = {};
      }
      options = $.extend(true, {}, tourbus.defaults, options);
      built = [];
      if (!(el instanceof $)) {
        el = $(el);
      }
      el.each(function() {
        return built.push(new Bus(this, options));
      });
      if (built.length === 0) {
        $.error("" + el.selector + " was not found!");
      }
      if (built.length === 1) {
        return built[0];
      }
      return built;
    },
    destroyAll: function() {
      var bus, index, _ref, _results;
      _ref = Bus._busses;
      _results = [];
      for (index in _ref) {
        bus = _ref[index];
        _results.push(bus.destroy());
      }
      return _results;
    },
    expose: function(global) {
      return global.tourbus = {
        Bus: Bus,
        Leg: Leg
      };
    }
  };

  tourbus.defaults = {
    debug: false,
    autoDepart: false,
    container: 'body',
    "class": null,
    startAt: 0,
    onDepart: function() {
      return null;
    },
    onStop: function() {
      return null;
    },
    onLegStart: function() {
      return null;
    },
    onLegEnd: function() {
      return null;
    },
    leg: {
      "class": null,
      scrollTo: null,
      scrollSpeed: 150,
      scrollContext: 100,
      orientation: 'bottom',
      align: 'left',
      width: 'auto',
      margin: 10,
      top: null,
      left: null,
      zindex: 9999,
      arrow: "50%"
    }
  };

}).call(this);

},{"./modules/bus":2,"./modules/leg":3}],2:[function(require,module,exports){
//# sourceMappingURL=bus.map
(function() {
  var $, Bus, Leg, utils,
    __slice = [].slice;

  $ = jQuery;

  Leg = require('./leg');

  utils = require('./utils');

  module.exports = Bus = (function() {
    Bus._busses = {};

    Bus._tours = 0;

    Bus.uniqueId = function() {
      return this._tours++;
    };

    function Bus(el, options) {
      this.options = options;
      this.id = this.constructor.uniqueId();
      this.elId = "tourbus-" + this.id;
      this.constructor._busses[this.id] = this;
      this.$original = $(el);
      this.rawData = this.$original.data();
      this.$container = $(utils.dataProp(this.rawData.container, this.options.container));
      this.$original.data({
        tourbus: this
      });
      this.currentLegIndex = null;
      this.legs = [];
      this.legEls = this.$original.children('li');
      this.totalLegs = this.legEls.length;
      this._configureElement();
      this._setupEvents();
      if (utils.dataProp(this.rawData.autoDepart, this.options.autoDepart)) {
        this.$original.trigger('depart.tourbus');
      }
      this._log('built tourbus with el', el.toString(), 'and options', this.options);
    }

    Bus.prototype.depart = function() {
      this.running = true;
      this.options.onDepart(this);
      this._log('departing', this);
      this.currentLegIndex = utils.dataProp(this.rawData.startAt, this.options.startAt);
      return this.showLeg();
    };

    Bus.prototype.stop = function(e) {
      if (!this.running) {
        return;
      }

      // ATLASSIAN : change here so the click only isolated for this plugin
      if (e && e.stopPropagation) {
          e.stopPropagation();
      }

      $.each(this.legs, $.proxy(this.hideLeg, this));
      this.currentLegIndex = null;
      this.options.onStop(this);
      return this.running = false;
    };

    Bus.prototype.on = function(event, selector, fn) {
      return this.$container.on(event, selector, fn);
    };

    Bus.prototype.currentLeg = function() {
      if (this.currentLegIndex === null) {
        return null;
      }
      return this.legs[this.currentLegIndex];
    };

    Bus.prototype.buildLeg = function(i) {
      var $legEl, data, leg;
      $legEl = $(this.legEls[i]);
      data = $legEl.data();
      this.legs[i] = leg = new Leg({
        bus: this,
        original: $legEl,
        // ATLASSIAN change here to support on the fly target
        target: $legEl.attr("data-el") || 'body',
        index: i,
        rawData: data
      });
      leg.render();
      this.$el.append(leg.$el);
      leg._position();
      leg.hide();
      return leg;
    };

    Bus.prototype.showLeg = function(index) {
      var leg, preventDefault;
      if (index == null) {
        index = this.currentLegIndex;
      }
      leg = this.legs[index] || this.buildLeg(index);
      this._log('showLeg:', leg);
      preventDefault = this.options.onLegStart(leg, this);
      if (preventDefault !== false) {
        leg.show();
      }
      if (++index < this.totalLegs && !this.legs[index]) {
        return this.buildLeg(index);
      }
    };

    Bus.prototype.hideLeg = function(index) {
      var leg, preventDefault;
      if (index == null) {
        index = this.currentLegIndex;
      }
      leg = this.legs[index];
      //ATLASSIAN : check to see leg is undefined or not before close it
      if (leg && leg.visible) {
        this._log('hideLeg:', leg);
        preventDefault = this.options.onLegEnd(leg, this);
        if (preventDefault !== false) {
          leg.hide();
        }
      }
      if (--index > 0 && !this.legs[index]) {
        return this.buildLeg(index);
      }
    };

    Bus.prototype.repositionLegs = function() {
      return $.each(this.legs, function(index, item) {
        if (item) {
            item.reposition();
        }

        return;
      });
    };

    Bus.prototype.next = function(e) {
      // ATLASSIAN : change here so the click only isolated for this plugin
      if (e && e.stopPropagation) {
          e.stopPropagation();
      }

      this.hideLeg();
      this.currentLegIndex++;
      if (this.currentLegIndex > this.totalLegs - 1) {
        return this.$original.trigger('stop.tourbus');
      } else {
        return this.showLeg();
      }
    };

    Bus.prototype.prev = function(e) {
      // ATLASSIAN : change here so the click only isolated for this plugin
      if (e && e.stopPropagation) {
          e.stopPropagation();
      }

      this.hideLeg();
      this.currentLegIndex--;
      if (this.currentLegIndex < 0) {
        return this.$original.trigger('stop.tourbus');
      } else {
        return this.showLeg();
      }
    };

    Bus.prototype.destroy = function() {
      $.each(this.legs, function(index, item) {
          // ATLASSIAN : change to make it work
          if (item && item.destroy) {
            item.destroy();
          }
      });
      this.legs = [];
      delete this.constructor._busses[this.id];
      this._teardownEvents();
      this.$original.removeData('tourbus');
      return this.$el.remove();
    };

    Bus.prototype._configureElement = function() {
      this.$el = $("<div class='tourbus-container'></div>");
      this.el = this.$el[0];
      this.$el.attr({
        id: this.elId
      });
      this.$el.addClass(utils.dataProp(this.rawData["class"], this.options["class"]));
      return this.$container.append(this.$el);
    };

    Bus.prototype._log = function() {
      if (!utils.dataProp(this.rawData.debug, this.options.debug)) {
        return;
      }
      return console.log.apply(console, ["TOURBUS " + this.id + ":"].concat(__slice.call(arguments)));
    };

    Bus.prototype._setupEvents = function() {
      this.$original.on('depart.tourbus', $.proxy(this.depart, this));
      this.$original.on('stop.tourbus', $.proxy(this.stop, this));
      this.$original.on('next.tourbus', $.proxy(this.next, this));
      return this.$original.on('prev.tourbus', $.proxy(this.prev, this));
    };

    Bus.prototype._teardownEvents = function() {
      return this.$original.off('.tourbus');
    };

    return Bus;

  })();

}).call(this);

},{"./leg":3,"./utils":4}],3:[function(require,module,exports){
//# sourceMappingURL=leg.map
(function() {
  var $, Leg, utils, _addRule;

  $ = jQuery;

  utils = require('./utils');

  module.exports = Leg = (function() {
    function Leg(options) {
      this.options = options;
      this.$original = this.options.original;
      this.bus = this.options.bus;
      this.rawData = this.options.rawData;
      this.index = this.options.index;
      this.$target = $(this.options.target);
      this.id = "" + this.bus.id + "-" + this.options.index;
      this.elId = "tourbus-leg-" + this.id;
      this.visible = false;
      if (this.$target.length === 0) {
        throw "" + this.$target.selector + " is not an element!";
      }
      this.content = this.$original.html();
      this._setupOptions();
      this._configureElement();
      this._configureTarget();
      this._configureScroll();
      this._setupEvents();
      this.bus._log("leg " + this.index + " made with options", this.options);
    }

    Leg.prototype.render = function() {
      var arrowClass, html;
      arrowClass = this.options.orientation === 'centered' ? '' : 'tourbus-arrow';
      this.$el.addClass(" " + arrowClass + " tourbus-arrow-" + this.options.orientation + " ");
      html = "<div class='tourbus-leg-inner'>\n  " + this.content + "\n</div>";
      this.$el.css({
        width: this.options.width,
        zIndex: this.options.zindex
      }).html(html);
      return this;
    };

    Leg.prototype.destroy = function() {
      this.$el.remove();
      return this._teardownEvents();
    };

    Leg.prototype.reposition = function() {
      this._configureTarget();
      return this._position();
    };

    Leg.prototype._position = function() {
      var css, keys, rule, selector;
      if (this.options.orientation !== 'centered') {
        rule = {};
        keys = {
          top: 'left',
          bottom: 'left',
          left: 'top',
          right: 'top'
        };
        if (typeof this.options.arrow === 'number') {
          this.options.arrow += 'px';
        }
        rule[keys[this.options.orientation]] = this.options.arrow;
        selector = "#" + this.elId + ".tourbus-arrow";
        this.bus._log("adding rule for " + this.elId, rule);
        _addRule("" + selector + ":before, " + selector + ":after", rule);
      }
      css = this._offsets();
      this.bus._log('setting offsets on leg', css);
      return this.$el.css(css);
    };

    Leg.prototype.show = function() {
      this.visible = true;
      this.$el.css({
        visibility: 'visible',
        opacity: 1.0,
        zIndex: this.options.zindex
      });
      return this.scrollIntoView();
    };

    Leg.prototype.hide = function() {
      this.visible = false;
      if (this.bus.options.debug) {
        return this.$el.css({
          visibility: 'visible',
          opacity: 0.4,
          zIndex: 0
        });
      } else {
        return this.$el.css({
          visibility: 'hidden'
        });
      }
    };

    Leg.prototype.scrollIntoView = function() {
      var scrollTarget;
      if (!this.willScroll) {
        return;
      }
      scrollTarget = utils.dataProp(this.options.scrollTo, this.$el);
      this.bus._log('scrolling to', scrollTarget, this.scrollSettings);
      return $.scrollTo(scrollTarget, this.scrollSettings);
    };

    Leg.prototype._setupOptions = function() {
      var dataProps, globalOptions, prop, _i, _len, _results;
      globalOptions = this.bus.options.leg;
      dataProps = ['class', 'top', 'left', 'scrollTo', 'scrollSpeed', 'scrollContext', 'margin', 'arrow', 'align', 'width', 'zindex', 'orientation'];
      _results = [];
      for (_i = 0, _len = dataProps.length; _i < _len; _i++) {
        prop = dataProps[_i];
        _results.push(this.options[prop] = utils.dataProp(this.rawData[prop], globalOptions[prop]));
      }
      return _results;
    };

    Leg.prototype._configureElement = function() {
      this.$el = $("<div class='tourbus-leg'></div>");
      this.el = this.$el[0];
      this.$el.attr({
        id: this.elId
      });
      this.$el.addClass(this.options["class"]);
      return this.$el.css({
        zIndex: this.options.zindex
      });
    };

    Leg.prototype._setupEvents = function() {
      this.$el.on('click', '.tourbus-next', $.proxy(this.bus.next, this.bus));
      this.$el.on('click', '.tourbus-prev', $.proxy(this.bus.prev, this.bus));
      return this.$el.on('click', '.tourbus-stop', $.proxy(this.bus.stop, this.bus));
    };

    Leg.prototype._teardownEvents = function() {
      return this.$el.off('click');
    };

    Leg.prototype._configureTarget = function() {
      this.targetOffset = this.$target.offset();
      if (utils.dataProp(this.options.top, false)) {
        this.targetOffset.top = this.options.top;
      }
      if (utils.dataProp(this.options.left, false)) {
        this.targetOffset.left = this.options.left;
      }
      this.targetWidth = this.$target.outerWidth();
      return this.targetHeight = this.$target.outerHeight();
    };

    Leg.prototype._configureScroll = function() {
      this.willScroll = $.fn.scrollTo && this.options.scrollTo !== false;
      return this.scrollSettings = {
        offset: -this.options.scrollContext,
        easing: 'linear',
        axis: 'y',
        duration: this.options.scrollSpeed
      };
    };

    Leg.prototype._offsets = function() {
      var dimension, elHalf, elHeight, elWidth, offsets, targetHalf, targetHeightOverride, validOrientations;
      elHeight = this.$el.height();
      elWidth = this.$el.width();
      var targetWidth, targetHeight;
      targetWidth = this.$target.width();
      targetHeight = this.$target.height();
      offsets = {};
      // ATLASSIAN change here to adjust popup at the middle of target
      switch (this.options.orientation) {
        case 'centered':
          targetHeightOverride = $(window).height();
          offsets.top = this.options.top;
          if (!utils.dataProp(offsets.top, false)) {
            offsets.top = (targetHeightOverride / 2) - (elHeight / 2);
          }
          offsets.left = (this.targetWidth / 2) - (elWidth / 2);
          break;
        case 'left':
          var additionalPadding = 0;
          if (!(typeof this.options.arrow === 'number')) {
              var parsePercent = parseFloat(this.options.arrow);
              additionalPadding = (parsePercent * elHeight)/100;
              offsets.top = this.targetOffset.top + this.options.top + targetHeight/2 - additionalPadding ;
          } else {
              offsets.top = this.targetOffset.top  - elHeight/2 + targetHeight/2 + this.options.top;
          }

          offsets.left = this.targetOffset.left - elWidth - this.options.margin;
          break;
        case 'right':
          offsets.top = this.targetOffset.top  - elHeight/2 + targetHeight/2;
          offsets.left = this.targetOffset.left + this.targetWidth + this.options.margin;
          break;
        case 'top':
          offsets.top = this.targetOffset.top - elHeight - this.options.margin;
          offsets.left = this.targetOffset.left  - elWidth/2 + targetWidth/2;
          break;
        case 'bottom':
          offsets.top = this.targetOffset.top + this.targetHeight + this.options.margin;
          offsets.left = this.targetOffset.left  - elWidth/2  + targetWidth/2;
      }
      validOrientations = {
        top: ['left', 'right'],
        bottom: ['left', 'right'],
        left: ['top', 'bottom'],
        right: ['top', 'bottom']
      };
      if (utils.include(this.options.orientation, validOrientations[this.options.align])) {
        switch (this.options.align) {
          case 'right':
            offsets.left += this.targetWidth - elWidth;
            break;
          case 'bottom':
            offsets.top += this.targetHeight - elHeight;
        }
      } else if (this.options.align === 'center') {
        if (utils.include(this.options.orientation, validOrientations.left)) {
          targetHalf = this.targetWidth / 2;
          elHalf = elWidth / 2;
          dimension = 'left';
        } else {
          targetHalf = this.targetHeight / 2;
          elHalf = elHeight / 2;
          dimension = 'top';
        }
        if (targetHalf > elHalf) {
          offsets[dimension] += targetHalf - elHalf;
        } else {
          offsets[dimension] -= elHalf - targetHalf;
        }
      }
      return offsets;
    };

    return Leg;

  })();

  _addRule = (function(styleTag) {
    var sheet;
    styleTag.type = 'text/css';
    document.getElementsByTagName('head')[0].appendChild(styleTag);
    sheet = document.styleSheets[document.styleSheets.length - 1];
    return function(selector, css) {
      var key, propText;
      propText = $.map((function() {
        var _results;
        _results = [];
        for (key in css) {
          _results.push(key);
        }
        return _results;
      })(), function(p) {
        return "" + p + ":" + css[p];
      }).join(';');
      try {
        if (sheet.insertRule) {
          sheet.insertRule("" + selector + " { " + propText + " }", (sheet.cssRules || sheet.rules).length);
        } else {
          sheet.addRule(selector, propText);
        }
      } catch (_error) {}
    };
  })(document.createElement('style'));

}).call(this);

},{"./utils":4}],4:[function(require,module,exports){
//# sourceMappingURL=utils.map
(function() {
  module.exports = {
    dataProp: function(possiblyFalsy, alternative) {
      if (possiblyFalsy === null || typeof possiblyFalsy === 'undefined') {
        return alternative;
      }
      return possiblyFalsy;
    },
    include: function(value, array) {
      return $.inArray(value, array || []) !== -1;
    }
  };

}).call(this);

},{}]},{},[1,2,3,4]);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:jira-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/jira/globals.js' */

;if (!window.JIRA)
    window.JIRA = {};

if (!window.JIRA.begetObject)
    window.JIRA.begetObject = function (obj) {
        var f = function()
        {};
        f.prototype = obj;
        return new f();
    };

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:jira-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/jira/Dropdown.js' */
/**
 * Creates a dropdown list from a JSON object
 *
 * @constructor JIRA.Dropdown
 * @deprecated
 * @author Scott Harwood
 *
 * NOTE: Please use @see AJS.Dropdown instead of this for future dropdown implementations.
 */

;JIRA.Dropdown = function() {

    // private

    var instances = [];

    return {

        // public

        /**
         * Adds this instance to private var <em>instances</em>
         * This reference can be used to access all instances
         * @function {public} addInstance
         */
        addInstance: function() {
            instances.push(this);
        },


        /**
         * Calls the hideList method on all instances of <em>dropdown</em>
         * @function {public} hideInstances
         */
        hideInstances: function() {
            var that = this;
            jQuery(instances).each(function(){
                if (that !== this) {
                    this.hideDropdown();
                }
            });
        },

        
        getHash: function () {
            if (!this.hash) {
                this.hash = {
                    container: this.dropdown,
                    hide: this.hideDropdown,
                    show: this.displayDropdown
                };
            }
            return this.hash;
        },

        /**
         * Calls <em>hideInstances</em> method to hide all other dropdowns.
         * Adds <em>active</em> class to <em>dropdown</em> and styles to make it visible.
         * @function {public} displayDropdown
         */
        displayDropdown: function() {
            if (JIRA.Dropdown.current === this) {
                return;
            }

            this.hideInstances();
            JIRA.Dropdown.current = this;
            this.dropdown.css({display: "block"});

            this.displayed = true;

            var dd = this.dropdown;
            setTimeout(function() {
                // Scroll dropdown into view
                var win = jQuery(window);
                var minScrollTop = dd.offset().top + dd.attr("offsetHeight") - win.height() + 10;

                if (win.scrollTop() < minScrollTop) {
                    jQuery("html,body").animate({scrollTop: minScrollTop}, 300, "linear");
                }
            }, 100);
        },

        /**
         *
         * Removes <em>active</em> class from <em>dropdown</em> and styles to make it hidden.
         * @function {public} hideDropdown
         */
        hideDropdown: function() {
            if (this.displayed === false) {
                return;
            }

            JIRA.Dropdown.current = null;
            this.dropdown.css({display: "none"});

            this.displayed = false;
        },

        /**
         * Initialises instance by, applying primary handler, user options and a Internet Explorer hack.
         * function {public} init
         * @param {HTMLElement} trigger
         * @param {HTMLElement} dropdown
         */
        init: function(trigger, dropdown) {

            var that = this;

            this.addInstance(this);
            this.dropdown = jQuery(dropdown);

            this.dropdown.css({display: "none"});

            // hide dropdown on tab
            jQuery(document).keydown(function(e){
                if(e.keyCode === 9) {
                    that.hideDropdown();
                }
            });

            // this instance is triggered by a method call
            if (trigger.target) {
                jQuery.aop.before(trigger, function(){
                    if (!that.displayed) {
                        that.displayDropdown();
                    }
                });

            // this instance is triggered by a click event
            } else {
                that.dropdown.css("top",jQuery(trigger).outerHeight() + "px");
                trigger.click(function(e){
                    if (!that.displayed) {
                        that.displayDropdown();
                        e.stopPropagation();
                        // lets not follow the link (if it is a link)
                    } else {
                        that.hideDropdown();
                    }
                    e.preventDefault();
                });
            }

            // hide dropdown when click anywhere other than on this instance
            jQuery(document.body).click(function(){
                if (that.displayed) {
                    that.hideDropdown();
                }
            });
        }
    };

}();

/**
 * Standard dropdown constructor 
 * @constucter Standard
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
JIRA.Dropdown.Standard = function(trigger, dropdown) {

    var that = JIRA.begetObject(JIRA.Dropdown);
    that.init(trigger, dropdown);

    return that;
};

/**
 * Standard dropdown constructor
 * @constucter Standard
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
JIRA.Dropdown.AutoComplete = function(trigger, dropdown) {

    var that = JIRA.begetObject(JIRA.Dropdown);

    that.init = function(trigger, dropdown) {

        this.addInstance(this);
        this.dropdown = jQuery(dropdown).click(function(e){
            // lets not hide dropdown when we click on it
            e.stopPropagation();
        });
        this.dropdown.css({display: "none"});

        // this instance is triggered by a method call
        if (trigger.target) {
            jQuery.aop.before(trigger, function(){
                if (!that.displayed) {
                    that.displayDropdown();
                }
            });

        // this instance is triggered by a click event
        } else {
            trigger.click(function(e){
                if (!that.displayed) {
                    that.displayDropdown();
                    e.stopPropagation();
                }
            });
        }

        // hide dropdown when click anywhere other than on this instance
        jQuery(document.body).click(function(){
            if (that.displayed) {
                that.hideDropdown();
            }
        });
    };

    that.init(trigger, dropdown);

    return that;
};

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:jira-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/jira/JiraAutoComplete.js' */

;JIRA.AutoComplete = function() {

    var inFocus;

    /**
     * Calls a callback after specified delay
     * @method {private} delay
     * @param {Number} l - length of delay in <em>seconds</em>
     * @param {Function} callback - function to call after delay
     */
    var delay = function(callback,l) {
        if (delay.t) {
            clearTimeout(delay.t);
            delay.t = undefined;
        }
        delay.t = setTimeout(callback, l * 1000);
    };

    var INVALID_KEYS = {
          9: true,
         13: true,
         14: true,
         25: true,
         27: true,
         38: true,
         40: true,
        224: true
    };

    return {

        /**
        * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
        * then dispatches saved response to <em>renderSuggestions</em> method.
        *
        * @method {public} dispatcher
        */
        dispatcher: function() {},


        /**
         * Gets cached response
         *
         * @method {public} getSavedResponse
         * @param {String} val
         * @returns {Object}
         */
        getSavedResponse: function() {},

        /**
         * Saves response
         *
         * @method {public} saveResponse
         * @param {String} val
         * @param {Object} response
         */
        saveResponse: function() {},

        /**
         * Called to render suggestions. Used to define interface only.
         * Rendering is difficult to make generic, best to leave this to extending prototypes.
         *
         * @method {public} renderSuggestions
         * @param {Object} res - results object
         */
        renderSuggestions: function() {},

        /**
         * Disables autocomplete. Useful for shared inputs.
         * i.e The selection of a radio button may disable the instance
         * @method {Public} disable
         */
        disable: function() {
            this.disabled = true;
        },

        /**
         * Enables autocomplete. Useful for shared inputs.
         * i.e The selection of a radio button may disable the instance
         * @method {Public} enable
         */
        enable: function() {
            this.disabled = false;
        },

        /**
         * Sets instance variables from options object
         * to do: make function create getters and setters
         * @method {public} set
         * @param {Object} options
         */
        set: function(options) {
            for (var name in options) {
                // safeguard to stop looping up the inheritance chain
                if (options.hasOwnProperty(name)) {
                    this[name] = options[name];
                }
            }
        },

        /**
         * Adds value to input field
         * @method {public} completeField
         * @param {String} value
         */
        completeField: function(value) {
            if (value) {
                this.field.val(value).focus();
            }
        },

        /**
         * Returns the text from the start of the field up to the end of
         * the position where suggestions are generated from.
         */
        textToSuggestionCursorPosition: function () {
            return this.field.val();
        },


        /**
         * An ajax request filter that only allows one request at a time. If there is another it will abort then issue
         * the new request.
         *
         * @param options - jQuery formatted ajax options
         */
        _makeRequest: function (options) {

            var that = this,
                requestParams = AJS.$.extend({}, options);

            // if we have we are still waiting for an old request, lets abort it as we are firing a new
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            requestParams.complete = function () {
                that.pendingRequest = null;
            };

            requestParams.error = function (xhr) {

                // We abort stale requests and this subsequently throws an error so we need to check if the request is aborted first.
                // We detect this using xhr.aborted property for native XHR requests but for "Microsoft.XMLHTTP" we use the status code, which is 0.
                // Status code is set to 0 when it is an unknown error so sense to fail silently.
                if (!xhr.aborted && xhr.status !== 0 && options.error) {
                    options.error.apply(this, arguments);
                }
            };

            requestParams.timeout = Confluence.TeamCalendars.ajaxTimeout;

            return this.pendingRequest = AJS.$.ajax(requestParams);
        },

        /**
         * Allows users to navigate/select suggestions using the keyboard
         * @method {public} addSuggestionControls
         */
         addSuggestionControls: function(suggestionNodes) {

            // reference to this for closures
            var that = this;

            /**
             * Make sure the index is within the threshold
             * Looks ugly! Has to be a better way.
             * @method {private} evaluateIndex
             * @param {Integer} idx
             * @param {Integer} max
             * @return {Integer} valid threshold
             */
            var evaluateIndex = function(idx, max) {
                var minBoundary = (that.autoSelectFirst === false) ? -1 : 0;
                if (that.allowArrowCarousel) {
                    if (idx > max) {
                        return minBoundary;
                    } else if (idx < minBoundary) {
                        return max;
                    } else {
                        return idx;
                    }
                }
                else {
                    if (idx > max) {
                        return max;
                    } else if (idx < minBoundary) {
                        that.responseContainer.scrollTop(0);
                        return minBoundary;
                    } else {
                        return idx;
                    }
                }
            };

            /**
             * Highlights focused node and removes highlight from previous.
             * Actual highlight styles to come from css, adding and removing classes here.
             * @method {private} setActive
             * @param {Integer} idx - Index of node to be highlighted
             */
            var setActive = function(idx) {

                    // if nothing is selected, select the first suggestion
                    if (that.selectedIndex !== undefined && that.selectedIndex > -1) {
                        that.suggestionNodes[that.selectedIndex][0].removeClass("active");
                    }
                    that.selectedIndex = evaluateIndex(idx, that.suggestionNodes.length-1);
                    if (that.selectedIndex > -1) {
                        that.suggestionNodes[that.selectedIndex][0].addClass("active");
                    }
            };

             /**
              * Checks to see if there is actually a suggestion in focus before attempting to use it
              * @method {private} evaluateIfActive
              * @returns {boolean}
              */
             var evaluateIfActive = function() {
                return that.suggestionNodes && that.suggestionNodes[that.selectedIndex] &&
                       that.suggestionNodes[that.selectedIndex][0].hasClass("active");
             };


            /**
             * When the responseContainer (dropdown) is visible listen for keyboard events
             * that represent focus or selection.
             * @method {private} keyPressHandler
             * @param {Object} e - event object
             */
            var keyPressHandler = function(e) {
                // only use keyboard events if dropdown is visible
                if (that.responseContainer.is(":visible")) {
                    // if enter key is pressed check that there is a node selected, then hide dropdown and complete field
                    if (e.keyCode === 13) {
                        if (evaluateIfActive() && !that.pendingRequest) {
                            that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                        }
                        e.preventDefault();
                    }
                }
            };

            /**
            * sets focus on suggestion nodes using the "up" and "down" arrows
            * These events need to be fired on mouseup as modifier keys don't register on keypress
            * @method {private} keyUpHandler
            * @param {Object} e - event object
            */
            var keyboardNavigateHandler = function(e) {

                // only use keyboard events if dropdown is visible
                if (that.responseContainer.is(":visible")) {

                    // keep cursor inside input field
                    if (that.field[0] !== document.activeElement){
                        that.field.focus();
                    }
                    // move selection down when down arrow is pressed
                    if (e.keyCode === 40) {
                        setActive(that.selectedIndex + 1);
                        if (that.selectedIndex >= 0) {
                            // move selection up when up arrow is pressed
                            var containerHeight = that.responseContainer.height();
                            var bottom = that.suggestionNodes[that.selectedIndex][0].position().top + that.suggestionNodes[that.selectedIndex][0].outerHeight() ;

                            if (bottom - containerHeight > 0){
                                that.responseContainer.scrollTop(that.responseContainer.scrollTop() + bottom - containerHeight + 2);
                            }
                        } else {
                            that.responseContainer.scrollTop(0);
                        }
                        e.preventDefault();
                    } else if (e.keyCode === 38) {
                        setActive(that.selectedIndex-1);
                        if (that.selectedIndex >= 0) {
                            // if tab key is pressed check that there is a node selected, then hide dropdown and complete field
                            var top = that.suggestionNodes[that.selectedIndex][0].position().top;
                            if (top < 0){
                                that.responseContainer.scrollTop(that.responseContainer.scrollTop() + top - 2);
                            }
                        }
                        e.preventDefault();
                    } else if (e.keyCode === 9) {
                        if (evaluateIfActive()) {
                            that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                            e.preventDefault();
                        } else {
                            that.dropdownController.hideDropdown();
                        }
                    }
                }
            };

            if (suggestionNodes.length) {

                this.selectedIndex = 0;
                this.suggestionNodes = suggestionNodes;

                for (var i=0; i < that.suggestionNodes.length; i++) {
                    var eventData = { instance: this, index: i };
                    this.suggestionNodes[i][0]
                        .bind("mouseover", eventData, activate)
                        .bind("mouseout", eventData, deactivate)
                        .bind("click", eventData, complete);
                }

                // make sure we don't bind more than once
                if (!this.keyboardHandlerBinded) {
                    jQuery(this.field).keypress(keyPressHandler);
                    if (jQuery.browser.mozilla) {
                        jQuery(this.field).keypress(keyboardNavigateHandler);
                    } else {
                        jQuery(this.field).keydown(keyboardNavigateHandler);
                    }
                    this.keyboardHandlerBinded = true;
                }

                // automatically select the first in the list
                if(that.autoSelectFirst === false) {
                    setActive(-1);
                } else {
                    setActive(0);
                }

                // sets the autocomplete singleton infocus var to this instance
                // is used to toggle event propagation. In short, the instance that it is set to will not hide the
                // dropdown each time you click the input field
                inFocus = this;
            }

            function activate(event) {
                if (that.dropdownController.displayed) {
                    setActive(event.data.index);
                }
            }
            function deactivate(event) {
                if (event.data.index === 0) {
                    that.selectedIndex = -1;
                }
                jQuery(this).removeClass("active");
            }
            function complete(event) {
                that.completeField(that.suggestionNodes[event.data.index][1]);
            }
        },


        /**
         * Uses jquery empty command, this is VERY important as it unassigns handlers
         * used for mouseover, click events which expose an opportunity for memory leaks
         * @method {public} clearResponseContainer
         */
        clearResponseContainer: function() {
            this.responseContainer.empty();
            this.suggestionNodes = undefined;
        },

        /**
         * function {Privileged} delay
         * @param response
         */
        delay: delay,

        /**
         * Builds HTML container for suggestions.
         * Positions container top position to be that of the field height
         * @method {public} buildResponseContainer
         */
        buildResponseContainer: function() {
            var inputParent = this.field.parent().addClass('atlassian-autocomplete');
            this.responseContainer = jQuery(document.createElement("div"));
            this.responseContainer
                .addClass("suggestions")
                .css({top: this.field.outerHeight() + "px"})
                .appendTo(inputParent);
        },

        /**
         * Validates the keypress by making sure the field value is beyond the set threshold and the key was either an
         * up or down arrow
         * @method {public} keyUpHandler
         * @param {Object} e - event object
         */
        keyUpHandler: (function () {
            var isIe8 = jQuery.browser.msie && jQuery.browser.version == 8;
            function callback() {
                if (!this.responseContainer) {
                    this.buildResponseContainer();
                }
                // send value to dispatcher to check if we have already got the response or if we need to go
                // back to the server
                this.dispatcher(this.field.val());
            }

            return function (e) {
                // only initialises once the field length is past set length
                if (this.field.val().length >= this.minQueryLength) {
                    // don't do anything if the key pressed is "enter" or "down" or "up" or "right" "left"
                    if (!(e.keyCode in INVALID_KEYS) || (this.responseContainer && !this.responseContainer.is(":visible") && (e.keyCode == 38 || e.keyCode == 40))) {
                        if (isIe8) {
                            // Performance workaround for IE8 (but not IE7): excessive DOM manipulation (JRADEV-3142)
                            delay(jQuery.proxy(callback, this), 0.200);
                        } else {
                            callback.call(this);
                        }
                    }
                }
                return e;
            };
        })(),

        /**
         * Adds in methods via AOP to handle multiple selections
         * @method {Public} addMultiSelectAdvice
         */
        addMultiSelectAdvice: function(delim) {

            // reference to this for closures
            var that = this;

            /**
             * Alerts user if value already exists
             * @method {private} alertUserValueAlreadyExists
             * @param {String} val - value that already exists, will be displayed in message to user.
             */
            var alertUserValueAlreadyExists = function(val) {

                // check if there is an existing alert before adding another
                if (!alertUserValueAlreadyExists.isAlerting) {

                    alertUserValueAlreadyExists.isAlerting = true;

                    // create alert node and append it to the input field's parent, fade it in then out with a short
                    // delay in between.
                    //TODO: JRA-1800 - Needs i18n!  
                    var userAlert = jQuery(document.createElement("div"))
                    .css({"float": "left", display: "none"})
                    .addClass("warningBox")
                    .html("Oops! You have already entered the value <em>" + val + "</em>" )
                    .appendTo(that.field.parent())
                    .show("fast", function(){
                        // display message for 4 seconds before fading out
                        that.delay(function(){
                            userAlert.hide("fast",function(){
                                // removes element from dom
                                userAlert.remove();
                                alertUserValueAlreadyExists.isAlerting = false;
                            });
                        }, 4);
                    });
                }
            };

          // rather than request the entire field return the last comma seperated value
            jQuery.aop.before({target: this, method: "dispatcher"}, function(innvocation){
                // matches everything after last comma
                var val = this.field.val();
                innvocation[0] = jQuery.trim(val.slice(val.lastIndexOf(delim) + 1));
                return innvocation;
            });

            // rather than replacing this field just append the new value
            jQuery.aop.before({target: this, method: "completeField"}, function(args){
                var valueToAdd = args[0],
                // create array of values
                untrimmedVals = this.field.val().split(delim);
                // trim the values in the array so we avoid extra spaces being appended to the usernames - see JRA-20657
                var trimmedVals = jQuery(untrimmedVals).map(function() {
                        return jQuery.trim(this);
                   }).get();
                // check if the value to append already exists. If it does then call alert to to tell user and sets
                // the last value to "". The value to add will either appear:
                // 1) at the start of the string
                // 2) after some whitespace; or
                // 3) directly after the delimiter
                // It is assumed that the value is delimited by the delimiter character surrounded by any number of spaces.
                if (!this.allowDuplicates && new RegExp("(?:^|[\\s" + delim + "])" + valueToAdd + "\\s*" + delim).test(this.field.val())) {
                    alertUserValueAlreadyExists(valueToAdd);
                    trimmedVals[trimmedVals.length-1] = "";
                } else {
                    // add the new value to the end of the array and then an empty value so we
                    // can get an extra delimiter at the end of the joined string
                    trimmedVals[trimmedVals.length-1] = valueToAdd;
                    trimmedVals[trimmedVals.length] = "";
                }

                // join the array of values with the delimiter plus an extra space to make the list of values readable
                args[0] = trimmedVals.join(delim.replace(/([^\s]$)/,"$1 "));

                return args;
            });
        },


        /**
         * Adds and manages state of dropdown control
         * @method {Public} addDropdownAdvice
         */
        addDropdownAdvice: function() {
            var that = this;

            // add dropdown functionality to response container
            jQuery.aop.after({target: this, method: "buildResponseContainer"}, function(args){
                this.dropdownController = JIRA.Dropdown.AutoComplete({target: this, method: "renderSuggestions"}, this.responseContainer);

                if (AJS.$.browser.msie) { // We need to remove this class for IE as it has position relative which causes content further down the dom to show through the suggestions
                    jQuery.aop.before({ target: this.dropdownController, method: "displayDropdown" }, function () {
                        that.field.parent().addClass("atlassian-autocomplete");
                    });

                    jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                        that.field.parent().removeClass("atlassian-autocomplete");
                    });
                }

                jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                    this.dropdown.removeClass("dropdown-ready");
                });

                return args;
            });

            // display dropdown afer suggestions are updated
            jQuery.aop.after({target: this, method: "renderSuggestions"}, function(args){
                if (args && args.length > 0) {
                    this.dropdownController.displayDropdown();
                    
                    if (this.maxHeight && this.dropdownController.dropdown.attr("scrollHeight") > this.maxHeight) {
                        this.dropdownController.dropdown.css({
                            height: this.maxHeight,
                            overflowX: "visible",
                            overflowY: "scroll"
                        })
                    } else if (this.maxHeight) {
                        this.dropdownController.dropdown.css({
                            height: "",
                            overflowX: "",
                            overflowY: ""
                        });
                    }
                    this.dropdownController.dropdown.addClass("dropdown-ready");
                } else {
                    this.dropdownController.hideDropdown();
                }
                return args;
            });

            // hide dropdown after suggestion value is applied to field
            jQuery.aop.after({target: this, method: "completeField"}, function(args){
                this.dropdownController.hideDropdown();
                return args;
            });

            jQuery.aop.after({target: this, method: "keyUpHandler"}, function(e) {
                // only initialises once the field length is past set length
                if ((!(this.field.val().length >= this.minQueryLength) || e.keyCode === 27)
                        && this.dropdownController && this.dropdownController.displayed) {
                    this.dropdownController.hideDropdown();
                    if (e.keyCode === 27) {
                        e.stopPropagation();
                    }
                }
                return e;
            });
        },

        /**
         * Initialises autocomplete by setting options, and assigning event handler to input field.
         * @method {public} init
         * @param {Object} options
         */
        init: function(options) {
            var that = this;
            this.set(options);
            this.field = this.field || jQuery("#" + this.fieldID);
             // turn off browser default autocomplete
            this.field.attr("autocomplete","off")
            .keyup(function(e){
                if (!that.disabled) {
                    that.keyUpHandler(e);
                }
            })
            .keydown(function (e) {
                var ESC_KEY = 27;
                // do not clear field in IE
                if (e.keyCode === ESC_KEY && that.responseContainer && that.responseContainer.is(":visible")) {
                    e.preventDefault();
                }
            })
            // this will stop the dropdown with the suggestions hiding whenever you click the field
            .click(function(e){
                if (inFocus === that) {
                    e.stopPropagation();
                }
            })
            .blur(function () {
                // we don't want the request to come back and show suggestions if we have already moved away from field
                if (that.pendingRequest) {
                    that.pendingRequest.abort();
                }
            });

            this.addDropdownAdvice();

            if (options.delimChar) {
                this.addMultiSelectAdvice(options.delimChar);
            }
        }
    };

}();


}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:jira-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/jira/JQLAutoComplete.js' */

;(function (){
var jql_operators = [{value:"=", displayName:"="}, {value:"!=", displayName:"!="}, {value:"~", displayName:"~"}, {value:"<=", displayName:"&lt;="}, {value:">=", displayName:"&gt;="}, {value:">", displayName:"&gt;"}, {value:"<", displayName:"&lt;"}, {value:"!~", displayName:"!~"}, {value:"is not", displayName:"is not"}, {value:"is", displayName:"is"}, {value:"not in", displayName:"not in"}, {value:"in", displayName:"in"}, {value: "was", displayName: "was"}, {value: "was not", displayName: "was not"},  {value: "was in", displayName: "was in"}, {value: "was not in", displayName: "was not in"}, {value: "changed", displayName: "changed"}];
var jql_logical_operators = [{value:"AND", displayName:"AND"}, {value:"OR", displayName:"OR"}];
var jql_logical_operators_and_order_by = [{value:"AND", displayName:"AND"}, {value:"OR", displayName:"OR"}, {value:"ORDER BY", displayName:"ORDER BY"}];
var jql_order_by_direction = [{value:"ASC", displayName:"ASC"}, {value:"DESC", displayName:"DESC"}];
var empty_operand = [{value:"EMPTY", displayName:"EMPTY", types:["java.lang.Object"]}];
var jql_not_logical_operator = [{value:"NOT", displayName:"NOT"}];
var jql_was_predicates= [{value:"AFTER", displayName:"AFTER", type:"java.util.Date", supportsList:"false"}, {value:"BEFORE", displayName:"BEFORE", type:"java.util.Date", supportsList:"false"}, {value:"BY", displayName:"BY", type:"com.opensymphony.user.User", supportsList:"false", auto:"true"}, {value:"DURING", displayName:"DURING", type:"java.util.Date", supportsList:"true"} ,{value:"ON", displayName:"ON", type:"java.util.Date", supportsList:"false"} ];
var jql_changed_predicates =   jql_was_predicates.concat([{value:"FROM", displayName:"FROM", type:"java.lang.String", supportsList: "true", auto: "true"}, {value:"TO", displayName:"TO", type:"java.lang.String", supportsList: "true", auto: "true"}]);
var jql_was_predicates_and_order_by= jql_was_predicates.concat(jql_logical_operators_and_order_by);
var jql_was_predicates_and_logical_operators= jql_was_predicates.concat(jql_logical_operators);
var jql_changed_predicates_and_order_by= jql_changed_predicates.concat(jql_logical_operators_and_order_by);
var jql_changed_predicates_and_logical_operators= jql_changed_predicates.concat(jql_logical_operators);

var REGEXP_ANDS            = /^AND\s/i;
var REGEXP_ORS             = /^OR\s/i;
var REGEXP_NOTS            = /^NOT\s/i;
var REGEXP_SNOT            = /^\s+not/i;
var REGEXP_SIN             = /^\s+in/i;
var REGEXP_SNOT_IN         = /^\s+(not\s+in|not|in)/i;
var REGEXP_COMMA_DELIMITER = /^\s*,/;
var REGEXP_ASCENDING       = /^\s+asc/i;
var REGEXP_DESCENDING      = /^\s+desc/i;
var REGEXP_ORDER_BY        = /^order\s+by/i;
var REGEXP_WHITESPACE      = /^\s/;
var REGEXP_UNICODE         = /^u[a-fA-F0-9]{4}/;
var REGEXP_FIELD_NAME      = /^\s-\scf\[\d\d\d\d\d\]/;
var REGEXP_NEW_LINE        = /[\r\n]/;
var REGEXP_NUMBER          = /\d/;
var REGEXP_TOKEN_CHAR      = /[^=!~<>(),\s&|]/;
var REGEXP_SPECIAL_CHAR    = /[{}*\/%+$#@?.;\][]/;
var REGEXP_SPACE_OR_ELSE   = /[\s(]/;
var REGEXP_CHARS_TO_ESCAPE = /[^trn"'\\\s]/;
var REGEXP_NOTSTART        = /^NO?$/i;
var REGEXP_INSTART         = /^IN?$/i;
var REGEXP_PREDICATE       = /^(after|before|by|during|from|on|to)/i;

JIRA.JQLAutoComplete = function (options) {

    var that = JIRA.begetObject(JIRA.AutoComplete);
    var parser = options.parser;
    var result;
    var jql_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue){
            // We only want the searchable fields
            return arrValue.searchable;
    });
    var jql_order_by_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue){
            // We only want the orderable fields
            return arrValue.orderable;
    }); 
    var jql_function_names = options.jqlFunctionNames;
    var PARSE_INDICATOR = jQuery("#" + options.errorID);
    var suggestionCount = 0;
    var jqlcolumnnum = jQuery("#jqlcolumnnum");
    var jqlrownum = jQuery("#jqlrownum");
    var jiraApplicationId = options.jiraApplicationId;
    var baseUrl = options.baseUrl;

    that.textToSuggestionCursorPosition = function () {
        return this.field.selectionRange().textBefore;
    };


    that.pushSuggestionsOnHtmlStack = function(suggestions, suggestionNodes, htmlParts, listItemIdentifier, mayNeedParenthesis)
    {
        var length = Math.min(15, suggestions.length);
        for (var i = 0; i < length; i++)
        {
            var actualValueSug;
            var displayNameSug;
            // We may have an object with displayName and value OR it may just be a string
            if (suggestions[i].value)
            {
                var resultSug = suggestions[i];
                if (result && mayNeedParenthesis)
                {
                    // This is a hack that adds an initial ( when the value is the first completed in a list
                    // We only do this for suggestions and not moreSuggestions since we know that this is
                    // the position that the values will take, moreSuggestions will be function suggestions
                    actualValueSug = ((result.getNeedsOpenParen()) ? "(" : "") + resultSug.value;
                }
                else
                {
                    actualValueSug = resultSug.value;
                }
                displayNameSug = resultSug.displayName;
            }
            else
            {
                displayNameSug = suggestions[i];
                actualValueSug = displayName;
            }
            suggestionNodes.push(actualValueSug);
            htmlParts.push(
                    '<li id="',
                    listItemIdentifier,
                    i,
                    '">',
                    displayNameSug,
                    '</li>'
                    );
        }
    };

    that.renderSuggestions = function ( suggestions, moreSuggestions, operatorSuggestions) {
        var suggestionNodes = [];

        if (suggestions instanceof Array)
        {
            if (suggestions.length < 1 && (moreSuggestions && moreSuggestions.length < 1) && (operatorSuggestions && operatorSuggestions.length < 1))
            {
                return suggestionNodes;
            }

            var htmlParts = ['<ul>'];
            if (operatorSuggestions && operatorSuggestions.length > 0)
            {
                 that.pushSuggestionsOnHtmlStack(operatorSuggestions, suggestionNodes, htmlParts, "jql_operator_suggest_", false);
            }
            that.pushSuggestionsOnHtmlStack(suggestions, suggestionNodes, htmlParts, "jql_value_suggest_", true);
            if (moreSuggestions && moreSuggestions.length > 0)
            {
                 that.pushSuggestionsOnHtmlStack(moreSuggestions,  suggestionNodes, htmlParts, "jql_function_suggest_", false);
            }
            htmlParts.push('</ul>');

            that.responseContainer
                .html(htmlParts.join(''))
                .find('li').each(function(i) {
                    suggestionNodes[i] = [jQuery(this), suggestionNodes[i]];
                });

            that.addSuggestionControls(suggestionNodes);
        }

        return suggestionNodes;
    };

    that.completeField = function(value)
    {
        var start = that.getReplacementStartIndex(result, value);

        var end = that.getReplacementEndIndex(result, start);

        that.replaceValue(start, end, value);

        // Parse the whole thing again with the full string so we can set the parse/not parse indicator correctly, possibly a third parse, this is starting to get crazy
        var newToken = parser.parse(this.field.val());
        that.updateParseIndicator(newToken);
    };

    that.prepareOperandSuggestions = function(canAutoComplete, fieldName, functionSuggestions, operatorSuggestions, suggestedValue)
    {
        if (canAutoComplete)
        {
            var currentSuggestionCount = suggestionCount;
            var fieldValue = (suggestedValue == null) ?  ( (result.getLastOperand() === null) ? "" : that.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
            var fieldNameValueKey = fieldName + ":" + fieldValue;
            var data = {fieldName:that.stripEscapeCharacters(fieldName)};
            if (result.getLastOperand() !== null || suggestedValue !== null)
            {
                data.fieldValue = fieldValue;
            }
            if (!that.getSavedResponse(fieldNameValueKey))
            {
                // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                that.dropdownController.dropdown.removeClass("dropdown-ready");
                this.delay(function()
                {
                    that._makeRequest({
                        url: baseUrl + "/rest/calendar-services/1.0/calendar/jira/" + encodeURIComponent(jiraApplicationId) + "/jql/autocomplete.json",
                        dataType: "json",
                        data: data,
                        success: function (response)
                        {
                            var results;
                            if (response !== null && response.results !== null)
                            {
                                results = response.results;
                            }
                            else
                            {
                                results = [];
                            }
                            // Cache the results
                            that.saveResponse(fieldNameValueKey, results);
                            that.renderSuggestionsForOperands(fieldValue, results, functionSuggestions, operatorSuggestions, currentSuggestionCount);
                        },
                        error: function ()
                        {
                            that.renderSuggestionsForOperands(fieldValue, [], functionSuggestions, operatorSuggestions, currentSuggestionCount);
                        }
                    });
                }, that.queryDelay);
            }
            else
            {
                that.renderSuggestionsForOperands(fieldValue, that.getSavedResponse(fieldNameValueKey), functionSuggestions, operatorSuggestions, currentSuggestionCount);
            }
        }
        else
        {
            // We should at least render the function suggestions
            that.renderSuggestionsForOperands(that.stripEscapeCharacters(result.getLastOperand()), [], functionSuggestions, operatorSuggestions, suggestionCount);
        }
    };

    that.preparePredicateSuggestions = function(predicateName, suggestedValue)
    {
        var currentSuggestionCount = suggestionCount;
        if (typeof suggestedValue == "undefined")
        {
            suggestedValue = null;
        }
        var functionSuggestions = that.slimListForPredicates(suggestedValue, jql_function_names, predicateName);
        that.boldMatchingString(suggestedValue, functionSuggestions);
        var predicateValue = (suggestedValue == null) ?  ( (result.getLastOperand() === null) ? "" : that.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
        var predicateNameValueKey = predicateName + ":" + predicateValue;
        var data = {predicateName:that.stripEscapeCharacters(predicateName)};
        if (result.getLastOperand() !== null || suggestedValue !== null)
        {
            data.predicateValue = predicateValue;
        }
        if (result.getLastFieldName() !== null)
        {
            data.fieldName = result.getLastFieldName();
            predicateNameValueKey = result.getLastFieldName()+":"+predicateNameValueKey;
        }
        if (that.predicateSupportsAutoComplete(predicateName))
        {
            if (!that.getSavedResponse(predicateNameValueKey))
            {
                // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                that.dropdownController.dropdown.removeClass("dropdown-ready");
                this.delay(function()
                {
                    that._makeRequest({
                        url: baseUrl + "/rest/calendar-services/1.0/calendar/jira/" + encodeURIComponent(jiraApplicationId) + "/jql/autocomplete.json",
                        dataType: "json",
                        data: data,
                        success: function (response)
                        {
                            var results;
                            if (response !== null && response.results !== null)
                            {
                                results = response.results;
                            }
                            else
                            {
                                results = [];
                            }
                            // Cache the results
                            that.saveResponse(predicateNameValueKey, results);
                            that.renderSuggestions(results, functionSuggestions);
                        },
                        error: function ()
                        {
                            that.renderSuggestionsForOperands(predicateValue, []);
                        }
                    });
                }, that.queryDelay);
            }
            else
            {
                that.renderSuggestions(that.getSavedResponse(predicateNameValueKey), functionSuggestions);
            }
        }
        else
        {
            // simply render functions
            that.renderSuggestions( [], functionSuggestions);
        }
    };

    that.incompleteOperator = function()
    {
        var tokens = result.getTokens();
        if (tokens == null || tokens.length  < 2)
        {
            return "";
        }
        else
        {
            var tokens = that.textToSuggestionCursorPosition().split(" ");
            if (tokens.length > 2)
            {
                return tokens[tokens.length-1];
            }
        }
        return "";
    };

    that.incompletePredicateValue = function()
    {
        var tokens = result.getTokens();
        if (tokens == null || tokens.length  < 3)
        {
            return "";
        }
        else
        {

            var tokens = that.textToSuggestionCursorPosition().split(/[\s(,]+/);
            if (tokens.length > 3)
            {
                return tokens[tokens.length - 1];
            }
        }
        return "";
    };

    that.dispatcher = function (val) {

        var that = this;
        var selectionRange = jQuery(that.field).selectionRange();
        var parseValue = val.substring(0, selectionRange.start);
        result = parser.parse(parseValue).getResult();
        // We will always make a suggestion from here so lets increment the count
        suggestionCount++;
        // In this case we suggest operators
        if (result.getNeedsField())
        {
            that.renderSuggestionsFromMap(that.stripEscapeCharacters(result.getLastFieldName()), jql_field_names, jql_not_logical_operator, true);
        }
        // for was queries you msay need either an operator or operand
        else if (result.getNeedsOperatorOrOperand())
        {
            var operator = result.getLastOperator();
            var operatorLength = operator.length;
            var parsedOperator = (operator.length > 0) ? parseValue.substr(result.getLastOperatorStartIndex()) : null;
            var functionSuggestions = (that.isEmptyOnlyOperator(result.getLastOperator())) ? empty_operand : jql_function_names;
            var operatorSuggestions = that.getSuggestionsForOperators(parsedOperator, jql_operators);
            if (operatorLength > 0)
            {
                var numSpaces = operator.length - (operator.replace(/\s+/g,'')).length;
                result.setLastOperandStartIndex(result.getLastOperatorStartIndex()+ operatorLength + numSpaces+1);
            }
            if (operatorSuggestions && operatorSuggestions.length > 0)
            {
                var tokens = result.getTokens();
                var operandSuggestion = that.incompleteOperator();
                that.prepareOperandSuggestions(true, result.getLastFieldName(), functionSuggestions, operatorSuggestions, operandSuggestion);
            }
        }
        else if (result.getNeedsOperator())
        {
            that.renderSuggestionsForOperators(result.getLastOperator(), jql_operators);
        }
        else if (result.getNeedsPredicateOperand())
        {
            var predicate = result.getLastWasPredicate();
            that.preparePredicateSuggestions(predicate, that.stripEscapeCharacters(result.getLastOperand()));
        }
        else if (result.getNeedsLogicalOperator())
        {
            if (result.getNeedsWasPredicate())
            {
                if (result.getNeedsOrderBy())
                {
                    var value = (result.getLastOrderBy() === null) ? result.getLastWasPredicate() : result.getLastOrderBy();
                    if (result.getLastOperator() == 'was')
                    {
                        that.renderSuggestionsFromMap(value, jql_was_predicates_and_order_by, false);
                    }
                    else
                    {
                        that.renderSuggestionsFromMap(value, jql_changed_predicates_and_order_by, false);
                    }
                }
                else
                {
                    if (result.getLastOperator() == 'was')
                    {
                        that.renderSuggestionsFromMap(result.getLastWasPredicate(), jql_was_predicates_and_logical_operators, false);
                    }
                    else
                    {
                        that.renderSuggestionsFromMap(result.getLastWasPredicate(), jql_changed_predicates_and_logical_operators, false);
                    }
                }

            }
            else
            {
                if (result.getNeedsOrderBy())
                {
                    var value = (result.getLastOrderBy() === null) ? result.getLastLogicalOperator() : result.getLastOrderBy();
                    that.renderSuggestionsFromMap(value, jql_logical_operators_and_order_by, false);
                }
                else
                {
                    that.renderSuggestionsFromMap(result.getLastLogicalOperator(), jql_logical_operators, false);
                }
            }
        }
        else if (result.getNeedsOrderByField())
        {
            that.renderSuggestionsFromMap(that.stripEscapeCharacters(result.getLastOrderByFieldName()), jql_order_by_field_names, true);
        }
        else if (result.getNeedsOrderByDirection())
        {
            that.renderSuggestionsFromMap(result.getLastOrderByDirection(), jql_order_by_direction, false);
        }
        else if (result.getNeedsOperand())
        {
            var fieldName = result.getLastFieldName();

            var canAutoComplete = false;
            // If we know that we are only suggesting empty then we do not need to suggest values
            if (!that.isEmptyOnlyOperator(result.getLastOperator()))
            {
                for (var i = 0; i < jql_field_names.length; i++)
                {
                    if (that.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                        (jql_field_names[i].cfid && that.equalsIgnoreCase(jql_field_names[i].cfid, fieldName)))
                    {
                        canAutoComplete = jql_field_names[i].auto;
                        break;
                    }
                }
            }

            var functionSuggestions = (that.isEmptyOnlyOperator(result.getLastOperator())) ? empty_operand : jql_function_names;
            that.prepareOperandSuggestions(canAutoComplete, fieldName, functionSuggestions,{});
        }
        else
        {
            that.dropdownController.hideDropdown();
        }

        // Need to update the parse/not parse indicator
        that.parse(val);
    };

    that.stripEscapeCharacters = function(val) {

        if (val == null)
        {
            return val;
        }
        var newVal = "";
        var strArr = val.split("");
        for(var i = 0; i < strArr.length; i++)
        {
            if (strArr[i] == '\\')
            {
                // If we are a unicode string then we just consume it like normal
                if (!REGEXP_UNICODE.test(val.substring(i, val.length)))
                {
                    // Just chew past the escape and use the next char, the parser has already made sure this is cool
                    i++;
                    if (i >= val.length)
                    {
                        break;
                    }
                }
            }
            newVal += strArr[i];
        }
        return newVal;
    };

    that.parse = function(val) {
        var newToken = parser.parse(val);
        that.updateParseIndicator(newToken);
        that.updateColumnLineCount();
        return newToken.getResult();
    };

    that.renderSuggestionsFromMap = function(stringVal, list, otherSuggestions, showFull)
    {
        if (!otherSuggestions)
        {
            otherSuggestions = {};
        }
        var suggestions = that.slimListForMapResults(stringVal, list, showFull);
        var relevantOtherSuggestions = that.slimListForMapResults(stringVal, otherSuggestions, showFull);
        that.boldMatchingString(stringVal, relevantOtherSuggestions);
        that.boldMatchingString(stringVal, suggestions);

        that.renderSuggestions(suggestions, relevantOtherSuggestions);
        if (suggestions.length === 0 && relevantOtherSuggestions.length === 0)
        {
            that.dropdownController.hideDropdown();
        }
    };

    that.getSuggestionsForOperators = function(stringVal, list)
    {
        var suggestions = that.slimListForMapResults(stringVal, list, false);

        var fieldName = result.getLastFieldName();
        // Find the current field, if we know about it and get the supported operators
        var supportedOperators;
        for (var i = 0; i < jql_field_names.length; i++)
        {
            if (that.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                (jql_field_names[i].cfid && that.equalsIgnoreCase(jql_field_names[i].cfid, fieldName)))
            {
                supportedOperators = jql_field_names[i].operators;
                break;
            }
        }

        // Now lets run through the remaining list and if we can identify the field we can see if that field
        // supports which operators
        if (supportedOperators)
        {
            suggestions = jQuery.grep(suggestions, function(arrValue){
                return jQuery.inArray(arrValue.value, supportedOperators) > -1;
            });
        }
        that.boldMatchingString(stringVal, suggestions);
        return suggestions;
    };

    that.renderSuggestionsForOperators = function(stringVal, list)
    {
        var suggestions = that.getSuggestionsForOperators(stringVal, list);
        that.renderSuggestions(suggestions);
        if (suggestions.length === 0)
        {
            that.dropdownController.hideDropdown();
        }
    };

    that.renderSuggestionsForOperands = function(stringVal, ajaxSuggestions, functions, operatorSuggestions, providedSuggestionCount)
    {
        // Only render the suggestions if we are the current suggestion
        if (providedSuggestionCount === suggestionCount)
        {
            // Don't need to slim the ajaxSuggestions since they came from the server slimmed down
            var functionsSuggestions = that.slimListForFunctionResults(stringVal, functions, result.getLastOperator());
            that.boldMatchingString(stringVal, functionsSuggestions);
            that.renderSuggestions( ajaxSuggestions, functionsSuggestions, operatorSuggestions);

            if (ajaxSuggestions.length === 0 && functionsSuggestions.length === 0 && operatorSuggestions.length == 0)
            {
                that.dropdownController.hideDropdown();
            }
        }
    };

    // This bolds the beginning portion of the matching string and converts the list to be value/displayName. This
    // assumes that all strings in the list have already been confirmed to match the incomming stringVal
    that.boldMatchingString = function(stringVal, list)
    {
        if (stringVal == null || list.length === 0)
        {
            return;
        }

        var boldLength = stringVal.length;
        // Run through all the characters looking for html escape characters so we can include their extra length in
        // the bold length
        for(var j = 0, n = boldLength; j < n; j++)
        {
            switch (stringVal.charAt(j))
            {
                case "<":
                case ">":
                    // We have one character representing this already, lets add the other 3 for &lt; or &gt;
                    boldLength += 3;
                    break;
                case "&":
                    // We have one character representing this already, lets add the other 4 for &amp;
                    boldLength += 4;
                    break;
                case '"':
                    // We have one character representing this already, lets add the other 5 for &quot;
                    boldLength += 5;
                    break;
            }
        }

        for(var i = 0; i < list.length; i++)
        {
            if (list[i].displayName)
            {
                var origVal = list[i].displayName;
                // Create a new copy of the object so we don't mess up the original list
                list[i] = {value:list[i].value, displayName:"<b>" + origVal.substring(0, boldLength) + "</b>" + origVal.substring(boldLength)};
            }
            else
            {
                // Add a displayName so we don't mess up the value
                list[i] = {value:list[i], displayName:"<b>" + list[i].substring(0, boldLength) + "</b>" + list[i].substring(boldLength)};
            }
        }
    };

    that.htmlEscape = function(stringVal)
    {
        if (stringVal == null)
        {
            return null;
        }
        var escapedVal = "";
        var strArr = stringVal.split("");
        // Run through all the characters looking for html escape characters so we can include their extra length in
        // the bold length
        for(var j = 0; j < strArr.length; j++)
        {
            if (strArr[j] === "<")
            {
                escapedVal += "&lt;";
            }
            else if(strArr[j] === ">")
            {
                escapedVal += "&gt;";
            }
            else if (strArr[j] === "&")
            {
                // We have one character representing this already, lets add the other 4 for &amp;
                escapedVal += "&amp;";
            }
            else if (strArr[j] === "\"")
            {
                // We have one character representing this already, lets add the other 5 for &quot;
                escapedVal += "&quot;";
            }
            else
            {
                escapedVal += strArr[j];
            }
        }
        return escapedVal;
    },

    that.getReplacementStartIndex = function(result, value)
    {
        var jQueryReference = jQuery(this.field);
        var start;
        if (result.getNeedsField())
        {
            start = result.getLastFieldNameStartIndex();
        }
        else if(result.getNeedsOperatorOrOperand())
        {
            // was presents difficulties - it may be followed by either an operand or an operator
            if(result.getNeedsOperator() && that.isWasOperator(value) )
            {
                start = result.getLastOperatorStartIndex();
            }
            else
            {
                start = result.getLastOperandStartIndex();
            }
        }
        else if(result.getNeedsOperand())
        {
            start = result.getLastOperandStartIndex();
        }
        else if(result.getNeedsOperator())
        {
            start = result.getLastOperatorStartIndex();
        }
        else if(result.getNeedsOrderByField())
        {
            start = result.getLastOrderByFieldNameStartIndex();
        }
        else if(result.getNeedsOrderByDirection())
        {
            start = result.getLastOrderByDirectionStartIndex();
        }
        else if (result.getNeedsPredicateOperand())
        {
            start = result.getLastOperandStartIndex();
        }
        else if(result.getNeedsLogicalOperator())
        {
            if (result.getLastLogicalOperatorStartIndex() !== null && result.getLastLogicalOperatorStartIndex() !== 0)
            {
                start = result.getLastLogicalOperatorStartIndex();
            }
            else
            {
                if (result.getLastOrderBy() !== null && result.getLastOrderByStartIndex() !== 0)
                {
                    start = result.getLastOrderByStartIndex();
                }
                else if (result.getLastWasPredicate() != null && result.getLastWasPredicateStartIndex() !== 0)
                {
                    start = result.getLastWasPredicateStartIndex();
                }
                else if (result.getMustBeOperatorOrPredicate() === true)
                {
                    start  =  jQueryReference.selectionRange().start;
                }
                else
                {
                    start = jQueryReference.selectionRange().start - 1;
                }
            }
        }
        else if (result.getNeedsWasPredicate())
        {
            start = result.getLastWasPredicateStartIndex();
        }
        else
        {
            start = jQueryReference.selectionRange().start - 1;
        }
        // sanity check
        return start != null ? start : jQueryReference.selectionRange().start;
    };

    that.getReplacementEndIndex = function(result, start)
    {
        var jQueryReference = jQuery(this.field);
        var selectionRange = jQueryReference.selectionRange();
        var end = null;
        // We only need to do a second parse if we have no highlighted selection AND we are not at the end of the input string
        // otherwise we just use the selectionEnd
        if (selectionRange.start === selectionRange.end && selectionRange.end !== this.field.val().length)
        {
            // Lets get the token number from the first parse, this is the token we are currently on
            var currentTokenIdx = result.getTokens().length - 1;

            // Parse it again, but this time the full string so we know what the full token is that we are trying to replace
            // with the selected completion
            var token = parser.parse(this.field.val());
            if (!token.getParseError())
            {
                // The user has not highlighted text so lets assume we are completing to the end of the current token
                // Ask the newly parsed result for the complete token we are in the middle of
                var fullTokenValue = token.getResult().getTokens()[currentTokenIdx];
                // This is a special case, we don't want to replace the '(' or ')' instead we want to add inside
                if (fullTokenValue !== null && fullTokenValue !== '(' && fullTokenValue !== ')' )
                {
                    var fullTextVal = this.field.val();
                    // Lets get the start position in the string
                    var remainingString = fullTextVal.substring(start, fullTextVal.length);
                    // We know that we are going to see the fullTokenValue next, but there may be some whitespace between
                    // here and there, lets make sure we ditch the whitespace as well.
                    var remainingStringArr = remainingString.split("");
                    var whitespaceCount = 0;
                    for(var i = 0; i < remainingStringArr.length; i++)
                    {
                        if (REGEXP_WHITESPACE.test(remainingStringArr[i]))
                        {
                            whitespaceCount++;
                        }
                        else
                        {
                            // Stop as soon as we no longer see whitespace
                            break;
                        }
                    }
                    end = start + fullTokenValue.length + whitespaceCount;
                }
            }
        }
        
        if (end === null)
        {
            end = selectionRange.end;
        }
        // As the start position could have been incremented to account for spaces in operators
        // e.g. was not in, it is feasible that end may be less than start so a quick check is in order.
        // If start is less than end pad with a space (one is sufficient)
        if (end < start)
        {
            that.replaceValue(start,end," ");
            end=start;
        }
        return end;
    };

   that.replaceValue = function(start, end, newValue)
    {
        var jQueryReference = jQuery(this.field);
        // Lets reset the selection range to include the characters that the user has already typed
        jQueryReference.selectionRange(start, end);
        // Lets replace the value with the autocomplete selected value
        jQueryReference.selection(newValue);
        // Lets stop the replaced bit from being highlighted
        var newEnd = jQueryReference.selectionRange().end;
        jQueryReference.selectionRange(newEnd, newEnd);
    };

    that.slimListForMapResults = function (stringVal, list, showFull)
    {
        var escString = that.htmlEscape(stringVal);
        var slimedList = jQuery.grep(list, function(arrValue){
            return that.startsWithIgnoreCaseNullsMeanAll(escString, arrValue.displayName) ;
        });

        if (!showFull)
        {
            // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
            // with this prefix.
            if (slimedList.length === 1 && !that.startsWithNotEqualsIgnoreCaseNullMeansAll(escString, slimedList[0].displayName))
            {
                return {};
            }
        }
        return slimedList;
    };

    that.slimListForFunctionResults = function (stringVal, list, operator)
    {
        var fieldName = result.getLastFieldName();
        // Find the current field, if we know about it and get the supported types
        var supportedTypes;
        for (var i = 0; i < jql_field_names.length; i++)
        {
            if (that.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                (jql_field_names[i].cfid && that.equalsIgnoreCase(jql_field_names[i].cfid, fieldName)))
            {
                supportedTypes = jql_field_names[i].types;
                break;
            }
        }

        var slimedList = jQuery.grep(list, function(arrValue){
            // For functions we only want to show the is list ones with list operators and vice versa
            if ((arrValue.isList && !that.isListSupportingOperator(operator)) ||
                (!arrValue.isList && that.isListSupportingOperator(operator)))
            {
                return false;
            }
            if (supportedTypes)
            {
                // Need to check for Object since this means we always fit
                var supportsFunction = jQuery.inArray("java.lang.Object", arrValue.types) > -1 || jQuery.inArray("java.lang.Object", supportedTypes) > -1;
                for(var i = 0; i < supportedTypes.length && !supportsFunction; i++)
                {
                    supportsFunction = jQuery.inArray(supportedTypes[i], arrValue.types) !== -1;
                }
                if (!supportsFunction)
                {
                    return false;
                }
            }
            else
            {
                // Can't find the field so we know that no functions will work with it
                return false;
            }
            return that.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName) ;
        });

        // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
        // with this prefix.
        if (slimedList.length === 1 && !that.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName))
        {
            return {};
        }
        return slimedList;
    };

    that.slimListForPredicates  = function (stringVal, list, predicate)
    {
        var supportedType;
        var supportsList;
        for (var i = 0; i < jql_changed_predicates.length; i++)
        {
            if (that.equalsIgnoreCase(result.getUnquotedString(jql_changed_predicates[i].value), predicate))
            {
                supportedType = jql_changed_predicates[i].type;
                supportsList = jql_changed_predicates[i].supportsList;
                break;
            }
        }

        var slimedList = jQuery.grep(list, function(arrValue){
            // For functions we only want to show the is list ones with list operators and vice versa

            if (typeof arrValue.isList != "undefined")
            {
                if ((arrValue.isList && !!supportsList) || (!arrValue.isList && supportsList))
                {
                    return false;
                }
            }
            var supportsFunction =  jQuery.inArray(supportedType, arrValue.types) !== -1;
            return supportsFunction ? that.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName) : false;
        });

        // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
        // with this prefix.
        if (slimedList.length === 1 && !that.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName))
        {
            return {};
        }
        return slimedList;
    };

    that.predicateSupportsAutoComplete = function(predicate)
    {
        var auto;
        for (var i = 0; i < jql_changed_predicates.length; i++)
        {
            if (that.equalsIgnoreCase(result.getUnquotedString(jql_changed_predicates[i].value), predicate))
            {
                auto = jql_changed_predicates[i].auto;
                break;
            }
        }
        return auto;

    };

    that.isListSupportingOperator = function (operator)
    {
        return operator === 'in' || operator === 'not in' || operator == 'was not in' || operator == 'was in';
    };

    that.isEmptyOnlyOperator = function (operator)
    {
        return operator === 'is' || operator === 'is not';
    };

    that.isWasOperator = function (operator)
    {
        return operator === 'was' || operator === 'was in' || operator == 'was not in' || operator == 'was not';
    };

    that.isChangedOperator = function (operator)
    {
        return operator === 'changed';
    };

    that.startsWithIgnoreCaseNullsMeanAll = function(startStr, str)
    {
        // In this case we want all elements of the list included
        if (str === null || startStr === null)
        {
            return true;
        }
        if (str.length < startStr.length)
        {
            return false;
        }
        else
        {
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    that.startsWithNotEqualsIgnoreCaseNullMeansAll = function(startStr, str)
    {
        // In this case we want all elements of the list included
        if (str === null || startStr === null)
        {
            return true;
        }
        if (str.length < startStr.length)
        {
            return false;
        }
        else
        {
            var subStrEquals = startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            if (subStrEquals)
            {
                // HACK!! This is a hack so that the custom field display values will not show up as a suggestion when they
                // are completely typed in.
                var equalsString = null;
                if (REGEXP_FIELD_NAME.test(str.substr(startStr.length, str.length)))
                {
                    equalsString = str.substr(0, startStr.length);
                }
                else
                {
                    equalsString = str;
                }
                return startStr.toLowerCase() != equalsString.toLowerCase();
            }
            return false;
        }
    };

    that.equalsIgnoreCase = function (str1, str2)
    {
        if (str1 === null && str2 === null)
        {
            return true;
        }
        else if (str1 === null || str1 === null)
        {
            return false;
        }
        else
        {
            return str1.toLowerCase() === str2.toLowerCase();
        }
    };

    /**
     * Gets cached response from <em>requested</em> object
     * @method {public} getSavedResponse
     * @param {String} val
     * @returns {Object}
     */
    that.getSavedResponse = function(val) {
        if (!this.requested) {
            this.requested = {};
        }
        return this.requested[val];
    };

    /**
     * Saves response to <em>requested</em> object
     * @method {public} saveResponse
     * @param {String} val
     * @param {Object} response
     */
    that.saveResponse = function(val, response) {
        if (typeof val === "string" && typeof response === "object") {
            if (!this.requested) {
                this.requested = {};
            }
            this.requested[val] = response;
        }
    };

    that.startsWithIgnoreCase = function(startStr, str)
    {
        if (str === null || startStr === null || str.length < startStr.length)
        {
            return false;
        }
        else
        {
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    that.updateParseIndicator = function(token)
    {
        if (token.getParseError())
        {
            PARSE_INDICATOR.attr("title", token.getResult().getParseErrorMsg()).removeClass("jqlgood").addClass("jqlerror");
        }
        else
        {
            PARSE_INDICATOR.attr("title", "").removeClass("jqlerror").addClass("jqlgood");
        }
    };

    that.updateColumnLineCount = function()
    {
        var jQueryReference = jQuery(that.field);
        var totalCharCountToCursor = 0;

        if(that.field[0] === document.activeElement) {
            var selectionRange = jQueryReference.selectionRange();
            totalCharCountToCursor = selectionRange.start;
        } else {
            totalCharCountToCursor = that.field[0].value.length;
        }
        var rowCount = 1;
        var colCount = 1;

        var fieldValue = that.field.val();

        for (var i = 0; i < totalCharCountToCursor; i++)
        {
            if (REGEXP_NEW_LINE.test(fieldValue.charAt(i)))
            {
                rowCount++;
                colCount = 1;
            }
            else
            {
                colCount++;
            }
        }

        // Update our counts for where our cursor is at the moment
        jqlcolumnnum.text(colCount);
        jqlrownum.text(rowCount);
    };

    that.init(options);

    return that;
};

JIRA.JQLAutoComplete.MyParser = function(jqlReservedWords) {

    var jql_reserved_words = jqlReservedWords;
    return {
        parse: function(input) {
            var token = JIRA.JQLAutoComplete.Token();

            token.init(input);
            this.jql(token);
//            token.toString();
            return token;
        },

        orderByClause: function(token)
        {
            var remainingString = token.remainingString();
            // Lets consume the 'order' token
            var matchArray = remainingString.match(REGEXP_ORDER_BY);

            if (matchArray)
            {
                var orderByString = remainingString.substring(0, matchArray[0].length);
                token.consumeCharacters(orderByString.length);
                token.getResult().setLastOrderBy(orderByString, token);
                
                if (!token.isComplete())
                {
                    // We must have some space in order to parse an order by fields
                    remainingString = token.remainingString();
                    if (REGEXP_WHITESPACE.test(remainingString))
                    {
                        this.chewWhitespace(token);
                        // Look for order by fields
                        this.orderByFields(token);
                    }
                    else
                    {
                        token.getResult().resetLogicalOperators();
                        token.setParseError();
                    }
                }
                else
                {
                    token.getResult().resetLogicalOperators();
                    token.setParseError();
                }
            }
            else
            {
                // Consume the remaining string
                token.consumeCharacters(remainingString.length);
                token.getResult().setLastOrderBy(remainingString, token);
                token.setParseError();
            }
        },

        orderByFields: function(token)
        {
            // Look for fields followed by 'asc' or 'desc' or commas
            this.orderByField(token);
            this.chewWhitespace(token);
            if (token.isComplete())
            {
                // We always need to check to see if we need to put in a place-holder for the order by direction
                if (!token.getResult().getNeedsOrderByField())
                {
                    token.getResult().setLastOrderByDirection("", token);
                    // This is not a parse error, it is just a token place holder so we will complete correctly
                }
            }
            else
            {
                // Look for a comma
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase(",", remainingString))
                {
                    token.consumeCharacter();
                    // Lets recurse back looking for more order by fields
                    this.orderByFields(token);
                    this.chewWhitespace(token);
                }
                else
                {
                    remainingString = token.remainingString();
                    if (remainingString !== null)
                    {
                        token.consumeCharacters(remainingString.length);
                    }
                    token.getResult().setNeedsOrderByDirection();
                    token.getResult().setLastOrderByDirection(remainingString, token);
                    token.setParseError();
                }
            }
        },

        orderByField: function(token)
        {
            this.chewWhitespace(token);
            var fieldName = this.fieldName(token);
            if (fieldName.length !== 0)
            {
                token.getResult().setLastOrderByFieldName(fieldName, token);

                // If we see a comma then we don't have an order by direction
                var remainingString = token.remainingString();

                if (!token.isComplete() && !REGEXP_COMMA_DELIMITER.test(remainingString))
                {
                    // Better look for a direction, but it is optional so no big deal if we do not find it
                    // We need a space between the order by field name and the direction
                    if (REGEXP_ASCENDING.test(remainingString))
                    {
                        this.chewWhitespace(token);
                        // consume and move on
                        token.consumeCharacters(3);
                        token.getResult().setLastOrderByDirection("asc", token);
                        token.getResult().setNeedsOrderByComma();
                    }
                    else if (REGEXP_DESCENDING.test(remainingString))
                    {
                        this.chewWhitespace(token);
                        // consume and move on
                        token.consumeCharacters(4);
                        token.getResult().setLastOrderByDirection("desc", token);
                        token.getResult().setNeedsOrderByComma();
                    }
                    else
                    {
                        token.getResult().setNeedsOrderByDirection();
                    }
                }
                else
                {
                    token.getResult().setNeedsOrderByField();
                    this.chewWhitespace(token);
                }
            }
            else
            {
                token.getResult().setLastOrderByFieldName("", token);                
                token.getResult().setNeedsOrderByField();
                token.setParseError();
            }
        },

        jql: function(token)
        {
            this.orClause(token);
            var remainingString = token.remainingString();
            if (this.startsWithIgnoreCase("ord", remainingString))
            {
                this.orderByClause(token);
            }
        },

        orClause: function(token)
        {

            while(!token.isComplete() && !this.startsWithIgnoreCase(")", token.remainingString()))
            {
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase("ord", remainingString))
                {
                    // lets give control back to the jql function so we can end up in the orderByClause
                    break;
                }
                if (token.getResult().getMustBeOperatorOrPredicate())
                {
                    token.getResult().resetLastPredicates();
                }
                else
                {
                    token.getResult().resetLogicalOperators();
                    this.andClause(token);
                }
                if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null)
                {
                    if (token.getResult().getNeedsWasPredicate())
                    {
                        this.predicateClause(token);
                    }
                    // we may as well exit early if the predicate clause has been handled
                    // and the token is complete
                    if (token.isComplete())
                    {
                        return;
                    }
                    // Look for an OR clause
                    remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase("ord", remainingString))
                    {
                        // lets give control back to the jql function so we can end up in the orderByClause
                        break;
                    }
                    else if (remainingString !== null && (REGEXP_ORS.test(remainingString) || this.startsWithIgnoreCase("|", remainingString) || this.startsWithIgnoreCase("||", remainingString)))
                    {
                        if (this.startsWithIgnoreCase("||", remainingString))
                        {
                            token.getResult().setLastLogicalOperator("||", token.getTokenStringIdx());
                            token.consumeCharacters(2);
                        }
                        else if (REGEXP_ORS.test(remainingString))
                        {
                            token.getResult().setLastLogicalOperator("OR", token.getTokenStringIdx());
                            token.consumeCharacters(3);
                        }
                        else
                        {
                            token.getResult().setLastLogicalOperator("|", token.getTokenStringIdx());
                            token.consumeCharacters(1);
                        }

                        token.getResult().resetTerminalClause();
                        if (token.isComplete())
                        {
                            token.setParseError();
                        }
                        token.getResult().setNeedsField();
                    }
                    // This block of code is very confusing. The reason it is here is that when we are in a nested
                    // block of '('s it is the terminalClause that handles the parens and it calls off to this orClause.
                    // The orClause needs to ignore the close paren so that the terminalClause can handle it, BUT only
                    // when we are currently in a set of parens. So, ff the remaining character is a close paren and
                    // we are not in parens then we are NOT in error, otherwise we are
                    else if (!this.startsWithIgnoreCase(")", remainingString) || !token.getInParens())
                    {
                        this.chewWhitespace(token);
                        var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx(): token.getMaxTokenStringIdx() - remainingString.length;
                        // let's tokenise this to simplify space handling
                        var tokens;
                        if (remainingString != null)
                        {
                            tokens = remainingString.split(" ");
                            token.getResult().setLastLogicalOperator(tokens[0], errorIdx);
                            token.getResult().setLastWasPredicate(tokens[0], token);
                            token.getResult().setNeedsLogicalOperator(token);
                        }

                        // may need to go around again to check for predicate
                        if (token.getResult().getLastWasOperator() == null)
                        {
                            token.setParseError();
                        }
                        else
                        {
                            if (tokens != null)
                            {
                                // JRADEV-6053 fails after and
                                if (REGEXP_PREDICATE.test(tokens[0]))
                                {
                                    token.getResult().setLastLogicalOperator(null);
                                    // JRADEV-7204 deleting back to predicate still leaves suggestions
                                    // in place, check this condition and reset
                                    token.getResult().resetNeedsPredicateOperand();
                                }
                                else
                                {
                                    if (REGEXP_ANDS.test(remainingString))
                                    {
                                        token.consumeCharacters(4);
                                        token.getResult().resetTerminalClause();
                                        token.getResult().setNeedsField();
                                    }
                                    if (token.isComplete() || tokens.length == 1)
                                    {
                                        token.setParseError();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },

        andClause: function(token)
        {
            this.chewWhitespace(token);
            this.notClause(token);
            if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null)
            {
                // Look for an AND clause
                this.chewWhitespace(token);

                var remainingString = token.remainingString();
                if (remainingString !== null && (REGEXP_ANDS.test(remainingString) || this.startsWithIgnoreCase("&", remainingString) || this.startsWithIgnoreCase("&&", remainingString)))
                {
                    if (this.startsWithIgnoreCase("&&", remainingString))
                    {
                        token.getResult().setLastLogicalOperator("&&", token.getTokenStringIdx());
                        token.consumeCharacters(2);
                    }
                    else if (this.startsWithIgnoreCase("&", remainingString))
                    {
                        token.getResult().setLastLogicalOperator("&", token.getTokenStringIdx());
                        token.consumeCharacters(1);
                    }
                    else
                    {
                        token.getResult().setLastLogicalOperator("AND", token.getTokenStringIdx());
                        token.consumeCharacters(4);
                    }
                    token.getResult().resetTerminalClause();
                    if (token.isComplete())
                    {
                        token.setParseError();
                    }

                    token.getResult().setNeedsField();
                }
                else
                {
                    token.getResult().setNeedsLogicalOperator(token);
                    // This is a special case for when we are about to place a logical operator into an existing string
                    // so that we will have a null place-holder token for the logical operator we expect.
                    if (token.isComplete())
                    {
                        token.getResult().setLastLogicalOperator(null, token.getMaxTokenStringIdx());
                    }
                }
            }
        },

        notClause: function(token)
        {
            this.chewWhitespace(token);
            if (!token.isComplete())
            {
                // Look for a NOT clause
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                if (remainingString !== null && (REGEXP_NOTS.test(remainingString) || this.startsWithIgnoreCase("!", remainingString)))
                {
                    // This is a bit of a hack that makes it so that you do not get a suggestion for a field until
                    // after you have typed a space after the NOT
                    token.getResult().needsField = false;
                    if (this.startsWithIgnoreCase("!", remainingString))
                    {
                        token.getResult().setLastLogicalOperator("!", token.getTokenStringIdx());
                        token.consumeCharacters(1);
                    }
                    else
                    {
                        token.getResult().setLastLogicalOperator("NOT", token.getTokenStringIdx());
                        token.consumeCharacters(4);
                    }
                    token.getResult().resetTerminalClause();
                    if (token.isComplete())
                    {
                        token.setParseError();
                    }

                    token.getResult().setNeedsField();
                }
                else
                {
                    this.terminalClause(token);
                }
            }
            else
            {
                // Let the terminal clause set all the error conditions and needs
                this.terminalClause(token);
                token.setParseError();
            }
        },

        predicateClause: function(token)
        {
            this.chewWhitespace(token);
            if (!token.isComplete()) {
                var remainingString = token.remainingString();
                var tokens = remainingString.split(/[\s(]+/);
                if (remainingString !== null)
                {
                    token.getResult().setMustBeOperatorOrPredicate(false);
                    // if the string starts with logical operator - return control to the
                    // not clause, however check if this is the last token, and if it is consume the
                    // characters
                    if (this.startsWithLogicalOperator(remainingString))
                    {
                        if (tokens.length == 1)
                        {
                            token.setParseError();
                            token.getResult().resetLogicalOperators();
                            return;
                        }
                        return;
                    }
                    token.getResult().resetNeedsPredicateOperand();
                    token.consumeCharacters(tokens[0].length);
                    token.getResult().setLastWasPredicate(tokens[0], token );
                    // if there is only 1 token then there is no whitespace, so get out of Dodge
                    if (tokens.length == 1)
                    {
                        token.setParseError();
                        return;
                    }
                    if (this.wasPredicateComplete(tokens[0]))
                    {
                        token.getResult().setNeedsPredicateOperand();
                        this.predicateOperand(token);
                    }
                    else
                    {
                        token.setParseError();
                    }
                 }
            }
            else
            {
                // Let the terminal clause set all the error conditions and needs
                token.setParseError();
            }

        },

        predicateOperand: function(token)
        {
            this.chewWhitespace(token);
            var predicateOperand = this.collectPredicateOperands(token);
            if (predicateOperand == null || predicateOperand == "")
            {
                token.getResult().setLastOperandStartIndex(token.getTokenStringIdx());
                token.setParseError();
            }
            // need a workaround to ensure you reset the needsPredicateOperand
            // easiest way is to check if you have entered a space after the
            // operand - meaning you want to go on parsing
            if (token.remainingString() != null)
            {
                token.getResult().resetNeedsPredicateOperand();
                token.getResult().resetLastPredicates();
                token.getResult().setMustBeOperatorOrPredicate(true);
                token.getResult().setNeedsLogicalOperator(token);
                this.chewWhitespace(token);
            }

        },

        collectPredicateOperands: function(token)
        {
            // If we have and in or not in operator then we need either a function or an open paren
            if (token.getResult().getLastWasPredicate() === 'DURING'  )
            {
                token.getResult().setNeedsOpenParen(true);
            }

            var predicateOperand = this.listOperand(token, true);
            if (predicateOperand.length === 0 )
            {
                predicateOperand = this.functionOperand(token);
                if (predicateOperand.length === 0)
                {
                    predicateOperand = this.singleValueOperand(token);
                }
                else
                {
                    // We were handled by a function so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }
            }
            else
            {
                // We were handled by a list so we no longer need the open paren
                token.getResult().setNeedsOpenParen(false);
            }
            return token.getResult().getUnquotedString(predicateOperand);
        },

        terminalClause: function(token)
        {
            // Lets always reset the last field variables
            token.getResult().resetTerminalClause();
            this.chewWhitespace(token);

            var remainingString = token.remainingString();
            // If we see a ( then we need to hand off to the or clause again
            if (this.startsWithIgnoreCase("(", remainingString))
            {
                token.getResult().addToken('(');
                token.setInParens();
                token.consumeCharacter();
                this.orClause(token);
                this.chewWhitespace(token);
                remainingString = token.remainingString();
                if (this.startsWithIgnoreCase(")", remainingString))
                {
                    token.getResult().addToken(')');
                    token.consumeCharacter();
                    token.setOutOfParens();
                    if (token.isComplete())
                    {
                        // We don't want to suggest a logical operator to the user if the query parses
                        token.getResult().resetLogicalOperators();
                        token.getResult().resetLastPredicates();
                    }
                }
                else
                {
                    token.setParseError();
                }
            }
            else
            {
                this.field(token);
                if (!token.isComplete())
                {
                    this.oper(token);
                    if (!token.isComplete())
                    {
                        if (token.getResult().getLastWasOperator() === 'changed')
                        {
                            token.getResult().setNeedsLogicalOperator(token);
                            return;
                        }
                        this.operand(token);

                        // This will only happen when we have seen a list operand that is properly closed
                        if (token.getResult().getOperandComplete())
                        {
                            // JRADEV-6372 Autocomplete does not parse after was in (or indeed was not in)
                            var lastWasOperator = token.getResult().getLastWasOperator();
                            token.getResult().setNeedsNothing();
                            if (lastWasOperator)
                            {
                                token.getResult().setLastWasOperator(lastWasOperator);
                            }
                        }
                        else if (token.isComplete() && !token.getResult().getNeedsListComma())
                        {
                            // This is not a parse error since we have found everything we were looking for
                            token.getResult().setNeedsOperand();
                        }
                    }
                    else
                    {
                        //if (token.getResult().get that.ge token.getResult().setNeedsOperator();
                        if (token.getResult().getLastOperator() == "was" || token.getResult().getLastOperator() == "was not")
                        {
                            token.getResult().setNeedsOperandOrOperator();
                        }
                        else if (token.getResult().getLastWasOperator() === 'changed')
                        {
                            // JRADEV-7179 Need to make sure that there is a space before calling for an autocomplete
                            var currentChar = token.currentCharacter();
                            if(currentChar !== null && REGEXP_SPACE_OR_ELSE.test(currentChar))
                            {
                                token.getResult().setNeedsLogicalOperator(token);
                            }
                            else
                            {
                                token.getResult().resetLogicalOperators();
                            }
                            return;
                        }
                        else
                        {
                            token.getResult().setNeedsOperator();
                        }
                        token.setParseError();
                    }
                }
                else
                {
                    token.getResult().setNeedsField();
                    token.setParseError();
                }
            }
        },

        field: function(token)
        {
            var fieldName = this.fieldName(token);
            if (fieldName.length !== 0 )
            {
                token.getResult().setLastFieldName(fieldName, token);
            }
            else if (token.getResult().getLastFieldName() === null)
            {
                remainingString = token.remainingString();
                token.getResult().setNeedsField();
                token.getResult().setLastFieldName(remainingString, token);
                token.setParseError();
            }
        },

        fieldName: function(token)
        {
            this.chewWhitespace(token);

            // Field is either a string or cf[12345]
            var remainingString = token.remainingString();
            if (this.startsWithIgnoreCase("cf", remainingString))
            {
                var origIdx = token.getTokenStringIdx();
                var origString = token.remainingString();
                token.consumeCharacters(2);
                this.chewWhitespace(token);
                remainingString = token.remainingString();
                // Now we must find a [ or the show is off
                if (this.startsWithIgnoreCase("[", remainingString))
                {
                    token.consumeCharacter();
                    // We must find a number in here until we encounter a ]
                    remainingString = token.remainingString();
                    var custFieldId = this.numberValue(token);
                    if (custFieldId.length !== 0)
                    {
                        // Lets find our closing ]
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();
                        if (this.startsWithIgnoreCase("]", remainingString))
                        {
                            token.consumeCharacter();
                            return origString.substring(0, token.getTokenStringIdx() - origIdx);
                        }
                    }
                }
                token.setParseError();
                return origString;
            }
            else
            {
                return this.fieldOrFunctionName(token);
            }
        },

        oper: function(token)
        {
            this.chewWhitespace(token);
            var remainingString = token.remainingString();
            var operator = this.getLongestOperatorMatch(remainingString, jql_operators);
            if (operator !== null)
            {
                // We found an operator, record it and consume the right amount of characters
                token.getResult().setLastOperator(operator, token.getTokenStringIdx());
                if (this.isWasOperator(operator) || this.isChangedOperator(operator))
                {
                    token.getResult().setLastWasOperator(operator);
                }
                token.consumeCharacters(operator.length);
                // If we are one of the word operators we need to enforce a space here
                if (operator == "in" || operator == "is" || operator == "is not" || operator == "not in" || operator == "was" || operator == "was not" || operator == "was in" || operator == "was not in")
                {
                    // We need a space or else
                    var currentChar = token.currentCharacter();
                    if(currentChar !== null && !REGEXP_SPACE_OR_ELSE.test(currentChar))
                    {
                        token.setParseError();
                    }
                }
                // was may be followed by not, so if it ihas a n or a no then the parser is still
                // in error

                if (operator  == "was")
                {
                    token.getResult().setNeedsOperandOrOperator();
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();

                    if (remainingString != null && (REGEXP_NOTSTART.test(remainingString) || REGEXP_INSTART.test(remainingString)))
                    {
                        token.setParseError();
                    }
                }
                else if (operator == "was not")
                {
                    token.getResult().setNeedsOperandOrOperator();
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();

                    if (remainingString != null && (REGEXP_INSTART.test(remainingString)))
                    {
                        token.setParseError();
                    }
                }
                else if (operator == "changed")
                {
                    token.getResult().setNeedsLogicalOperator(token);
                }
                else
                {
                    token.getResult().setNeedsOperand();
                }
            }
            else if (token.getResult().getLastOperator() === null)
            {
                var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx(): token.getMaxTokenStringIdx() - remainingString.length;
                token.getResult().setLastOperator(remainingString, errorIdx);
                token.getResult().setNeedsOperator();
                token.setParseError();
            }
        },

        operand: function(token)
        {
            this.chewWhitespace(token);

            // If we have and in or not in operator then we need either a function or an open paren
            if (token.getResult().getLastOperator() === 'in' || token.getResult().getLastOperator() === 'not in' || token.getResult().getLastOperator() === 'was not in' || token.getResult().getLastOperator() === 'was in' )
            {
                token.getResult().setNeedsOpenParen(true);
            }

            var operand = this.listOperand(token, true);
            if (operand.length === 0 )
            {
                operand = this.functionOperand(token);
                if (operand.length === 0)
                {
                    operand = this.singleValueOperand(token);
                }
                else
                {
                    // We were handled by a function so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }
            }
            else
            {
                // We were handled by a list so we no longer need the open paren
                token.getResult().setNeedsOpenParen(false);
            }

            if (operand === null || operand.length === 0)
            {
                var remainingString = token.remainingString();
                token.getResult().setLastOperand(remainingString, token);
                token.getResult().setNeedsOperand();
                token.setParseError();
            }
            if (operand.length !== 0)
            {
                return operand;
            }
            return "";
        },

        singleValueOperand: function(token)
        {
            var operand = this.stringValue(token);
            if (operand.length !== 0)
            {
                token.getResult().setLastOperand(operand, token);
                // Lets exclude empty and null, even though it is reserved
                if (operand.toLowerCase() != "empty" && operand.toLowerCase() != "null" && this.isReservedWord(operand.toLowerCase()))
                {
                    // These are reserved words
                    token.setParseError();
                }                
                return operand;
            }
            return "";
        },

        functionOperand: function(token)
        {
            var startIdx = token.getTokenStringIdx();
            var functionName = this.fieldOrFunctionName(token);
            // There can be whitespace between function name and arguments
            this.chewWhitespace(token);
            var listArguments = this.listOperand(token, false);
            if (functionName.length !== 0 && listArguments.length !== 0)
            {
                var operand = functionName + listArguments;
                // read in the whole value until we reach a close )
                token.getResult().setLastOperand(operand, token);
                return operand;
            }
            else
            {
                // back track
                token.backTrackToIdx(startIdx);
                return "";
            }
        },

        listOperand: function(token, treatAsOperands)
        {
            if (token.currentCharacter() == '(')
            {
                token.consumeCharacter();
                var listValue = this.collectListValues(token, treatAsOperands);
                var operandVal = "(" + listValue;

                this.chewWhitespace(token);
                if (token.currentCharacter() == ')')
                {
                    token.consumeCharacter();
                    operandVal += ")";
                    if (operandVal == "()" && treatAsOperands)
                    {
                        // Special case of an empty list which is still valid
                        token.getResult().setLastOperand(operandVal, token);
                    }
                    if(treatAsOperands)
                    {
                        token.getResult().setOperandComplete();
                        token.getResult().resetNeedsPredicateOperand();
                    }
                }
                else
                {
                   token.setParseError();
                }
                return operandVal;
            }
            else
            {
                return "";
            }
        },

        collectListValues: function(token, treatAsOperands)
        {
            if (treatAsOperands)
            {
                token.getResult().setNeedsOperand();
            }
            this.chewWhitespace(token);

            // grab the contents of the list, they should be singleValueOperands separated by commas, we only
            // need to keep track of the last encountered operand.
            var currentOperand = (treatAsOperands) ? this.operand(token) : this.stringValue(token);

            if (currentOperand.length !== 0)
            {
                // If there is whitespace then lets remember we need a comma
                if (this.chewWhitespace(token) && treatAsOperands)
                {
                    token.getResult().setNeedsListComma();
                }
                if (token.currentCharacter() == ',')
                {
                    // Consume the comma and recurse so we can collect the other values
                    token.consumeCharacter();
                    var nextValue = this.collectListValues(token, treatAsOperands);
                    if (nextValue.length === 0)
                    {
                        token.setParseError();
                    }
                    return currentOperand + ", " + nextValue;
                }
                else
                {
                    return currentOperand;
                }
            }
            else
            {
                return "";
            }
        },

        startsWithIgnoreCase: function(startStr, str)
        {
            if (str === null || startStr === null || str.length < startStr.length)
            {
                return false;
            }
            else
            {
                return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            }
        },

        startsWithLogicalOperator: function(str)
        {
            if (str === null)
            {
                return false;
            }
            else
            {
                return this.startsWithOr(str) ||  this.startsWithAnd(str) || this.startsWithNot(str) || this.startsWithBraces(str);
            }
        },

        startsWithOr: function(str)
        {
            return this.startsWithIgnoreCase("|", str) || this.startsWithIgnoreCase("||", str) ||
                    this.startsWithIgnoreCase("or", str);
        },

        startsWithAnd: function(str)
        {
            return this.startsWithIgnoreCase("&", str)  || this.startsWithIgnoreCase("&&", str)  ||
                       this.startsWithIgnoreCase("and", str);
        },

        startsWithNot: function(str)
        {
            return this.startsWithIgnoreCase("!", str) ||
                       this.startsWithIgnoreCase("not", str);
        },

        startsWithBraces: function(str)
        {
                    return this.startsWithIgnoreCase("(", str) ||
                       this.startsWithIgnoreCase(")", str);
        },

        chewWhitespace: function(token)
        {
            var foundWhiteSpace = false;
            var currentChar = token.currentCharacter();
            while(currentChar !== null && REGEXP_WHITESPACE.test(currentChar))
            {
                token.consumeCharacter();
                currentChar = token.currentCharacter();
                foundWhiteSpace = true;
            }
            return foundWhiteSpace;
        },

        getLongestOperatorMatch: function(value, listOfValues)
        {
            var longestMatch = null;
            // These first three cases are special since they might have more to them
            if (this.startsWithIgnoreCase("is", value))
            {
                // Look ahead for NOT, if we don't find it next then we must just be is
                var matchArray = value.substring(2).match(REGEXP_SNOT);

                if (matchArray)
                {
                    longestMatch = value.substring(0, matchArray[0].length + 2);
                }
                else
                {
                    longestMatch = "is";
                }
            }
            if (this.startsWithIgnoreCase("was", value))
            {
                // Look ahead for NOT or IN , if we don't find it next then we must just be was
                var matchArray = value.substring(3).match(REGEXP_SNOT_IN);

                if (matchArray)
                {
                    longestMatch = value.substring(0, matchArray[0].length + 3);
                }
                else
                {
                    longestMatch = "was";
                }
            }
            else if (this.startsWithIgnoreCase("not", value))
            {
                // Look ahead for IN, if we don't find it next then we are not an operator
                var matchArrayNot = value.substring(3).match(REGEXP_SIN);

                if (matchArrayNot)
                {
                    longestMatch = value.substring(0, matchArrayNot[0].length + 3);
                }
            }
            else
            {
                for(var i = 0; i < listOfValues.length; i++)
                {
                    if(this.startsWithIgnoreCase(listOfValues[i].value, value))
                    {
                        // We found a match
                        if (longestMatch === null || jql_operators[i].value.length > longestMatch)
                        {
                            longestMatch = jql_operators[i].value;
                        }
                    }
                }
            }
            return longestMatch;
        },

        getValueMinusExtraWhitespace: function(value)
        {
            if (value === null)
            {
                return null;
            }
            var newValue = "";
            var firstWhitespace = true;
            var valueArr = value.split("");
            for (var i = 0; i < valueArr.length; i++)
            {
                var currentChar = valueArr[i];
                if (REGEXP_WHITESPACE.test(currentChar))
                {
                    // We want to ignore extra whitespace, keeping only the first
                    if (firstWhitespace)
                    {
                        firstWhitespace = false;
                        newValue = newValue + currentChar;
                    }
                }
                else
                {
                    // If we encounter a non-whitespace then we want to reset our firstWhitespace test
                    firstWhitespace = true;
                    newValue = newValue + currentChar;
                }
            }
            return newValue;
        },

        fieldOrFunctionName: function(token)
        {
            var stringValue = this.stringValue(token);
            // Field or function names can not be the empty string
            if (stringValue === "\"\"" || stringValue === "''")
            {
                token.setParseError();
            }
            if (this.isReservedWord(stringValue.toLowerCase()))
            {
                // These are reserved words
                token.setParseError();
            }
            return stringValue;
        },

        isReservedWord: function(word)
        {
            return jQuery.inArray(word, jql_reserved_words) !== -1;
        },

        isWasOperator: function (operator)
        {
            return operator === 'was' || operator === 'was in' || operator == 'was not in' || operator == 'was not';
        },

        isChangedOperator: function (operator)
        {
            return operator === 'changed';
        },

        stringValue: function(token)
        {
            var stringValue = "";

            var inQuote = false;
            var inSingleQuote = false;
            var currentChar = token.currentCharacter();
            while(currentChar !== null && (inQuote || inSingleQuote|| REGEXP_TOKEN_CHAR.test(currentChar)))
            {
                // Read the escape character into the string
                stringValue = stringValue + currentChar;
                token.consumeCharacter();
                // Handle the escape character
                if (currentChar == '\\')
                {
                    // Just consume the next char as well
                    currentChar = token.currentCharacter();
                    if (currentChar === null)
                    {
                        token.setParseError();
                        break;                        
                    }
                    // These are the only valid characters to escape
                    else if (REGEXP_CHARS_TO_ESCAPE.test(currentChar))
                    {
                        // Check for unicode escapes
                        var remainingString = token.remainingString();
                        if (!REGEXP_UNICODE.test(remainingString))
                        {
                            token.setParseError();
                            break;
                        }
                    }

                    stringValue = stringValue + currentChar;
                    token.consumeCharacter();
                }
                // Check for illegal characters and kill the whole parse
                else if (REGEXP_SPECIAL_CHAR.test(currentChar) && !(inQuote || inSingleQuote))
                {
                    token.setParseError();
                    break;
                }                
                // We need to keep track if we are in a quote or not
                else if (currentChar == '"' && !inSingleQuote)
                {
                    inQuote = !inQuote;
                }
                else if (currentChar == "'" && !inQuote)
                {
                    inSingleQuote = !inSingleQuote;
                }
                currentChar = token.currentCharacter();
            }
            // We should never get left in a quote or single quote
            if (token.isComplete() && (inQuote || inSingleQuote))
            {
                token.setParseError();
            }
            return stringValue;
        },

        numberValue: function(token)
        {
            var numberVal = "";

            this.chewWhitespace(token);
            var currentChar = token.currentCharacter();
            while(currentChar !== null)
            {
                if (REGEXP_NUMBER.test(currentChar))
                {
                    numberVal = numberVal + currentChar;
                    token.consumeCharacter();
                }
                else
                {
                    // found not a number time to return
                    break;
                }
                currentChar = token.currentCharacter();
            }
            return numberVal;
        },

        wasPredicateComplete: function(predicate)
        {
            var foundPredicate = false;
            var arLen=jql_changed_predicates.length;
            for ( var i=0, len=arLen; i<len; ++i )
            {
                if (predicate.toLowerCase() == jql_changed_predicates[i].value.toLowerCase())
                {
                    foundPredicate = true;
                    break;
                }

            }
            return foundPredicate;
        }

    };
};

JIRA.JQLAutoComplete.ParseResult = function() {

    var tokens = [];
    var tokenIdx = 0;
    return {
        
        getTokens: function()
        {
            return tokens;  
        },

        addToken: function(token)
        {
            tokens[tokenIdx++] = token;
        },

        setLastFieldName: function(lastFieldName, token)
        {
            this.fieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
            // Get rid of quotes if we need to
            this.lastFieldName = this.getUnquotedString(lastFieldName);
            tokens[tokenIdx++] = lastFieldName;
        },

        getLastFieldName: function()
        {
            return this.lastFieldName;
        },

        getLastFieldNameStartIndex: function()
        {
            return this.fieldNameStartIndex;
        },

        setLastOrderByFieldName: function(lastFieldName, token)
        {
            this.orderByFieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
            // Get rid of quotes if we need to
            this.lastOrderByFieldName = this.getUnquotedString(lastFieldName);
            this.lastOrderByDirection = null;
            tokens[tokenIdx++] = lastFieldName;
        },

        getLastOrderByFieldName: function()
        {
            return this.lastOrderByFieldName;
        },

        getLastOrderByFieldNameStartIndex: function()
        {
            return this.orderByFieldNameStartIndex;
        },

        setLastOrderByDirection: function(lastDirection, token)
        {
            this.orderByDirectionStartIndex = (lastDirection === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastDirection.length);
            this.lastOrderByDirection = lastDirection;
            tokens[tokenIdx++] = lastDirection;
        },

        getLastOrderByDirection: function()
        {
            return this.lastOrderByDirection;
        },

        getLastOrderByDirectionStartIndex: function()
        {
            return this.orderByDirectionStartIndex;
        },

        setNeedsField: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = true;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
            this.needsWasPredicate = false;
            this.lastWasOperator = null;
        },

        getNeedsField: function()
        {
            return this.needsField;
        },

        setNeedsOrderByField: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = false;
            this.needsOrderByField = true;
            this.needsOrderByDirection = false;
            this.lastOrderByDirection = null;
            this.needsListComma = false;
        },

        getNeedsOrderByField: function()
        {
            return this.needsOrderByField;
        },

        setNeedsOrderByDirection: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = true;
            this.needsListComma = false;
        },

        getNeedsOrderByDirection: function()
        {
            return this.needsOrderByDirection;
        },

        setNeedsOrderByComma: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
        },

        setNeedsListComma: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = true;
        },

        getNeedsListComma: function()
        {
            return this.needsListComma;
        },

        setLastOperator: function(lastOperator, startIndex)
        {
            this.lastOperator = lastOperator;
            this.operatorStartIndex = startIndex;
            tokens[tokenIdx++] = lastOperator;
        },

        setLastWasOperator: function(lastWasOperator)
        {
             this.lastWasOperator = lastWasOperator;
        },

        getLastWasOperator: function()
        {
            return this.lastWasOperator;
        },

        getLastOperator: function()
        {
            return this.lastOperator;
        },

        getLastOperatorStartIndex: function()
        {
            return this.operatorStartIndex;
        },

        setLastOperand: function(lastOperand, token)
        {
            this.operandStartIndex = (lastOperand === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOperand.length);
            // Get rid of quotes if we need to
            this.lastOperand = this.getUnquotedString(lastOperand);
            tokens[tokenIdx++] = lastOperand;
        },

        getLastOperand: function()
        {
            return this.lastOperand;
        },

        setNeedsOperand: function()
        {
            this.needsField = false;
            this.needsOperator = false;
            this.needsLogicalOperator = false;
            this.needsOperand = true;
            this.needsOrderBy = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
        },

        setNeedsOperandOrOperator: function()
        {
            this.needsField = false;
            this.needsOperator = true;
            this.needsLogicalOperator = false;
            this.needsOperand = true;
            this.needsOrderBy = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
        },

        getNeedsOperand: function()
        {
            return this.needsOperand;
        },

        setNeedsPredicateOperand: function()
        {
             this.needsPredicateOperand = true;
        },

        resetNeedsPredicateOperand: function()
        {
            this.needsPredicateOperand = false;
            this.needsOperand = false;
        },

        getNeedsPredicateOperand: function()
        {
             return this.needsPredicateOperand;
        },

        getLastOperandStartIndex: function()
        {
            return this.operandStartIndex;
        },

        setLastOperandStartIndex: function(index)
        {
            this.operandStartIndex = index;
        },

        setLastLogicalOperator: function(lastLogicalOperator, startIndex)
        {
            this.lastLogicalOperator = lastLogicalOperator;
            this.logicalOperatorStartIndex = startIndex;
            tokens[tokenIdx++] = lastLogicalOperator;
        },

        setNeedsOperator: function()
        {
            this.needsField = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsOperator = true;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
        },

        getNeedsOperatorOrOperand:  function()
        {
           return this.needsOperator && this.needsOperand;
        },

        getNeedsOperator: function()
        {
            return this.needsOperator;
        },

        getLastLogicalOperator: function()
        {
            return this.lastLogicalOperator;
        },

        getLastLogicalOperatorStartIndex: function()
        {
            return this.logicalOperatorStartIndex;
        },

        setNeedsLogicalOperator: function(token)
        {
            this.needsLogicalOperator = true;
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsField = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsListComma = false;
            // Every time we need a logical operator we also could need an order by as long as we are not in parens
            this.needsOrderBy = !token.getInParens();
            // Every time a logical operator is needed you may need a predicate, but only if the last clause
            // was a was clause
            if (this.lastWasOperator != null)
            {
                this.needsWasPredicate = true;
            }
        },

        setNeedsOpenParen: function(value)
        {
            this.needsOpenParen = value;
        },

        getNeedsOpenParen: function()
        {
            return this.needsOpenParen;
        },

        getNeedsLogicalOperator: function()
        {
            return this.needsLogicalOperator;
        },

        getNeedsOrderBy: function()
        {
            return this.needsOrderBy;
        },

        getNeedsWasPredicate: function()
        {
            return this.needsWasPredicate;
        },

        setLastWasPredicate: function(lastWasPredicate, token)
        {
            this.wasPredicateStartIndex = (lastWasPredicate === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastWasPredicate.length);
            this.lastWasPredicate = lastWasPredicate;
            tokens[tokenIdx++] = lastWasPredicate;
        },

        getLastWasPredicate: function()
        {
            return this.lastWasPredicate;
        },

        resetLastPredicates : function()
        {
            this.lastLogicalOperator = null;
            this.lastWasPredicate = null;
            this.lastOperand = null;
            this.wasPredicateStartIndex = null;
            this.operandStartIndex = null;
        },

        getLastWasPredicateStartIndex: function()
        {
            return this.wasPredicateStartIndex;
        },

        setLastOrderBy: function(lastOrderBy, token)
        {
            this.orderByStartIndex = (lastOrderBy === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOrderBy.length);
            this.lastOrderBy = lastOrderBy;
            tokens[tokenIdx++] = lastOrderBy;
        },

        getLastOrderBy: function()
        {
            return this.lastOrderBy;
        },

        getLastOrderByStartIndex: function()
        {
            return this.orderByStartIndex;
        },

        resetLogicalOperators: function()
        {
            this.lastLogicalOperator = null;
            this.logicalOperatorStartIndex = null;
            this.needsLogicalOperator = null;
        },

        getUnquotedString: function(value)
        {
            // We only remove the last quote if it is NOT preceeded by an escape character
            var secondToLastNotEsacape = value != null && value.length >= 3 && value.charAt(value.length - 2) != '\\';

            if (value != null && value.charAt(0) == '"')
            {
                value = value.substring(1, value.length);

                if (value.charAt(value.length - 1) == '"' && secondToLastNotEsacape)
                {
                    value = value.substring(0, value.length - 1);
                }
            }
            else if (value != null && value.charAt(0) == "'")
            {
                value = value.substring(1, value.length);

                if (value.charAt(value.length - 1) == "'" && secondToLastNotEsacape)
                {
                    value = value.substring(0, value.length - 1);
                }                
            }

            return value;
        },

        setParseError: function(message)
        {
            this.parseError = true;
            this.parseErrorMsg = message;
        },

        getParseError: function()
        {
            return this.parseError;
        },

        getParseErrorMsg: function()
        {
            return this.parseErrorMsg;
        },

        setNeedsNothing: function()
        {
            this.needsOperator = false;
            this.needsOperand = false;
            this.needsLogicalOperator = false;
            this.needsOrderBy = false;
            this.needsField = false;
            this.needsOrderByField = false;
            this.needsOrderByDirection = false;
            this.needsOpenParen = false;
            this.needsListComma = false;
            this.needsWasPredicate = null;
            this.needsPredicateOperand = null;
            this.mustBeOperatorOrPredicate = null;
            this.lastWasOperator = null;
        },

        setOperandComplete: function()
        {
            this.operandComplete = true;
        },

        getOperandComplete: function()
        {
            return this.operandComplete;
        },

        setMustBeOperatorOrPredicate: function(state)
        {
            this.mustBeOperatorOrPredicate = state;
        },

        getMustBeOperatorOrPredicate: function()
        {
            return this.mustBeOperatorOrPredicate;
        },

        resetTerminalClause: function()
        {
            this.lastFieldName = null;
            this.fieldNameStartIndex = null;
            this.needsField = null;
            this.lastOperator = null;
            this.operatorStartIndex = null;
            this.needsOperator = null;
            this.lastOperand = null;
            this.operandStartIndex = null;
            this.needsOperand = null;
            this.operandComplete = null;
            this.needsOpenParen = null;
            this.needsListComma = false;
            this.mustBeOperatorOrPredicate = null;
        },

        init: function()
        {
            this.lastFieldName = null;
            this.fieldNameStartIndex = null;
            this.needsField = null;
            this.lastOperator = null;
            this.operatorStartIndex = null;
            this.needsOperator = null;
            this.lastOperand = null;
            this.operandStartIndex = null;
            this.needsOperand = null;
            this.lastLogicalOperator = null;
            this.logicalOperatorStartIndex = null;
            this.lastOrderByFieldName = null;
            this.lastOrderByFieldNameStartIndex = null;
            this.lastOrderByDirection = null;
            this.lastOrderByDirectionStartIndex = null;
            this.orderByStartIndex = null;
            this.lastOrderBy = null;
            this.needsOrderBy = null;
            this.needsOrderByField = null;
            this.needsOrderByDirection = null;
            this.operandComplete = null;
            this.needsOpenParen = null;
            this.needsListComma = null;
            this.wasPredicateStartIndex = null;
            this.lastWasPredicate = null;
            this.needsWasPredicate = null;
            this.needsPredicateOperand = null;
            this.mustBeOperatorOrPredicate = null;
            this.lastWasOperator = null;
        }
    };
};

JIRA.JQLAutoComplete.Token = function() {

    return {

        init: function(tokenString)
        {
            this.tokenStringIdx = 0;
            this.tokenString = tokenString;
            this.parseError = false;
            this.parseErrorMsg = null;
            this.result = JIRA.JQLAutoComplete.ParseResult();
            this.result.init();
            this.inParens = 0;
        },

        consumeCharacter: function()
        {
            this.tokenStringIdx ++;
        },

        consumeCharacters: function(numChars)
        {
            this.tokenStringIdx = this.tokenStringIdx + numChars;
        },

        backTrackToIdx: function(backTrackIdx)
        {
            this.tokenStringIdx = backTrackIdx;
            // Lets clear any parse errors that might have occurred as well
            this.parseError = false;
            this.parseErrorMsg = null;
            this.result.parseError = false;
            this.result.parseErrorMsg = null;
        },

        getTokenStringIdx: function()
        {
            return this.tokenStringIdx;
        },

        currentCharacter: function()
        {
            if (this.tokenStringIdx >= this.tokenString.length)
            {
                return null;
            }
            return this.tokenString.charAt(this.tokenStringIdx);
        },

        remainingString: function()
        {
            if (this.tokenStringIdx >= this.tokenString.length)
            {
                return null;
            }
            return this.tokenString.substr(this.tokenStringIdx, this.tokenString.length);
        },

        getMaxTokenStringIdx: function()
        {
            return this.tokenString.length;
        },

        isComplete: function()
        {
            if (this.parseError)
            {
                return true;
            }
            return this.tokenStringIdx >= this.tokenString.length;
        },

        setInParens: function()
        {
            this.inParens++;
        },

        setOutOfParens: function()
        {
            // Lets never go into negative here
            if (this.inParens !== 0)
            {
                this.inParens--;
            }
        },

        getInParens: function()
        {
            return this.inParens !== 0;
        },

        setParseError: function()
        {
            this.parseError = true;
            var preFixIdx = ((this.tokenStringIdx - 9) < 0) ? 0 : this.tokenStringIdx - 9;
            var errorPrefix = this.tokenString.substring(preFixIdx, this.tokenStringIdx - 1);
            this.result.setParseError("..." + errorPrefix + "^" + this.tokenString.substring(this.tokenStringIdx, this.tokenString.length));
        },

        getParseError: function()
        {
            return this.parseError;
        },

        getResult: function()
        {
            return this.result;
        }

    };

};



jQuery(function(){

//    restore('jqlHistory');

    jQuery(".jql-autocomplete-params").each(function(){
        var params = {};

        jQuery(this).find("input").each(function(){
            var $this = jQuery(this);
            params[$this.attr("id")] = $this.val();
        });

        var jqlFieldNames = JSON.parse(jQuery("#jqlFieldz").text());
        var jqlFunctionNames = JSON.parse(jQuery("#jqlFunctionNamez").text());
        var jqlReservedWords = JSON.parse(jQuery("#jqlReservedWordz").text());

        var jqlAutoComplete = JIRA.JQLAutoComplete({
            fieldID: 'jqltext',
            parser: JIRA.JQLAutoComplete.MyParser(jqlReservedWords),
            queryDelay: .65,
            jqlFieldNames: jqlFieldNames,
            jqlFunctionNames: jqlFunctionNames,
            minQueryLength: 0,
            allowArrowCarousel: true,
            autoSelectFirst: false,
            errorID: 'jqlerrormsg'
        });

        var jQueryRef = jQuery('#jqltext');

        jQueryRef.unbind("keypress", submitOnEnter).keypress(
                function (e) {
                    if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                        if (e.keyCode == 13 && !e.ctrlKey && ! e.shiftKey)
                        {
                            jQuery('#jqlform').submit();
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                });
        jqlAutoComplete.buildResponseContainer();
        jqlAutoComplete.parse(jQueryRef.text());
        jqlAutoComplete.updateColumnLineCount();

        jQueryRef.click(function(){
            jqlAutoComplete.dropdownController.hideDropdown();
        });
    });
});

})();

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:timeline-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/timeline.js' */
/**
 * @file timeline.js
 *
 * @brief
 * The Timeline is an interactive visualization chart to visualize events in
 * time, having a start and end date.
 * You can freely move and zoom in the timeline by dragging
 * and scrolling in the Timeline. Items are optionally dragable. The time
 * scale on the axis is adjusted automatically, and supports scales ranging
 * from milliseconds to years.
 *
 * Timeline is part of the CHAP Links library.
 *
 * Timeline is tested on Firefox 3.6, Safari 5.0, Chrome 6.0, Opera 10.6, and
 * Internet Explorer 6+.
 *
 * @license
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright (c) 2011-2013 Almende B.V.
 *
 * @author     Jos de Jong, <jos@almende.org>
 * @date    2013-04-18
 * @version 2.4.2
 */

/*
 * i18n mods by github user iktuz (https://gist.github.com/iktuz/3749287/)
 * added to v2.4.1 with da_DK language by @bjarkebech
 */

/*
 * TODO
 *
 * Add zooming with pinching on Android
 *
 * Bug: when an item contains a javascript onclick or a link, this does not work
 *      when the item is not selected (when the item is being selected,
 *      it is redrawn, which cancels any onclick or link action)
 * Bug: when an item contains an image without size, or a css max-width, it is not sized correctly
 * Bug: neglect items when they have no valid start/end, instead of throwing an error
 * Bug: Pinching on ipad does not work very well, sometimes the page will zoom when pinching vertically
 * Bug: cannot set max width for an item, like div.timeline-event-content {white-space: normal; max-width: 100px;}
 * Bug on IE in Quirks mode. When you have groups, and delete an item, the groups become invisible
 */

/**
 * Declare a unique namespace for CHAP's Common Hybrid Visualisation Library,
 * "links"
 */
if (typeof links === 'undefined') {
    links = {};
    // important: do not use var, as "var links = {};" will overwrite
    //            the existing links variable value with undefined in IE8, IE7.
}


/**
 * Ensure the variable google exists
 */
if (typeof google === 'undefined') {
    google = undefined;
    // important: do not use var, as "var google = undefined;" will overwrite
    //            the existing google variable value with undefined in IE8, IE7.
}


// ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
// TODO: When we drop support for IE8, we should leave the commented out code that defines Array.indexOf and Array.forEach but remove all other modifications that mention TEAMCAL-1747.
// Internet Explorer 8 and older does not support Array.indexOf,
// so we define it here in that case
// http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/
//if(!Array.prototype.indexOf) {
//    Array.prototype.indexOf = function(obj){
//        for(var i = 0; i < this.length; i++){
//            if(this[i] == obj){
//                return i;
//            }
//        }
//        return -1;
//    }
//}
// END ATLASSIAN

// Internet Explorer 8 and older does not support Array.forEach,
// so we define it here in that case
// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach
//if (!Array.prototype.forEach) {
//    Array.prototype.forEach = function(fn, scope) {
//        for(var i = 0, len = this.length; i < len; ++i) {
//            fn.call(scope || this, this[i], i, this);
//        }
//    }
//}
// END ATLASSIAN


/**
 * @constructor links.Timeline
 * The timeline is a visualization chart to visualize events in time.
 *
 * The timeline is developed in javascript as a Google Visualization Chart.
 *
 * @param {Element} container   The DOM element in which the Timeline will
 *                                  be created. Normally a div element.
 */
links.Timeline = function(container) {
    if (!container) {
        // this call was probably only for inheritance, no constructor-code is required
        return;
    }

    // create variables and set default values
    this.dom = {};
    this.conversion = {};
    this.eventParams = {}; // stores parameters for mouse events
    this.groups = [];
    this.groupIndexes = {};
    this.items = [];
    this.renderQueue = {
        show: [],   // Items made visible but not yet added to DOM
        hide: [],   // Items currently visible but not yet removed from DOM
        update: []  // Items with changed data but not yet adjusted DOM
    };
    this.renderedItems = [];  // Items currently rendered in the DOM
    this.clusterGenerator = new links.Timeline.ClusterGenerator(this);
    this.currentClusters = [];
    this.selection = undefined; // stores index and item which is currently selected

    this.listeners = {}; // event listener callbacks

    // Initialize sizes.
    // Needed for IE (which gives an error when you try to set an undefined
    // value in a style)
    this.size = {
        'actualHeight': 0,
        'axis': {
            'characterMajorHeight': 0,
            'characterMajorWidth': 0,
            'characterMinorHeight': 0,
            'characterMinorWidth': 0,
            'height': 0,
            'labelMajorTop': 0,
            'labelMinorTop': 0,
            'line': 0,
            'lineMajorWidth': 0,
            'lineMinorHeight': 0,
            'lineMinorTop': 0,
            'lineMinorWidth': 0,
            'top': 0
        },
        'contentHeight': 0,
        'contentLeft': 0,
        'contentWidth': 0,
        'frameHeight': 0,
        'frameWidth': 0,
        'groupsLeft': 0,
        'groupsWidth': 0,
        'items': {
            'top': 0
        }
    };

    this.dom.container = container;

    this.options = {
        'width': "100%",
        'height': "auto",
        'minHeight': 0,        // minimal height in pixels
        'autoHeight': true,

        'eventMargin': 10,     // minimal margin between events
        'eventMarginAxis': 20, // minimal margin between events and the axis
        'dragAreaWidth': 10,   // pixels

        'min': undefined,
        'max': undefined,
        'zoomMin': 10,     // milliseconds
        'zoomMax': 1000 * 60 * 60 * 24 * 365 * 10000, // milliseconds

        'moveable': true,
        'zoomable': true,
        'selectable': true,
        'editable': false,
        'snapEvents': true,
        'groupChangeable': true,

        'showCurrentTime': true, // show a red bar displaying the current time
        'showCustomTime': false, // show a blue, draggable bar displaying a custom time
        'showMajorLabels': true,
        'showMinorLabels': true,
        'showNavigation': false,
        'showButtonNew': false,
        'groupsOnRight': false,
        'axisOnTop': false,
        'stackEvents': true,
        'animate': true,
        'animateZoom': true,
        'cluster': false,
        'style': 'box',
        'customStackOrder': false, //a function(a,b) for determining stackorder amongst a group of items. Essentially a comparator, -ve value for "a before b" and vice versa

        //ATLASSIAN: load locale from Confluence system, don't need to timeline-locale.js, we can remove this code below
        'locale': 'en',
        'MONTHS': new Array("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"),
        'DAYS': new Array("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"),
        //END ATLASSIAN
        'MONTHS_SHORT': new Array("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"),
        'DAYS_SHORT': new Array("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"),
        'ZOOM_IN': "Zoom in",
        'ZOOM_OUT': "Zoom out",
        'MOVE_LEFT': "Move left",
        'MOVE_RIGHT': "Move right",
        'NEW': "New",
        'CREATE_NEW_EVENT': "Create new event"
    };

    this.clientTimeOffset = 0;    // difference between client time and the time
    // set via Timeline.setCurrentTime()
    var dom = this.dom;

    // remove all elements from the container element.
    while (dom.container.hasChildNodes()) {
        dom.container.removeChild(dom.container.firstChild);
    }

    // create a step for drawing the axis
    this.step = new links.Timeline.StepDate();

    // add standard item types
    this.itemTypes = {
        box:   links.Timeline.ItemBox,
        range: links.Timeline.ItemRange,
        dot:   links.Timeline.ItemDot
    };

    // initialize data
    this.data = [];
    this.firstDraw = true;

    // date interval must be initialized
    this.setVisibleChartRange(undefined, undefined, false);

    // render for the first time
    this.render();

    // fire the ready event
    var me = this;
    setTimeout(function () {
        me.trigger('ready');
    }, 0);
};


/**
 * Main drawing logic. This is the function that needs to be called
 * in the html page, to draw the timeline.
 *
 * A data table with the events must be provided, and an options table.
 *
 * @param {google.visualization.DataTable}      data
 *                                 The data containing the events for the timeline.
 *                                 Object DataTable is defined in
 *                                 google.visualization.DataTable
 * @param {Object} options         A name/value map containing settings for the
 *                                 timeline. Optional.
 */
links.Timeline.prototype.draw = function(data, options) {
    this.setOptions(options);

    // read the data
    this.setData(data);

    // set timer range. this will also redraw the timeline
    if (options && (options.start || options.end)) {
        this.setVisibleChartRange(options.start, options.end);
    }
    else if (this.firstDraw) {
        this.setVisibleChartRangeAuto();
    }

    this.firstDraw = false;
};


/**
 * Set options for the timeline.
 * Timeline must be redrawn afterwards
 * @param {Object} options A name/value map containing settings for the
 *                                 timeline. Optional.
 */
links.Timeline.prototype.setOptions = function(options) {
    if (options) {
        // retrieve parameter values
        for (var i in options) {
            if (options.hasOwnProperty(i)) {
                this.options[i] = options[i];
            }
        }

        // prepare i18n dependent on set locale
        if (typeof links.locales !== 'undefined' && this.options.locale !== 'en') {
            var localeOpts = links.locales[this.options.locale];
            if(localeOpts) {
                for (var l in localeOpts) {
                    if (localeOpts.hasOwnProperty(l)) {
                        this.options[l] = localeOpts[l];
                    }
                }
            }
        }

        // check for deprecated options
        if (options.showButtonAdd != undefined) {
            this.options.showButtonNew = options.showButtonAdd;
            console.log('WARNING: Option showButtonAdd is deprecated. Use showButtonNew instead');
        }
        if (options.intervalMin != undefined) {
            this.options.zoomMin = options.intervalMin;
            console.log('WARNING: Option intervalMin is deprecated. Use zoomMin instead');
        }
        if (options.intervalMax != undefined) {
            this.options.zoomMax = options.intervalMax;
            console.log('WARNING: Option intervalMax is deprecated. Use zoomMax instead');
        }

        if (options.scale && options.step) {
            this.step.setScale(options.scale, options.step);
        }
    }

    // validate options
    this.options.autoHeight = (this.options.height === "auto");
};

/**
 * Add new type of items
 * @param {String} typeName  Name of new type
 * @param {links.Timeline.Item} typeFactory Constructor of items
 */
links.Timeline.prototype.addItemType = function (typeName, typeFactory) {
    this.itemTypes[typeName] = typeFactory;
};

/**
 * Retrieve a map with the column indexes of the columns by column name.
 * For example, the method returns the map
 *     {
 *         start: 0,
 *         end: 1,
 *         content: 2,
 *         group: undefined,
 *         className: undefined
 *         editable: undefined
 *     }
 * @param {google.visualization.DataTable} dataTable
 * @type {Object} map
 */
links.Timeline.mapColumnIds = function (dataTable) {
    var cols = {},
        colMax = dataTable.getNumberOfColumns(),
        allUndefined = true;

    // loop over the columns, and map the column id's to the column indexes
    for (var col = 0; col < colMax; col++) {
        var id = dataTable.getColumnId(col) || dataTable.getColumnLabel(col);
        cols[id] = col;
        if (id == 'start' || id == 'end' || id == 'content' ||
            id == 'group' || id == 'className' || id == 'editable') {
            allUndefined = false;
        }
    }

    // if no labels or ids are defined,
    // use the default mapping for start, end, content
    if (allUndefined) {
        cols.start = 0;
        cols.end = 1;
        cols.content = 2;
    }

    return cols;
};

/**
 * Set data for the timeline
 * @param {google.visualization.DataTable | Array} data
 */
links.Timeline.prototype.setData = function(data) {
    // unselect any previously selected item
    this.unselectItem();

    if (!data) {
        data = [];
    }

    // clear all data
    this.stackCancelAnimation();
    this.clearItems();
    this.data = data;
    var items = this.items;
    this.deleteGroups();

    if (google && google.visualization &&
        data instanceof google.visualization.DataTable) {
        // map the datatable columns
        var cols = links.Timeline.mapColumnIds(data);

        // read DataTable
        for (var row = 0, rows = data.getNumberOfRows(); row < rows; row++) {
            items.push(this.createItem({
                'start':     ((cols.start != undefined)     ? data.getValue(row, cols.start)     : undefined),
                'end':       ((cols.end != undefined)       ? data.getValue(row, cols.end)       : undefined),
                'content':   ((cols.content != undefined)   ? data.getValue(row, cols.content)   : undefined),
                'group':     ((cols.group != undefined)     ? data.getValue(row, cols.group)     : undefined),
                'className': ((cols.className != undefined) ? data.getValue(row, cols.className) : undefined),
                'editable':  ((cols.editable != undefined)  ? data.getValue(row, cols.editable)  : undefined)
            }));
        }
    }
    else if (links.Timeline.isArray(data)) {
        // read JSON array
        for (var row = 0, rows = data.length; row < rows; row++) {
            var itemData = data[row];
            var item = this.createItem(itemData);
            items.push(item);
        }
    }
    else {
        throw "Unknown data type. DataTable or Array expected.";
    }

    // prepare data for clustering, by filtering and sorting by type
    if (this.options.cluster) {
        this.clusterGenerator.setData(this.items);
    }

    this.render({
        animate: false
    });
};

/**
 * Return the original data table.
 * @return {google.visualization.DataTable | Array} data
 */
links.Timeline.prototype.getData = function  () {
    return this.data;
};


/**
 * Update the original data with changed start, end or group.
 *
 * @param {Number} index
 * @param {Object} values   An object containing some of the following parameters:
 *                          {Date} start,
 *                          {Date} end,
 *                          {String} content,
 *                          {String} group
 */
links.Timeline.prototype.updateData = function  (index, values) {
    var data = this.data,
        prop;

    if (google && google.visualization &&
        data instanceof google.visualization.DataTable) {
        // update the original google DataTable
        var missingRows = (index + 1) - data.getNumberOfRows();
        if (missingRows > 0) {
            data.addRows(missingRows);
        }

        // map the column id's by name
        var cols = links.Timeline.mapColumnIds(data);

        // merge all fields from the provided data into the current data
        for (prop in values) {
            if (values.hasOwnProperty(prop)) {
                var col = cols[prop];
                if (col == undefined) {
                    // create new column
                    var value = values[prop];
                    var valueType = 'string';
                    if (typeof(value) == 'number')       {valueType = 'number';}
                    else if (typeof(value) == 'boolean') {valueType = 'boolean';}
                    else if (value instanceof Date)      {valueType = 'datetime';}
                    col = data.addColumn(valueType, prop);
                }
                data.setValue(index, col, values[prop]);

                // TODO: correctly serialize the start and end Date to the desired type (Date, String, or Number)
            }
        }
    }
    else if (links.Timeline.isArray(data)) {
        // update the original JSON table
        var row = data[index];
        if (row == undefined) {
            row = {};
            data[index] = row;
        }

        // merge all fields from the provided data into the current data
        for (prop in values) {
            if (values.hasOwnProperty(prop)) {
                row[prop] = values[prop];

                // TODO: correctly serialize the start and end Date to the desired type (Date, String, or Number)
            }
        }
    }
    else {
        throw "Cannot update data, unknown type of data";
    }
};

/**
 * Find the item index from a given HTML element
 * If no item index is found, undefined is returned
 * @param {Element} element
 * @return {Number | undefined} index
 */
links.Timeline.prototype.getItemIndex = function(element) {
    var e = element,
        dom = this.dom,
        frame = dom.items.frame,
        items = this.items,
        index = undefined;

    // try to find the frame where the items are located in
    while (e.parentNode && e.parentNode !== frame) {
        e = e.parentNode;
    }

    if (e.parentNode === frame) {
        // yes! we have found the parent element of all items
        // retrieve its id from the array with items
        for (var i = 0, iMax = items.length; i < iMax; i++) {
            if (items[i].dom === e) {
                index = i;
                break;
            }
        }
    }

    return index;
};

/**
 * Set a new size for the timeline
 * @param {string} width   Width in pixels or percentage (for example "800px"
 *                         or "50%")
 * @param {string} height  Height in pixels or percentage  (for example "400px"
 *                         or "30%")
 */
links.Timeline.prototype.setSize = function(width, height) {
    if (width) {
        this.options.width = width;
        this.dom.frame.style.width = width;
    }
    if (height) {
        this.options.height = height;
        this.options.autoHeight = (this.options.height === "auto");
        if (height !==  "auto" ) {
            this.dom.frame.style.height = height;
        }
    }

    this.render({
        animate: false
    });
};


/**
 * Set a new value for the visible range int the timeline.
 * Set start undefined to include everything from the earliest date to end.
 * Set end undefined to include everything from start to the last date.
 * Example usage:
 *    myTimeline.setVisibleChartRange(new Date("2010-08-22"),
 *                                    new Date("2010-09-13"));
 * @param {Date}   start     The start date for the timeline. optional
 * @param {Date}   end       The end date for the timeline. optional
 * @param {boolean} redraw   Optional. If true (default) the Timeline is
 *                           directly redrawn
 */
links.Timeline.prototype.setVisibleChartRange = function(start, end, redraw) {
    var range = {};
    if (!start || !end) {
        // retrieve the date range of the items
        range = this.getDataRange(true);
    }

    if (!start) {
        if (end) {
            if (range.min && range.min.valueOf() < end.valueOf()) {
                // start of the data
                start = range.min;
            }
            else {
                // 7 days before the end
                start = new Date(end.valueOf());
                start.setDate(start.getDate() - 7);
            }
        }
        else {
            // default of 3 days ago
            start = new Date();
            start.setDate(start.getDate() - 3);
        }
    }

    if (!end) {
        if (range.max) {
            // end of the data
            end = range.max;
        }
        else {
            // 7 days after start
            end = new Date(start.valueOf());
            end.setDate(end.getDate() + 7);
        }
    }

    // prevent start Date <= end Date
    if (end <= start) {
        end = new Date(start.valueOf());
        end.setDate(end.getDate() + 7);
    }

    // limit to the allowed range (don't let this do by applyRange,
    // because that method will try to maintain the interval (end-start)
    var min = this.options.min ? this.options.min : undefined; // date
    if (min != undefined && start.valueOf() < min.valueOf()) {
        start = new Date(min.valueOf()); // date
    }
    var max = this.options.max ? this.options.max : undefined; // date
    if (max != undefined && end.valueOf() > max.valueOf()) {
        end = new Date(max.valueOf()); // date
    }

    this.applyRange(start, end);

    if (redraw == undefined || redraw == true) {
        this.render({
            animate: false
        });  // TODO: optimize, no reflow needed
    }
    else {
        this.recalcConversion();
    }
};


/**
 * Change the visible chart range such that all items become visible
 */
links.Timeline.prototype.setVisibleChartRangeAuto = function() {
    var range = this.getDataRange(true);
    this.setVisibleChartRange(range.min, range.max);
};

/**
 * Adjust the visible range such that the current time is located in the center
 * of the timeline
 */
links.Timeline.prototype.setVisibleChartRangeNow = function() {
    var now = new Date();

    var diff = (this.end.valueOf() - this.start.valueOf());

    var startNew = new Date(now.valueOf() - diff/2);
    var endNew = new Date(startNew.valueOf() + diff);
    this.setVisibleChartRange(startNew, endNew);
};


/**
 * Retrieve the current visible range in the timeline.
 * @return {Object} An object with start and end properties
 */
links.Timeline.prototype.getVisibleChartRange = function() {
    return {
        'start': new Date(this.start.valueOf()),
        'end': new Date(this.end.valueOf())
    };
};

/**
 * Get the date range of the items.
 * @param {boolean} [withMargin]  If true, 5% of whitespace is added to the
 *                                left and right of the range. Default is false.
 * @return {Object} range    An object with parameters min and max.
 *                           - {Date} min is the lowest start date of the items
 *                           - {Date} max is the highest start or end date of the items
 *                           If no data is available, the values of min and max
 *                           will be undefined
 */
links.Timeline.prototype.getDataRange = function (withMargin) {
    var items = this.items,
        min = undefined, // number
        max = undefined; // number

    if (items) {
        for (var i = 0, iMax = items.length; i < iMax; i++) {
            var item = items[i],
                start = item.start != undefined ? item.start.valueOf() : undefined,
                end   = item.end != undefined   ? item.end.valueOf() : start;

            if (min != undefined && start != undefined) {
                min = Math.min(min.valueOf(), start.valueOf());
            }
            else {
                min = start;
            }

            if (max != undefined && end != undefined) {
                max = Math.max(max, end);
            }
            else {
                max = end;
            }
        }
    }

    if (min && max && withMargin) {
        // zoom out 5% such that you have a little white space on the left and right
        var diff = (max - min);
        min = min - diff * 0.05;
        max = max + diff * 0.05;
    }

    return {
        'min': min != undefined ? new Date(min) : undefined,
        'max': max != undefined ? new Date(max) : undefined
    };
};

/**
 * Re-render (reflow and repaint) all components of the Timeline: frame, axis,
 * items, ...
 * @param {Object} [options]  Available options:
 *                            {boolean} renderTimesLeft   Number of times the
 *                                                        render may be repeated
 *                                                        5 times by default.
 *                            {boolean} animate           takes options.animate
 *                                                        as default value
 */
links.Timeline.prototype.render = function(options) {
    var frameResized = this.reflowFrame();
    var axisResized = this.reflowAxis();
    var groupsResized = this.reflowGroups();
    var itemsResized = this.reflowItems();
    var resized = (frameResized || axisResized || groupsResized || itemsResized);

    // TODO: only stackEvents/filterItems when resized or changed. (gives a bootstrap issue).
    // if (resized) {
    var animate = this.options.animate;
    if (options && options.animate != undefined) {
        animate = options.animate;
    }

    this.recalcConversion();
    this.clusterItems();
    this.filterItems();
    this.stackItems(animate);

    this.recalcItems();

    // TODO: only repaint when resized or when filterItems or stackItems gave a change?
    var needsReflow = this.repaint();

    // re-render once when needed (prevent endless re-render loop)
    if (needsReflow) {
        var renderTimesLeft = options ? options.renderTimesLeft : undefined;
        if (renderTimesLeft == undefined) {
            renderTimesLeft = 5;
        }
        if (renderTimesLeft > 0) {
            this.render({
                'animate': options ? options.animate: undefined,
                'renderTimesLeft': (renderTimesLeft - 1)
            });
        }
    }
};

/**
 * Repaint all components of the Timeline
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */
links.Timeline.prototype.repaint = function() {
    var frameNeedsReflow = this.repaintFrame();
    var axisNeedsReflow  = this.repaintAxis();
    var groupsNeedsReflow  = this.repaintGroups();
    var itemsNeedsReflow = this.repaintItems();
    this.repaintCurrentTime();
    this.repaintCustomTime();

    return (frameNeedsReflow || axisNeedsReflow || groupsNeedsReflow || itemsNeedsReflow);
};

/**
 * Reflow the timeline frame
 * @return {boolean} resized    Returns true if any of the frame elements
 *                              have been resized.
 */
links.Timeline.prototype.reflowFrame = function() {
    var dom = this.dom,
        options = this.options,
        size = this.size,
        resized = false;

    // Note: IE7 has issues with giving frame.clientWidth, therefore I use offsetWidth instead
    var frameWidth  = dom.frame ? dom.frame.offsetWidth : 0,
        //ATLASSIAN - Needed for vertical scroll
        frameHeight = dom.frame ? dom.frame.children[0].clientHeight : 0;
        //END ATLASSIAN

    resized = resized || (size.frameWidth !== frameWidth);
    resized = resized || (size.frameHeight !== frameHeight);
    size.frameWidth = frameWidth;
    size.frameHeight = frameHeight;

    return resized;
};

/**
 * repaint the Timeline frame
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */
links.Timeline.prototype.repaintFrame = function() {
    var needsReflow = false,
        dom = this.dom,
        options = this.options,
        size = this.size;

    // main frame
    if (!dom.frame) {
        dom.frame = document.createElement("DIV");
        dom.frame.className = "timeline-frame";
        dom.frame.style.position = "relative";
        //ATLASSIAN - Allow vertical scrolling
        dom.frame.style.overflowX = "hidden";
        dom.frame.style.overflowY = "auto";
        //Alow vertical scrolling
        dom.container.appendChild(dom.frame);
        needsReflow = true;
    }

    var height = options.autoHeight ?
        (size.actualHeight + "px") :
        (options.height || "100%");
    var width  = options.width || "100%";
    needsReflow = needsReflow || (dom.frame.style.height != height);
    needsReflow = needsReflow || (dom.frame.style.width != width);
    //ATLASSIAN - For vertical scrolling set frame to set height.
    dom.frame.style.height = options.viewHeight ? options.viewHeight : height;
    //END ATLASSIAN
    dom.frame.style.width = width;

    // contents
    if (!dom.content) {
        // create content box where the axis and items will be created
        dom.content = document.createElement("DIV");
        dom.content.style.position = "relative";
        dom.content.style.overflow = "hidden";
        dom.frame.appendChild(dom.content);

        var timelines = document.createElement("DIV");
        timelines.style.position = "absolute";
        timelines.style.left = "0px";
        timelines.style.top = "0px";
        timelines.style.height = "100%";
        timelines.style.width = "0px";
        dom.content.appendChild(timelines);
        dom.contentTimelines = timelines;

        var params = this.eventParams,
            me = this;
        if (!params.onMouseDown) {
            params.onMouseDown = function (event) {me.onMouseDown(event);};
            links.Timeline.addEventListener(dom.content, "mousedown", params.onMouseDown);
        }
        if (!params.onTouchStart) {
            params.onTouchStart = function (event) {me.onTouchStart(event);};
            links.Timeline.addEventListener(dom.content, "touchstart", params.onTouchStart);
        }
        //ATLASSIAN - Disable mouse scroll
//        if (!params.onMouseWheel) {
//            params.onMouseWheel = function (event) {me.onMouseWheel(event);};
//            links.Timeline.addEventListener(dom.content, "mousewheel", params.onMouseWheel);
//        }
        //ATLASSIAN
        if (!params.onDblClick) {
            params.onDblClick = function (event) {me.onDblClick(event);};
            links.Timeline.addEventListener(dom.content, "dblclick", params.onDblClick);
        }

        needsReflow = true;
    }
    dom.content.style.left = size.contentLeft + "px";
    dom.content.style.top = "0px";
    dom.content.style.width = size.contentWidth + "px";
    //ATLASSIAN - Allow content height to be larger then frame height for vertical scrolling
    dom.content.style.height = height;
    //END ATLASSIAN

    this.repaintNavigation();
    //ATLASSIAN - Repaint the axis to keep it in the right place.
    this.reflowAxis();
    this.repaintAxis();
    //END ATLASSIAN

    return needsReflow;
};

/**
 * Reflow the timeline axis. Calculate its height, width, positioning, etc...
 * @return {boolean} resized    returns true if the axis is resized
 */
links.Timeline.prototype.reflowAxis = function() {
    var resized = false,
        dom = this.dom,
        options = this.options,
        size = this.size,
        axisDom = dom.axis;

    var characterMinorWidth  = (axisDom && axisDom.characterMinor) ? axisDom.characterMinor.clientWidth : 0,
        characterMinorHeight = (axisDom && axisDom.characterMinor) ? axisDom.characterMinor.clientHeight : 0,
        characterMajorWidth  = (axisDom && axisDom.characterMajor) ? axisDom.characterMajor.clientWidth : 0,
        characterMajorHeight = (axisDom && axisDom.characterMajor) ? axisDom.characterMajor.clientHeight : 0,
        axisHeight = (options.showMinorLabels ? characterMinorHeight : 0) +
            (options.showMajorLabels ? characterMajorHeight : 0);

    //ATLASSIAN - Needed for vertical scroll
    var frameHeight = dom.frame ? dom.frame.children[0].clientHeight : size.frameHeight;

    var axisTop  = options.axisOnTop ? 0 : frameHeight - axisHeight,
        axisLine = options.axisOnTop ? axisHeight : axisTop;
    //END ATLASSIAN

    resized = resized || (size.axis.top !== axisTop);
    resized = resized || (size.axis.line !== axisLine);
    resized = resized || (size.axis.height !== axisHeight);
    size.axis.top = axisTop;
    size.axis.line = axisLine;
    size.axis.height = axisHeight;
    size.axis.labelMajorTop = options.axisOnTop ? 0 : axisLine +
    (options.showMinorLabels ? characterMinorHeight : 0);
    size.axis.labelMinorTop = options.axisOnTop ?
        (options.showMajorLabels ? characterMajorHeight : 0) :
        axisLine;
    size.axis.lineMinorTop = options.axisOnTop ? size.axis.labelMinorTop : 0;
    size.axis.lineMinorHeight = options.showMajorLabels ?
    size.frameHeight - characterMajorHeight:
        size.frameHeight;
    if (axisDom && axisDom.minorLines && axisDom.minorLines.length) {
        size.axis.lineMinorWidth = axisDom.minorLines[0].offsetWidth;
    }
    else {
        size.axis.lineMinorWidth = 1;
    }
    if (axisDom && axisDom.majorLines && axisDom.majorLines.length) {
        size.axis.lineMajorWidth = axisDom.majorLines[0].offsetWidth;
    }
    else {
        size.axis.lineMajorWidth = 1;
    }

    resized = resized || (size.axis.characterMinorWidth  !== characterMinorWidth);
    resized = resized || (size.axis.characterMinorHeight !== characterMinorHeight);
    resized = resized || (size.axis.characterMajorWidth  !== characterMajorWidth);
    resized = resized || (size.axis.characterMajorHeight !== characterMajorHeight);
    size.axis.characterMinorWidth  = characterMinorWidth;
    size.axis.characterMinorHeight = characterMinorHeight;
    size.axis.characterMajorWidth  = characterMajorWidth;
    size.axis.characterMajorHeight = characterMajorHeight;

    var contentHeight = Math.max(size.frameHeight - axisHeight, 0);
    size.contentLeft = options.groupsOnRight ? 0 : size.groupsWidth;
    size.contentWidth = Math.max(size.frameWidth - size.groupsWidth, 0);
    size.contentHeight = contentHeight;

    size.axis.lineMinorHeight = contentHeight; //ATLASSIAN - We want to stop the grid line at the minor axis.

    return resized;
};

/**
 * Redraw the timeline axis with minor and major labels
 * @return {boolean} needsReflow     Returns true if the DOM is changed such
 *                                   that a reflow is needed.
 */
links.Timeline.prototype.repaintAxis = function() {
    var needsReflow = false,
        dom = this.dom,
        options = this.options,
        size = this.size,
        step = this.step;

    var axis = dom.axis;
    if (!axis) {
        axis = {};
        dom.axis = axis;
    }
    if (!size.axis.properties) {
        size.axis.properties = {};
    }
    if (!axis.minorTexts) {
        axis.minorTexts = [];
    }
    if (!axis.minorLines) {
        axis.minorLines = [];
    }
    if (!axis.majorTexts) {
        axis.majorTexts = [];
    }
    if (!axis.majorLines) {
        axis.majorLines = [];
    }

    if (!axis.frame) {
        axis.frame = document.createElement("DIV");
        axis.frame.style.position = "absolute";
        axis.frame.style.left = "0px";
        axis.frame.style.top = "0px";
        dom.content.appendChild(axis.frame);
    }

    // take axis offline
    dom.content.removeChild(axis.frame);

    axis.frame.style.width = (size.contentWidth) + "px";
    axis.frame.style.height = (size.axis.height) + "px";

    // the drawn axis is more wide than the actual visual part, such that
    // the axis can be dragged without having to redraw it each time again.
    var start = this.screenToTime(0);
    var end = this.screenToTime(size.contentWidth);

    // calculate minimum step (in milliseconds) based on character size
    if (size.axis.characterMinorWidth) {
        this.minimumStep = this.screenToTime(size.axis.characterMinorWidth * 6) -
        this.screenToTime(0);

        step.setRange(start, end, this.minimumStep);
    }

    var charsNeedsReflow = this.repaintAxisCharacters();
    needsReflow = needsReflow || charsNeedsReflow;

    // The current labels on the axis will be re-used (much better performance),
    // therefore, the repaintAxis method uses the mechanism with
    // repaintAxisStartOverwriting, repaintAxisEndOverwriting, and
    // this.size.axis.properties is used.
    this.repaintAxisStartOverwriting();

    step.start();
    var xFirstMajorLabel = undefined;
    var max = 0;
    while (!step.end() && max < 1000) {
        max++;
        var cur = step.getCurrent(),
            x = this.timeToScreen(cur),
            isMajor = step.isMajor();

        if (options.showMinorLabels) {
            this.repaintAxisMinorText(x, step.getLabelMinor(options));
        }

        if (isMajor && options.showMajorLabels) {
            if (x > 0) {
                if (xFirstMajorLabel == undefined) {
                    xFirstMajorLabel = x;
                }
                this.repaintAxisMajorText(x, step.getLabelMajor(options));
            }
            this.repaintAxisMajorLine(x);
        }
        else {
            this.repaintAxisMinorLine(x);
        }

        step.next();
    }

    // create a major label on the left when needed
    if (options.showMajorLabels) {
        var leftTime = this.screenToTime(0),
            leftText = this.step.getLabelMajor(options, leftTime),
            width = leftText.length * size.axis.characterMajorWidth + 10; // upper bound estimation

        if (xFirstMajorLabel == undefined || width < xFirstMajorLabel) {
            this.repaintAxisMajorText(0, leftText, leftTime);
        }
    }

    // cleanup left over labels
    this.repaintAxisEndOverwriting();

    this.repaintAxisHorizontal();

    // put axis online
    dom.content.insertBefore(axis.frame, dom.content.firstChild);

    return needsReflow;
};

/**
 * Create characters used to determine the size of text on the axis
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */
links.Timeline.prototype.repaintAxisCharacters = function () {
    // calculate the width and height of a single character
    // this is used to calculate the step size, and also the positioning of the
    // axis
    var needsReflow = false,
        dom = this.dom,
        axis = dom.axis,
        text;

    if (!axis.characterMinor) {
        text = document.createTextNode("0");
        var characterMinor = document.createElement("DIV");
        characterMinor.className = "timeline-axis-text timeline-axis-text-minor";
        characterMinor.appendChild(text);
        characterMinor.style.position = "absolute";
        characterMinor.style.visibility = "hidden";
        characterMinor.style.paddingLeft = "0px";
        characterMinor.style.paddingRight = "0px";
        axis.frame.appendChild(characterMinor);

        axis.characterMinor = characterMinor;
        needsReflow = true;
    }

    if (!axis.characterMajor) {
        text = document.createTextNode("0");
        var characterMajor = document.createElement("DIV");
        characterMajor.className = "timeline-axis-text timeline-axis-text-major";
        characterMajor.appendChild(text);
        characterMajor.style.position = "absolute";
        characterMajor.style.visibility = "hidden";
        characterMajor.style.paddingLeft = "0px";
        characterMajor.style.paddingRight = "0px";
        axis.frame.appendChild(characterMajor);

        axis.characterMajor = characterMajor;
        needsReflow = true;
    }

    return needsReflow;
};

/**
 * Initialize redraw of the axis. All existing labels and lines will be
 * overwritten and reused.
 */
links.Timeline.prototype.repaintAxisStartOverwriting = function () {
    var properties = this.size.axis.properties;

    properties.minorTextNum = 0;
    properties.minorLineNum = 0;
    properties.majorTextNum = 0;
    properties.majorLineNum = 0;
};

/**
 * End of overwriting HTML DOM elements of the axis.
 * remaining elements will be removed
 */
links.Timeline.prototype.repaintAxisEndOverwriting = function () {
    var dom = this.dom,
        props = this.size.axis.properties,
        frame = this.dom.axis.frame,
        num;

    // remove leftovers
    var minorTexts = dom.axis.minorTexts;
    num = props.minorTextNum;
    while (minorTexts.length > num) {
        var minorText = minorTexts[num];
        frame.removeChild(minorText);
        minorTexts.splice(num, 1);
    }

    var minorLines = dom.axis.minorLines;
    num = props.minorLineNum;
    while (minorLines.length > num) {
        var minorLine = minorLines[num];
        frame.removeChild(minorLine);
        minorLines.splice(num, 1);
    }

    var majorTexts = dom.axis.majorTexts;
    num = props.majorTextNum;
    while (majorTexts.length > num) {
        var majorText = majorTexts[num];
        frame.removeChild(majorText);
        majorTexts.splice(num, 1);
    }

    var majorLines = dom.axis.majorLines;
    num = props.majorLineNum;
    while (majorLines.length > num) {
        var majorLine = majorLines[num];
        frame.removeChild(majorLine);
        majorLines.splice(num, 1);
    }
};

/**
 * Repaint the horizontal line and background of the axis
 */
links.Timeline.prototype.repaintAxisHorizontal = function() {
    var axis = this.dom.axis,
        size = this.size,
        options = this.options;

    // line behind all axis elements (possibly having a background color)
    var hasAxis = (options.showMinorLabels || options.showMajorLabels);
    if (hasAxis) {
        if (!axis.backgroundLine) {
            // create the axis line background (for a background color or so)
            var backgroundLine = document.createElement("DIV");
            backgroundLine.className = "timeline-axis";
            backgroundLine.style.position = "absolute";
            backgroundLine.style.left = "0px";
            backgroundLine.style.width = "100%";
            backgroundLine.style.border = "none";
            axis.frame.insertBefore(backgroundLine, axis.frame.firstChild);

            axis.backgroundLine = backgroundLine;
        }

        if (axis.backgroundLine) {
            axis.backgroundLine.style.top = size.axis.top + "px";
            axis.backgroundLine.style.height = size.axis.height + "px";
        }
    }
    else {
        if (axis.backgroundLine) {
            axis.frame.removeChild(axis.backgroundLine);
            delete axis.backgroundLine;
        }
    }

    // line before all axis elements
    if (hasAxis) {
        if (axis.line) {
            // put this line at the end of all childs
            var line = axis.frame.removeChild(axis.line);
            axis.frame.appendChild(line);
        }
        else {
            // make the axis line
            var line = document.createElement("DIV");
            line.className = "timeline-axis";
            line.style.position = "absolute";
            line.style.left = "0px";
            line.style.width = "100%";
            line.style.height = "0px";
            axis.frame.appendChild(line);

            axis.line = line;
        }

        axis.line.style.top = size.axis.line + "px";
    }
    else {
        if (axis.line && axis.line.parentElement) {
            axis.frame.removeChild(axis.line);
            delete axis.line;
        }
    }
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 */
links.Timeline.prototype.repaintAxisMinorText = function (x, text) {
    var size = this.size,
        dom = this.dom,
        props = size.axis.properties,
        frame = dom.axis.frame,
        minorTexts = dom.axis.minorTexts,
        index = props.minorTextNum,
        label;

    if (index < minorTexts.length) {
        label = minorTexts[index]
    }
    else {
        // create new label
        var content = document.createTextNode("");
        label = document.createElement("DIV");
        label.appendChild(content);
        label.className = "timeline-axis-text timeline-axis-text-minor";
        label.style.position = "absolute";

        frame.appendChild(label);

        minorTexts.push(label);
    }

    label.childNodes[0].nodeValue = text;
    label.style.left = (x - 8) + "px"; //ATLASSIAN - we want to line up the date under the grid lines
    label.style.top  = size.axis.labelMinorTop + "px";
    //label.title = title;  // TODO: this is a heavy operation

    props.minorTextNum++;
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 */
links.Timeline.prototype.repaintAxisMinorLine = function (x) {
    var axis = this.size.axis,
        dom = this.dom,
        props = axis.properties,
        frame = dom.axis.frame,
        minorLines = dom.axis.minorLines,
        index = props.minorLineNum,
        line;

    if (index < minorLines.length) {
        line = minorLines[index];
    }
    else {
        // create vertical line
        line = document.createElement("DIV");
        line.className = "timeline-axis-grid timeline-axis-grid-minor";
        line.style.position = "absolute";
        line.style.width = "0px";

        frame.appendChild(line);
        minorLines.push(line);
    }

    line.style.top = axis.lineMinorTop + "px";
    line.style.height = axis.lineMinorHeight + "px";
    line.style.left = (x - axis.lineMinorWidth/2) + "px";

    props.minorLineNum++;
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 */
links.Timeline.prototype.repaintAxisMajorText = function (x, text) {
    var size = this.size,
        props = size.axis.properties,
        frame = this.dom.axis.frame,
        majorTexts = this.dom.axis.majorTexts,
        index = props.majorTextNum,
        label;

    if (index < majorTexts.length) {
        label = majorTexts[index];
    }
    else {
        // create label
        var content = document.createTextNode(text);
        label = document.createElement("DIV");
        label.className = "timeline-axis-text timeline-axis-text-major";
        label.appendChild(content);
        label.style.position = "absolute";
        label.style.top = "0px";

        frame.appendChild(label);
        majorTexts.push(label);
    }

    label.childNodes[0].nodeValue = text;
    label.style.top = size.axis.labelMajorTop + "px";
    label.style.left = x + "px";
    //label.title = title; // TODO: this is a heavy operation

    props.majorTextNum ++;
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 */
links.Timeline.prototype.repaintAxisMajorLine = function (x) {
    var size = this.size,
        props = size.axis.properties,
        axis = this.size.axis,
        frame = this.dom.axis.frame,
        majorLines = this.dom.axis.majorLines,
        index = props.majorLineNum,
        line;

    if (index < majorLines.length) {
        line = majorLines[index];
    }
    else {
        // create vertical line
        line = document.createElement("DIV");
        line.className = "timeline-axis-grid timeline-axis-grid-major";
        line.style.position = "absolute";
        line.style.top = "0px";
        line.style.width = "0px";

        frame.appendChild(line);
        majorLines.push(line);
    }

    line.style.left = (x - axis.lineMajorWidth/2) + "px";
    line.style.height = size.contentHeight + "px"; //ATLASSIAN We want the grid lines to stop at the minor axis7

    props.majorLineNum ++;
};

/**
 * Reflow all items, retrieve their actual size
 * @return {boolean} resized    returns true if any of the items is resized
 */
links.Timeline.prototype.reflowItems = function() {
    var resized = false,
        i,
        iMax,
        group,
        groups = this.groups,
        renderedItems = this.renderedItems;

    if (groups) { // TODO: need to check if labels exists?
        // loop through all groups to reset the items height
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        AJS.$.each(groups, function(groupIdx, group) {
            group.itemsHeight = 0;
        });
    }

    // loop through the width and height of all visible items
    for (i = 0, iMax = renderedItems.length; i < iMax; i++) {
        var item = renderedItems[i],
            domItem = item.dom;
        group = item.group;

        if (domItem) {
            // TODO: move updating width and height into item.reflow
            var width = domItem ? domItem.clientWidth : 0;
            var height = domItem ? domItem.clientHeight : 0;
            resized = resized || (item.width != width);
            resized = resized || (item.height != height);
            item.width = width;
            item.height = height;
            //item.borderWidth = (domItem.offsetWidth - domItem.clientWidth - 2) / 2; // TODO: borderWidth
            item.reflow();
        }

        if (group) {
            group.itemsHeight = group.itemsHeight ?
                Math.max(group.itemsHeight, item.height) :
                item.height;
        }
    }

    return resized;
};

/**
 * Recalculate item properties:
 * - the height of each group.
 * - the actualHeight, from the stacked items or the sum of the group heights
 * @return {boolean} resized    returns true if any of the items properties is
 *                              changed
 */
links.Timeline.prototype.recalcItems = function () {
    var resized = false,
        i,
        iMax,
        item,
        finalItem,
        finalItems,
        group,
        groups = this.groups,
        size = this.size,
        options = this.options,
        renderedItems = this.renderedItems;

    var actualHeight = 0;
    if (groups.length == 0) {
        // calculate actual height of the timeline when there are no groups
        // but stacked items
        if (options.autoHeight || options.cluster) {
            var min = 0,
                max = 0;

            if (this.stack && this.stack.finalItems) {
                // adjust the offset of all finalItems when the actualHeight has been changed
                finalItems = this.stack.finalItems;
                finalItem = finalItems[0];
                if (finalItem && finalItem.top) {
                    min = finalItem.top;
                    max = finalItem.top + finalItem.height;
                }
                for (i = 1, iMax = finalItems.length; i < iMax; i++) {
                    finalItem = finalItems[i];
                    min = Math.min(min, finalItem.top);
                    max = Math.max(max, finalItem.top + finalItem.height);
                }
            }
            else {
                item = renderedItems[0];
                if (item && item.top) {
                    min = item.top;
                    max = item.top + item.height;
                }
                for (i = 1, iMax = renderedItems.length; i < iMax; i++) {
                    item = renderedItems[i];
                    if (item.top) {
                        min = Math.min(min, item.top);
                        max = Math.max(max, (item.top + item.height));
                    }
                }
            }

            actualHeight = (max - min) + 2 * options.eventMarginAxis + size.axis.height;
            if (actualHeight < options.minHeight) {
                actualHeight = options.minHeight;
            }

            if (size.actualHeight != actualHeight && options.autoHeight && !options.axisOnTop) {
                // adjust the offset of all items when the actualHeight has been changed
                var diff = actualHeight - size.actualHeight;
                if (this.stack && this.stack.finalItems) {
                    finalItems = this.stack.finalItems;
                    for (i = 0, iMax = finalItems.length; i < iMax; i++) {
                        finalItems[i].top += diff;
                        finalItems[i].item.top += diff;
                    }
                }
                else {
                    for (i = 0, iMax = renderedItems.length; i < iMax; i++) {
                        renderedItems[i].top += diff;
                    }
                }
            }
        }
    }
    else {
        // loop through all groups to get the height of each group, and the
        // total height
        actualHeight = size.axis.height + 2 * options.eventMarginAxis;
        for (i = 0, iMax = groups.length; i < iMax; i++) {
            group = groups[i];

            var groupHeight = Math.max(group.labelHeight || 0, group.itemsHeight || 0);
            resized = resized || (groupHeight != group.height);
            group.height = groupHeight;

            actualHeight += groups[i].height + options.eventMargin;
        }

        // calculate top positions of the group labels and lines
        var eventMargin = options.eventMargin,
            top = options.axisOnTop ?
            options.eventMarginAxis + eventMargin/2 :
            size.contentHeight - options.eventMarginAxis + eventMargin/ 2,
            axisHeight = size.axis.height;

        for (i = 0, iMax = groups.length; i < iMax; i++) {
            group = groups[i];
            if (options.axisOnTop) {
                group.top = top + axisHeight;
                group.labelTop = top + axisHeight + (group.height - group.labelHeight) / 2;
                group.lineTop = top + axisHeight + group.height + eventMargin/2;
                top += group.height + eventMargin;
            }
            else {
                top -= group.height + eventMargin;
                group.top = top;
                group.labelTop = top + (group.height - group.labelHeight) / 2;
                group.lineTop = top - eventMargin/2;
            }
        }

        // calculate top position of the visible items
        for (i = 0, iMax = renderedItems.length; i < iMax; i++) {
            item = renderedItems[i];
            group = item.group;

            if (group) {
                item.top = group.top;
            }
        }

        resized = true;
    }

    if (actualHeight < options.minHeight) {
        actualHeight = options.minHeight;
    }
    resized = resized || (actualHeight != size.actualHeight);
    size.actualHeight = actualHeight;

    return resized;
};

/**
 * This method clears the (internal) array this.items in a safe way: neatly
 * cleaning up the DOM, and accompanying arrays this.renderedItems and
 * the created clusters.
 */
links.Timeline.prototype.clearItems = function() {
    // add all visible items to the list to be hidden
    var hideItems = this.renderQueue.hide;
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    AJS.$.each(this.renderedItems, function(itemIdx, item) {
        hideItems.push(item);
    });

    // clear the cluster generator
    this.clusterGenerator.clear();

    // actually clear the items
    this.items = [];
};

/**
 * Repaint all items
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */
links.Timeline.prototype.repaintItems = function() {
    var i, iMax, item, index;

    var needsReflow = false,
        dom = this.dom,
        size = this.size,
        timeline = this,
        renderedItems = this.renderedItems;

    if (!dom.items) {
        dom.items = {};
    }

    // draw the frame containing the items
    var frame = dom.items.frame;
    if (!frame) {
        frame = document.createElement("DIV");
        frame.style.position = "relative";
        dom.content.appendChild(frame);
        dom.items.frame = frame;
    }

    frame.style.left = "0px";
    frame.style.top = size.items.top + "px";
    frame.style.height = "0px";

    // Take frame offline (for faster manipulation of the DOM)
    dom.content.removeChild(frame);

    // process the render queue with changes
    var queue = this.renderQueue;
    var newImageUrls = [];
    needsReflow = needsReflow ||
    (queue.show.length > 0) ||
    (queue.update.length > 0) ||
    (queue.hide.length > 0);   // TODO: reflow needed on hide of items?

    while (item = queue.show.shift()) {
        item.showDOM(frame);
        item.getImageUrls(newImageUrls);
        renderedItems.push(item);
    }
    while (item = queue.update.shift()) {
        item.updateDOM(frame);
        item.getImageUrls(newImageUrls);
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        index = AJS.$.inArray(item, this.renderedItems);
//        index = this.renderedItems.indexOf(item);
        // END ATLASSIAN
        if (index == -1) {
            renderedItems.push(item);
        }
    }
    while (item = queue.hide.shift()) {
        item.hideDOM(frame);
        index = AJS.$.inArray(item, this.renderedItems);
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
//        index = this.renderedItems.indexOf(item);
        // END ATLASSIAN
        if (index != -1) {
            renderedItems.splice(index, 1);
        }
    }

    // reposition all visible items
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    AJS.$.each(renderedItems, function(itemIdx, item) {
        item.updatePosition(timeline);
    });
//    renderedItems.forEach(function (item) {
//        item.updatePosition(timeline);
//    });
    // END ATLASSIAN

    // redraw the delete button and dragareas of the selected item (if any)
    this.repaintDeleteButton();
    this.repaintDragAreas();

    // put frame online again
    dom.content.appendChild(frame);

    if (newImageUrls.length) {
        // retrieve all image sources from the items, and set a callback once
        // all images are retrieved
        var callback = function () {
            timeline.render();
        };
        var sendCallbackWhenAlreadyLoaded = false;
        links.imageloader.loadAll(newImageUrls, callback, sendCallbackWhenAlreadyLoaded);
    }

    return needsReflow;
};

/**
 * Reflow the size of the groups
 * @return {boolean} resized    Returns true if any of the frame elements
 *                              have been resized.
 */
links.Timeline.prototype.reflowGroups = function() {
    var resized = false,
        options = this.options,
        size = this.size,
        dom = this.dom;

    // calculate the groups width and height
    // TODO: only update when data is changed! -> use an updateSeq
    var groupsWidth = 0;

    // loop through all groups to get the labels width and height
    var groups = this.groups;
    var labels = this.dom.groups ? this.dom.groups.labels : [];
    for (var i = 0, iMax = groups.length; i < iMax; i++) {
        var group = groups[i];
        var label = labels[i];
        group.labelWidth  = label ? label.clientWidth : 0;
        group.labelHeight = label ? label.clientHeight : 0;
        group.width = group.labelWidth;  // TODO: group.width is redundant with labelWidth

        groupsWidth = Math.max(groupsWidth, group.width);
    }

    // limit groupsWidth to the groups width in the options
    if (options.groupsWidth !== undefined) {
        groupsWidth = dom.groups.frame ? dom.groups.frame.clientWidth : 0;
    }

    // compensate for the border width. TODO: calculate the real border width
    groupsWidth += 1;

    var groupsLeft = options.groupsOnRight ? size.frameWidth - groupsWidth : 0;
    resized = resized || (size.groupsWidth !== groupsWidth);
    resized = resized || (size.groupsLeft !== groupsLeft);
    size.groupsWidth = groupsWidth;
    size.groupsLeft = groupsLeft;

    return resized;
};

/**
 * Redraw the group labels
 */
links.Timeline.prototype.repaintGroups = function() {
    var dom = this.dom,
        timeline = this,
        options = this.options,
        size = this.size,
        groups = this.groups;

    if (dom.groups === undefined) {
        dom.groups = {};
    }

    var labels = dom.groups.labels;
    if (!labels) {
        labels = [];
        dom.groups.labels = labels;
    }
    var labelLines = dom.groups.labelLines;
    if (!labelLines) {
        labelLines = [];
        dom.groups.labelLines = labelLines;
    }
    var itemLines = dom.groups.itemLines;
    if (!itemLines) {
        itemLines = [];
        dom.groups.itemLines = itemLines;
    }

    // create the frame for holding the groups
    var frame = dom.groups.frame;
    if (!frame) {
        frame =  document.createElement("DIV");
        frame.className = "timeline-groups-axis";
        frame.style.position = "absolute";
        frame.style.overflow = "hidden";
        frame.style.top = "0px";
        frame.style.height = "100%";

        dom.frame.appendChild(frame);
        dom.groups.frame = frame;
    }

    frame.style.left = size.groupsLeft + "px";
    frame.style.width = (options.groupsWidth !== undefined) ?
        options.groupsWidth :
    size.groupsWidth + "px";

    // hide groups axis when there are no groups
    if (groups.length == 0) {
        frame.style.display = 'none';
    }
    else {
        frame.style.display = '';
    }

    // TODO: only create/update groups when data is changed.

    // create the items
    var current = labels.length,
        needed = groups.length;

    // overwrite existing group labels
    for (var i = 0, iMax = Math.min(current, needed); i < iMax; i++) {
        var group = groups[i];
        var label = labels[i];
        label.innerHTML = this.getGroupName(group);
        label.style.display = '';
    }

    // append new items when needed
    for (var i = current; i < needed; i++) {
        var group = groups[i];

        // create text label
        var label = document.createElement("DIV");
        label.className = "timeline-groups-text";
        label.style.position = "absolute";
        if (options.groupsWidth === undefined) {
            label.style.whiteSpace = "nowrap";
        }
        label.innerHTML = this.getGroupName(group);
        frame.appendChild(label);
        labels[i] = label;

        // create the grid line between the group labels
        var labelLine = document.createElement("DIV");
        labelLine.className = "timeline-axis-grid timeline-axis-grid-minor";
        labelLine.style.position = "absolute";
        labelLine.style.left = "0px";
        labelLine.style.width = "100%";
        labelLine.style.height = "0px";
        labelLine.style.borderTopStyle = "solid";
        frame.appendChild(labelLine);
        labelLines[i] = labelLine;

        // create the grid line between the items
        var itemLine = document.createElement("DIV");
        itemLine.className = "timeline-axis-grid timeline-axis-grid-minor";
        itemLine.style.position = "absolute";
        itemLine.style.left = "0px";
        itemLine.style.width = "100%";
        itemLine.style.height = "0px";
        itemLine.style.borderTopStyle = "solid";
        dom.content.insertBefore(itemLine, dom.content.firstChild);
        itemLines[i] = itemLine;
    }

    // remove redundant items from the DOM when needed
    for (var i = needed; i < current; i++) {
        var label = labels[i],
            labelLine = labelLines[i],
            itemLine = itemLines[i];

        frame.removeChild(label);
        frame.removeChild(labelLine);
        dom.content.removeChild(itemLine);
    }
    labels.splice(needed, current - needed);
    labelLines.splice(needed, current - needed);
    itemLines.splice(needed, current - needed);

    frame.style.borderStyle = options.groupsOnRight ?
        "none none none solid" :
        "none solid none none";

    // position the groups
    for (var i = 0, iMax = groups.length; i < iMax; i++) {
        var group = groups[i],
            label = labels[i],
            labelLine = labelLines[i],
            itemLine = itemLines[i];

        label.style.top = group.labelTop + "px";
        labelLine.style.top = group.lineTop + "px";
        itemLine.style.top = group.lineTop + "px";
        itemLine.style.width = size.contentWidth + "px";
    }

    if (!dom.groups.background) {
        // create the axis grid line background
        var background = document.createElement("DIV");
        background.className = "timeline-axis";
        background.style.position = "absolute";
        background.style.left = "0px";
        background.style.width = "100%";
        background.style.border = "none";

        frame.appendChild(background);
        dom.groups.background = background;
    }
    dom.groups.background.style.top = size.axis.top + 'px';
    dom.groups.background.style.height = size.axis.height + 'px';

    if (!dom.groups.line) {
        // create the axis grid line
        var line = document.createElement("DIV");
        line.className = "timeline-axis";
        line.style.position = "absolute";
        line.style.left = "0px";
        line.style.width = "100%";
        line.style.height = "0px";

        frame.appendChild(line);
        dom.groups.line = line;
    }
    dom.groups.line.style.top = size.axis.line + 'px';

    // create a callback when there are images which are not yet loaded
    // TODO: more efficiently load images in the groups
    if (dom.groups.frame && groups.length) {
        var imageUrls = [];
        links.imageloader.filterImageUrls(dom.groups.frame, imageUrls);
        if (imageUrls.length) {
            // retrieve all image sources from the items, and set a callback once
            // all images are retrieved
            var callback = function () {
                timeline.render();
            };
            var sendCallbackWhenAlreadyLoaded = false;
            links.imageloader.loadAll(imageUrls, callback, sendCallbackWhenAlreadyLoaded);
        }
    }
};


/**
 * Redraw the current time bar
 */
links.Timeline.prototype.repaintCurrentTime = function() {
    var options = this.options,
        dom = this.dom,
        size = this.size;

    if (!options.showCurrentTime) {
        if (dom.currentTime) {
            dom.contentTimelines.removeChild(dom.currentTime);
            delete dom.currentTime;
        }

        return;
    }

    if (!dom.currentTime) {
        // create the current time bar
        var currentTime = document.createElement("DIV");
        currentTime.className = "timeline-currenttime";
        currentTime.style.position = "absolute";
        currentTime.style.top = "0px";
        currentTime.style.height = "100%";

        dom.contentTimelines.appendChild(currentTime);
        dom.currentTime = currentTime;
    //Start ATLASSIAN - We want to recalculate the height of currentTime after the minor axis is rendered so we can stop
    //the line at the minor axis.
    } else {
        dom.currentTime.style.height = size.contentHeight + "px";
    }
    //END ATLASSIAN

    var now = new Date();
    var nowOffset = new Date(now.valueOf() + this.clientTimeOffset);
    var x = this.timeToScreen(nowOffset);

    var visible = (x > -size.contentWidth && x < 2 * size.contentWidth);
    dom.currentTime.style.display = visible ? '' : 'none';
    dom.currentTime.style.left = x + "px";
    dom.currentTime.title = "Current time: " + nowOffset;

    // start a timer to adjust for the new time
    if (this.currentTimeTimer != undefined) {
        clearTimeout(this.currentTimeTimer);
        delete this.currentTimeTimer;
    }
    var timeline = this;
    var onTimeout = function() {
        timeline.repaintCurrentTime();
    };
    // the time equal to the width of one pixel, divided by 2 for more smoothness
    var interval = 1 / this.conversion.factor / 2;
    if (interval < 30) interval = 30;
    this.currentTimeTimer = setTimeout(onTimeout, interval);
};

/**
 * Redraw the custom time bar
 */
links.Timeline.prototype.repaintCustomTime = function() {
    var options = this.options,
        dom = this.dom,
        size = this.size;

    if (!options.showCustomTime) {
        if (dom.customTime) {
            dom.contentTimelines.removeChild(dom.customTime);
            delete dom.customTime;
        }

        return;
    }

    if (!dom.customTime) {
        var customTime = document.createElement("DIV");
        customTime.className = "timeline-customtime";
        customTime.style.position = "absolute";
        customTime.style.top = "0px";
        customTime.style.height = "100%";

        var drag = document.createElement("DIV");
        drag.style.position = "relative";
        drag.style.top = "0px";
        drag.style.left = "-10px";
        drag.style.height = "100%";
        drag.style.width = "20px";
        customTime.appendChild(drag);

        dom.contentTimelines.appendChild(customTime);
        dom.customTime = customTime;

        // initialize parameter
        this.customTime = new Date();
    }

    var x = this.timeToScreen(this.customTime),
        visible = (x > -size.contentWidth && x < 2 * size.contentWidth);
    dom.customTime.style.display = visible ? '' : 'none';
    dom.customTime.style.left = x + "px";
    dom.customTime.title = "Time: " + this.customTime;
};


/**
 * Redraw the delete button, on the top right of the currently selected item
 * if there is no item selected, the button is hidden.
 */
links.Timeline.prototype.repaintDeleteButton = function () {
    var timeline = this,
        dom = this.dom,
        frame = dom.items.frame;

    var deleteButton = dom.items.deleteButton;
    if (!deleteButton) {
        // create a delete button
        deleteButton = document.createElement("DIV");
        deleteButton.className = "timeline-navigation-delete";
        deleteButton.style.position = "absolute";

        frame.appendChild(deleteButton);
        dom.items.deleteButton = deleteButton;
    }

    var index = this.selection ? this.selection.index : -1,
        item = this.selection ? this.items[index] : undefined;
    if (item && item.rendered && this.isEditable(item)) {
        var right = item.getRight(this),
            top = item.top;

        deleteButton.style.left = right + 'px';
        deleteButton.style.top = top + 'px';
        deleteButton.style.display = '';
        frame.removeChild(deleteButton);
        frame.appendChild(deleteButton);
    }
    else {
        deleteButton.style.display = 'none';
    }
};


/**
 * Redraw the drag areas. When an item (ranges only) is selected,
 * it gets a drag area on the left and right side, to change its width
 */
links.Timeline.prototype.repaintDragAreas = function () {
    var timeline = this,
        options = this.options,
        dom = this.dom,
        frame = this.dom.items.frame;

    // create left drag area
    var dragLeft = dom.items.dragLeft;
    if (!dragLeft) {
        dragLeft = document.createElement("DIV");
        dragLeft.className="timeline-event-range-drag-left";
        dragLeft.style.position = "absolute";

        frame.appendChild(dragLeft);
        dom.items.dragLeft = dragLeft;
    }

    // create right drag area
    var dragRight = dom.items.dragRight;
    if (!dragRight) {
        dragRight = document.createElement("DIV");
        dragRight.className="timeline-event-range-drag-right";
        dragRight.style.position = "absolute";

        frame.appendChild(dragRight);
        dom.items.dragRight = dragRight;
    }

    // reposition left and right drag area
    var index = this.selection ? this.selection.index : -1,
        item = this.selection ? this.items[index] : undefined;
    if (item && item.rendered && this.isEditable(item) &&
        (item instanceof links.Timeline.ItemRange)) {
        var left = this.timeToScreen(item.start),
            right = this.timeToScreen(item.end),
            top = item.top,
            height = item.height;

        dragLeft.style.left = left + 'px';
        dragLeft.style.top = top + 'px';
        dragLeft.style.width = options.dragAreaWidth + "px";
        dragLeft.style.height = height + 'px';
        dragLeft.style.display = '';
        frame.removeChild(dragLeft);
        frame.appendChild(dragLeft);

        dragRight.style.left = (right - options.dragAreaWidth) + 'px';
        dragRight.style.top = top + 'px';
        dragRight.style.width = options.dragAreaWidth + "px";
        dragRight.style.height = height + 'px';
        dragRight.style.display = '';
        frame.removeChild(dragRight);
        frame.appendChild(dragRight);
    }
    else {
        dragLeft.style.display = 'none';
        dragRight.style.display = 'none';
    }
};

/**
 * Create the navigation buttons for zooming and moving
 */
links.Timeline.prototype.repaintNavigation = function () {
    var timeline = this,
        options = this.options,
        dom = this.dom,
        frame = dom.frame,
        navBar = dom.navBar;

    if (!navBar) {
        var showButtonNew = options.showButtonNew && options.editable;
        var showNavigation = options.showNavigation && (options.zoomable || options.moveable);
        if (showNavigation || showButtonNew) {
            // create a navigation bar containing the navigation buttons
            navBar = document.createElement("DIV");
            navBar.style.position = "absolute";
            navBar.className = "timeline-navigation";
            if (options.groupsOnRight) {
                navBar.style.left = '10px';
            }
            else {
                //ATLASSIAN
                navBar.style.right = '32px';
                //END ATLASSIAN
            }
            if (options.axisOnTop) {
                navBar.style.bottom = '10px';
            }
            else {
                navBar.style.top = '10px';
            }
            dom.navBar = navBar;
            //ATLASSIAN - Append to the container, so the control float over the timeline
            dom.container.appendChild(navBar);
            //END ATLASSIAN
        }

        if (showButtonNew) {
            // create a new in button
            navBar.addButton = document.createElement("DIV");
            navBar.addButton.className = "timeline-navigation-new";

            navBar.addButton.title = options.CREATE_NEW_EVENT;
            var onAdd = function(event) {
                links.Timeline.preventDefault(event);
                links.Timeline.stopPropagation(event);

                // create a new event at the center of the frame
                var w = timeline.size.contentWidth;
                var x = w / 2;
                var xstart = timeline.screenToTime(x - w / 10); // subtract 10% of timeline width
                var xend = timeline.screenToTime(x + w / 10);   // add 10% of timeline width
                if (options.snapEvents) {
                    timeline.step.snap(xstart);
                    timeline.step.snap(xend);
                }

                var content = options.NEW;
                var group = timeline.groups.length ? timeline.groups[0].content : undefined;
                var preventRender = true;
                timeline.addItem({
                    'start': xstart,
                    'end': xend,
                    'content': content,
                    'group': group
                }, preventRender);
                var index = (timeline.items.length - 1);
                timeline.selectItem(index);

                timeline.applyAdd = true;

                // fire an add event.
                // Note that the change can be canceled from within an event listener if
                // this listener calls the method cancelAdd().
                timeline.trigger('add');

                if (timeline.applyAdd) {
                    // render and select the item
                    timeline.render({animate: false});
                    timeline.selectItem(index);
                }
                else {
                    // undo an add
                    timeline.deleteItem(index);
                }
            };
            links.Timeline.addEventListener(navBar.addButton, "mousedown", onAdd);
            navBar.appendChild(navBar.addButton);
        }

        if (showButtonNew && showNavigation) {
            // create a separator line
            navBar.addButton.style.borderRightWidth = "1px";
            navBar.addButton.style.borderRightStyle = "solid";
        }

        if (showNavigation) {
            if (options.zoomable) {
                // create a zoom in button
                navBar.zoomInButton = document.createElement("DIV");
                navBar.zoomInButton.className = "timeline-navigation-zoom-in";
                navBar.zoomInButton.title = this.options.ZOOM_IN;
                var onZoomIn = function(event) {
                    links.Timeline.preventDefault(event);
                    links.Timeline.stopPropagation(event);
                    timeline.zoom(0.4);
                    timeline.trigger("rangechange");
                    timeline.trigger("rangechanged");
                };
                links.Timeline.addEventListener(navBar.zoomInButton, "mousedown", onZoomIn);
                navBar.appendChild(navBar.zoomInButton);

                // create a zoom out button
                navBar.zoomOutButton = document.createElement("DIV");
                navBar.zoomOutButton.className = "timeline-navigation-zoom-out";
                navBar.zoomOutButton.title = this.options.ZOOM_OUT;
                var onZoomOut = function(event) {
                    links.Timeline.preventDefault(event);
                    links.Timeline.stopPropagation(event);
                    timeline.zoom(-0.4);
                    timeline.trigger("rangechange");
                    timeline.trigger("rangechanged");
                };
                links.Timeline.addEventListener(navBar.zoomOutButton, "mousedown", onZoomOut);
                navBar.appendChild(navBar.zoomOutButton);
            }

            if (options.moveable) {
                // create a move left button
                navBar.moveLeftButton = document.createElement("DIV");
                navBar.moveLeftButton.className = "timeline-navigation-move-left";
                navBar.moveLeftButton.title = this.options.MOVE_LEFT;
                var onMoveLeft = function(event) {
                    links.Timeline.preventDefault(event);
                    links.Timeline.stopPropagation(event);
                    timeline.move(-0.2);
                    timeline.trigger("rangechange");
                    timeline.trigger("rangechanged");
                };
                links.Timeline.addEventListener(navBar.moveLeftButton, "mousedown", onMoveLeft);
                navBar.appendChild(navBar.moveLeftButton);

                // create a move right button
                navBar.moveRightButton = document.createElement("DIV");
                navBar.moveRightButton.className = "timeline-navigation-move-right";
                navBar.moveRightButton.title = this.options.MOVE_RIGHT;
                var onMoveRight = function(event) {
                    links.Timeline.preventDefault(event);
                    links.Timeline.stopPropagation(event);
                    timeline.move(0.2);
                    timeline.trigger("rangechange");
                    timeline.trigger("rangechanged");
                };
                links.Timeline.addEventListener(navBar.moveRightButton, "mousedown", onMoveRight);
                navBar.appendChild(navBar.moveRightButton);
            }
        }
    }
};


/**
 * Set current time. This function can be used to set the time in the client
 * timeline equal with the time on a server.
 * @param {Date} time
 */
links.Timeline.prototype.setCurrentTime = function(time) {
    var now = new Date();
    this.clientTimeOffset = (time.valueOf() - now.valueOf());

    this.repaintCurrentTime();
};

/**
 * Get current time. The time can have an offset from the real time, when
 * the current time has been changed via the method setCurrentTime.
 * @return {Date} time
 */
links.Timeline.prototype.getCurrentTime = function() {
    var now = new Date();
    return new Date(now.valueOf() + this.clientTimeOffset);
};


/**
 * Set custom time.
 * The custom time bar can be used to display events in past or future.
 * @param {Date} time
 */
links.Timeline.prototype.setCustomTime = function(time) {
    this.customTime = new Date(time.valueOf());
    this.repaintCustomTime();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
links.Timeline.prototype.getCustomTime = function() {
    return new Date(this.customTime.valueOf());
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale(SCALE.MINUTES, 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {links.Timeline.StepDate.SCALE} scale
 *                               A scale. Choose from SCALE.MILLISECOND,
 *                               SCALE.SECOND, SCALE.MINUTE, SCALE.HOUR,
 *                               SCALE.WEEKDAY, SCALE.DAY, SCALE.MONTH,
 *                               SCALE.YEAR.
 * @param {int}        step   A step size, by default 1. Choose for
 *                               example 1, 2, 5, or 10.
 */
links.Timeline.prototype.setScale = function(scale, step) {
    this.step.setScale(scale, step);
    this.render(); // TODO: optimize: only reflow/repaint axis
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true or not defined, autoscaling is enabled.
 *                          If false, autoscaling is disabled.
 */
links.Timeline.prototype.setAutoScale = function(enable) {
    this.step.setAutoScale(enable);
    this.render(); // TODO: optimize: only reflow/repaint axis
};

/**
 * Redraw the timeline
 * Reloads the (linked) data table and redraws the timeline when resized.
 * See also the method checkResize
 */
links.Timeline.prototype.redraw = function() {
    this.setData(this.data);
};


/**
 * Check if the timeline is resized, and if so, redraw the timeline.
 * Useful when the webpage is resized.
 */
links.Timeline.prototype.checkResize = function() {
    // TODO: re-implement the method checkResize, or better, make it redundant as this.render will be smarter
    this.render();
};

/**
 * Check whether a given item is editable
 * @param {links.Timeline.Item} item
 * @return {boolean} editable
 */
links.Timeline.prototype.isEditable = function (item) {
    if (item) {
        if (item.editable != undefined) {
            return item.editable;
        }
        else {
            return this.options.editable;
        }
    }
    return false;
};

/**
 * Calculate the factor and offset to convert a position on screen to the
 * corresponding date and vice versa.
 * After the method calcConversionFactor is executed once, the methods screenToTime and
 * timeToScreen can be used.
 */
links.Timeline.prototype.recalcConversion = function() {
    this.conversion.offset = this.start.valueOf();
    this.conversion.factor = this.size.contentWidth /
    (this.end.valueOf() - this.start.valueOf());
};


/**
 * Convert a position on screen (pixels) to a datetime
 * Before this method can be used, the method calcConversionFactor must be
 * executed once.
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 */
links.Timeline.prototype.screenToTime = function(x) {
    var conversion = this.conversion;
    return new Date(x / conversion.factor + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * Before this method can be used, the method calcConversionFactor must be
 * executed once.
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 */
links.Timeline.prototype.timeToScreen = function(time) {
    var conversion = this.conversion;
    return (time.valueOf() - conversion.offset) * conversion.factor;
};



/**
 * Event handler for touchstart event on mobile devices
 */
links.Timeline.prototype.onTouchStart = function(event) {
    var params = this.eventParams,
        me = this;

    if (params.touchDown) {
        // if already moving, return
        return;
    }

    params.touchDown = true;
    params.zoomed = false;

    this.onMouseDown(event);

    if (!params.onTouchMove) {
        params.onTouchMove = function (event) {me.onTouchMove(event);};
        links.Timeline.addEventListener(document, "touchmove", params.onTouchMove);
    }
    if (!params.onTouchEnd) {
        params.onTouchEnd  = function (event) {me.onTouchEnd(event);};
        links.Timeline.addEventListener(document, "touchend",  params.onTouchEnd);
    }

    /* TODO
     // check for double tap event
     var delta = 500; // ms
     var doubleTapStart = (new Date()).valueOf();
     var target = links.Timeline.getTarget(event);
     var doubleTapItem = this.getItemIndex(target);
     if (params.doubleTapStart &&
     (doubleTapStart - params.doubleTapStart) < delta &&
     doubleTapItem == params.doubleTapItem) {
     delete params.doubleTapStart;
     delete params.doubleTapItem;
     me.onDblClick(event);
     params.touchDown = false;
     }
     params.doubleTapStart = doubleTapStart;
     params.doubleTapItem = doubleTapItem;
     */
    // store timing for double taps
    var target = links.Timeline.getTarget(event);
    var item = this.getItemIndex(target);
    params.doubleTapStartPrev = params.doubleTapStart;
    params.doubleTapStart = (new Date()).valueOf();
    params.doubleTapItemPrev = params.doubleTapItem;
    params.doubleTapItem = item;

    links.Timeline.preventDefault(event);
};

/**
 * Event handler for touchmove event on mobile devices
 */
links.Timeline.prototype.onTouchMove = function(event) {
    var params = this.eventParams;

    if (event.scale && event.scale !== 1) {
        params.zoomed = true;
    }

    if (!params.zoomed) {
        // move
        this.onMouseMove(event);
    }
    else {
        if (this.options.zoomable) {
            // pinch
            // TODO: pinch only supported on iPhone/iPad. Create something manually for Android?
            params.zoomed = true;

            var scale = event.scale,
                oldWidth = (params.end.valueOf() - params.start.valueOf()),
                newWidth = oldWidth / scale,
                diff = newWidth - oldWidth,
                start = new Date(parseInt(params.start.valueOf() - diff/2)),
                end = new Date(parseInt(params.end.valueOf() + diff/2));

            // TODO: determine zoom-around-date from touch positions?

            this.setVisibleChartRange(start, end);
            this.trigger("rangechange");
        }
    }

    links.Timeline.preventDefault(event);
};

/**
 * Event handler for touchend event on mobile devices
 */
links.Timeline.prototype.onTouchEnd = function(event) {
    var params = this.eventParams;
    var me = this;
    params.touchDown = false;

    if (params.zoomed) {
        this.trigger("rangechanged");
    }

    if (params.onTouchMove) {
        links.Timeline.removeEventListener(document, "touchmove", params.onTouchMove);
        delete params.onTouchMove;

    }
    if (params.onTouchEnd) {
        links.Timeline.removeEventListener(document, "touchend",  params.onTouchEnd);
        delete params.onTouchEnd;
    }

    this.onMouseUp(event);

    // check for double tap event
    var delta = 500; // ms
    var doubleTapEnd = (new Date()).valueOf();
    var target = links.Timeline.getTarget(event);
    var doubleTapItem = this.getItemIndex(target);
    if (params.doubleTapStartPrev &&
        (doubleTapEnd - params.doubleTapStartPrev) < delta &&
        params.doubleTapItem == params.doubleTapItemPrev) {
        params.touchDown = true;
        me.onDblClick(event);
        params.touchDown = false;
    }

    links.Timeline.preventDefault(event);
};


/**
 * Start a moving operation inside the provided parent element
 * @param {Event} event       The event that occurred (required for
 *                             retrieving the  mouse position)
 */
links.Timeline.prototype.onMouseDown = function(event) {
    event = event || window.event;

    var params = this.eventParams,
        options = this.options,
        dom = this.dom;

    // only react on left mouse button down
    var leftButtonDown = event.which ? (event.which == 1) : (event.button == 1);
    if (!leftButtonDown && !params.touchDown) {
        return;
    }

    // get mouse position
    params.mouseX = links.Timeline.getPageX(event);
    params.mouseY = links.Timeline.getPageY(event);
    params.frameLeft = links.Timeline.getAbsoluteLeft(this.dom.content);
    params.frameTop = links.Timeline.getAbsoluteTop(this.dom.content);
    params.previousLeft = 0;
    params.previousOffset = 0;

    params.moved = false;
    params.start = new Date(this.start.valueOf());
    params.end = new Date(this.end.valueOf());

    params.target = links.Timeline.getTarget(event);
    var dragLeft = (dom.items && dom.items.dragLeft) ? dom.items.dragLeft : undefined;
    var dragRight = (dom.items && dom.items.dragRight) ? dom.items.dragRight : undefined;
    params.itemDragLeft = (params.target === dragLeft);
    params.itemDragRight = (params.target === dragRight);

    if (params.itemDragLeft || params.itemDragRight) {
        params.itemIndex = this.selection ? this.selection.index : undefined;
    }
    else {
        params.itemIndex = this.getItemIndex(params.target);
    }

    params.customTime = (params.target === dom.customTime ||
    params.target.parentNode === dom.customTime) ?
        this.customTime :
        undefined;

    params.addItem = (options.editable && event.ctrlKey);
    if (params.addItem) {
        // create a new event at the current mouse position
        var x = params.mouseX - params.frameLeft;
        var y = params.mouseY - params.frameTop;

        var xstart = this.screenToTime(x);
        if (options.snapEvents) {
            this.step.snap(xstart);
        }
        var xend = new Date(xstart.valueOf());
        var content = options.NEW;
        var group = this.getGroupFromHeight(y);
        this.addItem({
            'start': xstart,
            'end': xend,
            'content': content,
            'group': this.getGroupName(group)
        });
        params.itemIndex = (this.items.length - 1);
        this.selectItem(params.itemIndex);
        params.itemDragRight = true;
    }

    var item = this.items[params.itemIndex];
    var isSelected = this.isSelected(params.itemIndex);
    params.editItem = isSelected && this.isEditable(item);
    if (params.editItem) {
        params.itemStart = item.start;
        params.itemEnd = item.end;
        params.itemGroup = item.group;
        params.itemLeft = item.start ? this.timeToScreen(item.start) : undefined;
        params.itemRight = item.end ? this.timeToScreen(item.end) : undefined;
    }
    else {
        this.dom.frame.style.cursor = 'move';
    }
    if (!params.touchDown) {
        // add event listeners to handle moving the contents
        // we store the function onmousemove and onmouseup in the timeline, so we can
        // remove the eventlisteners lateron in the function mouseUp()
        var me = this;
        if (!params.onMouseMove) {
            params.onMouseMove = function (event) {me.onMouseMove(event);};
            links.Timeline.addEventListener(document, "mousemove", params.onMouseMove);
        }
        if (!params.onMouseUp) {
            params.onMouseUp = function (event) {me.onMouseUp(event);};
            links.Timeline.addEventListener(document, "mouseup", params.onMouseUp);
        }

        links.Timeline.preventDefault(event);
    }
};


/**
 * Perform moving operating.
 * This function activated from within the funcion links.Timeline.onMouseDown().
 * @param {Event}   event  Well, eehh, the event
 */
links.Timeline.prototype.onMouseMove = function (event) {
    event = event || window.event;

    var params = this.eventParams,
        size = this.size,
        dom = this.dom,
        options = this.options;

    // calculate change in mouse position
    var mouseX = links.Timeline.getPageX(event);
    var mouseY = links.Timeline.getPageY(event);

    if (params.mouseX == undefined) {
        params.mouseX = mouseX;
    }
    if (params.mouseY == undefined) {
        params.mouseY = mouseY;
    }

    var diffX = mouseX - params.mouseX;
    var diffY = mouseY - params.mouseY;

    // if mouse movement is big enough, register it as a "moved" event
    if (Math.abs(diffX) >= 1) {
        params.moved = true;
    }

    if (params.customTime) {
        var x = this.timeToScreen(params.customTime);
        var xnew = x + diffX;
        this.customTime = this.screenToTime(xnew);
        this.repaintCustomTime();

        // fire a timechange event
        this.trigger('timechange');
    }
    else if (params.editItem) {
        //ATLASSIAN
        this.trigger("moved");
        //END ATLASSIAN
        var item = this.items[params.itemIndex],
            left,
            right;

        if (params.itemDragLeft) {
            // move the start of the item
            left = params.itemLeft + diffX;
            right = params.itemRight;

            item.start = this.screenToTime(left);
            if (options.snapEvents) {
                this.step.snap(item.start);
                left = this.timeToScreen(item.start);
            }

            if (left > right) {
                left = right;
                item.start = this.screenToTime(left);
            }
        }
        else if (params.itemDragRight) {
            // move the end of the item
            left = params.itemLeft;
            right = params.itemRight + diffX;

            item.end = this.screenToTime(right);
            if (options.snapEvents) {
                this.step.snap(item.end);
                right = this.timeToScreen(item.end);
            }

            if (right < left) {
                right = left;
                item.end = this.screenToTime(right);
            }
        }
        else {
            // move the item
            left = params.itemLeft + diffX;
            item.start = this.screenToTime(left);
            if (options.snapEvents) {
                this.step.snap(item.start);
                left = this.timeToScreen(item.start);
            }

            if (item.end) {
                right = left + (params.itemRight - params.itemLeft);
                item.end = this.screenToTime(right);
            }
        }

        item.setPosition(left, right);

        var dragging = params.itemDragLeft || params.itemDragRight;
        if (this.groups.length && !dragging) {
            // move item from one group to another when needed
            var y = mouseY - params.frameTop;
            var group = this.getGroupFromHeight(y);
            if (options.groupsChangeable && item.group !== group) {
                // move item to the other group
                // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
                var index = AJS.$.inArray(item, this.items);
//                var index = this.items.indexOf(item);
                // END ATLASSIAN
                this.changeItem(index, {'group': this.getGroupName(group)});
            }
            else {
                this.repaintDeleteButton();
                this.repaintDragAreas();
            }
        }
        else {
            // TODO: does not work well in FF, forces redraw with every mouse move it seems
            this.render(); // TODO: optimize, only redraw the items?
            // Note: when animate==true, no redraw is needed here, its done by stackItems animation
        }
    }
    else if (options.moveable) {
        var interval = (params.end.valueOf() - params.start.valueOf());
        var diffMillisecs = Math.round((-diffX) / size.contentWidth * interval);
        var newStart = new Date(params.start.valueOf() + diffMillisecs);
        var newEnd = new Date(params.end.valueOf() + diffMillisecs);
        this.applyRange(newStart, newEnd);
        // if the applied range is moved due to a fixed min or max,
        // change the diffMillisecs accordingly
        var appliedDiff = (this.start.valueOf() - newStart.valueOf());
        if (appliedDiff) {
            diffMillisecs += appliedDiff;
        }

        this.recalcConversion();

        // move the items by changing the left position of their frame.
        // this is much faster than repositioning all elements individually via the
        // repaintFrame() function (which is done once at mouseup)
        // note that we round diffX to prevent wrong positioning on millisecond scale
        var previousLeft = params.previousLeft || 0;
        var currentLeft = parseFloat(dom.items.frame.style.left) || 0;
        var previousOffset = params.previousOffset || 0;
        var frameOffset = previousOffset + (currentLeft - previousLeft);
        var frameLeft = -diffMillisecs / interval * size.contentWidth + frameOffset;

        dom.items.frame.style.left = (frameLeft) + "px";

        // read the left again from DOM (IE8- rounds the value)
        params.previousOffset = frameOffset;
        params.previousLeft = parseFloat(dom.items.frame.style.left) || frameLeft;

        this.repaintCurrentTime();
        this.repaintCustomTime();
        this.repaintAxis();

        // fire a rangechange event
        this.trigger('rangechange');
    }

    links.Timeline.preventDefault(event);
};


/**
 * Stop moving operating.
 * This function activated from within the funcion links.Timeline.onMouseDown().
 * @param {event}  event   The event
 */
links.Timeline.prototype.onMouseUp = function (event) {
    var params = this.eventParams,
        options = this.options;

    event = event || window.event;

    this.dom.frame.style.cursor = 'auto';

    // remove event listeners here, important for Safari
    if (params.onMouseMove) {
        links.Timeline.removeEventListener(document, "mousemove", params.onMouseMove);
        delete params.onMouseMove;
    }
    if (params.onMouseUp) {
        links.Timeline.removeEventListener(document, "mouseup",   params.onMouseUp);
        delete params.onMouseUp;
    }
    //links.Timeline.preventDefault(event);

    if (params.customTime) {
        // fire a timechanged event
        this.trigger('timechanged');
    }
    else if (params.editItem) {
        var item = this.items[params.itemIndex];

        if (params.moved || params.addItem) {
            this.applyChange = true;
            this.applyAdd = true;

            this.updateData(params.itemIndex, {
                'start': item.start,
                'end': item.end
            });

            // fire an add or change event.
            // Note that the change can be canceled from within an event listener if
            // this listener calls the method cancelChange().
            this.trigger(params.addItem ? 'add' : 'change');

            if (params.addItem) {
                if (this.applyAdd) {
                    this.updateData(params.itemIndex, {
                        'start': item.start,
                        'end': item.end,
                        'content': item.content,
                        'group': this.getGroupName(item.group)
                    });
                }
                else {
                    // undo an add
                    this.deleteItem(params.itemIndex);
                }
            }
            else {
                if (this.applyChange) {
                    this.updateData(params.itemIndex, {
                        'start': item.start,
                        'end': item.end
                    });
                }
                else {
                    // undo a change
                    delete this.applyChange;
                    delete this.applyAdd;

                    var item = this.items[params.itemIndex],
                        domItem = item.dom;

                    item.start = params.itemStart;
                    item.end = params.itemEnd;
                    item.group = params.itemGroup;
                    // TODO: original group should be restored too
                    item.setPosition(params.itemLeft, params.itemRight);
                }
            }

            // prepare data for clustering, by filtering and sorting by type
            if (this.options.cluster) {
                this.clusterGenerator.updateData();
            }

            this.render();
        }
    }
    else {
        if (!params.moved && !params.zoomed) {
            // mouse did not move -> user has selected an item

            if (params.target === this.dom.items.deleteButton) {
                // delete item
                if (this.selection) {
                    this.confirmDeleteItem(this.selection.index);
                }
            }
            else if (options.selectable) {
                // select/unselect item
                if (params.itemIndex != undefined) {
                    if (!this.isSelected(params.itemIndex)) {
                        this.selectItem(params.itemIndex);
                        this.trigger('select');
                    }
                }
                else {
                    this.unselectItem();
                    this.trigger('select');
                }
            }
        }
        else {
            // timeline is moved
            // TODO: optimize: no need to reflow and cluster again?
            this.render();

            if ((params.moved && options.moveable) || (params.zoomed && options.zoomable) ) {
                // fire a rangechanged event
                this.trigger('rangechanged');
            }
        }
    }
};

/**
 * Double click event occurred for an item
 * @param {Event}  event
 */
links.Timeline.prototype.onDblClick = function (event) {
    var params = this.eventParams,
        options = this.options,
        dom = this.dom,
        size = this.size;
    event = event || window.event;

    if (params.itemIndex != undefined) {
        var item = this.items[params.itemIndex];
        if (item && this.isEditable(item)) {
            // fire the edit event
            this.trigger('edit');
        }
    }
    else {
        if (options.editable) {
            /**
             * //ATLASSIAN - See TEAMCAL-982
             * The unmodified behavior of CHAP timeline is to create a new event at this point, insert it into the timeline
             * and select it. The new event causes the timeline to reogranise itself. This is undesirable for us as we
             * want to show our own add dialog first, which will allow the user to insert an event at any date, and then insert
             * the new event. We also want to avoid the calendar reorganising itself before our dialog is completed, therefore
             * it is not sufficent to simple cancel the add.
             *
             * Therefore we have modified this code to simply trigger an add event at this point. In addition inside the
             * links.Timeline.prototype.trigger function we calculate the date at which the user has double clicked, so that
             * we may populate our own add dialog with the correct default date.
             */
            this.trigger('add');
            /*
            // create a new item

            // get mouse position
            params.mouseX = links.Timeline.getPageX(event);
            params.mouseY = links.Timeline.getPageY(event);
            var x = params.mouseX - links.Timeline.getAbsoluteLeft(dom.content);
            var y = params.mouseY - links.Timeline.getAbsoluteTop(dom.content);

            // create a new event at the current mouse position
            var xstart = this.screenToTime(x);
            var xend = this.screenToTime(x  + size.frameWidth / 10); // add 10% of timeline width
            if (options.snapEvents) {
                this.step.snap(xstart);
                this.step.snap(xend);
            }

            var content = options.NEW;
            var group = this.getGroupFromHeight(y);   // (group may be undefined)
            var preventRender = true;
            this.addItem({
                'start': xstart,
                'end': xend,
                'content': content,
                'group': this.getGroupName(group)
            }, preventRender);
            params.itemIndex = (this.items.length - 1);
            this.selectItem(params.itemIndex);

            this.applyAdd = true;

            // fire an add event.
            // Note that the change can be canceled from within an event listener if
            // this listener calls the method cancelAdd().
            this.trigger('add');

            if (this.applyAdd) {
                // render and select the item
                this.render({animate: false});
                this.selectItem(params.itemIndex);
            }
            else {
                // undo an add
                this.deleteItem(params.itemIndex);
            }*/
            //END ATLASSIAN
        }
    }

    links.Timeline.preventDefault(event);
};


/**
 * Event handler for mouse wheel event, used to zoom the timeline
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event}  event   The event
 */
links.Timeline.prototype.onMouseWheel = function(event) {
    if (!this.options.zoomable)
        return;

    if (!event) { /* For IE. */
        event = window.event;
    }

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) { /* IE/Opera. */
        delta = event.wheelDelta/120;
    } else if (event.detail) { /* Mozilla case. */
        // In Mozilla, sign of delta is different than in IE.
        // Also, delta is multiple of 3.
        delta = -event.detail/3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
        // TODO: on FireFox, the window is not redrawn within repeated scroll-events
        // -> use a delayed redraw? Make a zoom queue?

        var timeline = this;
        var zoom = function () {
            // perform the zoom action. Delta is normally 1 or -1
            var zoomFactor = delta / 5.0;
            var frameLeft = links.Timeline.getAbsoluteLeft(timeline.dom.content);
            var mouseX = links.Timeline.getPageX(event);
            var zoomAroundDate =
                (mouseX != undefined && frameLeft != undefined) ?
                    timeline.screenToTime(mouseX - frameLeft) :
                    undefined;

            timeline.zoom(zoomFactor, zoomAroundDate);

            // fire a rangechange and a rangechanged event
            timeline.trigger("rangechange");
            timeline.trigger("rangechanged");
        };

        zoom();
    }

    // Prevent default actions caused by mouse wheel.
    // That might be ugly, but we handle scrolls somehow
    // anyway, so don't bother here...
    links.Timeline.preventDefault(event);
};


/**
 * Zoom the timeline the given zoomfactor in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try zoomfactor = 0.1 or -0.1
 * @param {Number} zoomFactor      Zooming amount. Positive value will zoom in,
 *                                 negative value will zoom out
 * @param {Date}   zoomAroundDate  Date around which will be zoomed. Optional
 */
links.Timeline.prototype.zoom = function(zoomFactor, zoomAroundDate) {
    // if zoomAroundDate is not provided, take it half between start Date and end Date
    if (zoomAroundDate == undefined) {
        zoomAroundDate = new Date((this.start.valueOf() + this.end.valueOf()) / 2);
    }

    // prevent zoom factor larger than 1 or smaller than -1 (larger than 1 will
    // result in a start>=end )
    if (zoomFactor >= 1) {
        zoomFactor = 0.9;
    }
    if (zoomFactor <= -1) {
        zoomFactor = -0.9;
    }

    // adjust a negative factor such that zooming in with 0.1 equals zooming
    // out with a factor -0.1
    if (zoomFactor < 0) {
        zoomFactor = zoomFactor / (1 + zoomFactor);
    }

    // zoom start Date and end Date relative to the zoomAroundDate
    var startDiff = (this.start.valueOf() - zoomAroundDate);
    var endDiff = (this.end.valueOf() - zoomAroundDate);

    // calculate new dates
    var newStart = new Date(this.start.valueOf() - startDiff * zoomFactor);
    var newEnd   = new Date(this.end.valueOf() - endDiff * zoomFactor);

    // only zoom in when interval is larger than minimum interval (to prevent
    // sliding to left/right when having reached the minimum zoom level)
    var interval = (newEnd.valueOf() - newStart.valueOf());
    var zoomMin = Number(this.options.zoomMin) || 10;
    if (zoomMin < 10) {
        zoomMin = 10;
    }
    if (interval >= zoomMin) {
        this.applyRange(newStart, newEnd, zoomAroundDate);
        this.render({
            animate: this.options.animate && this.options.animateZoom
        });
    }
};

/**
 * Move the timeline the given movefactor to the left or right. Start and end
 * date will be adjusted, and the timeline will be redrawn.
 * For example, try moveFactor = 0.1 or -0.1
 * @param {Number}  moveFactor      Moving amount. Positive value will move right,
 *                                 negative value will move left
 */
links.Timeline.prototype.move = function(moveFactor) {
    // zoom start Date and end Date relative to the zoomAroundDate
    var diff = (this.end.valueOf() - this.start.valueOf());

    // apply new dates
    var newStart = new Date(this.start.valueOf() + diff * moveFactor);
    var newEnd   = new Date(this.end.valueOf() + diff * moveFactor);
    this.applyRange(newStart, newEnd);

    this.render(); // TODO: optimize, no need to reflow, only to recalc conversion and repaint
};

/**
 * Apply a visible range. The range is limited to feasible maximum and minimum
 * range.
 * @param {Date} start
 * @param {Date} end
 * @param {Date}   zoomAroundDate  Optional. Date around which will be zoomed.
 */
links.Timeline.prototype.applyRange = function (start, end, zoomAroundDate) {
    // calculate new start and end value
    var startValue = start.valueOf(); // number
    var endValue = end.valueOf();     // number
    var interval = (endValue - startValue);

    // determine maximum and minimum interval
    var options = this.options;
    var year = 1000 * 60 * 60 * 24 * 365;
    var zoomMin = Number(options.zoomMin) || 10;
    if (zoomMin < 10) {
        zoomMin = 10;
    }
    var zoomMax = Number(options.zoomMax) || 10000 * year;
    if (zoomMax > 10000 * year) {
        zoomMax = 10000 * year;
    }
    if (zoomMax < zoomMin) {
        zoomMax = zoomMin;
    }

    // determine min and max date value
    var min = options.min ? options.min.valueOf() : undefined; // number
    var max = options.max ? options.max.valueOf() : undefined; // number
    if (min != undefined && max != undefined) {
        if (min >= max) {
            // empty range
            var day = 1000 * 60 * 60 * 24;
            max = min + day;
        }
        if (zoomMax > (max - min)) {
            zoomMax = (max - min);
        }
        if (zoomMin > (max - min)) {
            zoomMin = (max - min);
        }
    }

    // prevent empty interval
    if (startValue >= endValue) {
        endValue += 1000 * 60 * 60 * 24;
    }

    // prevent too small scale
    // TODO: IE has problems with milliseconds
    if (interval < zoomMin) {
        var diff = (zoomMin - interval);
        var f = zoomAroundDate ? (zoomAroundDate.valueOf() - startValue) / interval : 0.5;
        startValue -= Math.round(diff * f);
        endValue   += Math.round(diff * (1 - f));
    }

    // prevent too large scale
    if (interval > zoomMax) {
        var diff = (interval - zoomMax);
        var f = zoomAroundDate ? (zoomAroundDate.valueOf() - startValue) / interval : 0.5;
        startValue += Math.round(diff * f);
        endValue   -= Math.round(diff * (1 - f));
    }

    // prevent to small start date
    if (min != undefined) {
        var diff = (startValue - min);
        if (diff < 0) {
            startValue -= diff;
            endValue -= diff;
        }
    }

    // prevent to large end date
    if (max != undefined) {
        var diff = (max - endValue);
        if (diff < 0) {
            startValue += diff;
            endValue += diff;
        }
    }

    // apply new dates
    this.start = new Date(startValue);
    this.end = new Date(endValue);
};

/**
 * Delete an item after a confirmation.
 * The deletion can be cancelled by executing .cancelDelete() during the
 * triggered event 'delete'.
 * @param {int} index   Index of the item to be deleted
 */
links.Timeline.prototype.confirmDeleteItem = function(index) {
    this.applyDelete = true;

    // select the event to be deleted
    if (!this.isSelected(index)) {
        this.selectItem(index);
    }

    // fire a delete event trigger.
    // Note that the delete event can be canceled from within an event listener if
    // this listener calls the method cancelChange().
    this.trigger('delete');

    if (this.applyDelete) {
        this.deleteItem(index);
    }

    delete this.applyDelete;
};

/**
 * Delete an item
 * @param {int} index   Index of the item to be deleted
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 *                                          (optimization for multiple delete)
 */
links.Timeline.prototype.deleteItem = function(index, preventRender) {
    if (index >= this.items.length) {
        throw "Cannot delete row, index out of range";
    }

    if (this.selection) {
        // adjust the selection
        if (this.selection.index == index) {
            // item to be deleted is selected
            this.unselectItem();
        }
        else if (this.selection.index > index) {
            // update selection index
            this.selection.index--;
        }
    }

    // actually delete the item and remove it from the DOM
    var item = this.items.splice(index, 1)[0];
    this.renderQueue.hide.push(item);

    // delete the row in the original data table
    if (this.data) {
        if (google && google.visualization &&
            this.data instanceof google.visualization.DataTable) {
            this.data.removeRow(index);
        }
        else if (links.Timeline.isArray(this.data)) {
            this.data.splice(index, 1);
        }
        else {
            throw "Cannot delete row from data, unknown data type";
        }
    }

    // prepare data for clustering, by filtering and sorting by type
    if (this.options.cluster) {
        this.clusterGenerator.updateData();
    }

    if (!preventRender) {
        this.render();
    }
};


/**
 * Delete all items
 */
links.Timeline.prototype.deleteAllItems = function() {
    this.unselectItem();

    // delete the loaded items
    this.clearItems();

    // delete the groups
    this.deleteGroups();

    // empty original data table
    if (this.data) {
        if (google && google.visualization &&
            this.data instanceof google.visualization.DataTable) {
            this.data.removeRows(0, this.data.getNumberOfRows());
        }
        else if (links.Timeline.isArray(this.data)) {
            this.data.splice(0, this.data.length);
        }
        else {
            throw "Cannot delete row from data, unknown data type";
        }
    }

    // prepare data for clustering, by filtering and sorting by type
    if (this.options.cluster) {
        this.clusterGenerator.updateData();
    }

    this.render();
};


/**
 * Find the group from a given height in the timeline
 * @param {Number} height   Height in the timeline
 * @return {Object | undefined} group   The group object, or undefined if out
 *                                      of range
 */
links.Timeline.prototype.getGroupFromHeight = function(height) {
    var i,
        group,
        groups = this.groups;

    if (groups.length) {
        if (this.options.axisOnTop) {
            for (i = groups.length - 1; i >= 0; i--) {
                group = groups[i];
                if (height > group.top) {
                    return group;
                }
            }
        }
        else {
            for (i = 0; i < groups.length; i++) {
                group = groups[i];
                if (height > group.top) {
                    return group;
                }
            }
        }

        return group; // return the last group
    }

    return undefined;
};

/**
 * @constructor links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group. type, group.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */
links.Timeline.Item = function (data, options) {
    if (data) {
        /* TODO: use parseJSONDate as soon as it is tested and working (in two directions)
         this.start = links.Timeline.parseJSONDate(data.start);
         this.end = links.Timeline.parseJSONDate(data.end);
         */
        this.start = data.start;
        this.end = data.end;
        this.content = data.content;
        this.className = data.className;
        this.editable = data.editable;
        this.group = data.group;
    }
    this.top = 0;
    this.left = 0;
    this.width = 0;
    this.height = 0;
    this.lineWidth = 0;
    this.dotWidth = 0;
    this.dotHeight = 0;

    this.rendered = false; // true when the item is draw in the Timeline DOM

    if (options) {
        // override the default properties
        for (var option in options) {
            if (options.hasOwnProperty(option)) {
                this[option] = options[option];
            }
        }
    }

};



/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 */
links.Timeline.Item.prototype.reflow = function () {
    // Should be implemented by sub-prototype
    return false;
};

/**
 * Append all image urls present in the items DOM to the provided array
 * @param {String[]} imageUrls
 */
links.Timeline.Item.prototype.getImageUrls = function (imageUrls) {
    if (this.dom) {
        links.imageloader.filterImageUrls(this.dom, imageUrls);
    }
};

/**
 * Select the item
 */
links.Timeline.Item.prototype.select = function () {
    // Should be implemented by sub-prototype
};

/**
 * Unselect the item
 */
links.Timeline.Item.prototype.unselect = function () {
    // Should be implemented by sub-prototype
};

/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 */
links.Timeline.Item.prototype.createDOM = function () {
    // Should be implemented by sub-prototype
};

/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 */
links.Timeline.Item.prototype.showDOM = function (container) {
    // Should be implemented by sub-prototype
};

/**
 * Remove the items DOM from the current HTML container
 * @param {Element} container
 */
links.Timeline.Item.prototype.hideDOM = function (container) {
    // Should be implemented by sub-prototype
};

/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 */
links.Timeline.Item.prototype.updateDOM = function () {
    // Should be implemented by sub-prototype
};

/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options.
 * @param {links.Timeline} timeline
 */
links.Timeline.Item.prototype.updatePosition = function (timeline) {
    // Should be implemented by sub-prototype
};

/**
 * Check if the item is drawn in the timeline (i.e. the DOM of the item is
 * attached to the frame. You may also just request the parameter item.rendered
 * @return {boolean} rendered
 */
links.Timeline.Item.prototype.isRendered = function () {
    return this.rendered;
};

/**
 * Check if the item is located in the visible area of the timeline, and
 * not part of a cluster
 * @param {Date} start
 * @param {Date} end
 * @return {boolean} visible
 */
links.Timeline.Item.prototype.isVisible = function (start, end) {
    // Should be implemented by sub-prototype
    return false;
};

/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 */
links.Timeline.Item.prototype.setPosition = function (left, right) {
    // Should be implemented by sub-prototype
};

/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 */
links.Timeline.Item.prototype.getRight = function (timeline) {
    // Should be implemented by sub-prototype
    return 0;
};

/**
 * Calculate the width of the item
 * @param {links.Timeline} timeline
 * @return {Number} width
 */
links.Timeline.Item.prototype.getWidth = function (timeline) {
    // Should be implemented by sub-prototype
    return this.width || 0; // last rendered width
};


/**
 * @constructor links.Timeline.ItemBox
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group. type, group.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */
links.Timeline.ItemBox = function (data, options) {
    links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemBox.prototype = new links.Timeline.Item();

/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 * @override
 */
links.Timeline.ItemBox.prototype.reflow = function () {
    var dom = this.dom,
        dotHeight = dom.dot.offsetHeight,
        dotWidth = dom.dot.offsetWidth,
        lineWidth = dom.line.offsetWidth,
        resized = (
        (this.dotHeight != dotHeight) ||
        (this.dotWidth != dotWidth) ||
        (this.lineWidth != lineWidth)
        );

    this.dotHeight = dotHeight;
    this.dotWidth = dotWidth;
    this.lineWidth = lineWidth;

    return resized;
};

/**
 * Select the item
 * @override
 */
links.Timeline.ItemBox.prototype.select = function () {
    var dom = this.dom;
    links.Timeline.addClassName(dom, 'timeline-event-selected');
    links.Timeline.addClassName(dom.line, 'timeline-event-selected');
    links.Timeline.addClassName(dom.dot, 'timeline-event-selected');
};

/**
 * Unselect the item
 * @override
 */
links.Timeline.ItemBox.prototype.unselect = function () {
    var dom = this.dom;
    links.Timeline.removeClassName(dom, 'timeline-event-selected');
    links.Timeline.removeClassName(dom.line, 'timeline-event-selected');
    links.Timeline.removeClassName(dom.dot, 'timeline-event-selected');
};

/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */
links.Timeline.ItemBox.prototype.createDOM = function () {
    // background box
    var divBox = document.createElement("DIV");
    divBox.style.position = "absolute";
    divBox.style.left = this.left + "px";
    divBox.style.top = this.top + "px";

    // contents box (inside the background box). used for making margins
    var divContent = document.createElement("DIV");
    divContent.className = "timeline-event-content";
    divContent.innerHTML = this.content;
    divBox.appendChild(divContent);

    // line to axis
    var divLine = document.createElement("DIV");
    divLine.style.position = "absolute";
    divLine.style.width = "0px";
    // important: the vertical line is added at the front of the list of elements,
    // so it will be drawn behind all boxes and ranges
    divBox.line = divLine;

    // dot on axis
    var divDot = document.createElement("DIV");
    divDot.style.position = "absolute";
    divDot.style.width  = "0px";
    divDot.style.height = "0px";
    divBox.dot = divDot;

    this.dom = divBox;
    this.updateDOM();

    return divBox;
};

/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */
links.Timeline.ItemBox.prototype.showDOM = function (container) {
    var dom = this.dom;
    if (!dom) {
        dom = this.createDOM();
    }

    if (dom.parentNode != container) {
        if (dom.parentNode) {
            // container is changed. remove from old container
            this.hideDOM();
        }

        // append to this container
        container.appendChild(dom);
        container.insertBefore(dom.line, container.firstChild);
        // Note: line must be added in front of the this,
        //       such that it stays below all this
        container.appendChild(dom.dot);
        this.rendered = true;
    }
};

/**
 * Remove the items DOM from the current HTML container, but keep the DOM in
 * memory
 * @override
 */
links.Timeline.ItemBox.prototype.hideDOM = function () {
    var dom = this.dom;
    if (dom) {
        var parent = dom.parentNode;
        if (parent) {
            //ATLASSIAN -https://jira.atlassian.com/browse/TEAMCAL-1955
            var removeChild = function(toRemove) {
                if (toRemove && toRemove.parentNode)
                    toRemove.parentNode.removeChild(toRemove);
            };

            removeChild(dom.line);
            removeChild(dom.dot);
            removeChild(dom);
            //END ATLASSIAN
            this.rendered = false;
        }
    }
};

/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */
links.Timeline.ItemBox.prototype.updateDOM = function () {
    var divBox = this.dom;
    if (divBox) {
        var divLine = divBox.line;
        var divDot = divBox.dot;

        // update contents
        divBox.firstChild.innerHTML = this.content;

        // update class
        divBox.className = "timeline-event timeline-event-box";
        divLine.className = "timeline-event timeline-event-line";
        divDot.className  = "timeline-event timeline-event-dot";

        if (this.isCluster) {
            links.Timeline.addClassName(divBox, 'timeline-event-cluster');
            links.Timeline.addClassName(divLine, 'timeline-event-cluster');
            links.Timeline.addClassName(divDot, 'timeline-event-cluster');
        }

        // add item specific class name when provided
        if (this.className) {
            links.Timeline.addClassName(divBox, this.className);
            links.Timeline.addClassName(divLine, this.className);
            links.Timeline.addClassName(divDot, this.className);
        }

        // TODO: apply selected className?
    }
};

/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options.
 * @param {links.Timeline} timeline
 * @override
 */
links.Timeline.ItemBox.prototype.updatePosition = function (timeline) {
    var dom = this.dom;
    if (dom) {
        var left = timeline.timeToScreen(this.start),
            axisOnTop = timeline.options.axisOnTop,
            axisTop = timeline.size.axis.top,
            axisHeight = timeline.size.axis.height,
            boxAlign = (timeline.options.box && timeline.options.box.align) ?
                timeline.options.box.align : undefined;

        dom.style.top = this.top + "px";
        if (boxAlign == 'right') {
            dom.style.left = (left - this.width) + "px";
        }
        else if (boxAlign == 'left') {
            dom.style.left = (left) + "px";
        }
        else { // default or 'center'
            dom.style.left = (left - this.width/2) + "px";
        }

        var line = dom.line;
        var dot = dom.dot;
        line.style.left = (left - this.lineWidth/2) + "px";
        dot.style.left = (left - this.dotWidth/2) + "px";
        if (axisOnTop) {
            line.style.top = axisHeight + "px";
            line.style.height = Math.max(this.top - axisHeight, 0) + "px";
            dot.style.top = (axisHeight - this.dotHeight/2) + "px";
        }
        else {
            line.style.top = (this.top + this.height) + "px";
            line.style.height = Math.max(axisTop - this.top - this.height, 0) + "px";
            dot.style.top = (axisTop - this.dotHeight/2) + "px";
        }
    }
};

/**
 * Check if the item is visible in the timeline, and not part of a cluster
 * @param {Date} start
 * @param {Date} end
 * @return {Boolean} visible
 * @override
 */
links.Timeline.ItemBox.prototype.isVisible = function (start, end) {
    if (this.cluster) {
        return false;
    }

    return (this.start > start) && (this.start < end);
};

/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */
links.Timeline.ItemBox.prototype.setPosition = function (left, right) {
    var dom = this.dom;

    dom.style.left = (left - this.width / 2) + "px";
    dom.line.style.left = (left - this.lineWidth / 2) + "px";
    dom.dot.style.left = (left - this.dotWidth / 2) + "px";

    if (this.group) {
        this.top = this.group.top;
        dom.style.top = this.top + 'px';
    }
};

/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */
links.Timeline.ItemBox.prototype.getRight = function (timeline) {
    var boxAlign = (timeline.options.box && timeline.options.box.align) ?
        timeline.options.box.align : undefined;

    var left = timeline.timeToScreen(this.start);
    var right;
    if (boxAlign == 'right') {
        right = left;
    }
    else if (boxAlign == 'left') {
        right = (left + this.width);
    }
    else { // default or 'center'
        right = (left + this.width / 2);
    }

    return right;
};

/**
 * @constructor links.Timeline.ItemRange
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group. type, group.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */
links.Timeline.ItemRange = function (data, options) {
    links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemRange.prototype = new links.Timeline.Item();

/**
 * Select the item
 * @override
 */
links.Timeline.ItemRange.prototype.select = function () {
    var dom = this.dom;
    links.Timeline.addClassName(dom, 'timeline-event-selected');
};

/**
 * Unselect the item
 * @override
 */
links.Timeline.ItemRange.prototype.unselect = function () {
    var dom = this.dom;
    links.Timeline.removeClassName(dom, 'timeline-event-selected');
};

/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */
links.Timeline.ItemRange.prototype.createDOM = function () {
    // background box
    var divBox = document.createElement("DIV");
    divBox.style.position = "absolute";

    // contents box
    var divContent = document.createElement("DIV");
    divContent.className = "timeline-event-content";
    divBox.appendChild(divContent);

    this.dom = divBox;
    this.updateDOM();

    return divBox;
};

/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */
links.Timeline.ItemRange.prototype.showDOM = function (container) {
    var dom = this.dom;
    if (!dom) {
        dom = this.createDOM();
    }

    if (dom.parentNode != container) {
        if (dom.parentNode) {
            // container changed. remove the item from the old container
            this.hideDOM();
        }

        // append to the new container
        container.appendChild(dom);
        this.rendered = true;
    }
};

/**
 * Remove the items DOM from the current HTML container
 * The DOM will be kept in memory
 * @override
 */
links.Timeline.ItemRange.prototype.hideDOM = function () {
    var dom = this.dom;
    if (dom) {
        if (dom.parentNode) {
            dom.parentNode.removeChild(dom);
        }
        this.rendered = false;
    }
};

/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */
links.Timeline.ItemRange.prototype.updateDOM = function () {
    var divBox = this.dom;
    if (divBox) {
        // update contents
        divBox.firstChild.innerHTML = this.content;

        // update class
        divBox.className = "timeline-event timeline-event-range";

        if (this.isCluster) {
            links.Timeline.addClassName(divBox, 'timeline-event-cluster');
        }

        // add item specific class name when provided
        if (this.className) {
            links.Timeline.addClassName(divBox, this.className);
        }

        // TODO: apply selected className?
    }
};

/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options. *
 * @param {links.Timeline} timeline
 * @override
 */
links.Timeline.ItemRange.prototype.updatePosition = function (timeline) {
    var dom = this.dom;
    if (dom) {
        var contentWidth = timeline.size.contentWidth,
            left = timeline.timeToScreen(this.start),
            right = timeline.timeToScreen(this.end);

        // limit the width of the this, as browsers cannot draw very wide divs
        if (left < -contentWidth) {
            left = -contentWidth;
        }
        if (right > 2 * contentWidth) {
            right = 2 * contentWidth;
        }

        dom.style.top = this.top + "px";
        dom.style.left = left + "px";
        //dom.style.width = Math.max(right - left - 2 * this.borderWidth, 1) + "px"; // TODO: borderWidth
        dom.style.width = Math.max(right - left, 1) + "px";
    }
};

/**
 * Check if the item is visible in the timeline, and not part of a cluster
 * @param {Number} start
 * @param {Number} end
 * @return {boolean} visible
 * @override
 */
links.Timeline.ItemRange.prototype.isVisible = function (start, end) {
    if (this.cluster) {
        return false;
    }

    return (this.end > start)
        && (this.start < end);
};

/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */
links.Timeline.ItemRange.prototype.setPosition = function (left, right) {
    var dom = this.dom;

    dom.style.left = left + 'px';
    dom.style.width = (right - left) + 'px';

    if (this.group) {
        this.top = this.group.top;
        dom.style.top = this.top + 'px';
    }
};

/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */
links.Timeline.ItemRange.prototype.getRight = function (timeline) {
    return timeline.timeToScreen(this.end);
};

/**
 * Calculate the width of the item
 * @param {links.Timeline} timeline
 * @return {Number} width
 * @override
 */
links.Timeline.ItemRange.prototype.getWidth = function (timeline) {
    return timeline.timeToScreen(this.end) - timeline.timeToScreen(this.start);
};

/**
 * @constructor links.Timeline.ItemDot
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */
links.Timeline.ItemDot = function (data, options) {
    links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemDot.prototype = new links.Timeline.Item();

/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 * @override
 */
links.Timeline.ItemDot.prototype.reflow = function () {
    var dom = this.dom,
        dotHeight = dom.dot.offsetHeight,
        dotWidth = dom.dot.offsetWidth,
        contentHeight = dom.content.offsetHeight,
        resized = (
        (this.dotHeight != dotHeight) ||
        (this.dotWidth != dotWidth) ||
        (this.contentHeight != contentHeight)
        );

    this.dotHeight = dotHeight;
    this.dotWidth = dotWidth;
    this.contentHeight = contentHeight;

    return resized;
};

/**
 * Select the item
 * @override
 */
links.Timeline.ItemDot.prototype.select = function () {
    var dom = this.dom;
    links.Timeline.addClassName(dom, 'timeline-event-selected');
};

/**
 * Unselect the item
 * @override
 */
links.Timeline.ItemDot.prototype.unselect = function () {
    var dom = this.dom;
    links.Timeline.removeClassName(dom, 'timeline-event-selected');
};

/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */
links.Timeline.ItemDot.prototype.createDOM = function () {
    // background box
    var divBox = document.createElement("DIV");
    divBox.style.position = "absolute";

    // contents box, right from the dot
    var divContent = document.createElement("DIV");
    divContent.className = "timeline-event-content";
    divBox.appendChild(divContent);

    // dot at start
    var divDot = document.createElement("DIV");
    divDot.style.position = "absolute";
    divDot.style.width = "0px";
    divDot.style.height = "0px";
    divBox.appendChild(divDot);

    divBox.content = divContent;
    divBox.dot = divDot;

    this.dom = divBox;
    this.updateDOM();

    return divBox;
};

/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */
links.Timeline.ItemDot.prototype.showDOM = function (container) {
    var dom = this.dom;
    if (!dom) {
        dom = this.createDOM();
    }

    if (dom.parentNode != container) {
        if (dom.parentNode) {
            // container changed. remove it from old container first
            this.hideDOM();
        }

        // append to container
        container.appendChild(dom);
        this.rendered = true;
    }
};

/**
 * Remove the items DOM from the current HTML container
 * @override
 */
links.Timeline.ItemDot.prototype.hideDOM = function () {
    var dom = this.dom;
    if (dom) {
        if (dom.parentNode) {
            dom.parentNode.removeChild(dom);
        }
        this.rendered = false;
    }
};

/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */
links.Timeline.ItemDot.prototype.updateDOM = function () {
    if (this.dom) {
        var divBox = this.dom;
        var divDot = divBox.dot;

        // update contents
        divBox.firstChild.innerHTML = this.content;

        // update class
        divDot.className  = "timeline-event timeline-event-dot";

        if (this.isCluster) {
            links.Timeline.addClassName(divBox, 'timeline-event-cluster');
            links.Timeline.addClassName(divDot, 'timeline-event-cluster');
        }

        // add item specific class name when provided
        if (this.className) {
            links.Timeline.addClassName(divBox, this.className);
            links.Timeline.addClassName(divDot, this.className);
        }

        // TODO: apply selected className?
    }
};

/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options. *
 * @param {links.Timeline} timeline
 * @override
 */
links.Timeline.ItemDot.prototype.updatePosition = function (timeline) {
    var dom = this.dom;
    if (dom) {
        var left = timeline.timeToScreen(this.start);

        dom.style.top = this.top + "px";
        dom.style.left = (left - this.dotWidth / 2) + "px";

        dom.content.style.marginLeft = (1.5 * this.dotWidth) + "px";
        //dom.content.style.marginRight = (0.5 * this.dotWidth) + "px"; // TODO
        dom.dot.style.top = ((this.height - this.dotHeight) / 2) + "px";
    }
};

/**
 * Check if the item is visible in the timeline, and not part of a cluster.
 * @param {Date} start
 * @param {Date} end
 * @return {boolean} visible
 * @override
 */
links.Timeline.ItemDot.prototype.isVisible = function (start, end) {
    if (this.cluster) {
        return false;
    }

    return (this.start > start)
        && (this.start < end);
};

/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */
links.Timeline.ItemDot.prototype.setPosition = function (left, right) {
    var dom = this.dom;

    dom.style.left = (left - this.dotWidth / 2) + "px";

    if (this.group) {
        this.top = this.group.top;
        dom.style.top = this.top + 'px';
    }
};

/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */
links.Timeline.ItemDot.prototype.getRight = function (timeline) {
    return timeline.timeToScreen(this.start) + this.width;
};

/**
 * Retrieve the properties of an item.
 * @param {Number} index
 * @return {Object} properties   Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional),
 *                              {String} className (optional)
 *                              {boolean} editable (optional)
 */
links.Timeline.prototype.getItem = function (index) {
    if (index >= this.items.length) {
        throw "Cannot get item, index out of range";
    }

    var item = this.items[index];

    var properties = {};
    properties.start = new Date(item.start.valueOf());
    if (item.end) {
        properties.end = new Date(item.end.valueOf());
    }
    properties.content = item.content;
    if (item.group) {
        properties.group = this.getGroupName(item.group);
    }
    if ('className' in item) {
        properties.className = this.getGroupName(item.className);
    }
    if (item.hasOwnProperty('editable') && (typeof item.editable != 'undefined')) {
        properties.editable = item.editable;
    }

    return properties;
};

/**
 * Add a new item.
 * @param {Object} itemData     Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional)
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */
links.Timeline.prototype.addItem = function (itemData, preventRender) {
    var itemsData = [
        itemData
    ];

    this.addItems(itemsData, preventRender);
};

/**
 * Add new items.
 * @param {Array} itemsData An array containing Objects.
 *                          The objects must have the following parameters:
 *                            {Date} start,
 *                            {Date} end,
 *                            {String} content with text or HTML code,
 *                            {String} group
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */
links.Timeline.prototype.addItems = function (itemsData, preventRender) {
    var timeline = this,
        items = this.items;

    // append the items
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    AJS.$.each(itemsData, function(itemDataIdx, itemData) {
        var index = items.length;
        items.push(timeline.createItem(itemData));
        timeline.updateData(index, itemData);

        // note: there is no need to add the item to the renderQueue, that
        // will be done when this.render() is executed and all items are
        // filtered again.
    });
    // END ATLASSIAN
    // prepare data for clustering, by filtering and sorting by type
    if (this.options.cluster) {
        this.clusterGenerator.updateData();
    }

    if (!preventRender) {
        this.render({
            animate: false
        });
    }
};

/**
 * Create an item object, containing all needed parameters
 * @param {Object} itemData  Object containing parameters start, end
 *                           content, group.
 * @return {Object} item
 */
links.Timeline.prototype.createItem = function(itemData) {
    var type = itemData.end ? 'range' : this.options.style;
    var data = {
        start: itemData.start,
        end: itemData.end,
        content: itemData.content,
        className: itemData.className,
        editable: itemData.editable,
        group: this.getGroup(itemData.group)
    };
    // TODO: optimize this, when creating an item, all data is copied twice...

    // TODO: is initialTop needed?
    var initialTop,
        options = this.options;
    if (options.axisOnTop) {
        initialTop = this.size.axis.height + options.eventMarginAxis + options.eventMargin / 2;
    }
    else {
        initialTop = this.size.contentHeight - options.eventMarginAxis - options.eventMargin / 2;
    }

    if (type in this.itemTypes) {
        return new this.itemTypes[type](data, {'top': initialTop})
    }

    console.log('ERROR: Unknown event style "' + type + '"');
    return new links.Timeline.Item(data, {
        'top': initialTop
    });
};

/**
 * Edit an item
 * @param {Number} index
 * @param {Object} itemData     Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional)
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */
links.Timeline.prototype.changeItem = function (index, itemData, preventRender) {
    var oldItem = this.items[index];
    if (!oldItem) {
        throw "Cannot change item, index out of range";
    }

    // replace item, merge the changes
    var newItem = this.createItem({
        'start':   itemData.hasOwnProperty('start') ?   itemData.start :   oldItem.start,
        'end':     itemData.hasOwnProperty('end') ?     itemData.end :     oldItem.end,
        'content': itemData.hasOwnProperty('content') ? itemData.content : oldItem.content,
        'group':   itemData.hasOwnProperty('group') ?   itemData.group :   this.getGroupName(oldItem.group),
        'className': itemData.hasOwnProperty('className') ? itemData.className : oldItem.className,
        'editable': itemData.hasOwnProperty('editable') ? itemData.editable : oldItem.editable
    });
    this.items[index] = newItem;

    // append the changes to the render queue
    this.renderQueue.hide.push(oldItem);
    this.renderQueue.show.push(newItem);

    // update the original data table
    this.updateData(index, itemData);

    // prepare data for clustering, by filtering and sorting by type
    if (this.options.cluster) {
        this.clusterGenerator.updateData();
    }

    if (!preventRender) {
        // redraw timeline
        this.render({
            animate: false
        });

        newItem.select();
    }
};

/**
 * Delete all groups
 */
links.Timeline.prototype.deleteGroups = function () {
    this.groups = [];
    this.groupIndexes = {};
};


/**
 * Get a group by the group name. When the group does not exist,
 * it will be created.
 * @param {String} groupName   the name of the group
 * @return {Object} groupObject
 */
links.Timeline.prototype.getGroup = function (groupName) {
    var groups = this.groups,
        groupIndexes = this.groupIndexes,
        groupObj = undefined;

    var groupIndex = groupIndexes[groupName];
    if (groupIndex == undefined && groupName != undefined) { // not null or undefined
        groupObj = {
            'content': groupName,
            'labelTop': 0,
            'lineTop': 0
            // note: this object will lateron get addition information,
            //       such as height and width of the group
        };
        groups.push(groupObj);
        // sort the groups
        groups = groups.sort(function (a, b) {
            if (a.content > b.content) {
                return 1;
            }
            if (a.content < b.content) {
                return -1;
            }
            return 0;
        });

        // rebuilt the groupIndexes
        for (var i = 0, iMax = groups.length; i < iMax; i++) {
            groupIndexes[groups[i].content] = i;
        }
    }
    else {
        groupObj = groups[groupIndex];
    }

    return groupObj;
};

/**
 * Get the group name from a group object.
 * @param {Object} groupObj
 * @return {String} groupName   the name of the group, or undefined when group
 *                              was not provided
 */
links.Timeline.prototype.getGroupName = function (groupObj) {
    return groupObj ? groupObj.content : undefined;
};

/**
 * Cancel a change item
 * This method can be called insed an event listener which catches the "change"
 * event. The changed event position will be undone.
 */
links.Timeline.prototype.cancelChange = function () {
    this.applyChange = false;
};

/**
 * Cancel deletion of an item
 * This method can be called insed an event listener which catches the "delete"
 * event. Deletion of the event will be undone.
 */
links.Timeline.prototype.cancelDelete = function () {
    this.applyDelete = false;
};


/**
 * Cancel creation of a new item
 * This method can be called insed an event listener which catches the "new"
 * event. Creation of the new the event will be undone.
 */
links.Timeline.prototype.cancelAdd = function () {
    this.applyAdd = false;
};


/**
 * Select an event. The visible chart range will be moved such that the selected
 * event is placed in the middle.
 * For example selection = [{row: 5}];
 * @param {Array} selection   An array with a column row, containing the row
 *                           number (the id) of the event to be selected.
 * //ATLASSIAN - Added extra parameter to disable automatic visible range adjustment
 * @param {boolean} disableVisibleChartRangeUpdate True to disable automatic visible chart range update.
 * //END ATLASSIAN
 * @return {boolean}         true if selection is succesfully set, else false.
 */
links.Timeline.prototype.setSelection = function(selection, disableVisibleChartRangeUpdate) {
    if (selection != undefined && selection.length > 0) {
        if (selection[0].row != undefined) {
            var index = selection[0].row;
            if (this.items[index]) {
                var item = this.items[index];
                this.selectItem(index);

                // move the visible chart range to the selected event.
                var start = item.start;
                var end = item.end;
                var middle; // number
                if (end != undefined) {
                    middle = (end.valueOf() + start.valueOf()) / 2;
                } else {
                    middle = start.valueOf();
                }
                var diff = (this.end.valueOf() - this.start.valueOf()),
                    newStart = new Date(middle - diff/2),
                    newEnd = new Date(middle + diff/2);

                // ATLASSIAN - Don't update visible chart range if disableVisibleChartRangeUpdate is true
                if (!disableVisibleChartRangeUpdate)
                // END ATLASSIAN
                    this.setVisibleChartRange(newStart, newEnd);

                return true;
            }
        }
    }
    else {
        // unselect current selection
        this.unselectItem();
    }
    return false;
};

/**
 * Retrieve the currently selected event
 * @return {Array} sel  An array with a column row, containing the row number
 *                      of the selected event. If there is no selection, an
 *                      empty array is returned.
 */
links.Timeline.prototype.getSelection = function() {
    var sel = [];
    if (this.selection) {
        sel.push({"row": this.selection.index});
    }
    return sel;
};


/**
 * Select an item by its index
 * @param {Number} index
 */
links.Timeline.prototype.selectItem = function(index) {
    this.unselectItem();

    this.selection = undefined;

    if (this.items[index] != undefined) {
        var item = this.items[index],
            domItem = item.dom;

        this.selection = {
            'index': index
        };

        if (item && item.dom) {
            // TODO: move adjusting the domItem to the item itself
            if (this.isEditable(item)) {
                item.dom.style.cursor = 'move';
            }
            item.select();
        }
        this.repaintDeleteButton();
        this.repaintDragAreas();
    }
};

/**
 * Check if an item is currently selected
 * @param {Number} index
 * @return {boolean} true if row is selected, else false
 */
links.Timeline.prototype.isSelected = function (index) {
    return (this.selection && this.selection.index == index);
};

/**
 * Unselect the currently selected event (if any)
 */
links.Timeline.prototype.unselectItem = function() {
    if (this.selection) {
        var item = this.items[this.selection.index];

        if (item && item.dom) {
            var domItem = item.dom;
            domItem.style.cursor = '';
            item.unselect();
        }

        this.selection = undefined;
        this.repaintDeleteButton();
        this.repaintDragAreas();
    }
};


/**
 * Stack the items such that they don't overlap. The items will have a minimal
 * distance equal to options.eventMargin.
 * @param {boolean | undefined} animate    if animate is true, the items are
 *                                         moved to their new position animated
 *                                         defaults to false.
 */
links.Timeline.prototype.stackItems = function(animate) {
    if (this.groups.length > 0) {
        // under this conditions we refuse to stack the events
        // TODO: implement support for stacking items per group
        return;
    }

    if (animate == undefined) {
        animate = false;
    }

    // calculate the order and final stack position of the items
    var stack = this.stack;
    if (!stack) {
        stack = {};
        this.stack = stack;
    }
    stack.sortedItems = this.stackOrder(this.renderedItems);
    stack.finalItems = this.stackCalculateFinal(stack.sortedItems);

    if (animate || stack.timer) {
        // move animated to the final positions
        var timeline = this;
        var step = function () {
            var arrived = timeline.stackMoveOneStep(stack.sortedItems,
                stack.finalItems);

            timeline.repaint();

            if (!arrived) {
                stack.timer = setTimeout(step, 30);
            }
            else {
                delete stack.timer;
            }
        };

        if (!stack.timer) {
            stack.timer = setTimeout(step, 30);
        }
    }
    else {
        // move immediately to the final positions
        this.stackMoveToFinal(stack.sortedItems, stack.finalItems);
    }
};

/**
 * Cancel any running animation
 */
links.Timeline.prototype.stackCancelAnimation = function() {
    if (this.stack && this.stack.timer) {
        clearTimeout(this.stack.timer);
        delete this.stack.timer;
    }
};


/**
 * Order the items in the array this.items. The default order is determined via:
 * - Ranges go before boxes and dots.
 * - The item with the oldest start time goes first
 * If a custom function has been provided via the stackorder option, then this will be used.
 * @param {Array} items        Array with items
 * @return {Array} sortedItems Array with sorted items
 */
links.Timeline.prototype.stackOrder = function(items) {
    // TODO: store the sorted items, to have less work later on
    var sortedItems = items.concat([]);

    //if a customer stack order function exists, use it.
    var f = this.options.customStackOrder && (typeof this.options.customStackOrder === 'function') ? this.options.customStackOrder : function (a, b)
    {
        if ((a instanceof links.Timeline.ItemRange) &&
            !(b instanceof links.Timeline.ItemRange)) {
            return -1;
        }

        if (!(a instanceof links.Timeline.ItemRange) &&
            (b instanceof links.Timeline.ItemRange)) {
            return 1;
        }
        //ATLASSIAN - Function modified to reduce events "jumping" on horizontal scroll.
        //First sort by start date
        result = (a.start - b.start);

        //If same, sort by width
        if (!result) {
            result = (b.width - a.width);
        }

        //Finally try sorting by the event that is already higher to prevent items swapping.
        if (!result) {
            result = (b.bottom - a.bottom);
        }

        return result;
        //END ATLASSIAN
    };

    sortedItems.sort(f);

    return sortedItems;
};

/**
 * Adjust vertical positions of the events such that they don't overlap each
 * other.
 * @param {timeline.Item[]} items
 * @return {Object[]} finalItems
 */
links.Timeline.prototype.stackCalculateFinal = function(items) {
    var i,
        iMax,
        size = this.size,
        axisTop = size.axis.top,
        axisHeight = size.axis.height,
        options = this.options,
        axisOnTop = options.axisOnTop,
        eventMargin = options.eventMargin,
        eventMarginAxis = options.eventMarginAxis,
        finalItems = [];

    // initialize final positions
    for (i = 0, iMax = items.length; i < iMax; i++) {
        var item = items[i],
            top,
            bottom,
            height = item.height,
            width = item.getWidth(this),
            right = item.getRight(this),
            left = right - width;

        if (axisOnTop) {
            top = axisHeight + eventMarginAxis + eventMargin / 2;
        }
        else {
            top = axisTop - height - eventMarginAxis - eventMargin / 2;
        }
        bottom = top + height;

        finalItems[i] = {
            'left': left,
            'top': top,
            'right': right,
            'bottom': bottom,
            'height': height,
            'item': item
        };
    }

    if (this.options.stackEvents) {
        // calculate new, non-overlapping positions
        //var items = sortedItems;
        for (i = 0, iMax = finalItems.length; i < iMax; i++) {
            //for (var i = finalItems.length - 1; i >= 0; i--) {
            var finalItem = finalItems[i];
            var collidingItem = null;
            do {
                // TODO: optimize checking for overlap. when there is a gap without items,
                //  you only need to check for items from the next item on, not from zero
                collidingItem = this.stackItemsCheckOverlap(finalItems, i, 0, i-1);
                if (collidingItem != null) {
                    // There is a collision. Reposition the event above the colliding element
                    if (axisOnTop) {
                        finalItem.top = collidingItem.top + collidingItem.height + eventMargin;
                    }
                    else {
                        finalItem.top = collidingItem.top - finalItem.height - eventMargin;
                    }
                    finalItem.bottom = finalItem.top + finalItem.height;
                }
            } while (collidingItem);
        }
    }

    return finalItems;
};


/**
 * Move the events one step in the direction of their final positions
 * @param {Array} currentItems   Array with the real items and their current
 *                               positions
 * @param {Array} finalItems     Array with objects containing the final
 *                               positions of the items
 * @return {boolean} arrived     True if all items have reached their final
 *                               location, else false
 */
links.Timeline.prototype.stackMoveOneStep = function(currentItems, finalItems) {
    var arrived = true;

    // apply new positions animated
    for (i = 0, iMax = finalItems.length; i < iMax; i++) {
        var finalItem = finalItems[i],
            item = finalItem.item;

        var topNow = parseInt(item.top);
        var topFinal = parseInt(finalItem.top);
        var diff = (topFinal - topNow);
        if (diff) {
            var step = (topFinal == topNow) ? 0 : ((topFinal > topNow) ? 1 : -1);
            if (Math.abs(diff) > 4) step = diff / 4;
            var topNew = parseInt(topNow + step);

            if (topNew != topFinal) {
                arrived = false;
            }

            item.top = topNew;
            item.bottom = item.top + item.height;
        }
        else {
            item.top = finalItem.top;
            item.bottom = finalItem.bottom;
        }

        item.left = finalItem.left;
        item.right = finalItem.right;
    }

    return arrived;
};



/**
 * Move the events from their current position to the final position
 * @param {Array} currentItems   Array with the real items and their current
 *                               positions
 * @param {Array} finalItems     Array with objects containing the final
 *                               positions of the items
 */
links.Timeline.prototype.stackMoveToFinal = function(currentItems, finalItems) {
    // Put the events directly at there final position
    for (i = 0, iMax = finalItems.length; i < iMax; i++) {
        var finalItem = finalItems[i],
            current = finalItem.item;

        current.left = finalItem.left;
        current.top = finalItem.top;
        current.right = finalItem.right;
        current.bottom = finalItem.bottom;
    }
};



/**
 * Check if the destiny position of given item overlaps with any
 * of the other items from index itemStart to itemEnd.
 * @param {Array} items      Array with items
 * @param {int}  itemIndex   Number of the item to be checked for overlap
 * @param {int}  itemStart   First item to be checked.
 * @param {int}  itemEnd     Last item to be checked.
 * @return {Object}          colliding item, or undefined when no collisions
 */
links.Timeline.prototype.stackItemsCheckOverlap = function(items, itemIndex,
                                                           itemStart, itemEnd) {
    var eventMargin = this.options.eventMargin,
        collision = this.collision;

    // we loop from end to start, as we suppose that the chance of a
    // collision is larger for items at the end, so check these first.
    var item1 = items[itemIndex];
    for (var i = itemEnd; i >= itemStart; i--) {
        var item2 = items[i];
        if (collision(item1, item2, eventMargin)) {
            if (i != itemIndex) {
                return item2;
            }
        }
    }

    return undefined;
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, right, top, and bottom.
 * @param {Element} item1       The first item
 * @param {Element} item2       The second item
 * @param {Number}              margin  A minimum required margin. Optional.
 *                              If margin is provided, the two items will be
 *                              marked colliding when they overlap or
 *                              when the margin between the two is smaller than
 *                              the requested margin.
 * @return {boolean}            true if item1 and item2 collide, else false
 */
links.Timeline.prototype.collision = function(item1, item2, margin) {
    // set margin if not specified
    if (margin == undefined) {
        margin = 0;
    }

    // calculate if there is overlap (collision)
    return (item1.left - margin < item2.right &&
    item1.right + margin > item2.left &&
    item1.top - margin < item2.bottom &&
    item1.bottom + margin > item2.top);
};


/**
 * fire an event
 * @param {String} event   The name of an event, for example "rangechange" or "edit"
 */
links.Timeline.prototype.trigger = function (event) {
    // built up properties
    //ATLASSIAN
    var properties = null,
        mouseX,
        startDate;
    //END ATLASSIAN
    switch (event) {
        case 'rangechange':
        case 'rangechanged':
            properties = {
                'start': new Date(this.start.valueOf()),
                'end': new Date(this.end.valueOf())
            };
            break;

        case 'timechange':
        case 'timechanged':
            properties = {
                'time': new Date(this.customTime.valueOf())
            };
            break;
        //ATLASSIAN - See TEAMCAL-982
        case 'add':
            mouseX = this.eventParams.mouseX - links.Timeline.getAbsoluteLeft(this.dom.content);
            startDate = this.screenToTime(mouseX);
            properties = {
                'start' : startDate
            };
            break;
        //END ATLASSIAN
    }

    // trigger the links event bus
    links.events.trigger(this, event, properties);

    // trigger the google event bus
    if (google && google.visualization) {
        google.visualization.events.trigger(this, event, properties);
    }
};


/**
 * Cluster the events
 */
links.Timeline.prototype.clusterItems = function () {
    if (!this.options.cluster) {
        return;
    }

    var clusters = this.clusterGenerator.getClusters(this.conversion.factor);
    if (this.clusters != clusters) {
        // cluster level changed
        var queue = this.renderQueue;

        // remove the old clusters from the scene
        if (this.clusters) {
            // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
            AJS.$.each(this.clusters, function(clusterIdx, cluster) {
                queue.hide.push(cluster);

                // unlink the items
                AJS.$.each(cluster.items, function(itemIdx, item) {
                    item.cluster = undefined;
                });
            });
            // END ATLASSIAN
        }

        // append the new clusters
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        AJS.$.each(clusters, function(clusterIdx, cluster) {
            AJS.$.each(cluster.items, function(itemIdx, item) {
                item.cluster = cluster;
            });
        });
        // END ATLASSIAN

        this.clusters = clusters;
    }
};

/**
 * Filter the visible events
 */
links.Timeline.prototype.filterItems = function () {
    var queue = this.renderQueue,
        window = (this.end - this.start),
        start = new Date(this.start.valueOf() - window),
        end = new Date(this.end.valueOf() + window);

    function filter (arr) {
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        AJS.$.each(arr, function(itemIdx, item) {
            var rendered = item.rendered;
            var visible = item.isVisible(start, end);
            if (rendered != visible) {
                if (rendered) {
                    queue.hide.push(item); // item is rendered but no longer visible
                }
                if (visible && AJS.$.inArray(item, queue.show) == -1) {
                    queue.show.push(item); // item is visible but neither rendered nor queued up to be rendered
                }
            }
        });
        // END ATLASSIAN
    }

    // filter all items and all clusters
    filter(this.items);
    if (this.clusters) {
        filter(this.clusters);
    }
};

/** ------------------------------------------------------------------------ **/

/**
 * @constructor links.Timeline.ClusterGenerator
 * Generator which creates clusters of items, based on the visible range in
 * the Timeline. There is a set of cluster levels which is cached.
 * @param {links.Timeline} timeline
 */
links.Timeline.ClusterGenerator = function (timeline) {
    this.timeline = timeline;
    this.clear();
};

/**
 * Clear all cached clusters and data, and initialize all variables
 */
links.Timeline.ClusterGenerator.prototype.clear = function () {
    // cache containing created clusters for each cluster level
    this.items = [];
    this.groups = {};
    this.clearCache();
};

/**
 * Clear the cached clusters
 */
links.Timeline.ClusterGenerator.prototype.clearCache = function () {
    // cache containing created clusters for each cluster level
    this.cache = {};
    this.cacheLevel = -1;
    this.cache[this.cacheLevel] = [];
};

/**
 * Set the items to be clustered.
 * This will clear cached clusters.
 * @param {Item[]} items
 * @param {Object} [options]  Available options:
 *                            {boolean} applyOnChangedLevel
 *                                If true (default), the changed data is applied
 *                                as soon the cluster level changes. If false,
 *                                The changed data is applied immediately
 */
links.Timeline.ClusterGenerator.prototype.setData = function (items, options) {
    this.items = items || [];
    this.dataChanged = true;
    this.applyOnChangedLevel = true;
    if (options && options.applyOnChangedLevel) {
        this.applyOnChangedLevel = options.applyOnChangedLevel;
    }
    // console.log('clustergenerator setData applyOnChangedLevel=' + this.applyOnChangedLevel); // TODO: cleanup
};

/**
 * Update the current data set: clear cache, and recalculate the clustering for
 * the current level
 */
links.Timeline.ClusterGenerator.prototype.updateData = function () {
    this.dataChanged = true;
    this.applyOnChangedLevel = false;
};

/**
 * Filter the items per group.
 * @private
 */
links.Timeline.ClusterGenerator.prototype.filterData = function () {
    // filter per group
    var items = this.items || [];
    var groups = {};
    this.groups = groups;

    // split the items per group
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    AJS.$.each(items, function(itemIdx, item) {
        var groupName = item.group ? item.group.content : '';
        var group = groups[groupName];
        if (!group) {
            group = [];
            groups[groupName] = group;
        }
        group.push(item);

        // calculate the center of the item
        if (item.start) {
            if (item.end) {
                // range
                item.center = (item.start.valueOf() + item.end.valueOf()) / 2;
            }
            else {
                // box, dot
                item.center = item.start.valueOf();
            }
        }
    });
    // END ATLASSIAN

    // sort the items per group
    for (var groupName in groups) {
        if (groups.hasOwnProperty(groupName)) {
            groups[groupName].sort(function (a, b) {
                return (a.center - b.center);
            });
        }
    }

    this.dataChanged = false;
};

/**
 * Cluster the events which are too close together
 * @param {Number} scale     The scale of the current window,
 *                           defined as (windowWidth / (endDate - startDate))
 * @return {Item[]} clusters
 */
links.Timeline.ClusterGenerator.prototype.getClusters = function (scale) {
    var level = -1,
        granularity = 2, // TODO: what granularity is needed for the cluster levels?
        timeWindow = 0,  // milliseconds
        maxItems = 5;    // TODO: do not hard code maxItems

    if (scale > 0) {
        level = Math.round(Math.log(100 / scale) / Math.log(granularity));
        timeWindow = Math.pow(granularity, level);

        // groups must have a larger time window, as the items will not be stacked
        if (this.timeline.groups && this.timeline.groups.length) {
            timeWindow *= 4;
        }
    }

    // clear the cache when and re-filter the data when needed.
    if (this.dataChanged) {
        var levelChanged = (level != this.cacheLevel);
        var applyDataNow = this.applyOnChangedLevel ? levelChanged : true;
        if (applyDataNow) {
            // TODO: currently drawn clusters should be removed! mark them as invisible?
            this.clearCache();
            this.filterData();
            // console.log('clustergenerator: cache cleared...'); // TODO: cleanup
        }
    }

    this.cacheLevel = level;
    var clusters = this.cache[level];
    if (!clusters) {
        // console.log('clustergenerator: create cluster level ' + level); // TODO: cleanup
        clusters = [];

        // TODO: spit this method, it is too large
        for (var groupName in this.groups) {
            if (this.groups.hasOwnProperty(groupName)) {
                var items = this.groups[groupName];
                var iMax = items.length;
                var i = 0;
                while (i < iMax) {
                    // find all items around current item, within the timeWindow
                    var item = items[i];
                    var neighbors = 1;  // start at 1, to include itself)

                    // loop through items left from the current item
                    var j = i - 1;
                    while (j >= 0 && (item.center - items[j].center) < timeWindow / 2) {
                        if (!items[j].cluster) {
                            neighbors++;
                        }
                        j--;
                    }

                    // loop through items right from the current item
                    var k = i + 1;
                    while (k < items.length && (items[k].center - item.center) < timeWindow / 2) {
                        neighbors++;
                        k++;
                    }

                    // loop through the created clusters
                    var l = clusters.length - 1;
                    while (l >= 0 && (item.center - clusters[l].center) < timeWindow / 2) {
                        if (item.group == clusters[l].group) {
                            neighbors++;
                        }
                        l--;
                    }

                    // aggregate until the number of items is within maxItems
                    if (neighbors > maxItems) {
                        // too busy in this window.
                        var num = neighbors - maxItems + 1;
                        var clusterItems = [];

                        // append the items to the cluster,
                        // and calculate the average start for the cluster
                        var avg = undefined;  // number. average of all start dates
                        var min = undefined;  // number. minimum of all start dates
                        var max = undefined;  // number. maximum of all start and end dates
                        var containsRanges = false;
                        var count = 0;
                        var m = i;
                        while (clusterItems.length < num && m < items.length) {
                            var p = items[m];
                            var start = p.start.valueOf();
                            var end = p.end ? p.end.valueOf() : p.start.valueOf();
                            clusterItems.push(p);
                            if (count) {
                                // calculate new average (use fractions to prevent overflow)
                                avg = (count / (count + 1)) * avg + (1 / (count + 1)) * p.center;
                            }
                            else {
                                avg = p.center;
                            }
                            min = (min != undefined) ? Math.min(min, start) : start;
                            max = (max != undefined) ? Math.max(max, end) : end;
                            containsRanges = containsRanges || (p instanceof links.Timeline.ItemRange);
                            count++;
                            m++;
                        }

                        var cluster;
                        var title = 'Cluster containing ' + count +
                            ' events. Zoom in to see the individual events.';
                        var content = '<div title="' + title + '">' + count + ' events</div>';
                        var group = item.group ? item.group.content : undefined;
                        if (containsRanges) {
                            // boxes and/or ranges
                            cluster = this.timeline.createItem({
                                'start': new Date(min),
                                'end': new Date(max),
                                'content': content,
                                'group': group
                            });
                        }
                        else {
                            // boxes only
                            cluster = this.timeline.createItem({
                                'start': new Date(avg),
                                'content': content,
                                'group': group
                            });
                        }
                        cluster.isCluster = true;
                        cluster.items = clusterItems;
                        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
                        AJS.$.each(cluster.items, function(itemIdx, item) {
                            item.cluster = cluster;
                        });
                        // END ATLASSIAN

                        clusters.push(cluster);
                        i += num;
                    }
                    else {
                        delete item.cluster;
                        i += 1;
                    }
                }
            }
        }

        this.cache[level] = clusters;
    }

    return clusters;
};


/** ------------------------------------------------------------------------ **/


/**
 * Event listener (singleton)
 */
links.events = links.events || {
    'listeners': [],

    /**
     * Find a single listener by its object
     * @param {Object} object
     * @return {Number} index  -1 when not found
     */
    'indexOf': function (object) {
        var listeners = this.listeners;
        for (var i = 0, iMax = this.listeners.length; i < iMax; i++) {
            var listener = listeners[i];
            if (listener && listener.object == object) {
                return i;
            }
        }
        return -1;
    },

    /**
     * Add an event listener
     * @param {Object} object
     * @param {String} event       The name of an event, for example 'select'
     * @param {function} callback  The callback method, called when the
     *                             event takes place
     */
    'addListener': function (object, event, callback) {
        var index = this.indexOf(object);
        var listener = this.listeners[index];
        if (!listener) {
            listener = {
                'object': object,
                'events': {}
            };
            this.listeners.push(listener);
        }

        var callbacks = listener.events[event];
        if (!callbacks) {
            callbacks = [];
            listener.events[event] = callbacks;
        }

        // add the callback if it does not yet exist
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        if (AJS.$.inArray(callback, callbacks) == -1) {
            callbacks.push(callback);
        }
        // END ATLASSIAN
    },

    /**
     * Remove an event listener
     * @param {Object} object
     * @param {String} event       The name of an event, for example 'select'
     * @param {function} callback  The registered callback method
     */
    'removeListener': function (object, event, callback) {
        var index = this.indexOf(object);
        var listener = this.listeners[index];
        if (listener) {
            var callbacks = listener.events[event];
            if (callbacks) {
                // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
                var index = AJS.$.inArray(callback, callbacks);
                // END ATLASSIAN
                if (index != -1) {
                    callbacks.splice(index, 1);
                }

                // remove the array when empty
                if (callbacks.length == 0) {
                    delete listener.events[event];
                }
            }

            // count the number of registered events. remove listener when empty
            var count = 0;
            var events = listener.events;
            for (var e in events) {
                if (events.hasOwnProperty(e)) {
                    count++;
                }
            }
            if (count == 0) {
                delete this.listeners[index];
            }
        }
    },

    /**
     * Remove all registered event listeners
     */
    'removeAllListeners': function () {
        this.listeners = [];
    },

    /**
     * Trigger an event. All registered event handlers will be called
     * @param {Object} object
     * @param {String} event
     * @param {Object} properties (optional)
     */
    'trigger': function (object, event, properties) {
        var index = this.indexOf(object);
        var listener = this.listeners[index];
        if (listener) {
            var callbacks = listener.events[event];
            if (callbacks) {
                for (var i = 0, iMax = callbacks.length; i < iMax; i++) {
                    callbacks[i](properties);
                }
            }
        }
    }
};


/** ------------------------------------------------------------------------ **/

/**
 * @constructor  links.Timeline.StepDate
 * The class StepDate is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing start(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function end(). After each step, you can
 * retrieve the current date via get().
 * The class step has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} start          The start date, for example new Date(2010, 9, 21)
 *                              or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} end            The end date
 * @param {Number}  minimumStep Optional. Minimum step size in milliseconds
 */
links.Timeline.StepDate = function(start, end, minimumStep) {

    // variables
    this.current = new Date();
    this._start = new Date();
    this._end = new Date();

    this.autoScale  = true;
    this.scale = links.Timeline.StepDate.SCALE.DAY;
    this.step = 1;

    // initialize the range
    this.setRange(start, end, minimumStep);
};

/// enum scale
links.Timeline.StepDate.SCALE = {
    MILLISECOND: 1,
    SECOND: 2,
    MINUTE: 3,
    HOUR: 4,
    DAY: 5,
    WEEKDAY: 6,
    MONTH: 7,
    YEAR: 8
};


/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} start        The start date and time.
 * @param {Date} end          The end date and time.
 * @param {int}  minimumStep  Optional. Minimum step size in milliseconds
 */
links.Timeline.StepDate.prototype.setRange = function(start, end, minimumStep) {
    if (!(start instanceof Date) || !(end instanceof Date)) {
        //throw  "No legal start or end date in method setRange";
        return;
    }

    this._start = (start != undefined) ? new Date(start.valueOf()) : new Date();
    this._end = (end != undefined) ? new Date(end.valueOf()) : new Date();

    if (this.autoScale) {
        this.setMinimumStep(minimumStep);
    }
};

/**
 * Set the step iterator to the start date.
 */
links.Timeline.StepDate.prototype.start = function() {
    this.current = new Date(this._start.valueOf());
    this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
links.Timeline.StepDate.prototype.roundToMinor = function() {
    // round to floor
    // IMPORTANT: we have no breaks in this switch! (this is no bug)
    //noinspection FallthroughInSwitchStatementJS
    switch (this.scale) {
        case links.Timeline.StepDate.SCALE.YEAR:
            this.current.setFullYear(this.step * Math.floor(this.current.getFullYear() / this.step));
            this.current.setMonth(0);
        case links.Timeline.StepDate.SCALE.MONTH:        this.current.setDate(1);
        case links.Timeline.StepDate.SCALE.DAY:          // intentional fall through
        case links.Timeline.StepDate.SCALE.WEEKDAY:      this.current.setHours(0);
        case links.Timeline.StepDate.SCALE.HOUR:         this.current.setMinutes(0);
        case links.Timeline.StepDate.SCALE.MINUTE:       this.current.setSeconds(0);
        case links.Timeline.StepDate.SCALE.SECOND:       this.current.setMilliseconds(0);
        //case links.Timeline.StepDate.SCALE.MILLISECOND: // nothing to do for milliseconds
    }

    if (this.step != 1) {
        // round down to the first minor value that is a multiple of the current step size
        switch (this.scale) {
            case links.Timeline.StepDate.SCALE.MILLISECOND:  this.current.setMilliseconds(this.current.getMilliseconds() - this.current.getMilliseconds() % this.step);  break;
            case links.Timeline.StepDate.SCALE.SECOND:       this.current.setSeconds(this.current.getSeconds() - this.current.getSeconds() % this.step); break;
            case links.Timeline.StepDate.SCALE.MINUTE:       this.current.setMinutes(this.current.getMinutes() - this.current.getMinutes() % this.step); break;
            case links.Timeline.StepDate.SCALE.HOUR:         this.current.setHours(this.current.getHours() - this.current.getHours() % this.step); break;
            case links.Timeline.StepDate.SCALE.WEEKDAY:      // intentional fall through
            case links.Timeline.StepDate.SCALE.DAY:          this.current.setDate((this.current.getDate()-1) - (this.current.getDate()-1) % this.step + 1); break;
            case links.Timeline.StepDate.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() - this.current.getMonth() % this.step);  break;
            case links.Timeline.StepDate.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() - this.current.getFullYear() % this.step); break;
            default: break;
        }
    }
};

/**
 * Check if the end date is reached
 * @return {boolean}  true if the current date has passed the end date
 */
links.Timeline.StepDate.prototype.end = function () {
    return (this.current.valueOf() > this._end.valueOf());
};

/**
 * Do the next step
 */
links.Timeline.StepDate.prototype.next = function() {
    var prev = this.current.valueOf();

    // Two cases, needed to prevent issues with switching daylight savings
    // (end of March and end of October)
    if (this.current.getMonth() < 6)   {
        switch (this.scale) {
            case links.Timeline.StepDate.SCALE.MILLISECOND:

                this.current = new Date(this.current.valueOf() + this.step); break;
            case links.Timeline.StepDate.SCALE.SECOND:       this.current = new Date(this.current.valueOf() + this.step * 1000); break;
            case links.Timeline.StepDate.SCALE.MINUTE:       this.current = new Date(this.current.valueOf() + this.step * 1000 * 60); break;
            case links.Timeline.StepDate.SCALE.HOUR:
                this.current = new Date(this.current.valueOf() + this.step * 1000 * 60 * 60);
                // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
                var h = this.current.getHours();
                this.current.setHours(h - (h % this.step));
                break;
            case links.Timeline.StepDate.SCALE.WEEKDAY:      // intentional fall through
            case links.Timeline.StepDate.SCALE.DAY:          this.current.setDate(this.current.getDate() + this.step); break;
            case links.Timeline.StepDate.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() + this.step); break;
            case links.Timeline.StepDate.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() + this.step); break;
            default:                      break;
        }
    }
    else {
        switch (this.scale) {
            case links.Timeline.StepDate.SCALE.MILLISECOND:  this.current = new Date(this.current.valueOf() + this.step); break;
            case links.Timeline.StepDate.SCALE.SECOND:       this.current.setSeconds(this.current.getSeconds() + this.step); break;
            case links.Timeline.StepDate.SCALE.MINUTE:       this.current.setMinutes(this.current.getMinutes() + this.step); break;
            case links.Timeline.StepDate.SCALE.HOUR:         this.current.setHours(this.current.getHours() + this.step); break;
            case links.Timeline.StepDate.SCALE.WEEKDAY:      // intentional fall through
            case links.Timeline.StepDate.SCALE.DAY:          this.current.setDate(this.current.getDate() + this.step); break;
            case links.Timeline.StepDate.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() + this.step); break;
            case links.Timeline.StepDate.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() + this.step); break;
            default:                      break;
        }
    }

    if (this.step != 1) {
        // round down to the correct major value
        switch (this.scale) {
            case links.Timeline.StepDate.SCALE.MILLISECOND:  if(this.current.getMilliseconds() < this.step) this.current.setMilliseconds(0);  break;
            case links.Timeline.StepDate.SCALE.SECOND:       if(this.current.getSeconds() < this.step) this.current.setSeconds(0);  break;
            case links.Timeline.StepDate.SCALE.MINUTE:       if(this.current.getMinutes() < this.step) this.current.setMinutes(0);  break;
            case links.Timeline.StepDate.SCALE.HOUR:         if(this.current.getHours() < this.step) this.current.setHours(0);  break;
            case links.Timeline.StepDate.SCALE.WEEKDAY:      // intentional fall through
            case links.Timeline.StepDate.SCALE.DAY:          if(this.current.getDate() < this.step+1) this.current.setDate(1); break;
            case links.Timeline.StepDate.SCALE.MONTH:        if(this.current.getMonth() < this.step) this.current.setMonth(0);  break;
            case links.Timeline.StepDate.SCALE.YEAR:         break; // nothing to do for year
            default:                break;
        }
    }

    // safety mechanism: if current time is still unchanged, move to the end
    if (this.current.valueOf() == prev) {
        this.current = new Date(this._end.valueOf());
    }
};


/**
 * Get the current datetime
 * @return {Date}  current The current date
 */
links.Timeline.StepDate.prototype.getCurrent = function() {
    return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale(SCALE.MINUTES, 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {links.Timeline.StepDate.SCALE} newScale
 *                               A scale. Choose from SCALE.MILLISECOND,
 *                               SCALE.SECOND, SCALE.MINUTE, SCALE.HOUR,
 *                               SCALE.WEEKDAY, SCALE.DAY, SCALE.MONTH,
 *                               SCALE.YEAR.
 * @param {Number}     newStep   A step size, by default 1. Choose for
 *                               example 1, 2, 5, or 10.
 */
links.Timeline.StepDate.prototype.setScale = function(newScale, newStep) {
    this.scale = newScale;

    if (newStep > 0) {
        this.step = newStep;
    }

    this.autoScale = false;
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
links.Timeline.StepDate.prototype.setAutoScale = function (enable) {
    this.autoScale = enable;
};


/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} minimumStep  The minimum step size in milliseconds
 */
links.Timeline.StepDate.prototype.setMinimumStep = function(minimumStep) {
    if (minimumStep == undefined) {
        return;
    }

    var stepYear       = (1000 * 60 * 60 * 24 * 30 * 12);
    var stepMonth      = (1000 * 60 * 60 * 24 * 30);
    var stepDay        = (1000 * 60 * 60 * 24);
    var stepHour       = (1000 * 60 * 60);
    var stepMinute     = (1000 * 60);
    var stepSecond     = (1000);
    var stepMillisecond= (1);

    // find the smallest step that is larger than the provided minimumStep
    if (stepYear*1000 > minimumStep)        {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 1000;}
    if (stepYear*500 > minimumStep)         {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 500;}
    if (stepYear*100 > minimumStep)         {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 100;}
    if (stepYear*50 > minimumStep)          {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 50;}
    if (stepYear*10 > minimumStep)          {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 10;}
    if (stepYear*5 > minimumStep)           {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 5;}
    if (stepYear > minimumStep)             {this.scale = links.Timeline.StepDate.SCALE.YEAR;        this.step = 1;}
    if (stepMonth*3 > minimumStep)          {this.scale = links.Timeline.StepDate.SCALE.MONTH;       this.step = 3;}
    if (stepMonth > minimumStep)            {this.scale = links.Timeline.StepDate.SCALE.MONTH;       this.step = 1;}
    if (stepDay*5 > minimumStep)            {this.scale = links.Timeline.StepDate.SCALE.DAY;         this.step = 5;}
    if (stepDay*2 > minimumStep)            {this.scale = links.Timeline.StepDate.SCALE.DAY;         this.step = 2;}
    if (stepDay > minimumStep)              {this.scale = links.Timeline.StepDate.SCALE.DAY;         this.step = 1;}
    if (stepDay/2 > minimumStep)            {this.scale = links.Timeline.StepDate.SCALE.WEEKDAY;     this.step = 1;}
    if (stepHour*4 > minimumStep)           {this.scale = links.Timeline.StepDate.SCALE.HOUR;        this.step = 4;}
    if (stepHour > minimumStep)             {this.scale = links.Timeline.StepDate.SCALE.HOUR;        this.step = 1;}
    if (stepMinute*15 > minimumStep)        {this.scale = links.Timeline.StepDate.SCALE.MINUTE;      this.step = 15;}
    if (stepMinute*10 > minimumStep)        {this.scale = links.Timeline.StepDate.SCALE.MINUTE;      this.step = 10;}
    if (stepMinute*5 > minimumStep)         {this.scale = links.Timeline.StepDate.SCALE.MINUTE;      this.step = 5;}
    if (stepMinute > minimumStep)           {this.scale = links.Timeline.StepDate.SCALE.MINUTE;      this.step = 1;}
    if (stepSecond*15 > minimumStep)        {this.scale = links.Timeline.StepDate.SCALE.SECOND;      this.step = 15;}
    if (stepSecond*10 > minimumStep)        {this.scale = links.Timeline.StepDate.SCALE.SECOND;      this.step = 10;}
    if (stepSecond*5 > minimumStep)         {this.scale = links.Timeline.StepDate.SCALE.SECOND;      this.step = 5;}
    if (stepSecond > minimumStep)           {this.scale = links.Timeline.StepDate.SCALE.SECOND;      this.step = 1;}
    if (stepMillisecond*200 > minimumStep)  {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 200;}
    if (stepMillisecond*100 > minimumStep)  {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 100;}
    if (stepMillisecond*50 > minimumStep)   {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 50;}
    if (stepMillisecond*10 > minimumStep)   {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 10;}
    if (stepMillisecond*5 > minimumStep)    {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 5;}
    if (stepMillisecond > minimumStep)      {this.scale = links.Timeline.StepDate.SCALE.MILLISECOND; this.step = 1;}
};

/**
 * Snap a date to a rounded value. The snap intervals are dependent on the
 * current scale and step.
 * @param {Date} date   the date to be snapped
 */
links.Timeline.StepDate.prototype.snap = function(date) {
    if (this.scale == links.Timeline.StepDate.SCALE.YEAR) {
        var year = date.getFullYear() + Math.round(date.getMonth() / 12);
        date.setFullYear(Math.round(year / this.step) * this.step);
        date.setMonth(0);
        date.setDate(0);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
    }
    else if (this.scale == links.Timeline.StepDate.SCALE.MONTH) {
        if (date.getDate() > 15) {
            date.setDate(1);
            date.setMonth(date.getMonth() + 1);
            // important: first set Date to 1, after that change the month.
        }
        else {
            date.setDate(1);
        }

        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
    }
    else if (this.scale == links.Timeline.StepDate.SCALE.DAY ||
        this.scale == links.Timeline.StepDate.SCALE.WEEKDAY) {
        switch (this.step) {
            case 5:
            case 2:
                date.setHours(Math.round(date.getHours() / 24) * 24); break;
            default:
                date.setHours(Math.round(date.getHours() / 12) * 12); break;
        }
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
    }
    else if (this.scale == links.Timeline.StepDate.SCALE.HOUR) {
        switch (this.step) {
            case 4:
                date.setMinutes(Math.round(date.getMinutes() / 60) * 60); break;
            default:
                date.setMinutes(Math.round(date.getMinutes() / 30) * 30); break;
        }
        date.setSeconds(0);
        date.setMilliseconds(0);
    } else if (this.scale == links.Timeline.StepDate.SCALE.MINUTE) {
        switch (this.step) {
            case 15:
            case 10:
                date.setMinutes(Math.round(date.getMinutes() / 5) * 5);
                date.setSeconds(0);
                break;
            case 5:
                date.setSeconds(Math.round(date.getSeconds() / 60) * 60); break;
            default:
                date.setSeconds(Math.round(date.getSeconds() / 30) * 30); break;
        }
        date.setMilliseconds(0);
    }
    else if (this.scale == links.Timeline.StepDate.SCALE.SECOND) {
        switch (this.step) {
            case 15:
            case 10:
                date.setSeconds(Math.round(date.getSeconds() / 5) * 5);
                date.setMilliseconds(0);
                break;
            case 5:
                date.setMilliseconds(Math.round(date.getMilliseconds() / 1000) * 1000); break;
            default:
                date.setMilliseconds(Math.round(date.getMilliseconds() / 500) * 500); break;
        }
    }
    else if (this.scale == links.Timeline.StepDate.SCALE.MILLISECOND) {
        var step = this.step > 5 ? this.step / 2 : 1;
        date.setMilliseconds(Math.round(date.getMilliseconds() / step) * step);
    }
};

/**
 * Check if the current step is a major step (for example when the step
 * is DAY, a major step is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
links.Timeline.StepDate.prototype.isMajor = function() {
    switch (this.scale) {
        case links.Timeline.StepDate.SCALE.MILLISECOND:
            return (this.current.getMilliseconds() == 0);
        case links.Timeline.StepDate.SCALE.SECOND:
            return (this.current.getSeconds() == 0);
        case links.Timeline.StepDate.SCALE.MINUTE:
            return (this.current.getHours() == 0) && (this.current.getMinutes() == 0);
        // Note: this is no bug. Major label is equal for both minute and hour scale
        case links.Timeline.StepDate.SCALE.HOUR:
            return (this.current.getHours() == 0);
        case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through
        case links.Timeline.StepDate.SCALE.DAY:
            return (this.current.getDate() == 1);
        case links.Timeline.StepDate.SCALE.MONTH:
            return (this.current.getMonth() == 0);
        case links.Timeline.StepDate.SCALE.YEAR:
            return false;
        default:
            return false;
    }
};


/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Object} options
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
links.Timeline.StepDate.prototype.getLabelMinor = function(options, date) {
    if (date == undefined) {
        date = this.current;
    }

    switch (this.scale) {
        case links.Timeline.StepDate.SCALE.MILLISECOND:  return String(date.getMilliseconds());
        case links.Timeline.StepDate.SCALE.SECOND:       return String(date.getSeconds());
        case links.Timeline.StepDate.SCALE.MINUTE:
            return this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2);
        case links.Timeline.StepDate.SCALE.HOUR:
            return this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2);
        case links.Timeline.StepDate.SCALE.WEEKDAY:      return options.DAYS_SHORT[date.getDay()] + ' ' + date.getDate();
        case links.Timeline.StepDate.SCALE.DAY:          return String(date.getDate());
        case links.Timeline.StepDate.SCALE.MONTH:        return options.MONTHS_SHORT[date.getMonth()];   // month is zero based
        case links.Timeline.StepDate.SCALE.YEAR:         return String(date.getFullYear());
        default:                                         return "";
    }
};


/**
 * Returns formatted text for the major axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Object} options
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
links.Timeline.StepDate.prototype.getLabelMajor = function(options, date) {
    if (date == undefined) {
        date = this.current;
    }

    switch (this.scale) {
        case links.Timeline.StepDate.SCALE.MILLISECOND:
            return  this.addZeros(date.getHours(), 2) + ":" +
                this.addZeros(date.getMinutes(), 2) + ":" +
                this.addZeros(date.getSeconds(), 2);
        case links.Timeline.StepDate.SCALE.SECOND:
            return  date.getDate() + " " +
                options.MONTHS[date.getMonth()] + " " +
                this.addZeros(date.getHours(), 2) + ":" +
                this.addZeros(date.getMinutes(), 2);
        case links.Timeline.StepDate.SCALE.MINUTE:
            return  options.DAYS[date.getDay()] + " " +
                date.getDate() + " " +
                options.MONTHS[date.getMonth()] + " " +
                date.getFullYear();
        case links.Timeline.StepDate.SCALE.HOUR:
            return  options.DAYS[date.getDay()] + " " +
                date.getDate() + " " +
                options.MONTHS[date.getMonth()] + " " +
                date.getFullYear();
        case links.Timeline.StepDate.SCALE.WEEKDAY:
        case links.Timeline.StepDate.SCALE.DAY:
            return  options.MONTHS[date.getMonth()] + " " +
                date.getFullYear();
        case links.Timeline.StepDate.SCALE.MONTH:
            return String(date.getFullYear());
        default:
            return "";
    }
};

/**
 * Add leading zeros to the given value to match the desired length.
 * For example addZeros(123, 5) returns "00123"
 * @param {int} value   A value
 * @param {int} len     Desired final length
 * @return {string}     value with leading zeros
 */
links.Timeline.StepDate.prototype.addZeros = function(value, len) {
    var str = "" + value;
    while (str.length < len) {
        str = "0" + str;
    }
    return str;
};



/** ------------------------------------------------------------------------ **/

/**
 * Image Loader service.
 * can be used to get a callback when a certain image is loaded
 *
 */
links.imageloader = (function () {
    var urls = {};  // the loaded urls
    var callbacks = {}; // the urls currently being loaded. Each key contains
    // an array with callbacks

    /**
     * Check if an image url is loaded
     * @param {String} url
     * @return {boolean} loaded   True when loaded, false when not loaded
     *                            or when being loaded
     */
    function isLoaded (url) {
        if (urls[url] == true) {
            return true;
        }

        var image = new Image();
        image.src = url;
        if (image.complete) {
            return true;
        }

        return false;
    }

    /**
     * Check if an image url is being loaded
     * @param {String} url
     * @return {boolean} loading   True when being loaded, false when not loading
     *                             or when already loaded
     */
    function isLoading (url) {
        return (callbacks[url] != undefined);
    }

    /**
     * Load given image url
     * @param {String} url
     * @param {function} callback
     * @param {boolean} sendCallbackWhenAlreadyLoaded  optional
     */
    function load (url, callback, sendCallbackWhenAlreadyLoaded) {
        if (sendCallbackWhenAlreadyLoaded == undefined) {
            sendCallbackWhenAlreadyLoaded = true;
        }

        if (isLoaded(url)) {
            if (sendCallbackWhenAlreadyLoaded) {
                callback(url);
            }
            return;
        }

        if (isLoading(url) && !sendCallbackWhenAlreadyLoaded) {
            return;
        }

        var c = callbacks[url];
        if (!c) {
            var image = new Image();
            image.src = url;

            c = [];
            callbacks[url] = c;

            image.onload = function (event) {
                urls[url] = true;
                delete callbacks[url];

                for (var i = 0; i < c.length; i++) {
                    c[i](url);
                }
            }
        }

        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        if (AJS.$.inArray(callback, c) == -1) {
            c.push(callback);
        }
        // END ATLASSIAN
    }

    /**
     * Load a set of images, and send a callback as soon as all images are
     * loaded
     * @param {String[]} urls
     * @param {function } callback
     * @param {boolean} sendCallbackWhenAlreadyLoaded
     */
    function loadAll (urls, callback, sendCallbackWhenAlreadyLoaded) {
        // list all urls which are not yet loaded
        var urlsLeft = [];
        // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
        AJS.$.each(urls, function(urlIdx, url) {
            if (!isLoaded(url)) {
                urlsLeft.push(url);
            }
        });
        // END ATLASSIAN

        if (urlsLeft.length) {
            // there are unloaded images
            var countLeft = urlsLeft.length;
            // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
            AJS.$.each(urlsLeft, function(urlIdx, url) {
                load(url, function () {
                    countLeft--;
                    if (countLeft == 0) {
                        // done!
                        callback();
                    }
                }, sendCallbackWhenAlreadyLoaded);
            });
            // END ATLASSIAN
        }
        else {
            // we are already done!
            if (sendCallbackWhenAlreadyLoaded) {
                callback();
            }
        }
    }

    /**
     * Recursively retrieve all image urls from the images located inside a given
     * HTML element
     * @param {Node} elem
     * @param {String[]} urls   Urls will be added here (no duplicates)
     */
    function filterImageUrls (elem, urls) {
        var child = elem.firstChild;
        while (child) {
            if (child.tagName == 'IMG') {
                var url = child.src;
                // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
                if (AJS.$.inArray(url, urls) == -1) {
                    urls.push(url);
                }
                // END ATLASSIAN
            }

            filterImageUrls(child, urls);

            child = child.nextSibling;
        }
    }

    return {
        'isLoaded': isLoaded,
        'isLoading': isLoading,
        'load': load,
        'loadAll': loadAll,
        'filterImageUrls': filterImageUrls
    };
})();


/** ------------------------------------------------------------------------ **/


/**
 * Add and event listener. Works for all browsers
 * @param {Element} element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     useCapture
 */
links.Timeline.addEventListener = function (element, action, listener, useCapture) {
    if (element.addEventListener) {
        if (useCapture === undefined)
            useCapture = false;

        if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
            action = "DOMMouseScroll";  // For Firefox
        }

        element.addEventListener(action, listener, useCapture);
    } else {
        element.attachEvent("on" + action, listener);  // IE browsers
    }
};

/**
 * Remove an event listener from an element
 * @param {Element}  element   An html dom element
 * @param {string}       action    The name of the event, for example "mousedown"
 * @param {function}     listener  The listener function
 * @param {boolean}      useCapture
 */
links.Timeline.removeEventListener = function(element, action, listener, useCapture) {
    if (element.removeEventListener) {
        // non-IE browsers
        if (useCapture === undefined)
            useCapture = false;

        if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
            action = "DOMMouseScroll";  // For Firefox
        }

        element.removeEventListener(action, listener, useCapture);
    } else {
        // IE browsers
        element.detachEvent("on" + action, listener);
    }
};


/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
links.Timeline.getTarget = function (event) {
    // code from http://www.quirksmode.org/js/events_properties.html
    if (!event) {
        event = window.event;
    }

    var target;

    if (event.target) {
        target = event.target;
    }
    else if (event.srcElement) {
        target = event.srcElement;
    }

    if (target.nodeType != undefined && target.nodeType == 3) {
        // defeat Safari bug
        target = target.parentNode;
    }

    return target;
};

/**
 * Stop event propagation
 */
links.Timeline.stopPropagation = function (event) {
    if (!event)
        event = window.event;

    if (event.stopPropagation) {
        event.stopPropagation();  // non-IE browsers
    }
    else {
        event.cancelBubble = true;  // IE browsers
    }
};


/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
links.Timeline.preventDefault = function (event) {
    if (!event)
        event = window.event;

    if (event.preventDefault) {
        event.preventDefault();  // non-IE browsers
    }
    else {
        event.returnValue = false;  // IE browsers
    }
};


/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
links.Timeline.getAbsoluteLeft = function(elem) {
    var doc = document.documentElement;
    var body = document.body;

    var left = elem.offsetLeft;
    var e = elem.offsetParent;
    while (e != null && e != body && e != doc) {
        left += e.offsetLeft;
        left -= e.scrollLeft;
        e = e.offsetParent;
    }
    return left;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
links.Timeline.getAbsoluteTop = function(elem) {
    var doc = document.documentElement;
    var body = document.body;

    var top = elem.offsetTop;
    var e = elem.offsetParent;
    while (e != null && e != body && e != doc) {
        top += e.offsetTop;
        top -= e.scrollTop;
        e = e.offsetParent;
    }
    return top;
};

/**
 * Get the absolute, vertical mouse position from an event.
 * @param {Event} event
 * @return {Number} pageY
 */
links.Timeline.getPageY = function (event) {
    if ('pageY' in event) {
        return event.pageY;
    }
    else {
        var clientY;
        if (('targetTouches' in event) && event.targetTouches.length) {
            clientY = event.targetTouches[0].clientY;
        }
        else {
            clientY = event.clientY;
        }

        var doc = document.documentElement;
        var body = document.body;
        return clientY +
            ( doc && doc.scrollTop || body && body.scrollTop || 0 ) -
            ( doc && doc.clientTop || body && body.clientTop || 0 );
    }
};

/**
 * Get the absolute, horizontal mouse position from an event.
 * @param {Event} event
 * @return {Number} pageX
 */
links.Timeline.getPageX = function (event) {
    if ('pageY' in event) {
        return event.pageX;
    }
    else {
        var clientX;
        if (('targetTouches' in event) && event.targetTouches.length) {
            clientX = event.targetTouches[0].clientX;
        }
        else {
            clientX = event.clientX;
        }

        var doc = document.documentElement;
        var body = document.body;
        return clientX +
            ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
            ( doc && doc.clientLeft || body && body.clientLeft || 0 );
    }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
links.Timeline.addClassName = function(elem, className) {
    var classes = elem.className.split(' ');
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    if (AJS.$.inArray(className, classes) == -1) {
        classes.push(className); // add the class to the array
        elem.className = classes.join(' ');
    }
    // END ATLASSIAN
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
links.Timeline.removeClassName = function(elem, className) {
    var classes = elem.className.split(' ');
    // ATLASSIAN - https://jira.atlassian.com/browse/TEAMCAL-1747
    var index = AJS.$.inArray(className, classes);
    if (index != -1) {
        classes.splice(index, 1); // remove the class from the array
        elem.className = classes.join(' ');
    }
    // END ATLASSIAN
};

/**
 * Check if given object is a Javascript Array
 * @param {*} obj
 * @return {Boolean} isArray    true if the given object is an array
 */
// See http://stackoverflow.com/questions/2943805/javascript-instanceof-typeof-in-gwt-jsni
links.Timeline.isArray = function (obj) {
    if (obj instanceof Array) {
        return true;
    }
    return (Object.prototype.toString.call(obj) === '[object Array]');
};

/**
 * parse a JSON date
 * @param {Date | String | Number} date    Date object to be parsed. Can be:
 *                                         - a Date object like new Date(),
 *                                         - a long like 1356970529389,
 *                                         an ISO String like "2012-12-31T16:16:07.213Z",
 *                                         or a .Net Date string like
 *                                         "\/Date(1356970529389)\/"
 * @return {Date} parsedDate
 */
links.Timeline.parseJSONDate = function (date) {
    if (date == undefined) {
        return undefined;
    }

    //test for date
    if (date instanceof Date) {
        return date;
    }

    // test for MS format.
    // FIXME: will fail on a Number
    var m = date.match(/\/Date\((-?\d+)([-\+]?\d{2})?(\d{2})?\)\//i);
    if (m) {
        var offset = m[2]
            ? (3600000 * m[2]) // hrs offset
        + (60000 * m[3] * (m[2] / Math.abs(m[2]))) // mins offset
            : 0;

        return new Date(
            (1 * m[1]) // ticks
            + offset
        );
    }

    // failing that, try to parse whatever we've got.
    return Date.parse(date);
};

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:util', location = '/com/atlassian/confluence/extra/calendar3/util/util.js' */
define("tc/util", [ "jquery" ], function ($) {
    var module = {};

    module.showDialogInUpdatedHeight = function(aDialog) {
        // Such flashing is required so that the dialog resizes properly, and the stuff doesn't appear blank in IE7.
        if (!aDialog.getCurrentPanel().body.is(":visible"))
            aDialog.show();

        aDialog.updateHeight();


        // workaround AJS-627
        aDialog.popup.element.css("height", "");
        aDialog.popup.element.find("div.dialog-panel-body").css("height", "");
        aDialog.popup.element.find("form, div.buttons-container").css("margin-bottom", "0");
        aDialog.popup.changeSize(undefined, aDialog.popup.element.outerHeight());
        aDialog.hide();
        aDialog.show();
    };

    module.getRestBaseUrl = function() {
        return Confluence.getContextPath() + "/rest/calendar-services/1.0";
    };

    return module;
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-util', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-util/calendar-util-component.js' */
define("tc/calendar-util",
    [
        "jquery",
        "ajs",
        "tc-backbone",
        "tc/templates"
    ],
    function (
        $,
        AJS,
        Backbone,
        Templates) {

        "use strict";

        function removeDuplicatedErrorMessages(infoMessagesList){
            var uniqueMessageItems = {};
            $("li", infoMessagesList).each(function(){
                var item = $(this).text();
                if(uniqueMessageItems[item])
                {
                    $(this).remove();
                } else {
                    uniqueMessageItems[item] = true;
                }
            });
        }

        var calendarUtils = {
            panelEditCalendar: {
                GENERAL_PANEL : 0,
                EVENT_TYPE_PANEL : 1,
                RESTRICTION_PANEL : 2,
                SHARE_EMBEDDED_PANEL : 3,
                SUBSCRIBE_PANEL: 4
            },
            ajaxTimeout : 120000,
            isCalendarSearchDisabled : $("#team-calendars-search-disabled").length,
            hasJiraLink : $("#team-calendars-has-jira-link").length,
            getParameter : function(calendarDiv, configKey) {
                return this.getParameters(calendarDiv)[configKey];
            },
            getParameters : function(calendarDiv) {
                if (!calendarDiv.data("parameters")) {
                    var parameters = {};

                    $("fieldset.parameters input", calendarDiv).each(function() {
                        if (parameters[this.name]) {
                            if ($.isArray(parameters[this.name]))
                                parameters[this.name].push(this.value);
                            else
                                parameters[this.name] = [ parameters[this.name], this.value ];
                        } else {
                            parameters[this.name] = this.value;
                        }
                    });

                    calendarDiv.data("parameters", parameters);
                }

                return calendarDiv.data("parameters");
            },
            setParameter : function(calendarDiv, configKey, value) {
                calendarDiv.removeData("parameters");
                var paramsFieldset = $("fieldset.parameters", calendarDiv);
                $("input[name='" + configKey + "']", paramsFieldset).remove();

                if ($.isArray(value)) {
                    $.each(value, function(idx, aValue) {
                        $("<input type='hidden'/>").attr("name", configKey).val(aValue).appendTo(paramsFieldset);
                    });
                } else {
                    $("<input type='hidden'/>").attr("name", configKey).val(value).appendTo(paramsFieldset);
                }
            },
            getSortedSubCalendarsByTypeAndName : function(subCalendars) {

                if (!subCalendars)
                    return [];

                var subCalendarsByTypes = {};

                // Organise sub-calendars by type
                $.each(subCalendars, function(subCalendarIdx, subCalendar) {
                    var subCalendarType = subCalendar.subscriptionType || subCalendar.type,
                        subCalendarsOfType;

                    if (!subCalendarsByTypes[subCalendarType]) {
                        subCalendarsOfType = [];
                        subCalendarsByTypes[subCalendarType] = subCalendarsOfType;
                    } else {
                        subCalendarsOfType = subCalendarsByTypes[subCalendarType];
                    }

                    subCalendarsOfType.push(subCalendar);
                });

                // Sort sub-calendar types array
                $.each(subCalendarsByTypes, function(subCalendarType, subCalendarsOfType) {
                    subCalendarsOfType.sort(function(leftSubCalendar, rightSubCalendar) {
                        var leftName = (leftSubCalendar.name || "").toLowerCase(),
                            rightName = (rightSubCalendar.name || "").toLowerCase();

                        return leftName > rightName ? -1 : (rightName > leftName ? 1: 0);
                    });
                });

                var sortedSubCalendars = [];
                $.each(
                    // Process only the sub-calendar types we have
                    $.grep(
                        // Get the array indicating the order of sub-calendar types to process.
                        (function() {
                            var theOrder = [];

                            $.each(Confluence.TeamCalendars.subcalendar, function(handleType, handler) {
                                theOrder.push(handleType);
                            });

                            theOrder.sort(function(leftType, rightType) {
                                return Confluence.TeamCalendars.subcalendar[leftType].weight -
                                    Confluence.TeamCalendars.subcalendar[rightType].weight;
                            });

                            return theOrder;

                        })(),
                        function(subCalendarType) {
                            return subCalendarsByTypes[subCalendarType];
                        }
                    ),
                    function(typeIdx, subCalendarType) {
                        $.each(subCalendarsByTypes[subCalendarType], function(subCalendarIdx, subCalendar) {
                            sortedSubCalendars.push(subCalendar);
                        })
                    }
                );

                $.each(sortedSubCalendars, function(subCalendarIdx, subCalendar) {
                    if ($.isArray(subCalendar.childSubCalendars) && subCalendar.childSubCalendars.length) {
                        subCalendar.childSubCalendars.sort(
                            function(leftChild, rightChild) {
                                var leftChildWeight = window.Confluence.TeamCalendars.subcalendar[leftChild.subscriptionType || leftChild.type].weight,
                                    rightChildWeight = window.Confluence.TeamCalendars.subcalendar[rightChild.subscriptionType || rightChild.type].weight;

                                return leftChildWeight < rightChildWeight ? -1 : (leftChildWeight > rightChildWeight ? 1 : 0);
                            }
                        );
                    }
                });

                return sortedSubCalendars;
            },
            getAsArray : function() {
                var theArray = [];

                $.each(arguments, function(argIdx, argument) {
                    if ($.isArray(argument)) {
                        $.each(argument, function(argIdx, argElem) {
                            if (typeof argElem === "string")
                                theArray.push(argElem); // A sub-calendar ID in an array
                            else if ($.isPlainObject(argElem) && argElem.id && typeof argElem.id === "string")
                                theArray.push(argElem.id);
                            else
                                theArray.push(argElem.toString());
                        });
                    } else {
                        theArray.push(argument.toString());
                    }
                });

                return theArray;
            },
            populateTimeZoneDropDown : function(timeZoneSelect, timeZoneToSelect, onSuccess, onError) {
                var spinner = $(".spinner", timeZoneSelect.parent());
                spinner.removeClass("hidden");

                $.ajax({
                    type: "GET",
                    timeout: this.ajaxTimeout,
                    url: this.getRestBaseUrl() + "/timezones/calendar",
                    success: function(timeZones) {
                        timeZoneSelect
                            .html(Templates.timeZoneDropDown(timeZones))
                            .val(timeZoneToSelect);
                        spinner.addClass("hidden");
                        onSuccess();
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        spinner.addClass("hidden");
                        onError(XMLHttpRequest, textStatus, errorThrown);
                    }
                });
            },
            getRestBaseUrl : function() {
                return Confluence.getContextPath() + "/rest/calendar-services/1.0";
            },
            getCalendarServiceBaseUrl : function(relativePath) {
                return this.getRestBaseUrl() + "/calendar" + relativePath;
            },
            mergeSubCalendarObjectsToArray : function(arrayWithSubCalendarObject) {
                var that = this;
                if (arrayWithSubCalendarObject && $.isArray(arrayWithSubCalendarObject)) {
                    var mergeSubCalendarIntoContainingObject = function(objectContainingSubCalendar) {
                        $.extend(objectContainingSubCalendar, objectContainingSubCalendar.subCalendar);
                        delete objectContainingSubCalendar.subCalendar;
                    };

                    $.each(arrayWithSubCalendarObject, function(idx, arrayElement) {
                        mergeSubCalendarIntoContainingObject(arrayElement);
                        $.each(arrayElement.childSubCalendars || [], function(childIdx, objectContainingChildSubCalendar) {
                            mergeSubCalendarIntoContainingObject(objectContainingChildSubCalendar);
                        })
                    });
                }

                //Filter out the subscription calendars and arrange them so that they appear like child calendars
                //of a dummy "Subscriptions" parent calendar.
                var rearrangeSubCalendars = function(subCalendars) {
                    if (!(subCalendars && subCalendars.length))
                        return;

                    var subscriptionsParent = {
                            "name":              "\u8ba2\u9605",
                            "type":              "subscription",
                            "dummy":           true,
                            "id": "dummy"
                        }, //Build dummy parent calendar,
                        subscriptionChildSubCalendars = [],
                        rearrangedSubCalendars = [];

                    $.each(subCalendars, function(idx, subCalendar) {
                        if (that.isSubscriptionSubCalendar(subCalendar)) {
                            subscriptionChildSubCalendars.push(subCalendar);
                        } else {
                            rearrangedSubCalendars.push(subCalendar);
                        }
                    });

                    //Make the subscription calendars children of the dummy parent calendar
                    if (subscriptionChildSubCalendars.length) {
                        subscriptionsParent.childSubCalendars = subscriptionChildSubCalendars;
                        rearrangedSubCalendars.push(subscriptionsParent);
                    }

                    subCalendars.length = 0; // We need to modify the array. Delete all elements.
                    $.merge(subCalendars, rearrangedSubCalendars);
                };

                rearrangeSubCalendars(arrayWithSubCalendarObject);

                return arrayWithSubCalendarObject;
            },
            isRequireOauth : function(XMLHttpRequest) {
                var authHeader = XMLHttpRequest.getResponseHeader("WWW-Authenticate") || "";
                var realmRegEx = /OAuth realm\=\"([^\"]+)\"/;
                var matches = realmRegEx.exec(authHeader);
                if (matches){
                    return matches[1];
                }
                else{
                    return null;
                }
            },
            setFieldErrors : function(container, fieldErrors) {
                $("div.error", container).empty();

                if (!fieldErrors)
                    return;

                var _fieldErrors = $.isArray(fieldErrors) ? fieldErrors : [ fieldErrors ];

                if ($.isArray(fieldErrors)) {
                    for (var fieldErrorIndex = 0; fieldErrorIndex < _fieldErrors.length; ++fieldErrorIndex) {
                        var fieldName = _fieldErrors[fieldErrorIndex].field;
                        var _errorMessages = $.isArray(_fieldErrors[fieldErrorIndex].errorMessages)
                            ? _fieldErrors[fieldErrorIndex].errorMessages
                            : [ _fieldErrors[fieldErrorIndex].errorMessages ];


                        if (fieldName && _errorMessages) {
                            var errorDiv = $("div." + fieldName + "-error");
                            for (var errorMsgIndex = 0; errorMsgIndex < _errorMessages.length; ++errorMsgIndex) {
                                $(document.createElement("div")).html(_errorMessages[errorMsgIndex]).appendTo(errorDiv);
                            }
                        }
                    }
                }
            },
            showHTMLGenericError : function(container, message, errorClass, subcalendar) {
                var isError = message[0] === "html-error-type" || message[0] === "error-jql-wrong";
                var infoHTMLPanel = isError === true ?  $(".calendar-error", container) : $(".calendar-warning", container);
                var _infoHTMLClass = errorClass || "general";
                var infoMessagesList = isError === true ? $("ul.error-messages", infoHTMLPanel) : $("ul.warning-messages", infoHTMLPanel);
                var infoMessageItem = $("li." + errorClass, infoMessagesList);

                if (!infoMessageItem.length)
                    infoMessageItem = $(document.createElement("li")).addClass(_infoHTMLClass).appendTo(infoMessagesList);

                if(message[0] === "error-jql-wrong") {
                    infoMessageItem.text(message[1]);

                    if(subcalendar && subcalendar.eventsEditable) {
                        infoMessageItem.data("jiraCalendarId", subcalendar.id);
                        infoMessageItem.append("\u5c1d\u8bd5 \u003ca href=\u0022#\u0022 id=\u0022calendar-change-jql\u0022\u003e\u66f4\u6539\u67e5\u8be2\u3002\u003c/a\u003e");
                    }
                }
                else {
                    infoMessageItem.html(message[1]);
                }

                removeDuplicatedErrorMessages(infoMessagesList);
                if (infoMessagesList.children().length) {
                    infoMessagesList.removeClass("hidden");
                    infoHTMLPanel.removeClass("hidden");
                } else {
                    infoMessagesList.addClass("hidden");
                    infoHTMLPanel.addClass("hidden");
                }
            },
            setGenericErrors : function(container, message, errorClass) {
                var errorPanel = $(".calendar-error", container);
                var _errorClass = errorClass || "general";
                var errorMessagesList = $("ul.error-messages", errorPanel);
                var errorMessageItem = $("li." + errorClass, errorMessagesList);

                if (message) {
                    if (!errorMessageItem.length)
                        errorMessageItem = $(document.createElement("li")).addClass(_errorClass).appendTo(errorMessagesList);

                    if ($.isArray(message)) {
                        if (message.length > 1) {
                            var subMessagesList = $(document.createElement("ul"));
                            $.each(message, function(index, value) {
                                $(document.createElement("li")).text(value).appendTo(subMessagesList);
                            });
                            subMessagesList.appendTo(errorMessageItem);
                        } else {
                            errorMessageItem.text(message[0]);
                        }

                    } else if ($.isPlainObject(message)) {
                        var theMessage = message["message"] || "";
                        if (message["status-code"]) {
                            errorMessageItem.text(message["status-code"] + " - " + theMessage);
                        } else {
                            errorMessageItem.text(theMessage);
                        }
                    } else {
                        errorMessageItem.text(message);
                    }

                    removeDuplicatedErrorMessages(errorMessagesList);
                    //remove error message item has empty ul element
                    if (message.length > 1 &&  $("ul", errorMessageItem).children().length === 0){
                        errorMessageItem.remove();
                    }
                } else {
                    errorMessageItem.remove();
                }

                if (errorMessagesList.children().length) {
                    errorMessagesList.removeClass("hidden");
                    errorPanel.removeClass("hidden");
                } else {
                    errorMessagesList.addClass("hidden");
                    errorPanel.addClass("hidden");
                }
            },
            showAjaxError : function(container, XMLHttpRequest, textStatus, errorThrown, errorClass, subCalendar) {
                if ("application/json" === XMLHttpRequest.getResponseHeader("Content-Type")) {
                    var messageResponse;
                    try {
                        messageResponse = JSON.parse(XMLHttpRequest.responseText);
                    } catch (e) {
                        messageResponse = XMLHttpRequest.responseText;
                    }
                    if (XMLHttpRequest.status === 405 && messageResponse.reason && messageResponse.reason === "READ_ONLY") {
                        var errorMessage = ["html-error-type", "\u8fd9\u662f\u53ea\u8bfb\u7f51\u7ad9\u3002 \u60a8\u73b0\u5728\u65e0\u6cd5\u8fdb\u884c\u66f4\u6539\u3002"];
                        this.showHTMLGenericError(container, errorMessage, errorClass, subCalendar);
                    }
                    else if ($.isArray(messageResponse) && messageResponse.length === 2 && (messageResponse[0] === "warning-type" || messageResponse[0] === "html-error-type"
                            || messageResponse[0] === "error-jql-wrong")) {
                        this.showHTMLGenericError(container, messageResponse, errorClass, subCalendar);
                    } else {
                        this.setGenericErrors(container, messageResponse, errorClass);
                    }
                } else {
                    this.setGenericErrors(
                        container, errorThrown || textStatus || XMLHttpRequest.responseText || "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", errorClass
                    );
                }
            },
            getUserTimeZone : function() {
                return $("input[name='userTimeZoneId']").val() || $("#team-calendars-user-timezone").attr("content");
            },
            shouldShowTimezoneSetup : function() {
                var hasMessageKey = !$("#team-calendars-timezone-setup-dialog").length && $("#team-calendars-show-timezone-setup").length;

                if (AJS.Meta.get("space-key")) {
                    var isSpaceCalendarPage = $(".plugin-calendar-container.spaceCalendars").length;
                    return hasMessageKey && isSpaceCalendarPage;
                }
                return hasMessageKey;
            },
            suppressMessage : function(errorContainer, messageKey, successCallback) {
                var that = this;
                $.ajax({
                    cache: false,
                    data: {
                        messageKey : messageKey
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        that.showAjaxError(errorContainer, XMLHttpRequest, textStatus, errorThrown, "error-config-update");
                    },
                    success: function() {
                        that.setGenericErrors(errorContainer, null, "error-config-update");
                        if (successCallback && $.isFunction(successCallback))
                            successCallback();
                    },
                    type: "DELETE",
                    url : this.getCalendarServiceBaseUrl("/preferences/messagekey.json")
                });
            },
            fireEventForAnalytics : function(eventName, properties) {
                AJS.EventQueue = AJS.EventQueue || [];
                AJS.EventQueue.push({
                    name: 'teamcalendars.' + eventName,
                    properties: properties || {}
                });
            },
            isPDLEnabled : function() {
                return AJS.Meta.getNumber("build-number") >= 4000;
            },
            isJiraSubCalendar : function(subCalendar) {
                return subCalendar.type === "jira" || subCalendar.subscriptionType === "jira"
                    || subCalendar.type === "jira-agile-sprint" || subCalendar.subscriptionType === "jira-agile-sprint"
                    || subCalendar.type === "jira-project-releases" || subCalendar.subscriptionType === "jira-project-releases";
            },
            isSubscriptionSubCalendar : function(subCalendar) {
                return subCalendar.type === "subscription" || subCalendar.subscriptionType === "subscription";
            },
            isInternalSubscriptionSubCalendar : function(subCalendar) {
                return subCalendar.type === "internal-subscription";
            },
            isDummySubscriptionParentSubCalendar : function(subCalendar) {
                return subCalendar.dummy && this.isSubscriptionSubCalendar(subCalendar);
            },

            hasRestriction: function(subCalendar) {
                return subCalendar.usersPermittedToView.length > 0
                        || subCalendar.usersPermittedToEdit.length > 0
                        || subCalendar.groupsPermittedToView.length > 0
                        || subCalendar.groupsPermittedToEdit.length > 0;
            },

            updateDateDisplay : function(calendarDiv, displayHtml) {
                $(".date-display", calendarDiv).html(displayHtml || "");
            },
            showCalendarPopupHaveAnEmptySubcalendar : function(showPopularDialog, showCalendarDialog) {
                //CHECK HAS POPURLAR
                $.ajax({
                    dataType : "json",
                    success : function(responseEntity) {
                        if(responseEntity)
                        {
                            showPopularDialog();
                        } else {
                            showCalendarDialog();
                        }
                    },
                    type: "GET",
                    timeout: this.ajaxTimeout,
                    url : this.getCalendarServiceBaseUrl("/haspopular.json")
                });
            },

            disableButton: function(elButton, label) {
                elButton
                    .text(label)
                    .attr("disabled", "disabled")
                    .addClass("ui-state-disabled");
            },

            enableButton: function(elButton, label) {
                elButton
                    .text(label)
                    .removeAttr("disabled")
                    .removeClass("ui-state-disabled");
            },

            isJiraEventStream: function(type) {
                return type === "jira-calendar" || type === "jira-agile-sprint-calendar" || type === "jira-project-releases-calendar";
            },

            isCustomEventType: function(type) {
                return !this.isJiraEventStream(type) && !this.isJiraType(type) && !this.isEventTypeSanbox(type);
            },

            isEventTypeSanbox: function(type) {
                return type === "other" || type === "leaves" || type === "birthdays" || type === "travel";
            },

            isJiraEvent: function(event) {
                var type = event.eventType;
                return this.isJiraType(type);
            },

            isJiraType: function(type) {
                return type === "jira" || type === "jira-agile-sprint" || type === "jira-project-releases";
            },

            showInforReminder: function(periodInMins) {
                var inforReminder = null, intPeriodInMins = periodInMins !== "" ? parseInt(periodInMins) : 0;

                if (intPeriodInMins === 0) {
                    inforReminder = "\u65e0";
                } else if(intPeriodInMins < 60) { //minute
                    inforReminder = AJS.format("{0} \u5206\u949f", intPeriodInMins);
                } else {
                    var periodInHours = Math.floor(intPeriodInMins / 60);
                    if(periodInHours < 24) { //hour
                        inforReminder = AJS.format(periodInHours === 1 ? "{0} \u5c0f\u65f6" : "{0} \u5c0f\u65f6", periodInHours);
                    } else {
                        var periodInDays = Math.floor(periodInHours / 24);
                        if(periodInDays < 7) { //day
                            inforReminder = AJS.format(periodInDays === 1 ? "{0} \u5929" : "{0} \u5929", periodInDays);
                        } else { //week
                            var periodInWeek = Math.floor(periodInDays / 7);
                            inforReminder = AJS.format(periodInWeek === 1 ? "{0} \u5468" : "{0} \u5468", periodInWeek);
                        }
                    }
                }
                return inforReminder;
            },

            getPeriodReminderEventTypeSanboxOrJira: function(subCalendar, eventType) {
                var sanboxEventTypeReminders = subCalendar.sanboxEventTypeReminders;
                if(sanboxEventTypeReminders != undefined && sanboxEventTypeReminders.length > 0) {
                    if(this.isJiraType(eventType)) {
                        eventType += "-calendar";
                    }
                    for(var item in sanboxEventTypeReminders) {
                        if(eventType === sanboxEventTypeReminders[item].eventTypeId) {
                            return sanboxEventTypeReminders[item].periodInMins;
                        }
                    }
                }
            },

            getCalendarContext: function(calendarDiv) {
                var context;
                if(calendarDiv) {
                    context = this.getParameter(calendarDiv, "calendarContext");
                }

                return context || (AJS.Meta.get("space-key") ? "spaceCalendars" : "myCalendars");
            },

            isSingleCalendarView: function(calendarDiv) {
                return "singleCalendar" === this.getParameter(calendarDiv, "calendarContext");
            },

            isSpaceCalendarView: function(calendarDiv) {
                return "spaceCalendars" === this.getParameter(calendarDiv, "calendarContext");
            },

            isEmbeddedCalendarView: function(calendarDiv) {
                return "page" === this.getParameter(calendarDiv, "calendarContext");
            },

            isMyCalendarView: function(calendarDiv) {
                return "myCalendars" === this.getParameter(calendarDiv, "calendarContext");
            },

            putCalendarContextParams:function(data) {
                data.calendarContext = this.getCalendarContext();
                data.viewingSpaceKey = AJS.Meta.get("space-key") || "";
            },

            toggleNoCalendarPage: function(show) {
                if (show) {
                    $(".no-calendar-page").removeClass("hidden");

                    $(".space-calendar-wrapper").addClass("hidden");
                    $(".space-calendar-buttons").addClass("hidden");
                } else {
                    $(".no-calendar-page").addClass("hidden");

                    $(".space-calendar-buttons").removeClass("hidden");
                    $(".space-calendar-wrapper").removeClass("hidden");
                }
            },

            isValidLicense: function() {
                var licencseMessages = $(".aui-message.error.license-invalid");
                return licencseMessages.size() === 0;
            },

            getParamsFromUrl: function() {
                var vars = [], hash;
                var q = window.location.href.split('?')[1];
                if(q != undefined) {
                    q = q.split('&');
                    for(var i = 0; i < q.length; i++) {
                        hash = q[i].split('=');
                        vars.push(hash[1]);
                        vars[hash[0]] = hash[1];
                    }
                }
                return vars;
            },

            /**
             * Check if a text is truncated or not
             */
            isCalendarNameTruncated: function($element) {
                var isTruncated = false;

                var $c = $element
                        .clone()
                        .css({display: 'inline', width: 'auto', visibility: 'hidden'})
                        .appendTo('body');

                if( $c.width() > $element.width() ) {
                    isTruncated = true;
                }

                $c.remove();

                return isTruncated;
            }
        };

        return calendarUtils;
    });

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-util', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-util/calendar-util-component-compat.js' */
//Useful functions used by the Team Calendar javascript
;(function($) {

// HACK
//May have already been created by soy. Don't clobber it.
if (!Confluence.TeamCalendars) {Confluence.TeamCalendars = {}}

if (!Confluence.TeamCalendars.Dialogs) {
    Confluence.TeamCalendars.Dialogs = {};
}

if (!Confluence.TeamCalendars.hasJiraLink) {
    Confluence.TeamCalendars.hasJiraLink = $("#team-calendars-has-jira-link").length;
}

if (!Confluence.TeamCalendars.getRestBaseUrl) {
    Confluence.TeamCalendars.getRestBaseUrl = function() {
        return Confluence.getContextPath() + "/rest/calendar-services/1.0";
    };
}

})(AJS.$);

//This is here to make the existing API work.
require(["tc/calendar-util"], function (calendarUtil) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    for (var property in calendarUtil) {
        if (calendarUtil.hasOwnProperty(property)) {
            Confluence.TeamCalendars[property] = calendarUtil[property];
        }
    }
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:auto-complete-search-helper', location = 'com/atlassian/confluence/extra/calendar3/components/auto-complete-search-helper/auto-complete-search-helper.js' */
define("tc/auto-complete-search-helper",
    [
        "jquery",
        "tc/calendar-util"
    ], function
        (
            $,
            CalUtil
        )
    {
        "use strict";
        return {
            makeAutoCompleteSearch : function(calendarDiv, searchField, searchOptions, suggestionsContainer, suggestionClickHandler, resultFilter) {
                searchField.keydown(function(event) {
                    var selectedSuggestion = $("li.active", suggestionsContainer);

                    if (27 == event.keyCode) {
                        if (!suggestionsContainer.hasClass("hidden")) {
                            suggestionsContainer.addClass("hidden");
                            return false;
                        }
                    }

                    // keyup
                    if (38 == event.keyCode) {
                        if (!suggestionsContainer.hasClass("hidden")) {
                            if (selectedSuggestion.length) {
                                if (selectedSuggestion.prev().length)
                                    selectedSuggestion.removeClass("active").prev().addClass("active");
                            } else {
                                $(".aui-dropdown li:last", suggestionsContainer).addClass("active");
                            }
                            return false;
                        }
                    }

                    // keydown
                    if (40 == event.keyCode) {
                        if (!suggestionsContainer.hasClass("hidden")) {
                            if (selectedSuggestion.length) {
                                if (selectedSuggestion.next().length)
                                    selectedSuggestion.removeClass("active").next().addClass("active");
                            } else {
                                $(".aui-dropdown li:first", suggestionsContainer).addClass("active");
                            }
                            return false;
                        }
                        return false;
                    }

                    if (13 == event.keyCode) {
                        if (!suggestionsContainer.hasClass("hidden")) {
                            $(".aui-dropdown li.active a", suggestionsContainer).trigger("click");
                            return false;
                        }
                    }

                    if ($.trim(searchField.val())) {
                        setTimeout(function() {
                            if (!$.trim(searchField.val())) {
                                suggestionsContainer.addClass("hidden");
                                return;
                            }

                            $.ajax({
                                cache : false,
                                data : $.extend({
                                    search : "name",
                                    query : searchField.val()
                                }, searchOptions),
                                dataType : "json",
                                error : function(XMLHttpRequest, textStatus, errorThrown) {
                                    if (XMLHttpRequest.status !== 400) {
                                        // 400 is invalid search query - but we just want to swallow
                                        // it since the user may be typing a wiki link (which would be result in this error)
                                        CalUtil.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown);
                                    }
                                },
                                success : function(searchResult) {
                                    var suggestionList = $(document.createElement("ol"));
                                    var getHtmlLink = function(_result) {
                                        return result.id ? CalUtil.getParameter(calendarDiv, "baseUrl") + "/pages/viewpage.action?pageId=" + encodeURIComponent(_result.id) : "#";
                                    };

                                    for (var groupIdx = 0; groupIdx < searchResult.group.length; ++groupIdx) {
                                        var theGroup = searchResult.group[groupIdx];
                                        if (theGroup.result) {
                                            for (var resultIdx = 0; resultIdx < theGroup.result.length; ++resultIdx) {
                                                var result = theGroup.result[resultIdx];

                                                if (resultFilter && !resultFilter(result))
                                                    continue;

                                                var suggestion = $(document.createElement("li")).mouseover(function() {
                                                    $("li.active", suggestionsContainer).removeClass("active");
                                                    $(this).addClass("active");
                                                });

                                                if (result.thumbnailLink) {
                                                    $(document.createElement("img"))
                                                        .attr("src", result.thumbnailLink.href)
                                                        .appendTo(suggestion);
                                                }

                                                if (result.link && result.link.length) {
                                                    $(document.createElement("span"))
                                                        .attr("title", result.title || (result.space ? " " + result.space.name : ""))
                                                        .text(result.title)
                                                        .appendTo(
                                                        $(document.createElement("a"))
                                                            .data("result", result)
                                                            .attr("href", getHtmlLink(result) || "")
                                                            .addClass(result.type ? "content-type-" + result.type : "")
                                                            .click(function() {
                                                                if (suggestionClickHandler)
                                                                    suggestionClickHandler(searchField, $(this));
                                                                suggestionsContainer.addClass("hidden");
                                                                return false;
                                                            })
                                                            .appendTo(suggestion)
                                                    );
                                                }

                                                suggestion.appendTo(suggestionList);
                                            }
                                        }
                                    }

                                    if (suggestionList.children().length) {
                                        // We probably do not want too many results
                                        $("li", suggestionList).each(function(index) {
                                            if (index > 4)
                                                $(this).remove();
                                        });
                                        $(".aui-dropdown", suggestionsContainer).empty().append(suggestionList);
                                        suggestionsContainer.removeClass("hidden").dropDown("Standard");
                                    } else {
                                        suggestionsContainer.addClass("hidden");
                                    }
                                },
                                timeout: CalUtil.ajaxTimeout,
                                url : CalUtil.getParameter(calendarDiv, "baseUrl") + "/rest/prototype/1/search.json"
                            })
                        }, 300);
                    }
                }).focus(function() {
                    if (searchField.hasClass("with-hint"))
                        searchField.removeClass("with-hint").val("");
                }).blur(function() {
                    if (!$.trim(searchField.val()))
                        searchField.addClass("with-hint").val("Confluence\u9875\u6216\u662fURL");
                });
            }
        }
    });

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-delete-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/event-delete-dialog/event-delete-dialog.js' */
define("tc/event-delete-dialog", ["jquery"],
    function (
        $
    )
    {
    "use strict";
    return function (calendarDiv, anEvent, CalendarPlugin) {
        var confirmEventDeleteDialog;
        var deleteEventFunction = function (options, _confirmEventDeleteDialog) {
            if (!CalendarPlugin.isProcessingEvent(calendarDiv)) {
                CalendarPlugin.setProcessingEvent(calendarDiv, true, _confirmEventDeleteDialog);

                CalendarPlugin.deleteEvent(
                    calendarDiv,
                    options,
                    function (XMLHttpRequest, textStatus, errorThrown) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_EVENT_DELETE);
                        _confirmEventDeleteDialog.hide();
                        CalendarPlugin.setProcessingEvent(calendarDiv, false, _confirmEventDeleteDialog);
                    },
                    function (responseEntity) {
                        if (responseEntity.success) {
                            var eventSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, anEvent.subCalendarId);
                            var eventType = anEvent.eventType;

                            var property;
                            if(eventType === "custom" && eventSubCalendar && eventSubCalendar.customEventTypes && eventSubCalendar.customEventTypes.length) {
                                $.each(eventSubCalendar.customEventTypes, function(index, item) {
                                    if(item.customEventTypeId === anEvent.customEventTypeId) {
                                        property = {
                                            customEventTypeName: item.title
                                        };
                                    }
                                });
                            }

                            Confluence.TeamCalendars.fireEventForAnalytics("event.delete.default." + eventType + ".context." + CalendarPlugin.getParameter(calendarDiv, "calendarContext"), property);

                            CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_EVENT_DELETE);
                            if (options.singleInstance) {
                                CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("removeEvents", [ anEvent.id ]);
                            } else {
                                CalendarPlugin.reloadSubCalendar(calendarDiv, eventSubCalendar.id || eventSubCalendar.parentId);
                            }
                        } else {
                            CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_EVENT_DELETE);
                        }

                        _confirmEventDeleteDialog.hide();
                        CalendarPlugin.setProcessingEvent(calendarDiv, false, _confirmEventDeleteDialog);
                    });
                return false;
            }
        };

        if (anEvent.recur || anEvent.rruleStr) {
            // Recurring event
            confirmEventDeleteDialog = new AJS.Dialog({width: 550, height: 270, id: "tc-confirm-event-delete"});
            confirmEventDeleteDialog.addHeader("\u5220\u9664\u91cd\u590d\u7684\u4e8b\u5b9c");
            confirmEventDeleteDialog.addPanel(
                "",
                Confluence.TeamCalendars.Templates.confirmRecurringEventDelete({ "elementIdSuffix": CalendarPlugin.getParameter(calendarDiv, "elementIdSuffix") }),
                "tc-delete-event-confirmation-panel");

            var deleteDialogPanel = confirmEventDeleteDialog.getCurrentPanel().body;
            var spinner =  $("<span class='spinner hidden aui-icon aui-icon-wait'></span>");
            var addingSpinner = function (confirmEventDeleteDialog){
                var buttonPanel = confirmEventDeleteDialog.getPage(0).buttonpanel;
                // add spinner
                spinner.prependTo(buttonPanel);
            };

            confirmEventDeleteDialog.enableOkButton = function (){
                $(":button", deleteDialogPanel).each(function(index, btn){
                    $(btn).removeAttr("disabled")
                        .removeClass("ui-state-disabled");
                });

                spinner.addClass("hidden");
            };

            confirmEventDeleteDialog.disableOkButton = function () {
                $(":button", deleteDialogPanel).each(function(index, btn){
                    $(btn).attr("disabled", "disabled")
                        .addClass("ui-state-disabled");
                });

                spinner.removeClass("hidden");
            }

            $(".tc-delete-this-instance-only", deleteDialogPanel).click(function () {
                deleteEventFunction({
                    subCalendarId: anEvent.subCalendarId,
                    uid: anEvent.id,
                    recurrenceId: anEvent.recurId || "",
                    originalStart: anEvent.originalStart || "",
                    singleInstance: true
                }, confirmEventDeleteDialog);
                return false;
            });

            $(".tc-delete-future-instances-only", deleteDialogPanel).click(function () {
                deleteEventFunction({
                    subCalendarId: anEvent.subCalendarId,
                    uid: anEvent.id,
                    recurUntil: $.fullCalendar.formatDate(anEvent.start, "yyyyMMdd")
                }, confirmEventDeleteDialog);
                return false;
            });

            $(".tc-delete-all-instances", deleteDialogPanel).click(function () {
                deleteEventFunction({
                    subCalendarId: anEvent.subCalendarId,
                    uid: anEvent.id
                }, confirmEventDeleteDialog);
                return false;
            });

            confirmEventDeleteDialog.addLink("\u53d6\u6d88", function () {
                confirmEventDeleteDialog.hide();
                return false;
            });

            addingSpinner(confirmEventDeleteDialog);
        } else {
            confirmEventDeleteDialog = new AJS.Dialog(280, 170);
            confirmEventDeleteDialog.addHeader("\u5220\u9664\u4e8b\u5b9c");
            confirmEventDeleteDialog.addPanel(
                "",
                Confluence.TeamCalendars.Templates.confirmEventDelete(),
                "tc-delete-event-confirmation-panel");

            confirmEventDeleteDialog.addButton("\u662f", function () {
                deleteEventFunction({
                    subCalendarId: anEvent.subCalendarId,
                    uid: anEvent.id
                }, confirmEventDeleteDialog);
            });

            confirmEventDeleteDialog.addLink("\u53d6\u6d88", function () {
                confirmEventDeleteDialog.hide();
                return false;
            });
        }

        return confirmEventDeleteDialog;
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-delete-dialog', location = '/com/atlassian/confluence/extra/calendar3/components/event-delete-dialog/event-delete-dialog.soy' */
// This file was automatically generated from event-delete-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.confirmEventDelete = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml('\u771f\u60f3\u8fd9\u4e48\u5e72\uff1f\u4e0d\u80fd\u64a4\u6d88\u54e6') + '</p>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.confirmEventDelete.soyTemplateName = 'Confluence.TeamCalendars.Templates.confirmEventDelete';
}


Confluence.TeamCalendars.Templates.confirmRecurringEventDelete = function(opt_data, opt_ignored) {
  return '<ul class="tc-delete-recurring-event-options"><li><input type="button" value="' + soy.$$escapeHtml('\u4ec5\u6b64\u4e00\u9879') + '" class="tc-delete-this-instance-only tc-delete-button aui-button"><span class="tc-delete-description">' + soy.$$escapeHtml('\u6b64\u7cfb\u5217\u4e2d\u5176\u4ed6\u4e8b\u5b9c\u5c06\u7ef4\u6301\u539f\u72b6\u3002') + '</span></li><li><input type="button" value="' + soy.$$escapeHtml('\u6240\u6709\u672a\u6765\u4e8b\u5b9c') + '" class="tc-delete-future-instances-only tc-delete-button aui-button"><span class="tc-delete-description">' + soy.$$escapeHtml('\u6b64\u9879\u53ca\u672a\u6765\u6240\u6709\u4e8b\u5b9c\u5747\u4f1a\u88ab\u5220\u9664\u3002') + '</span></li><li class="tc-last-delete-option"><input type="button" value="' + soy.$$escapeHtml('\u7cfb\u5217\u4e2d\u7684\u5168\u90e8') + '" class="tc-delete-all-instances tc-delete-button aui-button"><span class="tc-delete-description">' + soy.$$escapeHtml('\u6574\u4e2a\u7cfb\u5217\u5c06\u88ab\u5220\u9664\u3002') + '</span></li></ul>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.confirmRecurringEventDelete.soyTemplateName = 'Confluence.TeamCalendars.Templates.confirmRecurringEventDelete';
}


Confluence.TeamCalendars.Templates.confirmCustomEventNameDelete = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml('\u5c06\u5220\u9664\u6240\u6709\u7684') + ' <strong>' + soy.$$escapeHtml(opt_data.customEventName) + '</strong> ' + soy.$$escapeHtml('\u5220\u9664\u65e5\u7a0b\u4e2d\u8be5\u4e8b\u4ef6\u7c7b\u578b\u53ca\u5176\u6240\u6709\u4e8b\u9879\u3002\u64cd\u4f5c\u4e0d\u53ef\u64a4\u9500\uff0c\u4f60\u786e\u5b9a\u5417\uff1f') + '</p>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.confirmCustomEventNameDelete.soyTemplateName = 'Confluence.TeamCalendars.Templates.confirmCustomEventNameDelete';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:form-state-control', location = '/com/atlassian/confluence/extra/calendar3/util/form-state-control.js' */
/**
 * This is a wrapper for methods to enable/disable element
 * Module confluence/form-state-control is only available from Confluence 7
 * Teamcal is a special plugin, we need to maintain backward compatibility, that's why we need this wrapper
 */
define("tc/form-state-control", [ "jquery", "ajs" ], function($, AJS) {
    var ConfluenceFormStateControl;
    try {
        ConfluenceFormStateControl = require('confluence/form-state-control');
    } catch (e) {
        AJS.log('[TEAMCAL] No module "confluence/form-state-control", falling back to default enable/disableElement');
    }
    
    function enableElement(element) {
        if (ConfluenceFormStateControl) {
            ConfluenceFormStateControl.enableElement(element);
        } else {
            $(element).enable();
        }
    }

    function disableElement(element) {
        if (ConfluenceFormStateControl) {
            ConfluenceFormStateControl.disableElement(element);
        } else {
            $(element).disable();
        }
    }

    return {
        enableElement: enableElement,
        disableElement: disableElement
    };
});

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:user-timezone-setup', location = 'com/atlassian/confluence/extra/calendar3/components/user-timezone-setup/user-timezone-setup.soy' */
// This file was automatically generated from user-timezone-setup.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.userTimezoneSetup = function(opt_data, opt_ignored) {
  return '<div class="user-time-zone-desc"></div><div class="user-time-zone-select hidden"><select name="userTimeZoneSetupSelect" id="userTimeZoneSetupSelect" disabled="disabled"></select>&nbsp;<span class="spinner aui-icon aui-icon-wait"></span></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.userTimezoneSetup.soyTemplateName = 'Confluence.TeamCalendars.Templates.userTimezoneSetup';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:user-timezone-setup', location = 'com/atlassian/confluence/extra/calendar3/components/user-timezone-setup/user-timezone-setup.js' */
define("tc/user-timezone-setup",
    [
        "jquery",
        "tc/util",
        "tc-backbone",
        "tc/templates",
        "tc/form-state-control"
    ],
    function(
        $,
        Util,
        Backbone,
        Templates,
        FormStateControl) {
        "use strict";

    var UserTimeZoneSetup = Backbone.View.extend({
        dialog: null, //instance of AJS.ConfluenceDialog,
        options: null,

        $userTimeZoneSelectContainer: null,
        userTimeZone: "",
        isPDLEnabled: false,
        baseUrlRest: "",
        baseUrlCalendarService: "",
        ajaxTimeout: 120000,

        template: Templates.userTimezoneSetup(),

        defaults: {
            callbackHandler: null,
            textTitleDialog: "\u914d\u7f6e\u56e2\u961f\u65e5\u7a0b\u8868",
            textDescTimeZoneSetup: "\u60a8\u7684\u65f6\u533a\u73b0\u88ab\u8bbe\u7f6e\u4e3a {0}\u3002 \u82e5\u5176\u5e76\u975e\u60a8\u6240\u5728\u7684\u65f6\u533a\uff0c\u8bf7\u9009\u62e9\u6b63\u786e\u65f6\u533a\u3002",
            textBtnOk: "\u786e\u5b9a"
        },

        initialize: function(options){
            this.options = $.extend({}, this.defaults, options);

            if (!this.options.callbackHandler) {
                AJS.debug("tc/user-timezone-setup: requires 'callbackHandler' object");
            }

            //TODO: should we move Confluence.TeamCalendars to an AMD module
            var TeamCalendars = Confluence.TeamCalendars;
            this.userTimeZone = TeamCalendars.getUserTimeZone();
            this.isPDLEnabled = TeamCalendars.isPDLEnabled();
            this.baseUrlRest = TeamCalendars.getRestBaseUrl();
            this.baseUrlCalendarService = TeamCalendars.getCalendarServiceBaseUrl("/preferences/timezone.json");
            this.ajaxTimeout = TeamCalendars.ajaxTimeout;

            this.options.textDescTimeZoneSetup = AJS.format(this.options.textDescTimeZoneSetup, this.userTimeZone);
        },

        render: function(){
            this._createDialog();
            this._populateTimeZoneDropDown();
            return this.dialog;
        },

        _createDialog: function(){
            var that = this;

            //create dialog
            this.dialog = new AJS.Dialog({
                "width": 512,
                "height": this.isPDLEnabled ? 220 : 200,
                "id" : "team-calendars-timezone-setup-dialog"
            });

            this.dialog.addHeader(this.options.textTitleDialog);
            this.dialog.addPanel("", this.template, "setup-calendar-panel");

             //Set okay button
            this.dialog.addButton(this.options.textBtnOk, function() {
                that.dialog.hide();
                that.dialog.remove();
                // remove element that flags timezone setup is still required
                $('#team-calendars-show-timezone-setup').remove();
                that.options.callbackHandler.showCalendarWizard();
            }, "set-timezone-button");

            this.el = this.dialog.getCurrentPanel().body;
            this.$el = $(this.el);

            //set text
            this.$el.find(".user-time-zone-desc").text(this.options.textDescTimeZoneSetup);

            //Post to server to set timezone
            this.$userTimeZoneSelectContainer = this.$el.find(".user-time-zone-select");
            this.$userTimeZoneSelectContainer.removeClass("hidden");

            this.$userTimeZoneSelectContainer.find("select").change(_.bind(this._changeSelectionTimeZone, this));

            //tell the server not to send this message again
            this.options.callbackHandler.suppressMessage("MESSAGE_KEY_TIMEZONE_SETUP");
            return this.dialog;
        },

        _populateTimeZoneDropDown: function() {
            var that = this,
                timeZoneSelect = this.$el.find("#userTimeZoneSetupSelect"),
                okButton = this.dialog.popup.element.find(".set-timezone-button");

            FormStateControl.disableElement(okButton);
            that.$userTimeZoneSelectContainer.addClass("loading");

            $.ajax({
                type: "GET",
                url: this.baseUrlRest + "/timezones/user",
                success: function(timeZones) {
                    timeZoneSelect
                        .html(Templates.timeZoneDropDown(timeZones))
                        .val(that.userTimeZone)
                        // For some reasons, this attribute (might work with other attributes) has to be rmemoved
                        // so the dropdown height in IE is right.
                        // Doensn't matter if the select was actually disabled in the first place.
                        .removeAttr("disabled");

                    that.$userTimeZoneSelectContainer.removeClass("loading");
                    FormStateControl.enableElement(okButton);
                },
                error: function(XMLHttpRequest, textStatus, errorThrown) {
                    that.options.callbackHandler.showAjaxError(XMLHttpRequest, textStatus, errorThrown);
                    that.$userTimeZoneSelectContainer.removeClass("loading");
                },
                timeout: this.ajaxTimeout
            });
        },

        _changeSelectionTimeZone: function() {
            var that = this;

            this.$userTimeZoneSelectContainer.addClass("loading");

            var setTimeZoneButton = this.dialog.popup.element.find(".set-timezone-button").attr("disabled", "disabled");
            var selectedOption = this.$userTimeZoneSelectContainer.find("option:selected");

            $.ajax({
                url: this.baseUrlCalendarService,
                cache: false,
                data: {
                    timeZoneId : selectedOption.val()
                },
                error: function(XMLHttpRequest, textStatus, errorThrown) {
                    that.options.callbackHandler.showAjaxError(XMLHttpRequest, textStatus, errorThrown, "error-config-update");
                    setTimeZoneButton.removeAttr("disabled");
                    that.$userTimeZoneSelectContainer.removeClass("loading");
                },
                success: function() {
                    that.options.callbackHandler.setGenericErrors(null, "error-config-update");
                    that.options.callbackHandler.setParameter("userTimeZoneId", selectedOption.val());
                    that.$el.find(".user-time-zone-desc").text(that.options.textDescTimeZoneSetup);
                    setTimeZoneButton.removeAttr("disabled");
                    that.$userTimeZoneSelectContainer.removeClass("loading");
                },
                type: "PUT",
                timeout: this.ajaxTimeout
            });
        }
    });

    return UserTimeZoneSetup;
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:user-timezone-setup', location = 'com/atlassian/confluence/extra/calendar3/components/user-timezone-setup/user-timezone-setup-combat.js' */
//This is here to make the existing API work.
require(["tc/user-timezone-setup"], function (UserTimeZoneSetup) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getTimeZoneSetupDialog = function(callbackHandler){
        return new UserTimeZoneSetup({
            callbackHandler: callbackHandler
        }).render();
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:import-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/import-subcalendar/import-subcalendar.soy' */
// This file was automatically generated from import-subcalendar.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.importSubcalendar = function(opt_data, opt_ignored) {
  return '<div class="aui-message aui-message-error error calendar-error hidden"><p class="title"><strong>' + soy.$$escapeHtml('\u6709\u9519\u8bef\u53d1\u751f\u3002') + '</strong></p><div class="error-content"><ul class="error-messages hidden"></ul></div></div><div class="aui-message aui-message-warning warning tc-need-timezone hidden"><p class="title"><strong>' + soy.$$escapeHtml('\u65e0\u6cd5\u786e\u5b9a\u65e5\u7a0b\u7684\u65f6\u533a\u3002') + '</strong></p><p>' + soy.$$escapeHtml('\u65e0\u6cd5\u786e\u5b9a\u8be5\u65e5\u5386\u7684\u65f6\u533a\uff0c\u8bf7\u5728\u4e0b\u9762\u8fdb\u884c\u65f6\u533a\u8bbe\u7f6e\u3002') + '</p></div><form name="importSubCalendarForm" class="sub-calendar-import-form aui" method="POST" action="' + soy.$$escapeHtml("") + '/plugins/calendar/importsubcalendar.action" enctype="multipart/form-data" target="import-iframe-sink"><input type="hidden" name="calendarId" value=""><input type="hidden" name="decorator" value="none"><input type="hidden" name="color" value=""><input type="hidden" name="spaceKey" value=""><div class="field-group"><label for="import-name">' + soy.$$escapeHtml('\u540d\u79f0') + '<span class="aui-icon icon-required"></span></label><input name="name" id="import-name"  type="text" class="text" value="" autocomplete="off"><div class="description">' + soy.$$escapeHtml('\u6b64\u5904\u7559\u7a7a\u6765\u4f7f\u7528ICS\u6587\u4ef6\u7684\u65e5\u7a0b\u540d\u79f0') + '</div><div class="error name-error"></div></div><div class="field-group"><label for="import-description">' + soy.$$escapeHtml('\u63cf\u8ff0') + '</label><textarea name="description" id="import-description" rows="4" class="textarea"></textarea></div><div class="field-group field-group-space-permission"><label for="spaceKeyAutocomplete">' + soy.$$escapeHtml('\u7a7a\u95f4') + '<span class="aui-icon icon-required"></span></label><input name="spaceKeyAutocomplete" id="spaceKeyAutocomplete" type="text" class="autocomplete-space text" data-max="5" data-none-message="' + soy.$$escapeHtml('\u672a\u53d1\u73b0\u7a7a\u95f2\u65f6\u95f4') + '"><div class="description">' + soy.$$escapeHtml('\u5c06\u65e5\u7a0b\u94fe\u63a5\u81f3\u7a7a\u95f4\uff0c\u4ee5\u4fbf\u4e8e\u67e5\u627e\u3002') + '</div><div class="error spaceKeyAutocomplete-error"></div></div><div class="field-group"><label for="ical-file">' + soy.$$escapeHtml('\u4e0a\u4f20iCal') + '<span class="aui-icon icon-required"></span></label><input type="file" class="file upfile" name="file_0" size="25"><div class="error file_0-error"></div></div><div class="field-group tc-field-group-timezone hidden"><label for="timeZone">' + soy.$$escapeHtml('\u65f6\u533a') + '<span class="aui-icon icon-required"></span></label><select name="timeZoneId" class="select timeZone"></select><span class="spinner aui-icon aui-icon-wait"></span><div class="error timeZoneId-error"></div></div></form>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.importSubcalendar.soyTemplateName = 'Confluence.TeamCalendars.Templates.importSubcalendar';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:import-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/import-subcalendar/import-subcalendar.js' */
define("tc/import-subcalendar",
    [
        "jquery",
        "underscore",
        "document",
        "tc/util",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util"
    ],
    function (
        $,
        _,
        document,
        Util,
        Backbone,
        Templates,
        CalUtil
    ) {

        "use strict";

        var ImportSubCalendarDialogView = Backbone.View.extend({
            dialog: null, //instance of AJS.ConfluenceDialog,
            //el: will be dialogContent of dialog
            $uploadIframe: null,
            //submit import button
            $submitButton: null,
            options: null, //setting collection of an instance of ImportSubCalendarDialogView

            template: Templates.importSubcalendar(),

            events: {
                "selected.autocomplete-content input[name='spaceKeyAutocomplete']": "_selectSpace"
            },

            defaults: {
                callbackHandler: null,
                textTitleDialog: "\u5bfc\u5165\u65e5\u7a0b\u8868",
                textBtnImport: "\u5bfc\u5165",
                textLinkCancel: "\u53d6\u6d88"
            },

            initialize: function (options) {
                this.options = $.extend({}, this.defaults, options);

                if (!this.options.callbackHandler) {
                    AJS.debug("tc/import-subcalendar: requires 'callbackHandler' object");
                }
            },

            render: function () {
                this._createSubCalendarImportDialog();
                this._populateSubCalendarImportForm();

                this.$submitButton = this.dialog.popup.element.find(".submit");
                return this.dialog;
            },

            _createSubCalendarImportDialog: function () {
                var that = this;
                var isSendingRequest = false;
                var submit = function () {

                    if (isSendingRequest) {
                        return;
                    }
                    var editForm = that.$el.find('form.sub-calendar-import-form');

                    isSendingRequest = true;
                    $.ajax({
                        type: "POST",
                        headers: {
                            "X-Atlassian-Token": "no-check"
                        },
                        url: Confluence.getContextPath() + "/plugins/calendar/importsubcalendar.action",
                        cache: false,
                        contentType: false,
                        processData: false,
                        data: new FormData(editForm[0]),
                        success: function(data) {
                            isSendingRequest = false;
                            that._loadedResultImport(data);
                        },
                        error: function () {
                            isSendingRequest = false;
                        }

                    });

                    that._submit();
                    return false;
                };

                //Do not need to create one more instance of AJS.ConfluenceDialog
                if (this.dialog) {
                    return;
                }

                this.dialog = new AJS.ConfluenceDialog({
                    height: 429,
                    width: 512,
                    onSubmit: submit,
                    id: "import-calendar-dialog"
                });

                this.dialog.addHeader(this.options.textTitleDialog);
                this.dialog.addPanel("", this.template, "calendar-dialog-panel");

                //add button submit for dialog
                this.dialog.addButton(
                    this.options.textBtnImport,
                    submit,
                    "submit"
                );

                //add cancel link for dialog
                this.dialog.addLink(
                    this.options.textLinkCancel,
                    _.bind(this._cancelDialog, this)
                );

                this.el = this.dialog.getCurrentPanel().body;
                this.$el = $(this.el);
                this.$uploadIframe = this.$el.find(".subcalendar-import-result");

                this.delegateEvents(); // this will bind all events once
            },

            _populateSubCalendarImportForm: function () {
                this.$el.find("input[name='name'], textarea[name='description'], input[name='spaceKey'], input[name='spaceKeyAutocomplete']").val("");
                this.$el.find("input[name='color']").val(this.options.callbackHandler.getNextCalendarColor());
                this.$el.find(".field-group .error").empty();

                //hidden space field when TC on space
                if (AJS.Meta.get("space-key")) {
                    this.$el.find("input[name='spaceKey']").val(AJS.Meta.get("space-key"));
                    var spaceDiv = $(".field-group-space-permission", this.$el);
                    spaceDiv.css("display", "none");
                }
            },

            _submit: function () {
                this.options.callbackHandler.setProcessingSubCalendar(true);
                this.spinnerDefer = this.options.callbackHandler.setSubCalendarSpinnerIconVisible(true);
                //disable submit when click
                CalUtil.disableButton(this.$submitButton, "\u5bfc\u5165\u4e2d...");
            },

            _selectSpace: function (e, selection) {
                this.$el.find("input[name='spaceKey']").val(selection.content.key);
                this.$el.find("input[name='spaceKeyAutocomplete']").val(selection.content.name);
            },

            _cancelDialog: function () {
                this.dialog.remove();
                this.dialog = null;
                return false;
            },

            _loadedResultImport: function (data) {
                var that = this;

                var responseDocument = document.createElement('html');
                responseDocument.innerHTML = data;

                var subcalendarId = $(responseDocument).find(".subcalendar-id").text();

                if ($(".import-timezone-required", responseDocument).length) { //We could not determine the calendars timezone

                    CalUtil.disableButton(this.$submitButton);

                    //Show a message explaining we need to know the timezone
                    that.$el.find(".tc-need-timezone").show();
                    //Show the timezone field
                    that.$el.find(".tc-field-group-timezone").show();

                    //TODO: need to refactor Confluence.TeamCalendars.populateTimeZoneDropDown
                    // and Confluence.TeamCalendars.getUserTimeZone
                    Confluence.TeamCalendars.populateTimeZoneDropDown(
                        that.$el.find(".tc-field-group-timezone .timeZone"),
                        Confluence.TeamCalendars.getUserTimeZone(),
                        function () {
                            CalUtil.enableButton(that.$submitButton, "\u5bfc\u5165");
                        },
                        function (XMLHttpRequest, textStatus, errorThrown) {
                            that.options.callbackHandler.showAjaxError(XMLHttpRequest, textStatus, errorThrown);
                        }
                    );

                    // Comment out to deal with AUI on Confluence 5.7
                    //Util.showDialogInUpdatedHeight(that.dialog);
                    that.dialog.updateHeight();
                } else if (!$(".import-successful", responseDocument).length) {
                    var fieldErrors = [];
                    $(".field-errors input", responseDocument).each(function () {
                        fieldErrors.push({
                            field: this.name,
                            errorMessages: [this.value]
                        });
                    });

                    if (fieldErrors.length) {
                        //TODO: need to refactor Confluence.TeamCalendars.setFieldErrors
                        Confluence.TeamCalendars.setFieldErrors(that.$el.find(".sub-calendar-import-form")[0], fieldErrors);
                        // Comment out to deal with AUI on Confluence 5.7
                        //Util.showDialogInUpdatedHeight(that.dialog);
                        that.dialog.updateHeight();
                    }

                    var errorMessages = [];
                    $(".action-error", responseDocument).each(function () {
                        errorMessages.push($(this).text());
                    });
                    if (errorMessages.length) {
                        //TODO: need to refactor Confluence.TeamCalendars.setGenericErrors
                        Confluence.TeamCalendars.setGenericErrors(that.el, errorMessages, "error-subcalendar-update");
                    }
                } else {
                    that.dialog.remove();
                    that.options.callbackHandler.handleImport(subcalendarId);
                }

                CalUtil.enableButton(this.$submitButton, "\u5bfc\u5165");

                if (this.spinnerDefer) this.spinnerDefer.resolve();
                that.options.callbackHandler.setProcessingSubCalendar(false);
            }
        });

        return ImportSubCalendarDialogView;
    });

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:import-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/import-subcalendar/import-subcalendar-compat.js' */
//This is here to make the existing API work.
require(["tc/import-subcalendar"], function (ImportSubCalendarDialogView) {
    "use strict";

    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getSubCalendarImportDialog = function(callbackHandler){
        return new ImportSubCalendarDialogView({
            callbackHandler: callbackHandler
        }).render();
    };
});

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:customeventtype-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-model.js' */
define("tc/customeventtype-model",
    [
        "jquery",
        "tc-backbone"
    ],
    function (
        $,
        Backbone)
    {
        "use strict";
        var customeEventTypeModel = Backbone.Model.extend({
            defaults : function (){
                return {
                    title: "",
                    icon: "",
                    subCalendar: "",
                    disable: false,
                    isCustomEvent: false,
                    id: "",
                    created: "",
                    periodInMins: ""
                };
            },
            validate: function (attrs) {
                if (!attrs.isCustomEvent){
                    return false;
                }

                var errors = [];
                if (!attrs.title)
                {
                    errors.push({field : "title", message : "\u9700\u586b\u4e8b\u4ef6\u540d"});
                }

                attrs.title = $.trim(attrs.title);
                if (attrs.title.length <= 0){
                    errors.push({field : "title", message : "\u9700\u586b\u4e8b\u4ef6\u540d"});
                }else {
                    if (attrs.title.length > 256){
                        errors.push({field : "title", message : "\u4e8b\u4ef6\u540d\u79f0\u5e94\u5c0f\u4e8e\u7b49\u4e8e256\u4e2a\u5b57\u7b26"});
                    }
                }

                if (!attrs.icon)
                {
                    errors.push({field : "icon", message : "\u9700\u586b\u4e8b\u4ef6\u56fe\u6807"});
                }

                return errors.length > 0 ? errors : false;
            },
            toggle: function() {
                this.set({disable: !this.get("disable")});
            }
        });

        return customeEventTypeModel;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:customeventtype-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-edit/customeventtype-edit.soy' */
// This file was automatically generated from customeventtype-edit.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.editCustomEventType = function(opt_data, opt_ignored) {
  var output = '<tr id="edit-custom-event-type-form"><td colspan="3"><div class="aui-message aui-message-warning warning tooltip-warning hidden"><span class="title">' + soy.$$escapeHtml('\u7ee7\u7eed\u524d\u8bf7\u5148\u4fdd\u5b58\u6216\u53d6\u6d88\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u7c7b\u578b\u3002') + '</span></div><form class="aui form-add-custom">';
  if (opt_data.isCustomEventType) {
    output += '<fieldset class="field-group custom-event-title"><label for="event-title">' + soy.$$escapeHtml('\u4e8b\u4ef6\u540d') + '<span class="aui-icon icon-required">required</span></label><input class="text medium-field" type="text" id="custom-eventtype-title" name="event-title" title="Event Title" value="' + soy.$$escapeHtml(opt_data.title) + '"/><p class="hidden error custom_event_type_field_error" data-field-name="title"></p></fieldset><fieldset class="field-group select-avatar tc-event-type-item"><label for="event-title">' + soy.$$escapeHtml('\u4e8b\u4ef6\u56fe\u6807') + '<span class="aui-icon icon-required">required</span></label><div class = "custom-eventtype-icons">';
    var eventTypeList15 = ['campaign', 'conference', 'deployment', 'home', 'marketing_email', 'meeting', 'milestone', 'outage', 'party', 'sporting_event', 'testing', 'training', 'workshop', 'events', 'travel', 'leaves', 'jira_box', 'sprints'];
    var eventTypeListLen15 = eventTypeList15.length;
    for (var eventTypeIndex15 = 0; eventTypeIndex15 < eventTypeListLen15; eventTypeIndex15++) {
      var eventTypeData15 = eventTypeList15[eventTypeIndex15];
      output += '<button class="' + ((opt_data.icon == eventTypeData15) ? 'selected' : '') + '">' + Confluence.TeamCalendars.Templates.renderImagePrinting({imageName: eventTypeData15, customClasses: ['aui-icon', 'icon-teamcals', eventTypeData15], dataIcon: eventTypeData15}) + '</button>';
    }
    output += '</div><p class="hidden error custom_event_type_field_error" data-field-name="icon"></p></fieldset>';
  } else {
    output += '<fieldset class="field-group"><span class="event-type-link" title="' + soy.$$escapeHtml(opt_data.title) + '">' + Confluence.TeamCalendars.Templates.renderImagePrinting({imageName: opt_data.icon, customClasses: ['event-type-table-item', opt_data.icon]}) + '<span class="event-type-label">' + soy.$$escapeHtml(opt_data.title) + '</span></span></fieldset>';
  }
  output += '<fieldset><div class="field-group"><label for="dBase">' + soy.$$escapeHtml('\u63d0\u9192') + '</label><select class="select" id="period-reminder" name="period" title="database select"><option value="0" ' + ((opt_data.periodInMins == 0) ? 'selected' : '') + '>' + soy.$$escapeHtml('\u65e0') + '</option><option value="5" ' + ((opt_data.periodInMins == 5) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5206\u949f','5')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="10" ' + ((opt_data.periodInMins == 10) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5206\u949f','10')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="20" ' + ((opt_data.periodInMins == 20) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5206\u949f','20')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="30" ' + ((opt_data.periodInMins == 30) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5206\u949f','30')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="60" ' + ((opt_data.periodInMins == 60) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5c0f\u65f6','1')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="120" ' + ((opt_data.periodInMins == 120) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5c0f\u65f6','2')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="240" ' + ((opt_data.periodInMins == 240) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5c0f\u65f6','4')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="480" ' + ((opt_data.periodInMins == 480) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5c0f\u65f6','8')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="1440" ' + ((opt_data.periodInMins == 1440) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5929','1')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="2880" ' + ((opt_data.periodInMins == 2880) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5929','2')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="4320" ' + ((opt_data.periodInMins == 4320) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5929','3')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="10080" ' + ((opt_data.periodInMins == 10080) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5468','1')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="20160" ' + ((opt_data.periodInMins == 20160) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5468','2')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="30240" ' + ((opt_data.periodInMins == 30240) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5468','3')) + ' ' + soy.$$escapeHtml('\u524d') + '</option><option value="40320" ' + ((opt_data.periodInMins == 40320) ? 'selected' : '') + '>' + soy.$$escapeHtml(AJS.format('{0} \u5468','4')) + ' ' + soy.$$escapeHtml('\u524d') + '</option></select></div></fieldset><div class="event-type-info"><div class="tc-aui-help-content"><div class="event-type-info-text"><span>' + soy.$$escapeHtml('\u53d8\u66f4\u5c06\u4f1a\u5f71\u54cd\u6240\u6709\u4f7f\u7528\u8fd9\u4e2a\u65e5\u7a0b\u8868\u7684\u7528\u6237;\u5305\u62ec\u63d0\u9192\u65f6\u95f4.') + '</span></div></div></div><span class="buttons-container"><span class="buttons"><input class="button button-panel-button save" tabindex="30" type="button" value="' + soy.$$escapeHtml('\u4fdd\u5b58') + '" id="save-custom-event-type"><a class="cancel" tabindex="31"  href="#">' + soy.$$escapeHtml('\u53d6\u6d88') + '</a></span></span></form></td></tr>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.editCustomEventType.soyTemplateName = 'Confluence.TeamCalendars.Templates.editCustomEventType';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:customeventtype-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-edit/customeventtype-edit.js' */
define("tc/customeventtype-edit",
    [
        "jquery",
        "underscore",
        "tc-backbone"
    ],
    function (
            $,
            _,
            Backbone
            )
    {
        "use strict";
        var CustomEventTypeEditInlineDialogView = Backbone.View.extend({
            parentCustomEventTypeDiv: null,
            mediator : null,
            isOpen: null,
            events: {
                "click input.save": "_updateCustomEventType",
                "click a.cancel": "_closeInlineDialog",
                "click .select-avatar button": "_selectIconCustomEventType",
                "keydown" : "handleKey"
            },
            initialize: function(option) {
                if(!option) {
                    return;
                }
                this.mediator = option.mediator;
                this.parentCustomEventTypeDiv = option.parentCustomEventTypeDiv;
                this.model.on("invalid", _.bind(this._handleError,this));

                // this event will trigger when new edit dialog open then we have a chance to close the previous one
                this.mediator.on("Custom-Event-Type.edit.open", _.bind(this.shouldRemoveMe, this));
                this.mediator.trigger("Custom-Event-Type.edit.open", this);
            },
            render: function() {
                // hide instructional text
                var that = this;

                var isCustomEventType = that.model.get("isCustomEvent") === true;

                $(".custom-event-type-items-instructional").addClass("hidden");
                $(that.parentCustomEventTypeDiv).addClass("hidden");

                $(that.parentCustomEventTypeDiv).after(Confluence.TeamCalendars.Templates.editCustomEventType({"title":that.model.get("title"), "icon": that.model.get("icon"), "periodInMins": that.model.get("periodInMins"), "isCustomEventType": isCustomEventType}));

                that.$editCustomEventTypeForm = $("#edit-custom-event-type-form");
                //HACK bind event for event-type-custom edit
                that.el = that.$editCustomEventTypeForm;
                that.$el = $(that.el);
                that.delegateEvents(); // this will bind all events once

                that.$editCustomEventTypeForm.find('.custom-event-title input').focus();

                this.isOpen = true;
            },

            shouldRemoveMe : function() {
                if (this.isOpen)
                {
                    this.remove();
                }
            },
            remove: function(){
                this._closeInlineDialog();
            },
            handleKey : function (e) {
                if (e.which === 13){
                    // Stop propagation to parent nodes
                    e.preventDefault();
                    e.stopPropagation();
                    this._updateCustomEventType();
                }

                if (e.which === 27){
                    e.preventDefault();
                    e.stopPropagation();
                    this._closeInlineDialog();
                }
            },
            _closeInlineDialog: function() {
                $(this.parentCustomEventTypeDiv).removeClass("hidden");
                if (this.model.collection && this.model.collection.customEventTypes().length === 0) {
                    $(".custom-event-type-items-instructional").removeClass("hidden");
                }
                this.$editCustomEventTypeForm.remove();
            },
            _updateCustomEventType: function() {
                // hide all error messages
                this.$editCustomEventTypeForm.find(".custom_event_type_field_error").each(function(index, errorItem){
                    var $errorItem = $(errorItem);
                    if (!$errorItem.hasClass("hidden")){
                        $errorItem.addClass("hidden");
                    }
                });

                var customEventTypeTitle = this.$editCustomEventTypeForm.find('.custom-event-title input').val();
                var customEventTypeIcon = this.$editCustomEventTypeForm.find(".select-avatar button.selected span").data("icon");
                var customEventTypePeriodInMins = this.$editCustomEventTypeForm.find("#period-reminder").val();

                var oldCustomEventTypeTitle = this.model.get("title");
                var oldCustomEventTypeIcon = this.model.get("icon");
                var oldCustomEventTypePeriodInMins = this.model.get("periodInMins");

                this.model.set({
                    title : customEventTypeTitle !== undefined ? customEventTypeTitle : oldCustomEventTypeTitle,
                    icon : customEventTypeIcon !== undefined ? customEventTypeIcon: oldCustomEventTypeIcon,
                    periodInMins: customEventTypePeriodInMins
                });

                if (!this.model.isValid()){
                    this.model.set({
                        title : oldCustomEventTypeTitle,
                        icon : oldCustomEventTypeIcon,
                        periodInMins: oldCustomEventTypePeriodInMins
                    });
                    return;
                }

                // trigger event to other view to handle
                this.mediator.trigger("Custom-Event-Type.save", this.model);

                this._closeInlineDialog();
            },
            _handleError : function (model, errors){
                var that = this;
                var getErrorMessageFor = function (fieldName){
                    var fieldError = _.where(errors, {field : fieldName});
                    if(fieldError.length > 0) {
                        return fieldError[0].message;
                    }
                    return "";
                };

                // show all error messages
                this.$editCustomEventTypeForm.find(".custom_event_type_field_error").each(function(index, errorItem){
                    var $errorItem = $(errorItem);
                    var fieldName = $errorItem.data("field-name");
                    $errorItem.html(getErrorMessageFor(fieldName));
                    if ($errorItem.hasClass("hidden")){
                        $errorItem.removeClass("hidden");
                    }

                    // try to set focus when there was a error on title field
                    if (fieldName === "title") {
                        that.$editCustomEventTypeForm.find("#custom-eventtype-title").focus();
                    }
                });
            },
            _selectIconCustomEventType: function(event) {
                if( !event ) {
                    event = window.event;
                }

                // stop default link click behaviour
                event.preventDefault();
                $(".select-avatar.tc-event-type-item button").removeClass('selected');
                var target = event.target || event.srcElement;
                if (target.nodeName === "SPAN") {
                    $(target).parent().addClass('selected');
                } else {
                    $(target).addClass('selected');
                }
            }
        });
        return CustomEventTypeEditInlineDialogView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:customeventtype-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-edit/customeventtype-edit-compat.js' */
//This is here to make the existing API work.
require(["tc/customeventtype-edit", "tc/customeventtype-model"], function (CustomEventTypeEditView, CustomeEventTypeModel) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getCustomEventTypeEdit = function(customEventTypeDiv, subCalendar){
        var parentCustomEventTypeDiv = $(customEventTypeDiv).parent().parent();
        var dataCustomEventType = $(parentCustomEventTypeDiv).find("span.custom-event-type").data();
        var customEventTypeModel = new CustomeEventTypeModel({
            title : dataCustomEventType.title,
            icon : dataCustomEventType.icon,
            subCalendar : subCalendar,
            periodInMins: dataCustomEventType.periodInMins
        });


        return new CustomEventTypeEditView({
            parentCustomEventTypeDiv: parentCustomEventTypeDiv,
            dataCustomEventType: dataCustomEventType,
            model: customEventTypeModel
        }).render();
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:tc-jquery-datepicker', location = 'com/atlassian/confluence/extra/calendar3/lib/jquery-plugins/jquery.ui.datepicker.js' */
/*
 * jQuery UI Datepicker 1.8.11
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.11" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();

/* Date picker manager.
   Use the singleton instance of this class, $.tcDatePicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.tcDatePicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false // True to size the input for the date format, false to leave as is
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = $('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>');
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},
	
	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			$('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.tcDatePicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.tcDatePicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if (TC_DATE_PICKER._datepickerShowing && TC_DATE_PICKER._lastInput == input[0])
					TC_DATE_PICKER._hideDatepicker();
				else
					TC_DATE_PICKER._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.tcDatePicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.tcDatePicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		inst.dpDiv.show();
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, TC_DATE_PICKER._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDateDatepicker(target, date);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = TC_DATE_PICKER._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if (TC_DATE_PICKER._datepickerShowing)
			switch (event.keyCode) {
				case 9: TC_DATE_PICKER._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + TC_DATE_PICKER._dayOverClass + ':not(.' + 
									TC_DATE_PICKER._currentClass + ')', inst.dpDiv);
						if (sel[0])
							TC_DATE_PICKER._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						else
							TC_DATE_PICKER._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: TC_DATE_PICKER._hideDatepicker();
						break; // hide on escape
				case 33: TC_DATE_PICKER._adjustDate(event.target, (event.ctrlKey ?
							-TC_DATE_PICKER._get(inst, 'stepBigMonths') :
							-TC_DATE_PICKER._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: TC_DATE_PICKER._adjustDate(event.target, (event.ctrlKey ?
							+TC_DATE_PICKER._get(inst, 'stepBigMonths') :
							+TC_DATE_PICKER._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) TC_DATE_PICKER._adjustDate(event.target, (event.ctrlKey ?
									-TC_DATE_PICKER._get(inst, 'stepBigMonths') :
									-TC_DATE_PICKER._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) TC_DATE_PICKER._adjustDate(event.target, (event.ctrlKey ?
									+TC_DATE_PICKER._get(inst, 'stepBigMonths') :
									+TC_DATE_PICKER._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) TC_DATE_PICKER._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			TC_DATE_PICKER._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = TC_DATE_PICKER._getInst(event.target);
		if (TC_DATE_PICKER._get(inst, 'constrainInput')) {
			var chars = TC_DATE_PICKER._possibleChars(TC_DATE_PICKER._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = TC_DATE_PICKER._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = TC_DATE_PICKER.parseDate(TC_DATE_PICKER._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					TC_DATE_PICKER._getFormatConfig(inst));
				if (date) { // only if valid
					TC_DATE_PICKER._setDateFromField(inst);
					TC_DATE_PICKER._updateAlternate(inst);
					TC_DATE_PICKER._updateDatepicker(inst);
				}
			}
			catch (event) {
				TC_DATE_PICKER.log(event);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if (TC_DATE_PICKER._isDisabledDatepicker(input) || TC_DATE_PICKER._lastInput == input) // already here
			return;
		var inst = TC_DATE_PICKER._getInst(input);
		if (TC_DATE_PICKER._curInst && TC_DATE_PICKER._curInst != inst) {
			TC_DATE_PICKER._curInst.dpDiv.stop(true, true);
		}
		var beforeShow = TC_DATE_PICKER._get(inst, 'beforeShow');
		extendRemove(inst.settings, (beforeShow ? beforeShow.apply(input, [input, inst]) : {}));
		inst.lastVal = null;
		TC_DATE_PICKER._lastInput = input;
		TC_DATE_PICKER._setDateFromField(inst);
		if (TC_DATE_PICKER._inDialog) // hide cursor
			input.value = '';
		if (!TC_DATE_PICKER._pos) { // position below input
			TC_DATE_PICKER._pos = TC_DATE_PICKER._findPos(input);
			TC_DATE_PICKER._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
			TC_DATE_PICKER._pos[0] -= document.documentElement.scrollLeft;
			TC_DATE_PICKER._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: TC_DATE_PICKER._pos[0], top: TC_DATE_PICKER._pos[1]};
		TC_DATE_PICKER._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		TC_DATE_PICKER._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = TC_DATE_PICKER._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: (TC_DATE_PICKER._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = TC_DATE_PICKER._get(inst, 'showAnim');
			var duration = TC_DATE_PICKER._get(inst, 'duration');
			var postProcess = function() {
				TC_DATE_PICKER._datepickerShowing = true;
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = TC_DATE_PICKER._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.show(showAnim, TC_DATE_PICKER._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			TC_DATE_PICKER._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		var borders = TC_DATE_PICKER._getBorders(inst.dpDiv);
		inst.dpDiv.empty().append(this._generateHTML(inst));
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a')
				.bind('mouseout', function(){
					$(this).removeClass('ui-state-hover');
					if(this.className.indexOf('ui-datepicker-prev') != -1) $(this).removeClass('ui-datepicker-prev-hover');
					if(this.className.indexOf('ui-datepicker-next') != -1) $(this).removeClass('ui-datepicker-next-hover');
				})
				.bind('mouseover', function(){
					if (!self._isDisabledDatepicker( inst.inline ? inst.dpDiv.parent()[0] : inst.input[0])) {
						$(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
						$(this).addClass('ui-state-hover');
						if(this.className.indexOf('ui-datepicker-prev') != -1) $(this).addClass('ui-datepicker-prev-hover');
						if(this.className.indexOf('ui-datepicker-next') != -1) $(this).addClass('ui-datepicker-next-hover');
					}
				})
			.end()
			.find('.' + this._dayOverClass + ' a')
				.trigger('mouseover')
			.end();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		else
			inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == TC_DATE_PICKER._curInst && TC_DATE_PICKER._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
		var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				TC_DATE_PICKER._tidyDialog(inst);
				this._curInst = null;
			};
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.hide(showAnim, TC_DATE_PICKER._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);  // trigger custom callback
			this._datepickerShowing = false;
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!TC_DATE_PICKER._curInst)
			return;
		var $target = $(event.target);
		if ($target[0].id != TC_DATE_PICKER._mainDivId &&
				$target.parents('#' + TC_DATE_PICKER._mainDivId).length == 0 &&
				!$target.hasClass(TC_DATE_PICKER.markerClassName) &&
				!$target.hasClass(TC_DATE_PICKER._triggerClass) &&
				TC_DATE_PICKER._datepickerShowing && !(TC_DATE_PICKER._inDialog && $.blockUI))
			TC_DATE_PICKER._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst._selectingMonthYear = false;
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Restore input focus after not changing month/year. */
	_clickMonthYear: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (inst.input && inst._selectingMonthYear) {
			setTimeout(function() {
				inst.input.focus();
			}, 0);
		}
		inst._selectingMonthYear = !inst._selectingMonthYear;
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = (lookAhead(match) ? longNames : shortNames);
			for (var i = 0; i < names.length; i++) {
				if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
					iValue += names[i].length;
					return i + 1;
				}
			}
			throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/*
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								(date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return TC_DATE_PICKER.parseDate(TC_DATE_PICKER._get(inst, 'dateFormat'),
					offset, TC_DATE_PICKER._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				TC_DATE_PICKER._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, TC_DATE_PICKER._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, TC_DATE_PICKER._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.tcDatePicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.tcDatePicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.tcDatePicker._hideDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.tcDatePicker._gotoToday(\'#' + inst.id + '\');"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var numRows = (isMultiMonth ? 6 : Math.ceil((leadDays + daysInMonth) / 7)); // calculate the number of rows to generate
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' onclick="DP_jQuery_' + dpuuid + '.tcDatePicker._selectDay(\'#' +
							inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' + 
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" ' +
				'onchange="DP_jQuery_' + dpuuid + '.tcDatePicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
				'onclick="DP_jQuery_' + dpuuid + '.tcDatePicker._clickMonthYear(\'#' + inst.id + '\');"' +
			 	'>';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		inst.yearshtml = '';
		if (secondary || !changeYear)
			html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
		else {
			// determine range of years to display
			var years = this._get(inst, 'yearRange').split(':');
			var thisYear = new Date().getFullYear();
			var determineYear = function(value) {
				var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
					(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
					parseInt(value, 10)));
				return (isNaN(year) ? thisYear : year);
			};
			var year = determineYear(years[0]);
			var endYear = Math.max(year, determineYear(years[1] || ''));
			year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
			endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
			inst.yearshtml += '<select class="ui-datepicker-year" ' +
				'onchange="DP_jQuery_' + dpuuid + '.tcDatePicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
				'onclick="DP_jQuery_' + dpuuid + '.tcDatePicker._clickMonthYear(\'#' + inst.id + '\');"' +
				'>';
			for (; year <= endYear; year++) {
				inst.yearshtml += '<option value="' + year + '"' +
					(year == drawYear ? ' selected="selected"' : '') +
					'>' + year + '</option>';
			}
			inst.yearshtml += '</select>';
			//when showing there is no need for later update
			if( ! $.browser.mozilla ){
				html += inst.yearshtml;
				inst.yearshtml = null;
			} else {
				// will be replaced later with inst.yearshtml
				html += '<select class="ui-datepicker-year"><option value="' + drawYear + '" selected="selected">' + drawYear + '</option></select>';
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
		(a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

var oldFnDatepicker = $.fn.tcDatePicker;
/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.tcDatePicker = function(options){
	
	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}
	
	/* Initialise the date picker. */
	if (!TC_DATE_PICKER.initialized) {
		$(document).mousedown(TC_DATE_PICKER._checkExternalClick).
			find('body').append(TC_DATE_PICKER.dpDiv);
		TC_DATE_PICKER.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return TC_DATE_PICKER['_' + options + 'Datepicker'].
			apply(TC_DATE_PICKER, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return TC_DATE_PICKER['_' + options + 'Datepicker'].
			apply(TC_DATE_PICKER, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			TC_DATE_PICKER['_' + options + 'Datepicker'].
				apply(TC_DATE_PICKER, [this].concat(otherArgs)) :
			TC_DATE_PICKER._attachDatepicker(this, options);
	});
};

$.fn.tcDatePicker.noConflict = function() {
	$.fn.tcDatePicker = oldFnDatepicker || $.fn.tcDatePicker;
	return this;
};

var TC_DATE_PICKER = new Datepicker(); // singleton instance
var oldDatepicker = $.tcDatePicker;
$.tcDatePicker = TC_DATE_PICKER;
TC_DATE_PICKER.initialized = false;
TC_DATE_PICKER.uuid = new Date().getTime();
TC_DATE_PICKER.version = "1.8.11";

TC_DATE_PICKER.noConflict = function() {
	$.tcDatePicker = oldDatepicker || $.tcDatePicker;
	return this;
};

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-edit-dialog.soy' */
// This file was automatically generated from event-edit-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.eventEdit = function(opt_data, opt_ignored) {
  return '<form name="event-edit" class="aui event-edit" method="POST" action="#"><input type="hidden" name="uid" value=""><input type="hidden" name="originalStartDate" value=""><input type="hidden" name="originalSubCalendarId" value=""><input type="hidden" name="originalEventType" value=""><input type="hidden" name="originalCustomEventTypeId" value=""><input type="hidden" name="childSubCalendarId" value=""><div class="event-type subcalendar-event"><div class="aui-message aui-message-error error calendar-error hidden"><p class="title"><strong>' + soy.$$escapeHtml('\u6709\u9519\u8bef\u53d1\u751f\u3002') + '</strong></p><div class="error-content"><ul class="error-messages hidden"></ul></div></div><div class="field-group field-group-calendar"><label for="calendar">' + soy.$$escapeHtml('\u65e5\u7a0b\u8868') + '<span class="aui-icon icon-required"></span></label><select name="calendar" id="calendar" class="sub-calendar-select select"></select><a href="#" id="calendar-tooltip" class="aui-icon icon-help hidden" original-title="show tooltip" title="' + soy.$$escapeHtml('\u4e0d\u52fe\u9009\u201c\u4ec5\u7f16\u8f91\u672c\u5b9e\u4f8b\u201d\u540e\uff0c\u5c06\u542f\u7528\u672c\u5b57\u6bb5') + '"></a></div><div class="field-group field-group-event-type"><label for="event-type">' + soy.$$escapeHtml('\u4e8b\u4ef6\u7c7b\u578b') + '<span class="aui-icon icon-required"></span></label><select name="event-type" id="event-type" class="event-type-select select"></select><a href="#" id="calendar-tooltip" class="aui-icon icon-help hidden" original-title="show tooltip" title="' + soy.$$escapeHtml('\u4e0d\u52fe\u9009\u201c\u4ec5\u7f16\u8f91\u672c\u5b9e\u4f8b\u201d\u540e\uff0c\u5c06\u542f\u7528\u672c\u5b57\u6bb5') + '"></a><div class="error type-error"></div></div><div id="event-fields-container"></div></form>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.eventEdit.soyTemplateName = 'Confluence.TeamCalendars.Templates.eventEdit';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-fields.soy' */
// This file was automatically generated from event-fields.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.Fields.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }
if (typeof Confluence.TeamCalendars.Templates.Fields == 'undefined') { Confluence.TeamCalendars.Templates.Fields = {}; }


Confluence.TeamCalendars.Templates.Fields.text = function(opt_data, opt_ignored) {
  return '<div class="field-group field-' + soy.$$escapeHtml(opt_data.id) + '" id="field-text-' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(opt_data.id) + '">' + soy.$$escapeHtml(opt_data.label) + ((opt_data.required) ? '<span class="aui-icon icon-required"></span>' : '') + '</label><input type="text" class="text" name="' + soy.$$escapeHtml(opt_data.id) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-text" value="" ' + ((opt_data.readOnly) ? ' readonly="readonly"' : '') + '><div class="error ' + soy.$$escapeHtml(opt_data.id) + '-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.text.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.text';
}


Confluence.TeamCalendars.Templates.Fields.inforReminderLabel = function(opt_data, opt_ignored) {
  return '<div class="field-group field-' + soy.$$escapeHtml(opt_data.id) + '" id="field-text-' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(opt_data.id) + '">' + soy.$$escapeHtml(opt_data.label) + '</label><div class="bodyInforReminderLabel">' + Confluence.TeamCalendars.Templates.Fields.bodyInforReminderLabel(opt_data) + '</div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.inforReminderLabel.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.inforReminderLabel';
}


Confluence.TeamCalendars.Templates.Fields.bodyInforReminderLabel = function(opt_data, opt_ignored) {
  return '' + ((opt_data.reminderPeriod > 0) ? '<span class="span-label field-value-normal">' + soy.$$filterNoAutoescape(opt_data.reminderPeriodText) + '</span><p/><div class="reminder-info"><div class="reminder-info-icon"><span class="aui-icon aui-icon-small aui-iconfont-info">Info</span></div><div class="reminder-info-text"><span>' + soy.$$filterNoAutoescape('\u63d0\u9192\u6839\u636e\u4e8b\u4ef6\u7c7b\u578b\u800c\u5b9a\u3002\x3ca href\x3d\x22#\x22 id\x3d\x22calendar-reminder-setting\x22\x3e\u7f16\u8f91\u4e8b\u4ef6\u7c7b\u578b\x3c/a\x3e') + '</span></div></div>' : '<span class="span-label field-value-normal">' + soy.$$escapeHtml(opt_data.reminderPeriodText) + ' ' + soy.$$filterNoAutoescape('\x3ca href\x3d\x22#\x22 id\x3d\x22calendar-reminder-setting\x22 class\x3d\x22add-reminder-setting\x22\x3e\u589e\u52a0\u63d0\u9192\x3c/a\x3e') + '</span>');
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.bodyInforReminderLabel.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.bodyInforReminderLabel';
}


Confluence.TeamCalendars.Templates.Fields.textarea = function(opt_data, opt_ignored) {
  return '<div class="field-group field-' + soy.$$escapeHtml(opt_data.id) + '" id="field-textarea-' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(opt_data.id) + '">' + soy.$$escapeHtml(opt_data.label) + ((opt_data.required) ? '<span class="aui-icon icon-required"></span>' : '') + '</label><textarea name="' + soy.$$escapeHtml(opt_data.id) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-textarea" class="textarea" rows="' + soy.$$escapeHtml(opt_data.size) + '" ' + ((opt_data.readOnly) ? ' readonly="readonly"' : '') + '></textarea><div class="error ' + soy.$$escapeHtml(opt_data.id) + '-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.textarea.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.textarea';
}


Confluence.TeamCalendars.Templates.Fields.page = function(opt_data, opt_ignored) {
  return '<div class="field-group field-' + soy.$$escapeHtml(opt_data.id) + ' field-group-eventlink" id="field-page-' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(opt_data.id) + '">' + soy.$$escapeHtml(opt_data.label) + ((opt_data.required) ? '<span class="aui-icon icon-required"></span>' : '') + '</label><input type="text" class="text" name="' + soy.$$escapeHtml(opt_data.id) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-text" value="" ' + ((opt_data.readOnly) ? ' readonly="readonly"' : '') + '><div class="' + soy.$$escapeHtml(opt_data.id) + '-suggestions aui-dd-parent hidden" ><div class="aui-dropdown"></div></div><div class="error ' + soy.$$escapeHtml(opt_data.id) + '-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.page.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.page';
}


Confluence.TeamCalendars.Templates.Fields.when = function(opt_data, opt_ignored) {
  return '<div id="field-when"><fieldset class="date-select"><legend><span>' + soy.$$escapeHtml('\u4f55\u65f6') + '<span class="aui-icon icon-required"></span></span></legend><div class="field-group"><label for="startDate">' + soy.$$escapeHtml('\u5f00\u59cb\u65e5\u671f') + '</label><input class="datepicker-field date-field start text" type="text" name="startDate" id="' + soy.$$escapeHtml(opt_data.id) + '-startDate" size="10" value="" autocomplete="off" ' + ((opt_data.disableStartDateTime) ? ' disabled="disabled"' : '') + '><label for="startTime">' + soy.$$escapeHtml('\u5f00\u59cb\u65f6\u95f4') + '</label><input type="text" class="time-field text" name="startTime" id="' + soy.$$escapeHtml(opt_data.id) + '-startTime" size="8" ' + ((opt_data.disableStartDateTime) ? ' disabled="disabled"' : '') + '><span>' + soy.$$escapeHtml('\u5230') + '</span><label for="endTime">' + soy.$$escapeHtml('\u7ed3\u675f\u65e5\u671f') + '</label><input type="text" class="time-field text" name="endTime" id="' + soy.$$escapeHtml(opt_data.id) + '-endTime" size="8" ' + ((opt_data.disableEndDateTime) ? ' disabled="disabled"' : '') + '><label for="endDate">' + soy.$$escapeHtml('\u7ed3\u675f\u65f6\u95f4') + '</label><input class="datepicker-field date-field end text" type="text" name="endDate" id="' + soy.$$escapeHtml(opt_data.id) + '-endDate" size="10" value="" autocomplete="off" ' + ((opt_data.disableEndDateTime) ? ' disabled="disabled"' : '') + '><div class="error when-error"></div></div></fieldset><div class="field-group field-group-allday"><label for="allDayEvent">' + soy.$$escapeHtml('\u5168\u5929\u4e8b\u5b9c') + '</label><input type="checkbox" class="checkbox" name="allDayEvent" id="' + soy.$$escapeHtml(opt_data.id) + '-allDayEvent" value="true" ' + ((opt_data.disableAllDay) ? ' disabled="disabled"' : '') + '></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.when.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.when';
}


Confluence.TeamCalendars.Templates.Fields.repeats = function(opt_data, opt_ignored) {
  return '<div id="field-repeats"><input type="hidden" name="freq" value=""><input type="hidden" name="byday" value=""><input type="hidden" name="recurrenceId" value=""><div class="field-group edit-this-instance-only-container hidden"><label for="editthisinstanceonly">' + soy.$$escapeHtml('\u4ec5\u7f16\u8f91\u6b64\u9879') + '</label><input type="checkbox" class="checkbox" name="editthisinstanceonly" id="editthisinstanceonly" value="true" checked="checked"></div><div class="field-group field-group-frequency"><label for="freq-select">' + soy.$$escapeHtml('\u91cd\u590d') + '</label><select name="freq-select" id="' + soy.$$escapeHtml(opt_data.id) + '-freq-select" class="select"><option value="">' + soy.$$escapeHtml('\u4e0d\u91cd\u590d') + '</option><option value="DAILY">' + soy.$$escapeHtml('\u6bcf\u65e5') + '</option><option value="WEEKLY-BYDAY">' + soy.$$escapeHtml('\u5de5\u4f5c\u65e5') + '</option><option value="WEEKLY">' + soy.$$escapeHtml('\u6bcf\u5468') + '</option><option value="MONTHLY">' + soy.$$escapeHtml('\u6bcf\u6708') + '</option><option value="YEARLY">' + soy.$$escapeHtml('\u6bcf\u5e74') + '</option></select></div><div class="hidden field-group interval-container"><label for="interval">' + soy.$$escapeHtml('\u91cd\u590d\u95f4\u9694') + '</label><input type="text" class="text" name="interval" id="' + soy.$$escapeHtml(opt_data.id) + '-interval" maxlength="2"><span class="interval-label"></span><div class="error interval-error"></div></div><fieldset class="date-select recur-ends hidden"><legend><span>' + soy.$$escapeHtml('\u7ed3\u675f') + '</span></legend><div class="field-group"><label for="recur-end-never">' + soy.$$escapeHtml('\u6c38\u4e0d') + '</label><input type="radio" class="radio recur-ends-never" name="recur-end" id="' + soy.$$escapeHtml(opt_data.id) + '-recur-end-never" checked="checked"><span class="label">' + soy.$$escapeHtml('\u6c38\u4e0d') + '</span><label for="recur-end-until">' + soy.$$escapeHtml('\u76f4\u81f3') + '</label><input type="radio" class="radio recur-ends-until" name="recur-end" id="' + soy.$$escapeHtml(opt_data.id) + '-recur-end-until" disabled="disabled"><span class="label">' + soy.$$escapeHtml('\u76f4\u81f3') + '</span><input class="datepicker-field date-field text" type="text" class="" name="until" id="' + soy.$$escapeHtml(opt_data.id) + '-until" value="" size="10" disabled="disabled"  autocomplete="off"><div class="error until-error"></div></div></fieldset></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeats.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeats';
}


Confluence.TeamCalendars.Templates.Fields.repeatComponentUnSupported = function(opt_data, opt_ignored) {
  return '<div class="field-group field-group-frequency"><label for="freq-select">' + soy.$$escapeHtml('\u91cd\u590d') + '</label><div class="aui-message aui-message-info info repeat-unsupported"><p>' + soy.$$escapeHtml('\u54e6\u6b64\u4e8b\u4ef6\u88ab\u8bbe\u7f6e\u4e3a\u5728\u53e6\u4e00\u4e2a\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4e2d\u91cd\u590d\u3002\u8981\u8fdb\u884c\u66f4\u6539\uff0c\u60a8\u9700\u8981\u5728\u8be5\u5e94\u7528\u7a0b\u5e8f\u4e2d\u7f16\u8f91\u6b64\u4e8b\u4ef6\u3002') + '</p></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatComponentUnSupported.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatComponentUnSupported';
}


Confluence.TeamCalendars.Templates.Fields.repeatComponent = function(opt_data, opt_ignored) {
  return '<div id="field-repeats"><input type="hidden" name="rruleStr" value=""><div class="field-group edit-this-instance-only-container hidden"><label for="editthisinstanceonly">' + soy.$$escapeHtml('\u4ec5\u7f16\u8f91\u6b64\u9879') + '</label><input type="checkbox" class="checkbox" name="editthisinstanceonly" id="editthisinstanceonly" value="true" checked="checked"></div><div class="field-group hidden frequency-container"><!-- just a placeholder will be replaced by actuall template --></div><fieldset class="group hidden repeat-on-container"><!-- just a placeholder will be replaced by actuall template --></fieldset><div class="hidden field-group interval-container"><!-- just a placeholder will be replaced by actuall template --></div><fieldset class="hidden date-select recur-ends-container"><!-- just a placeholder will be replaced by actuall template --></fieldset></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatComponent.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatComponent';
}


Confluence.TeamCalendars.Templates.Fields.repeatFrequency = function(opt_data, opt_ignored) {
  return '<div class="hidden field-group frequency-container"><label for="freq-select">' + soy.$$escapeHtml('\u91cd\u590d') + '</label><select name="freq-select" id="freq-select" class="select"><option value="">' + soy.$$escapeHtml('\u4e0d\u91cd\u590d') + '</option><option value="DAILY">' + soy.$$escapeHtml('\u6bcf\u65e5') + '</option><option value="WEEKLY">' + soy.$$escapeHtml('\u6bcf\u5468') + '</option><option value="MONTHLY">' + soy.$$escapeHtml('\u6bcf\u6708') + '</option><option value="YEARLY">' + soy.$$escapeHtml('\u6bcf\u5e74') + '</option></select></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatFrequency.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatFrequency';
}


Confluence.TeamCalendars.Templates.Fields.repeatOnMonthly = function(opt_data, opt_ignored) {
  return '<fieldset class="group hidden repeat-on-container"><legend><span>' + soy.$$escapeHtml('\u91cd\u590d\u4e8e') + '</span></legend><div class="radio"><input class="radio" name="monthlyRepeatOn" id="monthlyRepeatOnSameDate" type="radio"><label for="irTwo">' + soy.$$escapeHtml('\u540c\u4e00\u5929') + '</label></div><div class="radio"><input class="radio" name="monthlyRepeatOn" id="monthlyRepeatOnSameDay" type="radio"><label for="irTwo">' + soy.$$escapeHtml('\u6bcf\u4e2a\u6708\u7684\u540c\u4e00\u5929') + '</label></div><div class="radio hidden" id="monthlyRepeatOnSameDayContainer"><select id="monthlyRepeatOnSameDayByMonthDay" class="select"><option value="1">' + soy.$$escapeHtml('\u7b2c\u4e00\u4e2a') + '</option><option value="2">' + soy.$$escapeHtml('\u7b2c\u4e8c\u4e2a') + '</option><option value="3">' + soy.$$escapeHtml('\u7b2c\u4e09\u4e2a') + '</option><option value="4">' + soy.$$escapeHtml('\u7b2c\u56db\u4e2a') + '</option><option value="-1">' + soy.$$escapeHtml('\u6700\u540e\u4e00\u4e2a') + '</option></select><select id="monthlyRepeatOnSameDayByWeekDay" class="select"><option value="0">' + soy.$$escapeHtml('\u5468\u4e00') + '</option><option value="1">' + soy.$$escapeHtml('\u5468\u4e8c') + '</option><option value="2">' + soy.$$escapeHtml('\u5468\u4e09') + '</option><option value="3">' + soy.$$escapeHtml('\u5468\u56db') + '</option><option value="4">' + soy.$$escapeHtml('\u5468\u4e94') + '</option><option value="5">' + soy.$$escapeHtml('\u5468\u516d') + '</option><option value="6">' + soy.$$escapeHtml('\u5468\u65e5') + '</option><option class="with-separator" value="day">' + soy.$$escapeHtml('\u5929') + '</option></select></div></fieldset>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatOnMonthly.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatOnMonthly';
}


Confluence.TeamCalendars.Templates.Fields.repeatOnWeekly = function(opt_data, opt_ignored) {
  return '<fieldset class="group hidden repeat-on-container"><legend><span>' + soy.$$escapeHtml('\u91cd\u590d\u4e8e') + '</span></legend><div class="checkbox"><input name="repeatOnMon" id="repeatOnMon" value="0" class="" type="checkbox"><label for="repeatOnMon">' + soy.$$escapeHtml('\u5468\u4e00') + '</label><input name="repeatOnTues" id="repeatOnTues" value="1" class="" type="checkbox"><label for="repeatOnTues">' + soy.$$escapeHtml('\u5468\u4e8c') + '</label><input name="repeatOnWeds" id="repeatOnWeds" value="2" class="" type="checkbox"><label for="repeatOnWeds">' + soy.$$escapeHtml('\u5468\u4e09') + '</label><input name="repeatOnThurs" id="repeatOnThurs" value="3" class="" type="checkbox"><label for="repeatOnThurs">' + soy.$$escapeHtml('\u5468\u56db') + '</label></div><div class="checkbox"><input name="repeatOnFri" id="repeatOnFri" value="4" class="" type="checkbox"><label for="repeatOnFri">' + soy.$$escapeHtml('\u5468\u4e94') + '</label><input name="repeatOnSat" id="repeatOnSat" value="5" class="" type="checkbox"><label for="repeatOnSat">' + soy.$$escapeHtml('\u5468\u516d') + '</label><input name="repeatOnSun" id="repeatOnSun" value="6" class="" type="checkbox"><label for="repeatOnSun">' + soy.$$escapeHtml('\u5468\u65e5') + '</label></div></fieldset>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatOnWeekly.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatOnWeekly';
}


Confluence.TeamCalendars.Templates.Fields.repeatInterval = function(opt_data, opt_ignored) {
  return '<div class="hidden field-group interval-container"><label for="interval">' + soy.$$escapeHtml('\u91cd\u590d\u95f4\u9694') + '</label><input type="text" class="text" name="interval" id="repeat-interval-txtField" maxlength="2"><span class="interval-label"></span><div class="error interval-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatInterval.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatInterval';
}


Confluence.TeamCalendars.Templates.Fields.repeatRecurEnd = function(opt_data, opt_ignored) {
  return '<fieldset class="hidden date-select recur-ends-container"><legend><span>' + soy.$$escapeHtml('\u7ed3\u675f') + '</span></legend><div class="radio"><input type="radio" class="radio recur-ends-never" name="recur-end" id="recur-end-never"><span class="label">' + soy.$$escapeHtml('\u6c38\u4e0d') + '</span></div><div class="radio"><input type="radio" class="radio recur-ends-times" name="recur-end" id="recur-end-times"><span class="label">' + soy.$$escapeHtml('\u91cd\u590d') + '</span><input type="text" class="text" name="recur-end-times" id="recur-end-times-txtField" maxlength="2"><span class="interval-label">' + soy.$$escapeHtml('\u6b21') + '</span></div><div class="radio"><input type="radio" class="radio recur-ends-until" name="recur-end" id="recur-end-until"><span class="label">' + soy.$$escapeHtml('\u76f4\u81f3') + '</span><input class="datepicker-field date-field text" type="text" class="" name="until" id="until" value="" size="10" disabled="disabled"  autocomplete="off"></div><div class="error until-error"></div></fieldset>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.repeatRecurEnd.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.repeatRecurEnd';
}


Confluence.TeamCalendars.Templates.Fields.user = function(opt_data, opt_ignored) {
  return '<div class="field-group field-group-' + soy.$$escapeHtml(opt_data.id) + '" id="field-user-' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(opt_data.id) + '">' + soy.$$escapeHtml(opt_data.label) + ((opt_data.required) ? '<span class="aui-icon icon-required"></span>' : '') + '</label><input type="text" class="text autocomplete-user" name="' + soy.$$escapeHtml(opt_data.id) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-user-picker" value="" data-max="10" data-none-message="' + soy.$$escapeHtml('\u672a\u627e\u5230\u7528\u6237\u3002') + '" data-template="{title}"><ul class="invitees hidden"></ul><div class="error ' + soy.$$escapeHtml(opt_data.id) + '-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.user.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.user';
}


Confluence.TeamCalendars.Templates.Fields.userSelection = function(opt_data, opt_ignored) {
  return '<li class="invitee" title="' + soy.$$escapeHtml(opt_data.fullName) + ' (' + soy.$$escapeHtml(opt_data.userName) + ')"><div class="invitee-left" threedots="' + soy.$$escapeHtml(opt_data.fullName) + ' (' + soy.$$escapeHtml(opt_data.userName) + ')"><img src="' + soy.$$escapeHtml(opt_data.imgPath) + '"><span class="invitee-name-display">' + soy.$$escapeHtml(opt_data.fullName) + '<span class="user-name">(' + soy.$$escapeHtml(opt_data.userName) + ')</span></span></div><div class="invitee-right"><a class="delete-invitee" title="' + soy.$$escapeHtml('\u5220\u9664') + '"></a></div><div class="clear"></div></li>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.userSelection.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.userSelection';
}


Confluence.TeamCalendars.Templates.Fields.serverSelector = function(opt_data, opt_ignored) {
  return '<div class="field-group field-group-jira field-group-jira-server" id="field-serverSelector"><label for="tc-jira-server">' + soy.$$escapeHtml('\u670d\u52a1\u5668') + '<span class="aui-icon icon-required"></span></label><select name="tc-jira-server" class="select tc-jira-server"></select><span class="spinner aui-icon aui-icon-wait"></span><div class="error server-error"></div><div class="error oauth-error hidden"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.serverSelector.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.serverSelector';
}


Confluence.TeamCalendars.Templates.Fields.projectSelector = function(opt_data, opt_ignored) {
  return '<div class="field-group field-group-jira field-group-jira-project" id="field-projectSelector"><label for="tc-jira-project">' + soy.$$escapeHtml('\u9879\u76ee') + '<span class="aui-icon icon-required"></span></label><select name="tc-jira-project" class="select tc-jira-project"></select><span class="spinner aui-icon aui-icon-wait"></span><div class="error project-error"></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.Fields.projectSelector.soyTemplateName = 'Confluence.TeamCalendars.Templates.Fields.projectSelector';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-edit-dialog.js' */
define("tc/event-edit-dialog",
    [
        "jquery",
        "tc/event-field-handlers",
        "tc/event-types",
        "tc-backbone",
        "tc/calendar-util",
        "tc/form-state-control"
    ],
    function (
        $,
        eventFieldHandlers,
        EventTypes,
        Backbone,
        CalUtil,
        FormStateControl
        )
    {
       "use strict";
        var CalendarPlugin,
        calendarDiv,
        dialog,
        okButtonStates = {};

        var EventEditDialog = Backbone.View.extend({
            disableCalSelect : function() {
                if ($.fn.auiSelect2) {
                    $("select#calendar").auiSelect2("disable");
                } else {
                    $("select#calendar").attr("disabled", true);
                }

                if(AJS.Meta.get("build-number") >= 4520) {
                    $('#event-type').auiSelect2("enable", false);
                } else {
                    $('#event-type').auiSelect2("disable");
                }
            },

            enableCalSelect : function() {
                if ($.fn.auiSelect2) {
                    $("select#calendar").auiSelect2("enable");
                } else {
                    $("select#calendar").attr("disabled", false);
                }

                if(AJS.Meta.get("build-number") >= 4520) {
                   $('#event-type').auiSelect2("enable", true);
                } else {
                   $('#event-type').auiSelect2("enable");
                }
            },

            showToolTip : function() {
                $("#edit-event-dialog .subcalendar-event select.event-type-select").css('display','none');

                // fix layout for Internet Explorer, support IE11 and 5.2 <= Confluence < 5.3
                var ua = window.navigator.userAgent;
                var msie = ua.indexOf("MSIE ");
                if (AJS.Meta.get("build-number") < 4520 || msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./)) {
                    $("#edit-event-dialog .field-group-event-type .icon-help").css("top", "-10px");
                }

                $("#calendar-tooltip.icon-help").removeClass("hidden").tooltip({aria:true});
            },

            hiddenToolTip: function() {
                $("#calendar-tooltip.icon-help").addClass("hidden");
            },

            getField : function(fieldsDiv, fieldName) {
                return $("input[name='" + fieldName + "']", fieldsDiv);
            },

            getSelect : function(fieldsDiv, fieldName) {
                return $("select[name='" + fieldName + "']", fieldsDiv);
            },

            getTextSelect : function(fieldsDiv, fieldName) {
                return $("select[name='" + fieldName + "'] option:selected", fieldsDiv).text();
            },

            getTextArea : function(fieldsDiv, fieldName) {
                return $("textarea[name='" + fieldName + "']", fieldsDiv);
            },

            show : function() {
                dialog.show();
            },

            hide : function() {
                dialog.hide();
            },

            remove : function() {
                dialog.remove();
            },

            /**
             * This is the public interface. This function returns a edit event dialog.
             *
             * event : The event to edit. If creating a new event just create an object with the appropriate date fields set.
             *
             * subCalendar : The subCalendar the event belong to. If null the event will be associated with the first calendar
             * in the list of users calendars alphabetically.
             *
             * _CalendarPlugin : A reference to the CalendarPlugin object.
             *
             * _calendarDiv : The div of the calendar we are editing.
             */
            getEditEventDialog : function(event, subCalendar, _CalendarPlugin, _calendarDiv) {
                var eventEditForm,
                    submit,
                    cancel,
                    dialogPanel,
                    eventTypes,
                    fieldHandlersForType = [],
                    okButton,
                    localStorage = Confluence.TeamCalendars.LocalStorage,
                    originalEventSubCalendarId = event.originalEventSubCalendarId,
                    eventEditDialog = this;

                var width = 580, height = 700;

                //Sometimes the event to create the dialog is fired multiple times. If we are already showing a dialog return it.
                if (dialog && dialog.isVisible()) {
                    return dialog;
                }

                //This should never happen as we destroy the dialog when you close it.
                //But just in case log a warning and kill the existing dialog.
                if (dialog) {
                    dialog.remove();
                    dialog = null;
                    AJS.log("Warning: old event edit dialog was not destroyed before creating a new one.");
                }

                CalendarPlugin = _CalendarPlugin;
                calendarDiv = _calendarDiv;

                eventTypes = EventTypes.DefaultEventType;

                //HACK to convert undefined to "" so jQuery each will not ignore them
                function removeUndefined(data) {
                    var fixedData = {};
                    $.each(data, function(name, value) {
                        if (value === undefined) {
                            fixedData[name] = "";
                        } else {
                            fixedData[name] = value;
                        }
                    });
                    return fixedData;
                }

                //Called when the user submits the event edit dialog. Collects and massages data from the form and then calls
                //CalendarPlugin.updateEvent to send the data to the server. Also handles errors that come back from the server.
                function submitForm(fieldsDiv, fieldHandlers) {
                    var originalSubCalendarId,
                        originalStartDate,
                        subCalendarId,
                        uid,
                        allDayEvent,
                        until,
                        eventTypeName,
                        eventType,
                        originalEventType,
                        originalCustomEventTypeId,
                        customEventTypeId,
                        childSubCalendarId;

                    if (CalendarPlugin.isProcessingEvent(calendarDiv)) {
                        return false;
                    }

                    CalendarPlugin.setProcessingEvent(calendarDiv, true, eventEditForm);

                    originalSubCalendarId = eventEditDialog.getField(dialogPanel, "originalSubCalendarId").val();
                    childSubCalendarId = eventEditDialog.getField(dialogPanel, "childSubCalendarId").val();
                    originalStartDate = eventEditDialog.getField(dialogPanel, "originalStartDate").val();
                    subCalendarId = $("option:selected", eventEditDialog.getSelect(dialogPanel, "calendar")).val();
                    uid = eventEditDialog.getField(dialogPanel, "uid").val();
                    eventTypeName = eventEditDialog.getSelect(dialogPanel, "event-type").val();
                    eventType = CalUtil.isCustomEventType(eventTypeName) ? EventTypes.CustomEventType : eventTypes[eventTypeName];
                    allDayEvent = eventEditDialog.getField(dialogPanel, "allDayEvent").is(":checked");
                    until = eventEditDialog.getField(dialogPanel, "until");
                    originalEventType = eventEditDialog.getField(dialogPanel, "originalEventType").val();
                    originalCustomEventTypeId = eventEditDialog.getField(dialogPanel, "originalCustomEventTypeId").val();
                    customEventTypeId = CalUtil.isCustomEventType(eventTypeName) ? eventTypeName : "";

                    //save calendarSelect and eventType to cookie
                    localStorage.setItem("last-selected-calendar", subCalendarId);
                    localStorage.setItem("last-selected-calendar-type", eventTypeName);

                    if (!uid) { //We are creating a new event
                        calendarDiv.data(CalendarPlugin.PREF_LAST_ALL_DAY_USED, allDayEvent.toString());
                    }

                    if(!eventType) {
                        return;
                    }

                    var analyticEventTrigger = function (properties) {
                        if (!uid) { //We are creating a new event
                            //only fire event for analytics when creating new event.
                            console.log("rrule : "+ properties.rrule);
                            addEventAnalytics(properties);
                        }
                    };
                    //Some event types, e.g. JIRA send something totally different to the server for historical reasons. So we
                    //let them have their own handler to submit the form.
                    if (eventType.customHandler) {
                        eventType.customHandler.submitForm(
                                fieldsDiv,
                                eventEditDialog.getField(fieldsDiv, "name").val(),
                                subCalendarId,
                                CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                                function() {
                                    dialog.remove();
                                    CalendarPlugin.setProcessingEvent(calendarDiv, false, eventEditForm);
                                    CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                                    analyticEventTrigger({rrule: ""});
                                },
                                function() {
                                    CalendarPlugin.setProcessingEvent(calendarDiv, false, eventEditForm);
                                });
                        return;
                    }

                    CalendarPlugin.updateEvent(
                        calendarDiv, (function() {
                            var data = {
                                //These fields are always on the form.
                                originalSubCalendarId : originalSubCalendarId,
                                originalStartDate : originalStartDate,
                                subCalendarId : subCalendarId,
                                uid : uid,
                                eventType : CalUtil.isCustomEventType(eventTypeName) ? "custom" : eventTypeName,
                                originalEventType: originalEventType,
                                customEventTypeId: customEventTypeId,
                                originalCustomEventTypeId: originalCustomEventTypeId,
                                childSubCalendarId: childSubCalendarId, //need hold this childSubCalendar for purpose check exist JIRA event type,
                                recurrenceId: event.recurId || ""
                            };

                            //Get data from each field.
                            $.each(fieldHandlers, function(i, handler) {
                                $.extend(data, removeUndefined(handler.getData()));
                            });

                            analyticEventTrigger({rrule: data.rruleStr || ""});
                            return data;
                        })(),
                        function(XMLHttpRequest, textStatus, errorThrown) {
                            CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("unselect");
                            CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_EVENT_UPDATE);
                            CalendarPlugin.setProcessingEvent(calendarDiv, false, eventEditForm);
                        },
                        function(responseEntity) {
                            CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("unselect");
                            CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_EVENT_UPDATE);
                            if (responseEntity.success) {
                                Confluence.TeamCalendars.setFieldErrors(fieldsDiv, null);

                                var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, responseEntity.subCalendar.id);
                                if (!subCalendar) {
                                    // New event type
                                    var parentSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, responseEntity.subCalendar.parentId);

                                    subCalendar = responseEntity.subCalendar;

                                    //update list custom for change event type to other subcalendar
                                    if(subCalendar.type === "custom" || subCalendar.subscriptionType === "custom") {
                                        var rsCustomEventType = subCalendar.customEventTypes;
                                        var parentCustomEventType = parentSubCalendar.customEventTypes;
                                        if(rsCustomEventType && rsCustomEventType.length) {
                                            if(parentCustomEventType && parentCustomEventType.length) {
                                                var isExistCustomEventType = false;
                                                for(var i = 0; i < parentCustomEventType.length; i++) {
                                                    if(parentCustomEventType[i].customEventTypeId === rsCustomEventType[0].customEventTypeId) {
                                                        isExistCustomEventType = true;
                                                        break;
                                                    }
                                                }

                                                if(!isExistCustomEventType) {
                                                    parentCustomEventType.push(rsCustomEventType[0]);
                                                }
                                            } else {
                                                parentSubCalendar.customEventTypes.push(rsCustomEventType[0]);
                                            }
                                        }
                                    }

                                    parentSubCalendar.childSubCalendars = $.merge([ subCalendar ], parentSubCalendar.childSubCalendars || []);
                                    CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                                    CalendarPlugin.addSubCalendarEventSource(calendarDiv, subCalendar.id);
                                    if(originalEventSubCalendarId && responseEntity.subCalendar && (responseEntity.subCalendar.parentId !== originalSubCalendarId || subCalendar.id !== originalEventSubCalendarId)) {
                                        CalendarPlugin.reloadSubCalendar(calendarDiv, originalEventSubCalendarId);
                                    }
                                } else {
                                    // Existing event type
                                    var listSubcalendarId = [subCalendar.id];
                                    if(originalEventSubCalendarId && (subCalendar.id !== originalEventSubCalendarId || responseEntity.subCalendar.parentId !== originalSubCalendarId )) {
                                        listSubcalendarId.push(originalEventSubCalendarId);
                                    }
                                    CalendarPlugin.reloadSubCalendar(calendarDiv, listSubcalendarId);
                                }

                                dialog.remove();

                            } else {
                                Confluence.TeamCalendars.setFieldErrors(fieldsDiv, responseEntity.fieldErrors);
                            }
                            CalendarPlugin.setProcessingEvent(calendarDiv, false, eventEditForm);
                       });
                    return false;
                }

                //Helper function to add and populate the calendar field.
                function addCalendarField(dialogPanel, event) {
                    var updatableSubCalendars = CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv);
                    updatableSubCalendars.sort(function(leftSubCalendar, rightSubCalendar) {
                        var leftSubCalendarName = leftSubCalendar.name.toLowerCase(), rightSubCalendarName = rightSubCalendar.name.toLowerCase();
                        return leftSubCalendarName.localeCompare(rightSubCalendarName);
                    });

                    var calendarSelect = eventEditDialog.getSelect(dialogPanel, "calendar");
                    $.each(updatableSubCalendars, function(_subCalendarIdx, _aSubCalendar) {
                        calendarSelect.append($("<option/>", { "value" :_aSubCalendar.id, "text" : _aSubCalendar.name}));
                    });

                    if ($.fn.auiSelect2) {
                        console.log("Enable select2 for calendar selection");
                        calendarSelect.auiSelect2({
                            minimumResultsForSearch: -1
                        });
                    }

                    //hidden the calendar field if just subscribed to one calendar.
                    if (updatableSubCalendars.length === 1) {
                        calendarSelect.parent().hide();
                    }

                    var setSelectedCalendar = function (subCalendarId){
                        // don't select the subCalendarId if it's not one of the subscribed calendars, it won't exist in the selector
                        if (calendarSelect.find("option[value='" + subCalendarId + "']").length > 0) {
                            console.log("Enable select2 for calendar selection " + subCalendarId);
                            if ($.fn.auiSelect2) {
                                calendarSelect.auiSelect2('val', subCalendarId);
                            } else {
                                calendarSelect.val(subCalendarId);
                            }
                        }
                    }

                    if (event.subCalendarId) {
                        var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId);
                        if (subCalendar) {
                            var subCalendarId = subCalendar.parentId || event.subCalendarId;
                            setSelectedCalendar(subCalendarId);
                        }
                    } else {
                        //set default for calendar from cookie
                        var calendarSelectedId = localStorage.getItem("last-selected-calendar");
                        if(calendarSelectedId) {
                            console.log("Enable select2 for last calendar selection " + calendarSelectedId);
                            setSelectedCalendar(calendarSelectedId)
                        }
                    }

                    if (event !== undefined && (CalUtil.isJiraEvent(event) || CalUtil.isJiraEventStream(event.eventType))) {
                        FormStateControl.disableElement(calendarSelect);
                    }

                    //change calendar option
                    calendarSelect.change( function() {
                        var originalValueSubCalendarId = eventEditDialog.getField(dialogPanel, "originalSubCalendarId").val();
                        var originalValueEventType = eventEditDialog.getField(dialogPanel, "originalEventType").val();
                        if (updatableSubCalendars.length > 1  && originalValueSubCalendarId !== "" && originalValueEventType !== "") {
                            var optionSelected = $(this).find("option:selected");
                            var typeValue = eventEditDialog.getSelect(dialogPanel, "event-type").val();
                            if(originalValueSubCalendarId === optionSelected.val() && typeValue === originalValueEventType) {
                                FormStateControl.enableElement($("#editthisinstanceonly"));
                            } else {
                                FormStateControl.disableElement($("#editthisinstanceonly"));
                            }
                        }
                        addEventTypeField(dialogPanel, true);
                    });
                }

                function formatEventType(type) {
                    var classIcon = CalUtil.isCustomEventType(type.id) ? type.css : type.id;
                    var iconTemplate = Confluence.TeamCalendars.Templates.renderCustomImagePrinting({eventType: classIcon});
                    var eventTypeItem = $("<div/>", {"class": "tc-event-type-item", "title": type.text})
                        .append(iconTemplate)
                        .append($("<span/>", { "class":"ellipsis_text", "text": type.text }));
                    return $("<div/>").append(eventTypeItem).html();
                }

                function getListDisableEvent(calendarId) {
                    var listCalendarObject = CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv);
                    for (var item in listCalendarObject) {
                       if(listCalendarObject[item].id === calendarId) {
                           return listCalendarObject[item].disableEventTypes;
                       }
                    }
                }

                function getListCustomEventType(calendarId) {
                     var listCalendarObject = CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv);
                     for (var item in listCalendarObject) {
                        if(listCalendarObject[item].id === calendarId) {
                            return listCalendarObject[item].customEventTypes;
                        }
                     }
                }

                function getOriginalCustomEventType(originalValueSubCalendarId, customEventTypeId) {
                    var originalCustomEventType;
                    if(!customEventTypeId) {
                        return originalCustomEventType;
                    }

                    var listOriginalCustomEventType = getListCustomEventType(originalValueSubCalendarId);
                    if(listOriginalCustomEventType && listOriginalCustomEventType.length) {
                        for(var i =0; i<listOriginalCustomEventType.length; i++) {
                            if(listOriginalCustomEventType[i].customEventTypeId === customEventTypeId) {
                                originalCustomEventType = listOriginalCustomEventType[i];
                                break;
                            }
                        }
                    }
                    return originalCustomEventType;
                }

                function sortCustomEventType(listCustomEventTypes) {
                    listCustomEventTypes.sort(function(eventA, eventB) {
                       return eventA.title.toUpperCase().localeCompare(eventB.title.toUpperCase());
                    });

                    return listCustomEventTypes;
                }

                //Helper function to add and populate the event type field.
                function addEventTypeField(dialogPanel, isChangSubcalendar) {
                    var typeSelect = eventEditDialog.getSelect(dialogPanel, "event-type");

                    if(isChangSubcalendar) {
                        typeSelect.empty();
                    }

                    var originalValueEventType = eventEditDialog.getField(dialogPanel, "originalEventType").val();
                    var originalValueSubCalendarId = eventEditDialog.getField(dialogPanel, "originalSubCalendarId").val();
                    var calendarIdSelected = eventEditDialog.getSelect(dialogPanel, "calendar").find("option:selected").val();
                    var listDisableEvent = getListDisableEvent(calendarIdSelected);
                    var listCustomEventType = sortCustomEventType(getListCustomEventType(calendarIdSelected)); //sort list custom event type

                    var originalCustomEventType = getOriginalCustomEventType(originalValueSubCalendarId, event.customEventTypeId);

                    var isDisableEvent = function(eventType) {
                        for (var item in listDisableEvent) {
                            if (eventType === listDisableEvent[item])
                            {
                                return true;
                            }
                        }
                        return false;
                    };

                    //load event type when edit
                    if(event.id) {
                        $.each(
                            eventTypes,
                            function(i, type) {
                                if ((originalValueEventType === type.id || !isDisableEvent(type.id) && (CalUtil.isJiraEvent(event) || type.hiddenFromEventCreation === undefined))) {
                                    typeSelect.append($("<option/>", { "value" : type.id, "text" : type.name } ));
                                }
                            }
                        );

                        $.each(
                            listCustomEventType,
                            function(i, item){
                                if(!isDisableEvent(item.customEventTypeId)) {
                                    typeSelect.append($("<option/>", { "value": item.customEventTypeId, "class" : item.icon, "data-custom-id": item.customEventTypeId, "text" : item.title}));
                                }
                            }
                        );

                        //load custom event type
                        if(isChangSubcalendar && originalCustomEventType) {
                            var existCustomEventType = false;
                            for(var i = 0; i < listCustomEventType.length; i++) {
                                if(listCustomEventType[i].title === originalCustomEventType.title) {
                                    existCustomEventType = true;
                                    break;
                                }
                            }
                            if(!existCustomEventType) {
                                typeSelect.append($("<option/>", { "value": originalCustomEventType.customEventTypeId, "class" : originalCustomEventType.icon, "data-custom-id": originalCustomEventType.customEventTypeId, "text" : originalCustomEventType.title}));
                            }
                        }
                    } else {//load event type when create new event
                        //load list event type exclude jira type
                        $.each(
                            eventTypes,
                            function(i, type) {
                                if (!isDisableEvent(type.id) && (CalUtil.isJiraEvent(event) || type.hiddenFromEventCreation === undefined)) {
                                    typeSelect.append($("<option/>", { "value" : type.id, "text" : type.name } ));
                                }
                            }
                        );

                        //load custom event type
                        $.each(
                            listCustomEventType,
                            function(i, item){
                                if(!isDisableEvent(item.customEventTypeId)) {
                                    typeSelect.append($("<option/>", { "value": item.customEventTypeId, "class" : item.icon, "data-custom-id": item.customEventTypeId, "text" : item.title}));
                                }
                            }
                        );

                        //load list event jira type
                        $.each(
                            eventTypes,
                            function(i, type) {
                                if (type.hiddenFromEventCreation !== undefined && type.hiddenFromEventCreation === false && !isDisableEvent(type.id) ) {
                                    typeSelect.append($("<option/>", { "value" : type.id, "text" : type.name } ));
                                }
                            }
                        );

                        //Disable OK button if don't have event type is enable
                        if (typeSelect.children().length > 0) {
                            $(".field-group-event-type .type-error", dialogPanel).empty();
                            $("#event-fields-container", dialogPanel).show();
                            eventEditDialog.enableOkButton();
                        } else {
                            typeSelect.append($("<option/>", { "value" : "", "text" : "" } )); //Hack for case all event type is disabled.
                            $(".field-group-event-type .type-error", dialogPanel).append($("<span/>", {"text": "\u6240\u6709\u7684\u4e8b\u4ef6\u5df2\u88ab\u7981\u7528\uff0c\u8bf7\u5411\u65e5\u7a0b\u4e2d\u6dfb\u52a0\u65b0\u7684\u4e8b\u4ef6\u7c7b\u578b\u3002"}));
                            $("#event-fields-container", dialogPanel).hide();
                            eventEditForm.disableOkButton({
                                "buttonText" : "\u786e\u5b9a"
                            });
                        }

                        //add link custom event type
                        typeSelect.append($("<option/>", { "value": "addNewCustomEventType", "class" : "addNewCustomEventType", "text" :  "\u6dfb\u52a0\u65b0\u4e8b\u4ef6\u7c7b\u578b"}));
                    }

                    if(AJS.$.fn.auiSelect2){
                        $('.event-edit #event-type').auiSelect2({
                            formatSelection: formatEventType,
                            formatResult: formatEventType,
                            minimumResultsForSearch: -1
                        });

                        if(event.id && CalUtil.isJiraEvent(event)) {
                            //support new method disable auislect2 from confluence 5.3
                            if(AJS.Meta.get("build-number") >= 4520) {
                                $('#event-type').auiSelect2("enable", false);
                            } else {
                                $('#event-type').auiSelect2("disable");
                            }
                        }
                    }

                    if(event.eventType && event.eventType === "custom") {
                        typeSelect.change(handleEventTypeChange).val(event.customEventTypeId).trigger("change");
                    } else {
                        typeSelect.change(handleEventTypeChange).val(event.eventType || localStorage.getItem("last-selected-calendar-type") || "other").trigger("change");
                    }
                }

                //Set hidden fields that are always present on the dialog.
                function setHiddenFields() {
                    eventEditDialog.getField(dialogPanel, "uid").val(event.id || "");
                    eventEditDialog.getField(dialogPanel, "originalStartDate").val(event.originalStart || "");
                    eventEditDialog.getField(dialogPanel, "originalSubCalendarId").val(event.subCalendarId || "");
                    eventEditDialog.getField(dialogPanel, "originalEventType").val(event.eventType || "");
                    eventEditDialog.getField(dialogPanel, "originalCustomEventTypeId").val(event.customEventTypeId || "");
                    eventEditDialog.getField(dialogPanel, "childSubCalendarId").val(event.childSubCalendarId || "");
                }

                //Handle event type change
                function handleEventTypeChange(event) {
                    if(!dialog) {
                        return;
                    }
                    var type = event.target.value;

                    if(type === "addNewCustomEventType") {
                        var subCalendarId = $("option:selected", eventEditDialog.getSelect(dialogPanel, "calendar")).val();
                        dialog.remove();
                        var subCalendarSelectObject = CalendarPlugin.getSubCalendar(calendarDiv, subCalendarId);
                        var subCalendarEditDialog = CalendarPlugin.showCustomEventEditForm(calendarDiv, subCalendarSelectObject);
                        return;
                    }

                    changeEventType(type);
                    //check event != jira and set attribute for select element
                    if (!CalUtil.isJiraEventStream(type)) {
                        eventEditDialog.getSelect(dialogPanel, "event-type").data("previous", type);
                    }

                    calculateDialogHeight();
                }

                function calculateDialogHeight() {
                    if (dialog) {
                        dialog.getCurrentPanel().body.css({height:"auto"});
                        $("#" + dialog.id).css({height:"auto"});
                    }
                }

                //Called when the event type changes.
                function changeEventType(type) {
                    if(!type) {
                        return;
                    }

                    var fields = CalUtil.isCustomEventType(type) ? EventTypes.CustomEventType.fields : eventTypes[type].fields,
                        fieldHandlers = [],
                        fieldsContainer = $('#event-fields-container'),
                        eventTypeIsJira = CalUtil.isJiraEventStream(type),
                        fieldsDiv = eventTypeIsJira ? $('#' + type + '-event-fields', fieldsContainer) : $('#tc-event-fields', fieldsContainer),
                        eventTypeName = eventEditDialog.getSelect(dialogPanel, "event-type").val(),
                        previousType = eventEditDialog.getSelect(dialogPanel, "event-type").data("previous"),
                        previousValueSummaryHolder,
                        originalEventType = eventEditDialog.getField(dialogPanel, "originalEventType").val();

                    if (event && CalUtil.isJiraEventStream(event.eventType)) {
                        // An existing event. Disable event type changing.
                        // TODO: Discuss feasibility for the ability to change existing event's type.
                        eventEditDialog.getSelect(dialogPanel, "event-type").attr("disabled", "disabled");
                    }

                    if(!eventTypeIsJira && previousType) {// get field value previous value of summary or what
                        var previousFields = CalUtil.isCustomEventType(previousType) ? EventTypes.CustomEventType.fields : eventTypes[previousType].fields;
                        $.each(
                            $.grep(
                                previousFields,
                                function(aField) {
                                    return aField.type === "text" && aField.copyto;
                                }
                            ),
                            function(id, fieldSelected) {
                                previousValueSummaryHolder = eventEditDialog.getField(fieldsDiv, fieldSelected.id).val();
                            }
                        );
                    }

                    //Hide the current fieldsDiv.
                    $(".event-fields", fieldsContainer).each(function() {
                        $(this).find(".error").empty();
                        $(this).hide();
                    });

                    //enable fieldsDiv for event type is JIRA
                    if (fieldsDiv.length && eventTypeIsJira ) {
                        fieldsDiv.show();
                        fieldHandlers = fieldHandlersForType[type];
                    } else {
                        //disable all field event have fieldsDiv is div#tc-event-fields
                        if (fieldsDiv.length) {
                            fieldsDiv.show();
                            $("#tc-event-fields >div").hide();
                        } else {
                            //create new fieldsDiv for event type
                            if (eventTypeIsJira) {
                                fieldsDiv = $("<div/>", {
                                    "id" : type + "-event-fields",
                                    "class" : "event-fields"
                                });
                            } else {
                                fieldsDiv = $("<div/>", {
                                    "id" : "tc-event-fields",
                                    "class" : "event-fields"
                                });
                            }
                            fieldsContainer.append(fieldsDiv);
                        }

                        //For each field in event type add field to panel
                        $.each(fields, function(i, field) {
                            if (eventTypeIsJira) {
                                fieldHandlers[i] = eventFieldHandlers[field.type](field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog);
                                fieldHandlers[i].add();
                                fieldHandlers[i].init();
                            } else {
                                fieldHandlers[i] = eventFieldHandlers.getEventField(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog, previousValueSummaryHolder);
                            }
                        });
                        fieldHandlersForType[type] = fieldHandlers;
                    }

                    var getOkButtonState = function() {
                        return okButtonStates[eventTypeName] !== false;
                    };

                    if (getOkButtonState())
                        eventEditForm.enableOkButton();
                    else
                        eventEditForm.disableOkButton({
                            "buttonText" : "\u786e\u5b9a"
                        });

                    //attach new onSubmit handler for current fieldsDiv
                    eventEditForm.unbind("submit").submit(function() {
                        submitForm(fieldsDiv, fieldHandlers);
                        return false;
                    });

                    //Disable/enable this instance only field
                    if (originalEventType !== undefined && originalEventType !== "") {
                        var originalValueSubCalendarId = eventEditDialog.getField(dialogPanel, "originalSubCalendarId").val();
                        var calendarValSelect = eventEditDialog.getSelect(dialogPanel, "calendar").val();
                        if(originalEventType === type && calendarValSelect === originalValueSubCalendarId) {
                            FormStateControl.enableElement($("#editthisinstanceonly"));
                        } else {
                            FormStateControl.disableElement($("#editthisinstanceonly"));
                        }
                    }

                    //click to link setting reminder in add event
                    $(fieldsDiv)
                        .off("click.calendar-reminder-setting")
                        .on("click.calendar-reminder-setting", "#calendar-reminder-setting", function() {
                            var calendarValSelect = eventEditDialog.getSelect(dialogPanel, "calendar").val();
                            dialog.hide();
                            var subCalendarSelectObject = CalendarPlugin.getSubCalendar(calendarDiv, calendarValSelect);
                            CalendarPlugin.showCustomEventEditForm(calendarDiv, subCalendarSelectObject, eventTypeName);
                            return;
                        });
                }

                AJS.unbind("show-dialog-edit-event.teamcalendar").bind("show-dialog-edit-event.teamcalendar", function(event) {
                    var eventContainer = CalUtil.isJiraEventStream(eventEditDialog.getSelectedEventType()) ? "#" + eventEditDialog.getSelectedEventType() + "-event-fields" : "#tc-event-fields";
                    var fieldReminder = $("#field-text-reminder .bodyInforReminderLabel", $(eventContainer, dialogPanel));
                    var eventTypeReminder = CalendarPlugin.getCurrentReminderForEventType(calendarDiv, eventEditDialog);
                    var hasReminderPeriod = eventTypeReminder && eventTypeReminder.periodInMins > 0;
                    //update field reminder when edit/create
                    $(fieldReminder).empty().append(
                        Confluence.TeamCalendars.Templates.Fields.bodyInforReminderLabel({
                            "reminderPeriodText" : hasReminderPeriod ? AJS.format("{0}\u524d", CalUtil.showInforReminder(eventTypeReminder.periodInMins)) : "\u65e0\u3002",
                            "reminderPeriod": hasReminderPeriod ? eventTypeReminder.periodInMins : 0
                        })
                    );
                    dialog.show();
                });

                AJS.unbind("remove-dialog-edit-event.teamcalendar").bind("remove-dialog-edit-event.teamcalendar", function(event) {
                    if(dialog) {
                        dialog.remove();
                    }
                });

                AJS.bind("remove.dialog", function(e, data) {
                    if (data.dialog.id == "edit-event-dialog") {
                        dialog = null;
                    }
                });

                submit = function() {
                    eventEditForm.submit();
                    AJS.unbind("show-dialog-edit-event.teamcalendar");
                    return false
                };

                cancel = function() {
                    dialog.remove();
                    AJS.unbind("show-dialog-edit-event.teamcalendar");
                    return false;
                };

                dialog = new AJS.ConfluenceDialog({
                    "id": "edit-event-dialog",
                    "width": width,
                    "height": height,
                    "onSubmit" : submit,
                    "onCancel": cancel
                });

                dialog.addHeader(event.title || "\u521b\u5efa\u4e8b\u5b9c");
                dialog.addButton("\u786e\u5b9a", submit, "submit");
                dialog.addLink("\u53d6\u6d88", cancel);

                okButton = dialog.popup.element.find(".submit");

                dialog.addPanel(
                    "",
                    Confluence.TeamCalendars.Templates.eventEdit(),
                    "calendar-dialog-panel");


                dialogPanel = dialog.getCurrentPanel().body;

                var setOkButtonState = function(enabled) {
                    okButtonStates[eventEditDialog.getSelect(dialogPanel, "event-type").val()] = enabled;
                };

                var addEventAnalytics = function (propeties) {
                    var context = "myCalendars";

                    if (AJS.Meta.get("space-key")) {
                        if (AJS.Meta.get("content-id")) {
                            context = "embedded";
                        } else {
                            if(CalUtil.isSingleCalendarView(_calendarDiv)){
                                context = "singleCalendar";
                            } else {
                                context = "spaceCalendars";
                            }
                        }
                    }

                    Confluence.TeamCalendars.fireEventForAnalytics("add.event." + context, propeties);
                };

                eventEditForm = $("form[name='event-edit']", dialogPanel);
                eventEditForm.disableOkButton = function(options) {
                    var mergedOptions = $.extend({
                        "buttonText" : "\u6b63\u5728\u6dfb\u52a0..."
                    }, options);

                    okButton.text(mergedOptions.buttonText)
                        .attr("disabled", "disabled")
                        .addClass("ui-state-disabled");

                    setOkButtonState(false);
                };

                eventEditForm.enableOkButton = function(options) {
                    var mergedOptions = $.extend({
                        "buttonText" : "\u786e\u5b9a"
                    }, options);

                    okButton.removeAttr("disabled")
                        .removeClass("ui-state-disabled")
                        .text(mergedOptions.buttonText);

                    setOkButtonState(true);
                };

                //Add calendar field
                addCalendarField(dialogPanel, event);

                dialog.disableOkButton = eventEditForm.disableOkButton;
                dialog.enableOkButton = eventEditForm.enableOkButton;

                //Add event type field
                addEventTypeField(dialogPanel);

                setHiddenFields();

                return dialog;
            },

            disableOkButton : function(options) {
                dialog.disableOkButton(options);
            },
            enableOkButton : function(options) {
                dialog.enableOkButton(options);
            },

            getSelectedEventType : function() {
                return this.getSelect(dialog.popup.element, "event-type").val();
            },

            getSelectedSubCalendarId: function() {
                return this.getSelect(dialog.popup.element, "calendar").val();
            },

            getTextSelectedEventType: function() {
                return this.getTextSelect(dialog.popup.element, "event-type");
            },

            getTextSelectedSubCalendar: function() {
                return this.getTextSelect(dialog.popup.element, "calendar");
            }

        });

        return EventEditDialog;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/lib/rrule.js' */
/*!
 * rrule.js - Library for working with recurrence rules for calendar dates.
 * https://github.com/jakubroztocil/rrule
 *
 * Copyright 2010, Jakub Roztocil and Lars Schoning
 * Licenced under the BSD licence.
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 * Based on:
 * python-dateutil - Extensions to the standard Python datetime module.
 * Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
 * Copyright (c) 2012 - Tomi Pievilinen <tomi.pievilainen@iki.fi>
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 */
/* global module, define */

;(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = factory()
    } else if (typeof define === 'function' && define.amd) {
        define([], factory)
    } else {
        root.RRule = factory(root)
        root.RRuleSet = root.RRule.RRuleSet
        root.rrulestr = root.RRule.rrulestr
    }
}(typeof window === 'object' ? window : this, function (root) {
    // =============================================================================
    // Date utilities
    // =============================================================================

    /**
     * General date-related utilities.
     * Also handles several incompatibilities between JavaScript and Python
     *
     */
    var dateutil = {
        MONTH_DAYS: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],

        /**
         * Number of milliseconds of one day
         */
        ONE_DAY: 1000 * 60 * 60 * 24,

        /**
         * @see: <http://docs.python.org/library/datetime.html#datetime.MAXYEAR>
         */
        MAXYEAR: 9999,

        /**
         * Python uses 1-Jan-1 as the base for calculating ordinals but we don't
         * want to confuse the JS engine with milliseconds > Number.MAX_NUMBER,
         * therefore we use 1-Jan-1970 instead
         */
        ORDINAL_BASE: new Date(1970, 0, 1),

        /**
         * Python: MO-SU: 0 - 6
         * JS: SU-SAT 0 - 6
         */
        PY_WEEKDAYS: [6, 0, 1, 2, 3, 4, 5],

        /**
         * py_date.timetuple()[7]
         */
        getYearDay: function (date) {
            var dateNoTime = new Date(
                date.getFullYear(), date.getMonth(), date.getDate())
            return Math.ceil(
                (dateNoTime - new Date(date.getFullYear(), 0, 1)) / dateutil.ONE_DAY) + 1
        },

        isLeapYear: function (year) {
            if (year instanceof Date) year = year.getFullYear()
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)
        },

        /**
         * @return {Number} the date's timezone offset in ms
         */
        tzOffset: function (date) {
            return date.getTimezoneOffset() * 60 * 1000
        },

        /**
         * @see: <http://www.mcfedries.com/JavaScript/DaysBetween.asp>
         */
        daysBetween: function (date1, date2) {
            // The number of milliseconds in one day
            // Convert both dates to milliseconds
            var date1_ms = date1.getTime() - dateutil.tzOffset(date1)
            var date2_ms = date2.getTime() - dateutil.tzOffset(date2)
            // Calculate the difference in milliseconds
            var difference_ms = Math.abs(date1_ms - date2_ms)
            // Convert back to days and return
            return Math.round(difference_ms / dateutil.ONE_DAY)
        },

        /**
         * @see: <http://docs.python.org/library/datetime.html#datetime.date.toordinal>
         */
        toOrdinal: function (date) {
            return dateutil.daysBetween(date, dateutil.ORDINAL_BASE)
        },

        /**
         * @see - <http://docs.python.org/library/datetime.html#datetime.date.fromordinal>
         */
        fromOrdinal: function (ordinal) {
            var millisecsFromBase = ordinal * dateutil.ONE_DAY
            return new Date(dateutil.ORDINAL_BASE.getTime() -
                dateutil.tzOffset(dateutil.ORDINAL_BASE) +
                millisecsFromBase +
                dateutil.tzOffset(new Date(millisecsFromBase)))
        },

        /**
         * @see: <http://docs.python.org/library/calendar.html#calendar.monthrange>
         */
        monthRange: function (year, month) {
            var date = new Date(year, month, 1)
            return [dateutil.getWeekday(date), dateutil.getMonthDays(date)]
        },

        getMonthDays: function (date) {
            var month = date.getMonth()
            return month === 1 && dateutil.isLeapYear(date)
                ? 29 : dateutil.MONTH_DAYS[month]
        },

        /**
         * @return {Number} python-like weekday
         */
        getWeekday: function (date) {
            return dateutil.PY_WEEKDAYS[date.getDay()]
        },

        /**
         * @see: <http://docs.python.org/library/datetime.html#datetime.datetime.combine>
         */
        combine: function (date, time) {
            time = time || date
            return new Date(
                date.getFullYear(), date.getMonth(), date.getDate(),
                time.getHours(), time.getMinutes(), time.getSeconds(),
                time.getMilliseconds())
        },

        clone: function (date) {
            var dolly = new Date(date.getTime())
            return dolly
        },

        cloneDates: function (dates) {
            var clones = []
            for (var i = 0; i < dates.length; i++) {
                clones.push(dateutil.clone(dates[i]))
            }
            return clones
        },

        /**
         * Sorts an array of Date or dateutil.Time objects
         */
        sort: function (dates) {
            dates.sort(function (a, b) {
                return a.getTime() - b.getTime()
            })
        },

        timeToUntilString: function (time) {
            var comp
            var date = new Date(time)
            var comps = [
                date.getUTCFullYear(),
                date.getUTCMonth() + 1,
                date.getUTCDate(),
                'T',
                date.getUTCHours(),
                date.getUTCMinutes(),
                date.getUTCSeconds(),
                'Z'
            ]

            for (var i = 0; i < comps.length; i++) {
                comp = comps[i]
                if (!/[TZ]/.test(comp) && comp < 10) comps[i] = '0' + String(comp)
            }
            return comps.join('')
        },

        untilStringToDate: function (until) {
            var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/
            var bits = re.exec(until)
            if (!bits) throw new Error('Invalid UNTIL value: ' + until)
            return new Date(Date.UTC(
                bits[1],
                bits[2] - 1,
                bits[3],
                bits[5] || 0,
                bits[6] || 0,
                bits[7] || 0))
        }
    }

    dateutil.Time = function (hour, minute, second, millisecond) {
        this.hour = hour
        this.minute = minute
        this.second = second
        this.millisecond = millisecond || 0
    }

    dateutil.Time.prototype = {
        constructor: dateutil.Time,
        getHours: function () {
            return this.hour
        },
        getMinutes: function () {
            return this.minute
        },
        getSeconds: function () {
            return this.second
        },
        getMilliseconds: function () {
            return this.millisecond
        },
        getTime: function () {
            return ((this.hour * 60 * 60) + (this.minute * 60) + this.second) * 1000 +
                this.millisecond
        }
    }

    // =============================================================================
    // Helper functions
    // =============================================================================

    /**
     * Simplified version of python's range()
     */
    var range = function (start, end) {
        if (arguments.length === 1) {
            end = start
            start = 0
        }
        var rang = []
        for (var i = start; i < end; i++) rang.push(i)
        return rang
    }

    var repeat = function (value, times) {
        var i = 0
        var array = []

        if (value instanceof Array) {
            for (; i < times; i++) array[i] = [].concat(value)
        } else {
            for (; i < times; i++) array[i] = value
        }
        return array
    }

    /**
     * Python like split
     */
    var split = function (str, sep, num) {
        var splits = str.split(sep)
        return num
            ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits
    }

    /**
     * closure/goog/math/math.js:modulo
     * Copyright 2006 The Closure Library Authors.
     * The % operator in JavaScript returns the remainder of a / b, but differs from
     * some other languages in that the result will have the same sign as the
     * dividend. For example, -1 % 8 == -1, whereas in some other languages
     * (such as Python) the result would be 7. This function emulates the more
     * correct modulo behavior, which is useful for certain applications such as
     * calculating an offset index in a circular list.
     *
     * @param {number} a The dividend.
     * @param {number} b The divisor.
     * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
     *     or b < x <= 0, depending on the sign of b).
     */
    var pymod = function (a, b) {
        var r = a % b
        // If r and b differ in sign, add b to wrap the result to the correct sign.
        return (r * b < 0) ? r + b : r
    }

    /**
     * @see: <http://docs.python.org/library/functions.html#divmod>
     */
    var divmod = function (a, b) {
        return {div: Math.floor(a / b), mod: pymod(a, b)}
    }

    /**
     * Python-like boolean
     * @return {Boolean} value of an object/primitive, taking into account
     * the fact that in Python an empty list's/tuple's
     * boolean value is False, whereas in JS it's true
     */
    var plb = function (obj) {
        return (obj instanceof Array && obj.length === 0)
            ? false : Boolean(obj)
    }

    /**
     * Return true if a value is in an array
     */
    var contains = function (arr, val) {
        return arr.indexOf(val) !== -1
    }

    // =============================================================================
    // Date masks
    // =============================================================================

    // Every mask is 7 days longer to handle cross-year weekly periods.

    var M365MASK = [].concat(
        repeat(1, 31), repeat(2, 28), repeat(3, 31),
        repeat(4, 30), repeat(5, 31), repeat(6, 30),
        repeat(7, 31), repeat(8, 31), repeat(9, 30),
        repeat(10, 31), repeat(11, 30), repeat(12, 31),
        repeat(1, 7))

    var M366MASK = [].concat(
        repeat(1, 31), repeat(2, 29), repeat(3, 31),
        repeat(4, 30), repeat(5, 31), repeat(6, 30),
        repeat(7, 31), repeat(8, 31), repeat(9, 30),
        repeat(10, 31), repeat(11, 30), repeat(12, 31),
        repeat(1, 7))

    var M28 = range(1, 29)
    var M29 = range(1, 30)
    var M30 = range(1, 31)
    var M31 = range(1, 32)

    var MDAY366MASK = [].concat(
        M31, M29, M31,
        M30, M31, M30,
        M31, M31, M30,
        M31, M30, M31,
        M31.slice(0, 7))

    var MDAY365MASK = [].concat(
        M31, M28, M31,
        M30, M31, M30,
        M31, M31, M30,
        M31, M30, M31,
        M31.slice(0, 7))

    M28 = range(-28, 0)
    M29 = range(-29, 0)
    M30 = range(-30, 0)
    M31 = range(-31, 0)

    var NMDAY366MASK = [].concat(
        M31, M29, M31,
        M30, M31, M30,
        M31, M31, M30,
        M31, M30, M31,
        M31.slice(0, 7))

    var NMDAY365MASK = [].concat(
        M31, M28, M31,
        M30, M31, M30,
        M31, M31, M30,
        M31, M30, M31,
        M31.slice(0, 7))

    var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
    var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]

    var WDAYMASK = (function () {
        for (var wdaymask = [], i = 0; i < 55; i++) wdaymask = wdaymask.concat(range(7))
        return wdaymask
    }())

    // =============================================================================
    // Weekday
    // =============================================================================

    var Weekday = function (weekday, n) {
        if (n === 0) throw new Error("Can't create weekday with n == 0")
        this.weekday = weekday
        this.n = n
    }

    Weekday.prototype = {
        constructor: Weekday,
        // __call__ - Cannot call the object directly, do it through
        // e.g. RRule.TH.nth(-1) instead,
        nth: function (n) {
            return this.n === n ? this : new Weekday(this.weekday, n)
        },

        // __eq__
        equals: function (other) {
            return this.weekday === other.weekday && this.n === other.n
        },

        // __repr__
        toString: function () {
            var s = ['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU'][this.weekday]
            if (this.n) s = (this.n > 0 ? '+' : '') + String(this.n) + s
            return s
        },

        getJsWeekday: function () {
            return this.weekday === 6 ? 0 : this.weekday + 1
        }

    }

    // =============================================================================
    // RRule
    // =============================================================================

    /**
     *
     * @param {Object?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>
     *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...
     * @constructor
     */
    var RRule = function (options, noCache) {
        options = options || {}
        // RFC string
        this._string = null
        this._cache = noCache ? null : {
            all: false,
            before: [],
            after: [],
            between: []
        }

        // used by toString()
        this.origOptions = {}

        var invalid = []
        var keys = Object.keys(options)
        var defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS)

        // Shallow copy for origOptions and check for invalid
        keys.forEach(function (key) {
            this.origOptions[key] = options[key]
            if (!contains(defaultKeys, key)) invalid.push(key)
        }, this)

        if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))

        if (!RRule.FREQUENCIES[options.freq] && options.byeaster === null) {
            throw new Error('Invalid frequency: ' + String(options.freq))
        }

        // Merge in default options
        defaultKeys.forEach(function (key) {
            if (!contains(keys, key)) options[key] = RRule.DEFAULT_OPTIONS[key]
        })

        var opts = this.options = options

        if (opts.byeaster !== null) opts.freq = RRule.YEARLY
        if (!opts.dtstart) opts.dtstart = new Date()

        var millisecondModulo = opts.dtstart.getTime() % 1000
        if (opts.wkst === null) {
            opts.wkst = RRule.MO.weekday
        } else if (typeof opts.wkst === 'number') {
            // cool, just keep it like that
        } else {
            opts.wkst = opts.wkst.weekday
        }

        if (opts.bysetpos !== null) {
            if (typeof opts.bysetpos === 'number') opts.bysetpos = [opts.bysetpos]

            for (var i = 0; i < opts.bysetpos.length; i++) {
                var v = opts.bysetpos[i]
                if (v === 0 || !(v >= -366 && v <= 366)) {
                    throw new Error('bysetpos must be between 1 and 366,' +
                        ' or between -366 and -1')
                }
            }
        }

        if (!(plb(opts.byweekno) || plb(opts.byyearday) || plb(opts.bymonthday) ||
                opts.byweekday !== null || opts.byeaster !== null)) {
            switch (opts.freq) {
                case RRule.YEARLY:
                    if (!opts.bymonth) opts.bymonth = opts.dtstart.getMonth() + 1
                    opts.bymonthday = opts.dtstart.getDate()
                    break
                case RRule.MONTHLY:
                    opts.bymonthday = opts.dtstart.getDate()
                    break
                case RRule.WEEKLY:
                    opts.byweekday = dateutil.getWeekday(opts.dtstart)
                    break
            }
        }

        // bymonth
        if (opts.bymonth !== null && !(opts.bymonth instanceof Array)) {
            opts.bymonth = [opts.bymonth]
        }
        // byyearday
        if (opts.byyearday !== null && !(opts.byyearday instanceof Array)) {
            opts.byyearday = [opts.byyearday]
        }

        // bymonthday
        if (opts.bymonthday === null) {
            opts.bymonthday = []
            opts.bynmonthday = []
        } else if (opts.bymonthday instanceof Array) {
            var bymonthday = []
            var bynmonthday = []

            for (i = 0; i < opts.bymonthday.length; i++) {
                v = opts.bymonthday[i]
                if (v > 0) {
                    bymonthday.push(v)
                } else if (v < 0) {
                    bynmonthday.push(v)
                }
            }
            opts.bymonthday = bymonthday
            opts.bynmonthday = bynmonthday
        } else {
            if (opts.bymonthday < 0) {
                opts.bynmonthday = [opts.bymonthday]
                opts.bymonthday = []
            } else {
                opts.bynmonthday = []
                opts.bymonthday = [opts.bymonthday]
            }
        }

        // byweekno
        if (opts.byweekno !== null && !(opts.byweekno instanceof Array)) {
            opts.byweekno = [opts.byweekno]
        }

        // byweekday / bynweekday
        if (opts.byweekday === null) {
            opts.bynweekday = null
        } else if (typeof opts.byweekday === 'number') {
            opts.byweekday = [opts.byweekday]
            opts.bynweekday = null
        } else if (opts.byweekday instanceof Weekday) {
            if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
                opts.byweekday = [opts.byweekday.weekday]
                opts.bynweekday = null
            } else {
                opts.bynweekday = [
                    [opts.byweekday.weekday, opts.byweekday.n]
                ]
                opts.byweekday = null
            }
        } else {
            var byweekday = []
            var bynweekday = []

            for (i = 0; i < opts.byweekday.length; i++) {
                var wday = opts.byweekday[i]

                if (typeof wday === 'number') {
                    byweekday.push(wday)
                } else if (!wday.n || opts.freq > RRule.MONTHLY) {
                    byweekday.push(wday.weekday)
                } else {
                    bynweekday.push([wday.weekday, wday.n])
                }
            }
            opts.byweekday = plb(byweekday) ? byweekday : null
            opts.bynweekday = plb(bynweekday) ? bynweekday : null
        }

        // byhour
        if (opts.byhour === null) {
            opts.byhour = (opts.freq < RRule.HOURLY) ? [opts.dtstart.getHours()] : null
        } else if (typeof opts.byhour === 'number') {
            opts.byhour = [opts.byhour]
        }

        // byminute
        if (opts.byminute === null) {
            opts.byminute = (opts.freq < RRule.MINUTELY)
                ? [opts.dtstart.getMinutes()] : null
        } else if (typeof opts.byminute === 'number') {
            opts.byminute = [opts.byminute]
        }

        // bysecond
        if (opts.bysecond === null) {
            opts.bysecond = (opts.freq < RRule.SECONDLY)
                ? [opts.dtstart.getSeconds()] : null
        } else if (typeof opts.bysecond === 'number') {
            opts.bysecond = [opts.bysecond]
        }

        if (opts.freq >= RRule.HOURLY) {
            this.timeset = null
        } else {
            this.timeset = []
            for (i = 0; i < opts.byhour.length; i++) {
                var hour = opts.byhour[i]
                for (var j = 0; j < opts.byminute.length; j++) {
                    var minute = opts.byminute[j]
                    for (var k = 0; k < opts.bysecond.length; k++) {
                        var second = opts.bysecond[k]
                        // python:
                        // datetime.time(hour, minute, second,
                        // tzinfo=self._tzinfo))
                        this.timeset.push(new dateutil.Time(hour, minute, second, millisecondModulo))
                    }
                }
            }
            dateutil.sort(this.timeset)
        }
    }

    // RRule class 'constants'

    RRule.FREQUENCIES = [
        'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',
        'HOURLY', 'MINUTELY', 'SECONDLY'
    ]

    RRule.YEARLY = 0
    RRule.MONTHLY = 1
    RRule.WEEKLY = 2
    RRule.DAILY = 3
    RRule.HOURLY = 4
    RRule.MINUTELY = 5
    RRule.SECONDLY = 6

    RRule.MO = new Weekday(0)
    RRule.TU = new Weekday(1)
    RRule.WE = new Weekday(2)
    RRule.TH = new Weekday(3)
    RRule.FR = new Weekday(4)
    RRule.SA = new Weekday(5)
    RRule.SU = new Weekday(6)

    RRule.DEFAULT_OPTIONS = {
        freq: null,
        dtstart: null,
        interval: 1,
        wkst: RRule.MO,
        count: null,
        until: null,
        bysetpos: null,
        bymonth: null,
        bymonthday: null,
        bynmonthday: null,
        byyearday: null,
        byweekno: null,
        byweekday: null,
        bynweekday: null,
        byhour: null,
        byminute: null,
        bysecond: null,
        byeaster: null
    }

    RRule.parseText = function (text, language) {
        return getnlp().parseText(text, language)
    }

    RRule.fromText = function (text, language) {
        return getnlp().fromText(text, language)
    }

    RRule.optionsToString = function (options) {
        var key, value, strValues
        var pairs = []
        var keys = Object.keys(options)
        var defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS)

        for (var i = 0; i < keys.length; i++) {
            if (!contains(defaultKeys, keys[i])) continue

            key = keys[i].toUpperCase()
            value = options[keys[i]]
            strValues = []

            if (value === null || value instanceof Array && !value.length) continue

            switch (key) {
                case 'FREQ':
                    value = RRule.FREQUENCIES[options.freq]
                    break
                case 'WKST':
                    value = value.toString()
                    break
                case 'BYWEEKDAY':
                    /*
                    NOTE: BYWEEKDAY is a special case.
                    RRule() deconstructs the rule.options.byweekday array
                    into an array of Weekday arguments.
                    On the other hand, rule.origOptions is an array of Weekdays.
                    We need to handle both cases here.
                    It might be worth change RRule to keep the Weekdays.

                    Also, BYWEEKDAY (used by RRule) vs. BYDAY (RFC)

                    */
                    key = 'BYDAY'
                    if (!(value instanceof Array)) value = [value]

                    for (var wday, j = 0; j < value.length; j++) {
                        wday = value[j]
                        if (wday instanceof Weekday) {
                            // good
                        } else if (wday instanceof Array) {
                            wday = new Weekday(wday[0], wday[1])
                        } else {
                            wday = new Weekday(wday)
                        }
                        strValues[j] = wday.toString()
                    }
                    value = strValues
                    break
                case 'DTSTART':
                case 'UNTIL':
                    value = dateutil.timeToUntilString(value)
                    break
                default:
                    if (value instanceof Array) {
                        for (j = 0; j < value.length; j++) strValues[j] = String(value[j])
                        value = strValues
                    } else {
                        value = String(value)
                    }

            }
            pairs.push([key, value])
        }

        var strings = []
        for (i = 0; i < pairs.length; i++) {
            var attr = pairs[i]
            strings.push(attr[0] + '=' + attr[1].toString())
        }
        return strings.join(';')
    }

    RRule.prototype = {
        constructor: RRule,

        /**
         * @param {Function} iterator - optional function that will be called
         *                   on each date that is added. It can return false
         *                   to stop the iteration.
         * @return Array containing all recurrences.
         */
        all: function (iterator) {
            if (iterator) {
                return this._iter(new CallbackIterResult('all', {}, iterator))
            } else {
                var result = this._cacheGet('all')
                if (result === false) {
                    result = this._iter(new IterResult('all', {}))
                    this._cacheAdd('all', result)
                }
                return result
            }
        },

        /**
         * Returns all the occurrences of the rrule between after and before.
         * The inc keyword defines what happens if after and/or before are
         * themselves occurrences. With inc == True, they will be included in the
         * list, if they are found in the recurrence set.
         * @return Array
         */
        between: function (after, before, inc, iterator) {
            var args = {
                before: before,
                after: after,
                inc: inc
            }

            if (iterator) {
                return this._iter(new CallbackIterResult('between', args, iterator))
            }
            var result = this._cacheGet('between', args)
            if (result === false) {
                result = this._iter(new IterResult('between', args))
                this._cacheAdd('between', result, args)
            }
            return result
        },

        /**
         * Returns the last recurrence before the given datetime instance.
         * The inc keyword defines what happens if dt is an occurrence.
         * With inc == True, if dt itself is an occurrence, it will be returned.
         * @return Date or null
         */
        before: function (dt, inc) {
            var args = {dt: dt, inc: inc}
            var result = this._cacheGet('before', args)
            if (result === false) {
                result = this._iter(new IterResult('before', args))
                this._cacheAdd('before', result, args)
            }
            return result
        },

        /**
         * Returns the first recurrence after the given datetime instance.
         * The inc keyword defines what happens if dt is an occurrence.
         * With inc == True, if dt itself is an occurrence, it will be returned.
         * @return Date or null
         */
        after: function (dt, inc) {
            var args = {dt: dt, inc: inc}
            var result = this._cacheGet('after', args)
            if (result === false) {
                result = this._iter(new IterResult('after', args))
                this._cacheAdd('after', result, args)
            }
            return result
        },

        /**
         * Returns the number of recurrences in this set. It will have go trough
         * the whole recurrence, if this hasn't been done before.
         */
        count: function () {
            return this.all().length
        },

        /**
         * Converts the rrule into its string representation
         * @see <http://www.ietf.org/rfc/rfc2445.txt>
         * @return String
         */
        toString: function () {
            return RRule.optionsToString(this.origOptions)
        },

        /**
         * Will convert all rules described in nlp:ToText
         * to text.
         */
        toText: function (gettext, language) {
            return getnlp().toText(this, gettext, language)
        },

        isFullyConvertibleToText: function () {
            return getnlp().isFullyConvertible(this)
        },

        /**
         * @param {String} what - all/before/after/between
         * @param {Array,Date} value - an array of dates, one date, or null
         * @param {Object?} args - _iter arguments
         */
        _cacheAdd: function (what, value, args) {
            if (!this._cache) return

            if (value) {
                value = (value instanceof Date)
                    ? dateutil.clone(value) : dateutil.cloneDates(value)
            }

            if (what === 'all') {
                this._cache.all = value
            } else {
                args._value = value
                this._cache[what].push(args)
            }
        },

        /**
         * @return false - not in the cache
         *         null  - cached, but zero occurrences (before/after)
         *         Date  - cached (before/after)
         *         []    - cached, but zero occurrences (all/between)
         *         [Date1, DateN] - cached (all/between)
         */
        _cacheGet: function (what, args) {
            if (!this._cache) return false

            var cached = false
            var argsKeys = args ? Object.keys(args) : []
            var findCacheDiff = function (item) {
                for (var key, i = 0; i < argsKeys.length; i++) {
                    key = argsKeys[i]
                    if (String(args[key]) !== String(item[key])) return true
                }
                return false
            }

            if (what === 'all') {
                cached = this._cache.all
            } else {
                // Let's see whether we've already called the
                // 'what' method with the same 'args'
                for (var item, i = 0; i < this._cache[what].length; i++) {
                    item = this._cache[what][i]
                    if (argsKeys.length && findCacheDiff(item)) continue
                    cached = item._value
                    break
                }
            }

            if (!cached && this._cache.all) {
                // Not in the cache, but we already know all the occurrences,
                // so we can find the correct dates from the cached ones.
                var iterResult = new IterResult(what, args)
                for (i = 0; i < this._cache.all.length; i++) {
                    if (!iterResult.accept(this._cache.all[i])) break
                }
                cached = iterResult.getValue()
                this._cacheAdd(what, cached, args)
            }

            return cached instanceof Array
                ? dateutil.cloneDates(cached)
                : (cached instanceof Date ? dateutil.clone(cached) : cached)
        },

        /**
         * @return a RRule instance with the same freq and options
         *          as this one (cache is not cloned)
         */
        clone: function () {
            return new RRule(this.origOptions)
        },

        _iter: function (iterResult) {
            /* Since JavaScript doesn't have the python's yield operator (<1.7),
               we use the IterResult object that tells us when to stop iterating.

            */

            var dtstart = this.options.dtstart
            var dtstartMillisecondModulo = this.options.dtstart % 1000

            var year = dtstart.getFullYear()
            var month = dtstart.getMonth() + 1
            var day = dtstart.getDate()
            var hour = dtstart.getHours()
            var minute = dtstart.getMinutes()
            var second = dtstart.getSeconds()
            var weekday = dateutil.getWeekday(dtstart)

            // Some local variables to speed things up a bit
            var freq = this.options.freq
            var interval = this.options.interval
            var wkst = this.options.wkst
            var until = this.options.until
            var bymonth = this.options.bymonth
            var byweekno = this.options.byweekno
            var byyearday = this.options.byyearday
            var byweekday = this.options.byweekday
            var byeaster = this.options.byeaster
            var bymonthday = this.options.bymonthday
            var bynmonthday = this.options.bynmonthday
            var bysetpos = this.options.bysetpos
            var byhour = this.options.byhour
            var byminute = this.options.byminute
            var bysecond = this.options.bysecond

            var ii = new Iterinfo(this)
            ii.rebuild(year, month)

            var getdayset = {}
            getdayset[RRule.YEARLY] = ii.ydayset
            getdayset[RRule.MONTHLY] = ii.mdayset
            getdayset[RRule.WEEKLY] = ii.wdayset
            getdayset[RRule.DAILY] = ii.ddayset
            getdayset[RRule.HOURLY] = ii.ddayset
            getdayset[RRule.MINUTELY] = ii.ddayset
            getdayset[RRule.SECONDLY] = ii.ddayset

            getdayset = getdayset[freq]

            var timeset
            if (freq < RRule.HOURLY) {
                timeset = this.timeset
            } else {
                var gettimeset = {}
                gettimeset[RRule.HOURLY] = ii.htimeset
                gettimeset[RRule.MINUTELY] = ii.mtimeset
                gettimeset[RRule.SECONDLY] = ii.stimeset
                gettimeset = gettimeset[freq]
                if ((freq >= RRule.HOURLY && plb(byhour) && !contains(byhour, hour)) ||
                    (freq >= RRule.MINUTELY && plb(byminute) && !contains(byminute, minute)) ||
                    (freq >= RRule.SECONDLY && plb(bysecond) && !contains(bysecond, minute))) {
                    timeset = []
                } else {
                    timeset = gettimeset.call(ii, hour, minute, second, dtstartMillisecondModulo)
                }
            }

            var total = 0
            var count = this.options.count
            var i, j, k, dm, div, mod, tmp, pos, dayset, start, end, fixday, filtered

            while (true) {
                // Get dayset with the right frequency
                tmp = getdayset.call(ii, year, month, day)
                dayset = tmp[0]
                start = tmp[1]
                end = tmp[2]

                // Do the "hard" work ;-)
                filtered = false
                for (j = start; j < end; j++) {
                    i = dayset[j]

                    filtered = (plb(bymonth) && !contains(bymonth, ii.mmask[i])) ||
                        (plb(byweekno) && !ii.wnomask[i]) ||
                        (plb(byweekday) && !contains(byweekday, ii.wdaymask[i])) ||
                        (plb(ii.nwdaymask) && !ii.nwdaymask[i]) ||
                        (byeaster !== null && !contains(ii.eastermask, i)) ||
                        ((plb(bymonthday) || plb(bynmonthday)) &&
                            !contains(bymonthday, ii.mdaymask[i]) &&
                            !contains(bynmonthday, ii.nmdaymask[i])) ||
                        (plb(byyearday) &&
                            ((i < ii.yearlen &&
                                !contains(byyearday, i + 1) &&
                                !contains(byyearday, -ii.yearlen + i)) ||
                                (i >= ii.yearlen &&
                                    !contains(byyearday, i + 1 - ii.yearlen) &&
                                    !contains(byyearday, -ii.nextyearlen + i - ii.yearlen))))

                    if (filtered) dayset[i] = null
                }

                // Output results
                if (plb(bysetpos) && plb(timeset)) {
                    var daypos, timepos
                    var poslist = []

                    for (i, j = 0; j < bysetpos.length; j++) {
                        pos = bysetpos[j]

                        if (pos < 0) {
                            daypos = Math.floor(pos / timeset.length)
                            timepos = pymod(pos, timeset.length)
                        } else {
                            daypos = Math.floor((pos - 1) / timeset.length)
                            timepos = pymod((pos - 1), timeset.length)
                        }

                        try {
                            tmp = []
                            for (k = start; k < end; k++) {
                                var val = dayset[k]
                                if (val === null) continue
                                tmp.push(val)
                            }
                            if (daypos < 0) {
                                // we're trying to emulate python's aList[-n]
                                i = tmp.slice(daypos)[0]
                            } else {
                                i = tmp[daypos]
                            }

                            var time = timeset[timepos]
                            var date = dateutil.fromOrdinal(ii.yearordinal + i)
                            var res = dateutil.combine(date, time)
                            // XXX: can this ever be in the array?
                            // - compare the actual date instead?
                            if (!contains(poslist, res)) poslist.push(res)
                        } catch (e) {}
                    }

                    dateutil.sort(poslist)
                    for (j = 0; j < poslist.length; j++) {
                        res = poslist[j]
                        if (until && res > until) {
                            this._len = total
                            return iterResult.getValue()
                        } else if (res >= dtstart) {
                            ++total
                            if (!iterResult.accept(res)) return iterResult.getValue()
                            if (count) {
                                --count
                                if (!count) {
                                    this._len = total
                                    return iterResult.getValue()
                                }
                            }
                        }
                    }
                } else {
                    for (j = start; j < end; j++) {
                        i = dayset[j]
                        if (i !== null) {
                            date = dateutil.fromOrdinal(ii.yearordinal + i)
                            for (k = 0; k < timeset.length; k++) {
                                time = timeset[k]
                                res = dateutil.combine(date, time)
                                if (until && res > until) {
                                    this._len = total
                                    return iterResult.getValue()
                                } else if (res >= dtstart) {
                                    ++total
                                    if (!iterResult.accept(res)) return iterResult.getValue()
                                    if (count) {
                                        --count
                                        if (!count) {
                                            this._len = total
                                            return iterResult.getValue()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Handle frequency and interval
                fixday = false
                if (freq === RRule.YEARLY) {
                    year += interval
                    if (year > dateutil.MAXYEAR) {
                        this._len = total
                        return iterResult.getValue()
                    }
                    ii.rebuild(year, month)
                } else if (freq === RRule.MONTHLY) {
                    month += interval
                    if (month > 12) {
                        div = Math.floor(month / 12)
                        mod = pymod(month, 12)
                        month = mod
                        year += div
                        if (month === 0) {
                            month = 12
                            --year
                        }
                        if (year > dateutil.MAXYEAR) {
                            this._len = total
                            return iterResult.getValue()
                        }
                    }
                    ii.rebuild(year, month)
                } else if (freq === RRule.WEEKLY) {
                    if (wkst > weekday) {
                        day += -(weekday + 1 + (6 - wkst)) + interval * 7
                    } else {
                        day += -(weekday - wkst) + interval * 7
                    }
                    weekday = wkst
                    fixday = true
                } else if (freq === RRule.DAILY) {
                    day += interval
                    fixday = true
                } else if (freq === RRule.HOURLY) {
                    if (filtered) {
                        // Jump to one iteration before next day
                        hour += Math.floor((23 - hour) / interval) * interval
                    }
                    while (true) {
                        hour += interval
                        dm = divmod(hour, 24)
                        div = dm.div
                        mod = dm.mod
                        if (div) {
                            hour = mod
                            day += div
                            fixday = true
                        }
                        if (!plb(byhour) || contains(byhour, hour)) break
                    }
                    timeset = gettimeset.call(ii, hour, minute, second)
                } else if (freq === RRule.MINUTELY) {
                    if (filtered) {
                        // Jump to one iteration before next day
                        minute += Math.floor(
                            (1439 - (hour * 60 + minute)) / interval) * interval
                    }

                    while (true) {
                        minute += interval
                        dm = divmod(minute, 60)
                        div = dm.div
                        mod = dm.mod
                        if (div) {
                            minute = mod
                            hour += div
                            dm = divmod(hour, 24)
                            div = dm.div
                            mod = dm.mod
                            if (div) {
                                hour = mod
                                day += div
                                fixday = true
                                filtered = false
                            }
                        }
                        if ((!plb(byhour) || contains(byhour, hour)) &&
                            (!plb(byminute) || contains(byminute, minute))) {
                            break
                        }
                    }
                    timeset = gettimeset.call(ii, hour, minute, second)
                } else if (freq === RRule.SECONDLY) {
                    if (filtered) {
                        // Jump to one iteration before next day
                        second += Math.floor(
                            (86399 - (hour * 3600 + minute * 60 + second)) / interval) * interval
                    }
                    while (true) {
                        second += interval
                        dm = divmod(second, 60)
                        div = dm.div
                        mod = dm.mod
                        if (div) {
                            second = mod
                            minute += div
                            dm = divmod(minute, 60)
                            div = dm.div
                            mod = dm.mod
                            if (div) {
                                minute = mod
                                hour += div
                                dm = divmod(hour, 24)
                                div = dm.div
                                mod = dm.mod
                                if (div) {
                                    hour = mod
                                    day += div
                                    fixday = true
                                }
                            }
                        }
                        if ((!plb(byhour) || contains(byhour, hour)) &&
                            (!plb(byminute) || contains(byminute, minute)) &&
                            (!plb(bysecond) || contains(bysecond, second))) {
                            break
                        }
                    }
                    timeset = gettimeset.call(ii, hour, minute, second)
                }

                if (fixday && day > 28) {
                    var daysinmonth = dateutil.monthRange(year, month - 1)[1]
                    if (day > daysinmonth) {
                        while (day > daysinmonth) {
                            day -= daysinmonth
                            ++month
                            if (month === 13) {
                                month = 1
                                ++year
                                if (year > dateutil.MAXYEAR) {
                                    this._len = total
                                    return iterResult.getValue()
                                }
                            }
                            daysinmonth = dateutil.monthRange(year, month - 1)[1]
                        }
                        ii.rebuild(year, month)
                    }
                }
            }
        }

    }

    RRule.parseString = function (rfcString) {
        rfcString = rfcString.replace(/^\s+|\s+$/, '')
        if (!rfcString.length) return null

        var i, j, key, value, attr
        var attrs = rfcString.split(';')
        var options = {}

        for (i = 0; i < attrs.length; i++) {
            attr = attrs[i].split('=')
            key = attr[0]
            value = attr[1]
            switch (key) {
                case 'FREQ':
                    options.freq = RRule[value]
                    break
                case 'WKST':
                    options.wkst = RRule[value]
                    break
                case 'COUNT':
                case 'INTERVAL':
                case 'BYSETPOS':
                case 'BYMONTH':
                case 'BYMONTHDAY':
                case 'BYYEARDAY':
                case 'BYWEEKNO':
                case 'BYHOUR':
                case 'BYMINUTE':
                case 'BYSECOND':
                    if (value.indexOf(',') !== -1) {
                        value = value.split(',')
                        for (j = 0; j < value.length; j++) {
                            if (/^[+-]?\d+$/.test(value[j])) value[j] = Number(value[j])
                        }
                    } else if (/^[+-]?\d+$/.test(value)) {
                        value = Number(value)
                    }
                    key = key.toLowerCase()
                    options[key] = value
                    break
                case 'BYDAY': // => byweekday
                    var n, wday, day
                    var days = value.split(',')

                    options.byweekday = []
                    for (j = 0; j < days.length; j++) {
                        day = days[j]
                        if (day.length === 2) { // MO, TU, ...
                            wday = RRule[day] // wday instanceof Weekday
                            options.byweekday.push(wday)
                        } else { // -1MO, +3FR, 1SO, ...
                            day = day.match(/^([+-]?\d)([A-Z]{2})$/)
                            n = Number(day[1])
                            wday = day[2]
                            wday = RRule[wday].weekday
                            options.byweekday.push(new Weekday(wday, n))
                        }
                    }
                    break
                case 'DTSTART':
                    options.dtstart = dateutil.untilStringToDate(value)
                    break
                case 'UNTIL':
                    options.until = dateutil.untilStringToDate(value)
                    break
                case 'BYEASTER':
                    options.byeaster = Number(value)
                    break
                default:
                    throw new Error("Unknown RRULE property '" + key + "'")
            }
        }
        return options
    }

    RRule.fromString = function (string) {
        return new RRule(RRule.parseString(string))
    }

    // =============================================================================
    // Iterinfo
    // =============================================================================

    var Iterinfo = function (rrule) {
        this.rrule = rrule
        this.lastyear = null
        this.lastmonth = null
        this.yearlen = null
        this.nextyearlen = null
        this.yearordinal = null
        this.yearweekday = null
        this.mmask = null
        this.mrange = null
        this.mdaymask = null
        this.nmdaymask = null
        this.wdaymask = null
        this.wnomask = null
        this.nwdaymask = null
        this.eastermask = null
    }

    Iterinfo.prototype.easter = function (y, offset) {
        offset = offset || 0

        var a = y % 19
        var b = Math.floor(y / 100)
        var c = y % 100
        var d = Math.floor(b / 4)
        var e = b % 4
        var f = Math.floor((b + 8) / 25)
        var g = Math.floor((b - f + 1) / 3)
        var h = Math.floor(19 * a + b - d - g + 15) % 30
        var i = Math.floor(c / 4)
        var k = c % 4
        var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7
        var m = Math.floor((a + 11 * h + 22 * l) / 451)
        var month = Math.floor((h + l - 7 * m + 114) / 31)
        var day = (h + l - 7 * m + 114) % 31 + 1
        var date = Date.UTC(y, month - 1, day + offset)
        var yearStart = Date.UTC(y, 0, 1)

        return [Math.ceil((date - yearStart) / (1000 * 60 * 60 * 24))]
    }

    Iterinfo.prototype.rebuild = function (year, month) {
        var rr = this.rrule

        if (year !== this.lastyear) {
            this.yearlen = dateutil.isLeapYear(year) ? 366 : 365
            this.nextyearlen = dateutil.isLeapYear(year + 1) ? 366 : 365
            var firstyday = new Date(year, 0, 1)

            this.yearordinal = dateutil.toOrdinal(firstyday)
            this.yearweekday = dateutil.getWeekday(firstyday)

            var wday = dateutil.getWeekday(new Date(year, 0, 1))

            if (this.yearlen === 365) {
                this.mmask = [].concat(M365MASK)
                this.mdaymask = [].concat(MDAY365MASK)
                this.nmdaymask = [].concat(NMDAY365MASK)
                this.wdaymask = WDAYMASK.slice(wday)
                this.mrange = [].concat(M365RANGE)
            } else {
                this.mmask = [].concat(M366MASK)
                this.mdaymask = [].concat(MDAY366MASK)
                this.nmdaymask = [].concat(NMDAY366MASK)
                this.wdaymask = WDAYMASK.slice(wday)
                this.mrange = [].concat(M366RANGE)
            }

            if (!plb(rr.options.byweekno)) {
                this.wnomask = null
            } else {
                this.wnomask = repeat(0, this.yearlen + 7)
                var no1wkst, firstwkst, wyearlen
                no1wkst = firstwkst = pymod(7 - this.yearweekday + rr.options.wkst, 7)
                if (no1wkst >= 4) {
                    no1wkst = 0
                    // Number of days in the year, plus the days we got
                    // from last year.
                    wyearlen = this.yearlen + pymod(this.yearweekday - rr.options.wkst, 7)
                } else {
                    // Number of days in the year, minus the days we
                    // left in last year.
                    wyearlen = this.yearlen - no1wkst
                }
                var div = Math.floor(wyearlen / 7)
                var mod = pymod(wyearlen, 7)
                var numweeks = Math.floor(div + (mod / 4))
                for (var n, i, j = 0; j < rr.options.byweekno.length; j++) {
                    n = rr.options.byweekno[j]
                    if (n < 0) {
                        n += numweeks + 1
                    } if (!(n > 0 && n <= numweeks)) {
                        continue
                    } if (n > 1) {
                        i = no1wkst + (n - 1) * 7
                        if (no1wkst !== firstwkst) {
                            i -= 7 - firstwkst
                        }
                    } else {
                        i = no1wkst
                    }
                    for (var k = 0; k < 7; k++) {
                        this.wnomask[i] = 1
                        i++
                        if (this.wdaymask[i] === rr.options.wkst) break
                    }
                }

                if (contains(rr.options.byweekno, 1)) {
                    // Check week number 1 of next year as well
                    // orig-TODO : Check -numweeks for next year.
                    i = no1wkst + numweeks * 7
                    if (no1wkst !== firstwkst) i -= 7 - firstwkst
                    if (i < this.yearlen) {
                        // If week starts in next year, we
                        // don't care about it.
                        for (j = 0; j < 7; j++) {
                            this.wnomask[i] = 1
                            i += 1
                            if (this.wdaymask[i] === rr.options.wkst) break
                        }
                    }
                }

                if (no1wkst) {
                    // Check last week number of last year as
                    // well. If no1wkst is 0, either the year
                    // started on week start, or week number 1
                    // got days from last year, so there are no
                    // days from last year's last week number in
                    // this year.
                    var lnumweeks
                    if (!contains(rr.options.byweekno, -1)) {
                        var lyearweekday = dateutil.getWeekday(new Date(year - 1, 0, 1))
                        var lno1wkst = pymod(7 - lyearweekday + rr.options.wkst, 7)
                        var lyearlen = dateutil.isLeapYear(year - 1) ? 366 : 365
                        if (lno1wkst >= 4) {
                            lno1wkst = 0
                            lnumweeks = Math.floor(52 +
                                pymod(lyearlen + pymod(lyearweekday - rr.options.wkst, 7), 7) / 4)
                        } else {
                            lnumweeks = Math.floor(52 + pymod(this.yearlen - no1wkst, 7) / 4)
                        }
                    } else {
                        lnumweeks = -1
                    }
                    if (contains(rr.options.byweekno, lnumweeks)) {
                        for (i = 0; i < no1wkst; i++) this.wnomask[i] = 1
                    }
                }
            }
        }

        if (plb(rr.options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
            var ranges = []
            if (rr.options.freq === RRule.YEARLY) {
                if (plb(rr.options.bymonth)) {
                    for (j = 0; j < rr.options.bymonth.length; j++) {
                        month = rr.options.bymonth[j]
                        ranges.push(this.mrange.slice(month - 1, month + 1))
                    }
                } else {
                    ranges = [[0, this.yearlen]]
                }
            } else if (rr.options.freq === RRule.MONTHLY) {
                ranges = [this.mrange.slice(month - 1, month + 1)]
            }
            if (plb(ranges)) {
                // Weekly frequency won't get here, so we may not
                // care about cross-year weekly periods.
                this.nwdaymask = repeat(0, this.yearlen)

                for (j = 0; j < ranges.length; j++) {
                    var rang = ranges[j]
                    var first = rang[0]
                    var last = rang[1]
                    last -= 1
                    for (k = 0; k < rr.options.bynweekday.length; k++) {
                        wday = rr.options.bynweekday[k][0]
                        n = rr.options.bynweekday[k][1]
                        if (n < 0) {
                            i = last + (n + 1) * 7
                            i -= pymod(this.wdaymask[i] - wday, 7)
                        } else {
                            i = first + (n - 1) * 7
                            i += pymod(7 - this.wdaymask[i] + wday, 7)
                        }
                        if (first <= i && i <= last) this.nwdaymask[i] = 1
                    }
                }
            }

            this.lastyear = year
            this.lastmonth = month
        }

        if (rr.options.byeaster !== null) {
            this.eastermask = this.easter(year, rr.options.byeaster)
        }
    }

    Iterinfo.prototype.ydayset = function (year, month, day) {
        return [range(this.yearlen), 0, this.yearlen]
    }

    Iterinfo.prototype.mdayset = function (year, month, day) {
        var set = repeat(null, this.yearlen)
        var start = this.mrange[month - 1]
        var end = this.mrange[month]
        for (var i = start; i < end; i++) set[i] = i
        return [set, start, end]
    }

    Iterinfo.prototype.wdayset = function (year, month, day) {
        // We need to handle cross-year weeks here.
        var set = repeat(null, this.yearlen + 7)
        var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal
        var start = i
        for (var j = 0; j < 7; j++) {
            set[i] = i
            ++i
            if (this.wdaymask[i] === this.rrule.options.wkst) break
        }
        return [set, start, i]
    }

    Iterinfo.prototype.ddayset = function (year, month, day) {
        var set = repeat(null, this.yearlen)
        var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal
        set[i] = i
        return [set, i, i + 1]
    }

    Iterinfo.prototype.htimeset = function (hour, minute, second, millisecond) {
        var set = []
        var rr = this.rrule
        for (var i = 0; i < rr.options.byminute.length; i++) {
            minute = rr.options.byminute[i]
            for (var j = 0; j < rr.options.bysecond.length; j++) {
                second = rr.options.bysecond[j]
                set.push(new dateutil.Time(hour, minute, second, millisecond))
            }
        }
        dateutil.sort(set)
        return set
    }

    Iterinfo.prototype.mtimeset = function (hour, minute, second, millisecond) {
        var set = []
        var rr = this.rrule
        for (var j = 0; j < rr.options.bysecond.length; j++) {
            second = rr.options.bysecond[j]
            set.push(new dateutil.Time(hour, minute, second, millisecond))
        }
        dateutil.sort(set)
        return set
    }

    Iterinfo.prototype.stimeset = function (hour, minute, second, millisecond) {
        return [new dateutil.Time(hour, minute, second, millisecond)]
    }

    // =============================================================================
    // Results
    // =============================================================================

    /**
     * This class helps us to emulate python's generators, sorta.
     */
    var IterResult = function (method, args) {
        this.init(method, args)
    }

    IterResult.prototype = {
        constructor: IterResult,
        init: function (method, args) {
            this.method = method
            this.args = args
            this.minDate = null
            this.maxDate = null
            this._result = []

            if (method === 'between') {
                this.maxDate = args.inc
                    ? args.before : new Date(args.before.getTime() - 1)
                this.minDate = args.inc
                    ? args.after : new Date(args.after.getTime() + 1)
            } else if (method === 'before') {
                this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1)
            } else if (method === 'after') {
                this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1)
            }
        },

        /**
         * Possibly adds a date into the result.
         *
         * @param {Date} date - the date isn't necessarly added to the result
         *                      list (if it is too late/too early)
         * @return {Boolean} true if it makes sense to continue the iteration
         *                   false if we're done.
         */
        accept: function (date) {
            var tooEarly = this.minDate && date < this.minDate
            var tooLate = this.maxDate && date > this.maxDate

            if (this.method === 'between') {
                if (tooEarly) return true
                if (tooLate) return false
            } else if (this.method === 'before') {
                if (tooLate) return false
            } else if (this.method === 'after') {
                if (tooEarly) return true
                this.add(date)
                return false
            }

            return this.add(date)
        },

        /**
         *
         * @param {Date} date that is part of the result.
         * @return {Boolean} whether we are interested in more values.
         */
        add: function (date) {
            this._result.push(date)
            return true
        },

        /**
         * 'before' and 'after' return only one date, whereas 'all'
         * and 'between' an array.
         * @return {Date,Array?}
         */
        getValue: function () {
            var res = this._result
            switch (this.method) {
                case 'all':
                case 'between':
                    return res
                case 'before':
                case 'after':
                    return res.length ? res[res.length - 1] : null
            }
        },

        clone: function () {
            return new IterResult(this.method, this.args)
        }
    }

    /**
     * IterResult subclass that calls a callback function on each add,
     * and stops iterating when the callback returns false.
     */
    var CallbackIterResult = function (method, args, iterator) {
        var allowedMethods = ['all', 'between']
        if (!contains(allowedMethods, method)) {
            throw new Error('Invalid method "' + method +
                '". Only all and between works with iterator.')
        }
        this.add = function (date) {
            if (iterator(date, this._result.length)) {
                this._result.push(date)
                return true
            }
            return false
        }

        this.init(method, args)
    }
    CallbackIterResult.prototype = IterResult.prototype

    /**
     *
     * @param {Boolean?} noCache
     *  The same stratagy as RRule on cache, default to false
     * @constructor
     */

    var RRuleSet = function (noCache) {
        // Let RRuleSet cacheable
        this._cache = noCache ? null : {
            all: false,
            before: [],
            after: [],
            between: []
        }
        this._rrule = []
        this._rdate = []
        this._exrule = []
        this._exdate = []
    }

    RRuleSet.prototype = {
        constructor: RRuleSet,

        /**
         * @param {RRule}
         */
        rrule: function (rrule) {
            if (!(rrule instanceof RRule)) {
                throw new TypeError(String(rrule) + ' is not RRule instance')
            }
            if (!contains(this._rrule.map(String), String(rrule))) {
                this._rrule.push(rrule)
            }
        },

        /**
         * @param {Date}
         */
        rdate: function (date) {
            if (!(date instanceof Date)) {
                throw new TypeError(String(date) + ' is not Date instance')
            }
            if (!contains(this._rdate.map(Number), Number(date))) {
                this._rdate.push(date)
                dateutil.sort(this._rdate)
            }
        },

        /**
         * @param {RRule}
         */
        exrule: function (rrule) {
            if (!(rrule instanceof RRule)) {
                throw new TypeError(String(rrule) + ' is not RRule instance')
            }
            if (!contains(this._exrule.map(String), String(rrule))) {
                this._exrule.push(rrule)
            }
        },

        /**
         * @param {Date}
         */
        exdate: function (date) {
            if (!(date instanceof Date)) {
                throw new TypeError(String(date) + ' is not Date instance')
            }
            if (!contains(this._exdate.map(Number), Number(date))) {
                this._exdate.push(date)
                dateutil.sort(this._exdate)
            }
        },

        valueOf: function () {
            var result = []
            if (this._rrule.length) {
                this._rrule.forEach(function (rrule) {
                    result.push('RRULE:' + rrule)
                })
            }
            if (this._rdate.length) {
                result.push('RDATE:' + this._rdate.map(function (rdate) {
                    return dateutil.timeToUntilString(rdate)
                }).join(','))
            }
            if (this._exrule.length) {
                this._exrule.forEach(function (exrule) {
                    result.push('EXRULE:' + exrule)
                })
            }
            if (this._exdate.length) {
                result.push('EXDATE:' + this._exdate.map(function (exdate) {
                    return dateutil.timeToUntilString(exdate)
                }).join(','))
            }
            return result
        },

        /**
         * to generate recurrence field sush as:
         *   ["RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU;DTSTART=19970902T010000Z","RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH;DTSTART=19970902T010000Z"]
         */
        toString: function () {
            return JSON.stringify(this.valueOf())
        },

        _iter: function (iterResult) {
            var _exdateHash = {}
            var _exrule = this._exrule
            var _accept = iterResult.accept

            function evalExdate (after, before) {
                _exrule.forEach(function (rrule) {
                    rrule.between(after, before, true).forEach(function (date) {
                        _exdateHash[Number(date)] = true
                    })
                })
            }

            this._exdate.forEach(function (date) {
                _exdateHash[Number(date)] = true
            })

            iterResult.accept = function (date) {
                var dt = Number(date)
                if (!_exdateHash[dt]) {
                    evalExdate(new Date(dt - 1), new Date(dt + 1))
                    if (!_exdateHash[dt]) {
                        _exdateHash[dt] = true
                        return _accept.call(this, date)
                    }
                }
                return true
            }

            if (iterResult.method === 'between') {
                evalExdate(iterResult.args.after, iterResult.args.before)
                iterResult.accept = function (date) {
                    var dt = Number(date)
                    if (!_exdateHash[dt]) {
                        _exdateHash[dt] = true
                        return _accept.call(this, date)
                    }
                    return true
                }
            }

            for (var i = 0; i < this._rdate.length; i++) {
                if (!iterResult.accept(new Date(this._rdate[i]))) break
            }

            this._rrule.forEach(function (rrule) {
                rrule._iter(iterResult)
            })

            var res = iterResult._result
            dateutil.sort(res)
            switch (iterResult.method) {
                case 'all':
                case 'between':
                    return res
                case 'before':
                    return (res.length && res[res.length - 1]) || null
                case 'after':
                    return (res.length && res[0]) || null
                default:
                    return null
            }
        },

        /**
         * Create a new RRuleSet Object completely base on current instance
         */
        clone: function () {
            var rrs = new RRuleSet(!!this._cache)
            var i
            for (i = 0; i < this._rrule.length; i++) {
                rrs.rrule(this._rrule[i].clone())
            }
            for (i = 0; i < this._rdate.length; i++) {
                rrs.rdate(new Date(this._rdate[i]))
            }
            for (i = 0; i < this._exrule.length; i++) {
                rrs.exrule(this._exrule[i].clone())
            }
            for (i = 0; i < this._exdate.length; i++) {
                rrs.exdate(new Date(this._exdate[i]))
            }
            return rrs
        }
    }

    /**
     * Inherts method from RRule
     *  add Read interface and set RRuleSet cacheable
     */
    var RRuleSetMethods = ['all', 'between', 'before', 'after', 'count', '_cacheAdd', '_cacheGet']
    RRuleSetMethods.forEach(function (method) {
        RRuleSet.prototype[method] = RRule.prototype[method]
    })

    /**
     * RRuleStr
     *  To parse a set of rrule strings
     */

    var RRuleStr = function () {}

    RRuleStr.DEFAULT_OPTIONS = {
        dtstart: null,
        cache: false,
        unfold: false,
        forceset: false,
        compatible: false,
        ignoretz: false,
        tzinfos: null
    }

    RRuleStr._freq_map = {
        'YEARLY': RRule.YEARLY,
        'MONTHLY': RRule.MONTHLY,
        'WEEKLY': RRule.WEEKLY,
        'DAILY': RRule.DAILY,
        'HOURLY': RRule.HOURLY,
        'MINUTELY': RRule.MINUTELY,
        'SECONDLY': RRule.SECONDLY
    }

    RRuleStr._weekday_map = {
        'MO': 0,
        'TU': 1,
        'WE': 2,
        'TH': 3,
        'FR': 4,
        'SA': 5,
        'SU': 6
    }

    RRuleStr.prototype = {
        constructor: RRuleStr,

        _handle_int: function (rrkwargs, name, value, options) {
            rrkwargs[name.toLowerCase()] = parseInt(value, 10)
        },

        _handle_int_list: function (rrkwargs, name, value, options) {
            rrkwargs[name.toLowerCase()] = value.split(',').map(function (x) {
                return parseInt(x, 10)
            })
        },

        _handle_FREQ: function (rrkwargs, name, value, options) {
            rrkwargs['freq'] = RRuleStr._freq_map[value]
        },

        _handle_UNTIL: function (rrkwargs, name, value, options) {
            try {
                rrkwargs['until'] = dateutil.untilStringToDate(value)
            } catch (error) {
                throw new Error('invalid until date')
            }
        },

        _handle_WKST: function (rrkwargs, name, value, options) {
            rrkwargs['wkst'] = RRuleStr._weekday_map[value]
        },

        _handle_BYWEEKDAY: function (rrkwargs, name, value, options) {
            // Two ways to specify this: +1MO or MO(+1)
            var splt, i, j, n, w, wday
            var l = []
            var wdays = value.split(',')

            for (i = 0; i < wdays.length; i++) {
                wday = wdays[i]
                if (wday.indexOf('(') > -1) {
                    // If it's of the form TH(+1), etc.
                    splt = wday.split('(')
                    w = splt[0]
                    n = parseInt(splt.slice(1, -1), 10)
                } else {
                    // # If it's of the form +1MO
                    for (j = 0; j < wday.length; j++) {
                        if ('+-0123456789'.indexOf(wday[j]) === -1) break
                    }
                    n = wday.slice(0, j) || null
                    w = wday.slice(j)

                    if (n) n = parseInt(n, 10)
                }

                var weekday = new Weekday(RRuleStr._weekday_map[w], n)
                l.push(weekday)
            }
            rrkwargs['byweekday'] = l
        },

        _parseRfcRRule: function (line, options) {
            options = options || {}
            options.dtstart = options.dtstart || null
            options.cache = options.cache || false
            options.ignoretz = options.ignoretz || false
            options.tzinfos = options.tzinfos || null

            var name, value, parts
            if (line.indexOf(':') !== -1) {
                parts = line.split(':')
                name = parts[0]
                value = parts[1]

                if (name !== 'RRULE') throw new Error('unknown parameter name')
            } else {
                value = line
            }

            var i
            var rrkwargs = {}
            var pairs = value.split(';')

            for (i = 0; i < pairs.length; i++) {
                parts = pairs[i].split('=')
                name = parts[0].toUpperCase()
                value = parts[1].toUpperCase()

                try {
                    this['_handle_' + name](rrkwargs, name, value, {
                        ignoretz: options.ignoretz,
                        tzinfos: options.tzinfos
                    })
                } catch (error) {
                    throw new Error("unknown parameter '" + name + "':" + value)
                }
            }
            rrkwargs.dtstart = rrkwargs.dtstart || options.dtstart
            return new RRule(rrkwargs, !options.cache)
        },

        _parseRfc: function (s, options) {
            if (options.compatible) {
                options.forceset = true
                options.unfold = true
            }

            s = s && s.toUpperCase().trim()
            if (!s) throw new Error('Invalid empty string')

            var i = 0
            var line, lines

            // More info about 'unfold' option
            // Go head to http://www.ietf.org/rfc/rfc2445.txt
            if (options.unfold) {
                lines = s.split('\n')
                while (i < lines.length) {
                    // TODO
                    line = lines[i] = lines[i].replace(/\s+$/g, '')
                    if (!line) {
                        lines.splice(i, 1)
                    } else if (i > 0 && line[0] === ' ') {
                        lines[i - 1] += line.slice(1)
                        lines.splice(i, 1)
                    } else {
                        i += 1
                    }
                }
            } else {
                lines = s.split(/\s/)
            }

            var rrulevals = []
            var rdatevals = []
            var exrulevals = []
            var exdatevals = []
            var name, value, parts, parms, parm, dtstart, rset, j, k, datestrs, datestr

            if (!options.forceset && lines.length === 1 && (s.indexOf(':') === -1 ||
                    s.indexOf('RRULE:') === 0)) {
                return this._parseRfcRRule(lines[0], {
                    cache: options.cache,
                    dtstart: options.dtstart,
                    ignoretz: options.ignoretz,
                    tzinfos: options.tzinfos
                })
            } else {
                for (i = 0; i < lines.length; i++) {
                    line = lines[i]
                    if (!line) continue
                    if (line.indexOf(':') === -1) {
                        name = 'RRULE'
                        value = line
                    } else {
                        parts = split(line, ':', 1)
                        name = parts[0]
                        value = parts[1]
                    }
                    parms = name.split(';')
                    if (!parms) throw new Error('empty property name')
                    name = parms[0]
                    parms = parms.slice(1)

                    if (name === 'RRULE') {
                        for (j = 0; j < parms.length; j++) {
                            parm = parms[j]
                            throw new Error('unsupported RRULE parm: ' + parm)
                        }
                        rrulevals.push(value)
                    } else if (name === 'RDATE') {
                        for (j = 0; j < parms.length; j++) {
                            parm = parms[j]
                            if (parm !== 'VALUE=DATE-TIME') {
                                throw new Error('unsupported RDATE parm: ' + parm)
                            }
                        }
                        rdatevals.push(value)
                    } else if (name === 'EXRULE') {
                        for (j = 0; j < parms.length; j++) {
                            parm = parms[j]
                            throw new Error('unsupported EXRULE parm: ' + parm)
                        }
                        exrulevals.push(value)
                    } else if (name === 'EXDATE') {
                        for (j = 0; j < parms.length; j++) {
                            parm = parms[j]
                            if (parm !== 'VALUE=DATE-TIME') {
                                throw new Error('unsupported RDATE parm: ' + parm)
                            }
                        }
                        exdatevals.push(value)
                    } else if (name === 'DTSTART') {
                        dtstart = dateutil.untilStringToDate(value)
                    } else {
                        throw new Error('unsupported property: ' + name)
                    }
                }

                if (options.forceset || rrulevals.length > 1 || rdatevals.length ||
                    exrulevals.length || exdatevals.length) {
                    rset = new RRuleSet(!options.cache)
                    for (j = 0; j < rrulevals.length; j++) {
                        rset.rrule(this._parseRfcRRule(rrulevals[j], {
                            dtstart: options.dtstart || dtstart,
                            ignoretz: options.ignoretz,
                            tzinfos: options.tzinfos
                        }))
                    }
                    for (j = 0; j < rdatevals.length; j++) {
                        datestrs = rdatevals[j].split(',')
                        for (k = 0; k < datestrs.length; k++) {
                            datestr = datestrs[k]
                            rset.rdate(dateutil.untilStringToDate(datestr))
                        }
                    }
                    for (j = 0; j < exrulevals.length; j++) {
                        rset.exrule(this._parseRfcRRule(exrulevals[j], {
                            dtstart: options.dtstart || dtstart,
                            ignoretz: options.ignoretz,
                            tzinfos: options.tzinfos
                        }))
                    }
                    for (j = 0; j < exdatevals.length; j++) {
                        datestrs = exdatevals[j].split(',')
                        for (k = 0; k < datestrs.length; k++) {
                            datestr = datestrs[k]
                            rset.exdate(dateutil.untilStringToDate(datestr))
                        }
                    }

                    if (options.campatiable && options.dtstart) rset.rdate(dtstart)
                    return rset
                } else {
                    return this._parseRfcRRule(rrulevals[0], {
                        dtstart: options.dtstart || dtstart,
                        cache: options.cache,
                        ignoretz: options.ignoretz,
                        tzinfos: options.tzinfos
                    })
                }
            }
        },

        parse: function (s, options) {
            options = options || {}

            var invalid = []
            var keys = Object.keys(options)
            var defaultKeys = Object.keys(RRuleStr.DEFAULT_OPTIONS)

            keys.forEach(function (key) {
                if (!contains(defaultKeys, key)) invalid.push(key)
            }, this)

            if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))

            // Merge in default options
            defaultKeys.forEach(function (key) {
                if (!contains(keys, key)) options[key] = RRuleStr.DEFAULT_OPTIONS[key]
            })

            return this._parseRfc(s, options)
        }
    }

    RRuleStr.prototype._handle_DTSTART = function (rrkwargs, name, value, options) {
        rrkwargs[name.toLowerCase()] = dateutil.untilStringToDate(value)
    }

    RRuleStr.prototype._handle_BYDAY = RRuleStr.prototype._handle_BYWEEKDAY
    RRuleStr.prototype._handle_INTERVAL = RRuleStr.prototype._handle_int
    RRuleStr.prototype._handle_COUNT = RRuleStr.prototype._handle_int

    ;[
        '_handle_BYSETPOS', '_handle_BYMONTH', '_handle_BYMONTHDAY',
        '_handle_BYYEARDAY', '_handle_BYEASTER', '_handle_BYWEEKNO',
        '_handle_BYHOUR', '_handle_BYMINUTE', '_handle_BYSECOND'
    ].forEach(function (method) {
        RRuleStr.prototype[method] = RRuleStr.prototype._handle_int_list
    })

    // =============================================================================
    // Export
    // =============================================================================

    // Only one RRuleStr instance for all rrule string parsing work.
    var rruleStr = new RRuleStr()
    var rrulestr = function () {
        return rruleStr.parse.apply(rruleStr, arguments)
    }

    RRule.RRule = RRule
    RRule.RRuleSet = RRuleSet
    RRule.rrulestr = rrulestr
    return RRule

    function getnlp () {
        // Lazy, runtime import to avoid circular refs.
        if (!getnlp._nlp) {
            if (root && root._getRRuleNLP) {
                getnlp._nlp = root._getRRuleNLP(RRule)
            } else if (typeof require === 'function') {
                getnlp._nlp = require('./nlp')(RRule)
            } else {
                throw new Error('You need to include rrule/nlp.js for fromText/toText to work.')
            }
        }
        return getnlp._nlp
    }
}))

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/lib/nlp.js' */
/*!
 * rrule.js - Library for working with recurrence rules for calendar dates.
 * https://github.com/jakubroztocil/rrule
 *
 * Copyright 2010, Jakub Roztocil and Lars Schoning
 * Licenced under the BSD licence.
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 */

/**
 *
 * Implementation of RRule.fromText() and RRule::toText().
 *
 *
 * On the client side, this file needs to be included
 * when those functions are used.
 *
 */
/* global module, define */

;(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = factory()
    } else if (typeof define === 'function' && define.amd) {
        define([], factory)
    } else {
        root._getRRuleNLP = factory()
    }
}(typeof window === 'object' ? window : this, function () {
    // =============================================================================
    // Helper functions
    // =============================================================================

    /**
     * Return true if a value is in an array
     */
    var contains = function (arr, val) {
        return arr.indexOf(val) !== -1
    }

    return function (RRule) {
        // =============================================================================
        // ToText
        // =============================================================================

        /**
         *
         * @param {RRule} rrule
         * Optional:
         * @param {Function} gettext function
         * @param {Object} language definition
         * @constructor
         */
        var ToText = function (rrule, gettext, language) {
            this.text = ''
            this.language = language || ENGLISH
            this.gettext = gettext || function (id) {
                return id
            }

            this.rrule = rrule
            this.freq = rrule.options.freq
            this.options = rrule.options
            this.origOptions = rrule.origOptions

            if (this.origOptions.bymonthday) {
                var bymonthday = [].concat(this.options.bymonthday)
                var bynmonthday = [].concat(this.options.bynmonthday)

                bymonthday.sort()
                bynmonthday.sort()
                bynmonthday.reverse()
                // 1, 2, 3, .., -5, -4, -3, ..
                this.bymonthday = bymonthday.concat(bynmonthday)
                if (!this.bymonthday.length) this.bymonthday = null
            }

            if (this.origOptions.byweekday) {
                var byweekday = !(this.origOptions.byweekday instanceof Array)
                    ? [this.origOptions.byweekday] : this.origOptions.byweekday
                var days = String(byweekday)

                this.byweekday = {
                    allWeeks: byweekday.filter(function (weekday) {
                        return !Boolean(weekday.n)
                    }),
                    someWeeks: byweekday.filter(function (weekday) {
                        return Boolean(weekday.n)
                    }),
                    isWeekdays: (
                        days.indexOf('MO') !== -1 &&
                        days.indexOf('TU') !== -1 &&
                        days.indexOf('WE') !== -1 &&
                        days.indexOf('TH') !== -1 &&
                        days.indexOf('FR') !== -1 &&
                        days.indexOf('SA') === -1 &&
                        days.indexOf('SU') === -1
                    )
                }

                var sortWeekDays = function (a, b) {
                    return a.weekday - b.weekday
                }

                this.byweekday.allWeeks.sort(sortWeekDays)
                this.byweekday.someWeeks.sort(sortWeekDays)

                if (!this.byweekday.allWeeks.length) this.byweekday.allWeeks = null
                if (!this.byweekday.someWeeks.length) this.byweekday.someWeeks = null
            } else {
                this.byweekday = null
            }
        }

        var common = [
            'count', 'until', 'interval',
            'byweekday', 'bymonthday', 'bymonth'
        ]
        ToText.IMPLEMENTED = []
        ToText.IMPLEMENTED[RRule.HOURLY] = common
        ToText.IMPLEMENTED[RRule.DAILY] = ['byhour'].concat(common)
        ToText.IMPLEMENTED[RRule.WEEKLY] = common
        ToText.IMPLEMENTED[RRule.MONTHLY] = common
        ToText.IMPLEMENTED[RRule.YEARLY] = ['byweekno', 'byyearday'].concat(common)

        /**
         * Test whether the rrule can be fully converted to text.
         * @param {RRule} rrule
         * @return {Boolean}
         */
        ToText.isFullyConvertible = function (rrule) {
            var canConvert = true

            if (!(rrule.options.freq in ToText.IMPLEMENTED)) return false
            if (rrule.origOptions.until && rrule.origOptions.count) return false

            for (var key in rrule.origOptions) {
                if (contains(['dtstart', 'wkst', 'freq'], key)) return true
                if (!contains(ToText.IMPLEMENTED[rrule.options.freq], key)) return false
            }

            return canConvert
        }

        ToText.prototype = {
            constructor: ToText,

            isFullyConvertible: function () {
                return ToText.isFullyConvertible(this.rrule)
            },

            /**
             * Perform the conversion. Only some of the frequencies are supported.
             * If some of the rrule's options aren't supported, they'll
             * be omitted from the output an "(~ approximate)" will be appended.
             * @return {*}
             */
            toString: function () {
                var gettext = this.gettext

                if (!(this.options.freq in ToText.IMPLEMENTED)) {
                    return gettext('RRule error: Unable to fully convert this rrule to text')
                }

                this.text = [gettext('every')]
                this[RRule.FREQUENCIES[this.options.freq]]()

                if (this.options.until) {
                    this.add(gettext('until'))
                    var until = this.options.until
                    this.add(this.language.monthNames[until.getMonth()])
                        .add(until.getDate() + ',')
                        .add(until.getFullYear())
                } else if (this.options.count) {
                    this.add(gettext('for'))
                        .add(this.options.count)
                        .add(this.plural(this.options.count)
                            ? gettext('times') : gettext('time'))
                }

                if (!this.isFullyConvertible()) this.add(gettext('(~ approximate)'))

                return this.text.join('')
            },

            HOURLY: function () {
                var gettext = this.gettext

                if (this.options.interval !== 1) this.add(this.options.interval)

                this.add(this.plural(this.options.interval)
                    ? gettext('hours') : gettext('hour'))
            },

            DAILY: function () {
                var gettext = this.gettext

                if (this.options.interval !== 1) this.add(this.options.interval)

                if (this.byweekday && this.byweekday.isWeekdays) {
                    this.add(this.plural(this.options.interval)
                        ? gettext('weekdays') : gettext('weekday'))
                } else {
                    this.add(this.plural(this.options.interval)
                        ? gettext('days') : gettext('day'))
                }

                if (this.origOptions.bymonth) {
                    this.add(gettext('in'))
                    this._bymonth()
                }

                if (this.bymonthday) {
                    this._bymonthday()
                } else if (this.byweekday) {
                    this._byweekday()
                } else if (this.origOptions.byhour) {
                    this._byhour()
                }
            },

            WEEKLY: function () {
                var gettext = this.gettext

                if (this.options.interval !== 1) {
                    this.add(this.options.interval)
                        .add(this.plural(this.options.interval)
                            ? gettext('weeks') : gettext('week'))
                }

                if (this.byweekday && this.byweekday.isWeekdays) {
                    if (this.options.interval === 1) {
                        this.add(this.plural(this.options.interval)
                            ? gettext('weekdays') : gettext('weekday'))
                    } else {
                        this.add(gettext('on')).add(gettext('weekdays'))
                    }
                } else {
                    if (this.options.interval === 1) this.add(gettext('week'))

                    if (this.origOptions.bymonth) {
                        this.add(gettext('in'))
                        this._bymonth()
                    }

                    if (this.bymonthday) {
                        this._bymonthday()
                    } else if (this.byweekday) {
                        this._byweekday()
                    }
                }
            },

            MONTHLY: function () {
                var gettext = this.gettext

                if (this.origOptions.bymonth) {
                    if (this.options.interval !== 1) {
                        this.add(this.options.interval).add(gettext('months'))
                        if (this.plural(this.options.interval)) this.add(gettext('in'))
                    } else {
                        // this.add(gettext('MONTH'))
                    }
                    this._bymonth()
                } else {
                    if (this.options.interval !== 1) this.add(this.options.interval)
                    this.add(this.plural(this.options.interval)
                        ? gettext('months') : gettext('month'))
                }
                if (this.bymonthday) {
                    this._bymonthday()
                } else if (this.byweekday && this.byweekday.isWeekdays) {
                    this.add(gettext('on')).add(gettext('weekdays'))
                } else if (this.byweekday) {
                    this._byweekday()
                }
            },

            YEARLY: function () {
                var gettext = this.gettext

                if (this.origOptions.bymonth) {
                    if (this.options.interval !== 1) {
                        this.add(this.options.interval)
                        this.add(gettext('years'))
                    } else {
                        // this.add(gettext('YEAR'))
                    }
                    this._bymonth()
                } else {
                    if (this.options.interval !== 1) this.add(this.options.interval)
                    this.add(this.plural(this.options.interval)
                        ? gettext('years') : gettext('year'))
                }

                if (this.bymonthday) {
                    this._bymonthday()
                } else if (this.byweekday) {
                    this._byweekday()
                }

                if (this.options.byyearday) {
                    this.add(gettext('on the'))
                        .add(this.list(this.options.byyearday, this.nth, gettext('and')))
                        .add(gettext('day'))
                }

                if (this.options.byweekno) {
                    this.add(gettext('in'))
                        .add(this.plural(this.options.byweekno.length) ? gettext('weeks') : gettext('week'))
                        .add(this.list(this.options.byweekno, null, gettext('and')))
                }
            },

            _bymonthday: function () {
                var gettext = this.gettext
                if (this.byweekday && this.byweekday.allWeeks) {
                    this.add(gettext('on'))
                        .add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext('or')))
                        .add(gettext('the'))
                        .add(this.list(this.bymonthday, this.nth, gettext('or')))
                } else {
                    this.add(gettext('on the'))
                        .add(this.list(this.bymonthday, this.nth, gettext('and')))
                }
                // this.add(gettext('DAY'))
            },

            _byweekday: function () {
                var gettext = this.gettext
                if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
                    this.add(gettext('on'))
                        .add(this.list(this.byweekday.allWeeks, this.weekdaytext))
                }

                if (this.byweekday.someWeeks) {
                    if (this.byweekday.allWeeks) this.add(gettext('and'))

                    this.add(gettext('on the'))
                        .add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext('and')))
                }
            },

            _byhour: function () {
                var gettext = this.gettext

                this.add(gettext('at'))
                    .add(this.list(this.origOptions.byhour, null, gettext('and')))
            },

            _bymonth: function () {
                this.add(this.list(this.options.bymonth, this.monthtext, this.gettext('and')))
            },

            nth: function (n) {
                var nth, npos
                var gettext = this.gettext

                if (n === -1) return gettext('last')

                npos = Math.abs(n)
                switch (npos) {
                    case 1:
                    case 21:
                    case 31:
                        nth = npos + gettext('st')
                        break
                    case 2:
                    case 22:
                        nth = npos + gettext('nd')
                        break
                    case 3:
                    case 23:
                        nth = npos + gettext('rd')
                        break
                    default:
                        nth = npos + gettext('th')
                }

                return n < 0 ? nth + ' ' + gettext('last') : nth
            },

            monthtext: function (m) {
                return this.language.monthNames[m - 1]
            },

            weekdaytext: function (wday) {
                var weekday = typeof wday === 'number' ? wday : wday.getJsWeekday()
                return (wday.n ? this.nth(wday.n) + ' ' : '') +
                    this.language.dayNames[weekday]
            },

            plural: function (n) {
                return n % 100 !== 1
            },

            add: function (s) {
                this.text.push(' ')
                this.text.push(s)
                return this
            },

            list: function (arr, callback, finalDelim, delim) {
                var delimJoin = function (array, delimiter, finalDelimiter) {
                    var list = ''

                    for (var i = 0; i < array.length; i++) {
                        if (i !== 0) {
                            if (i === array.length - 1) {
                                list += ' ' + finalDelimiter + ' '
                            } else {
                                list += delimiter + ' '
                            }
                        }
                        list += array[i]
                    }
                    return list
                }

                delim = delim || ','
                callback = callback || function (o) {
                    return o
                }
                var self = this
                var realCallback = function (arg) {
                    return callback.call(self, arg)
                }

                if (finalDelim) {
                    return delimJoin(arr.map(realCallback), delim, finalDelim)
                } else {
                    return arr.map(realCallback).join(delim + ' ')
                }
            }
        }

        // =============================================================================
        // fromText
        // =============================================================================
        /**
         * Will be able to convert some of the below described rules from
         * text format to a rule object.
         *
         *
         * RULES
         *
         * Every ([n])
         *       day(s)
         *     | [weekday], ..., (and) [weekday]
         *     | weekday(s)
         *     | week(s)
         *     | month(s)
         *     | [month], ..., (and) [month]
         *     | year(s)
         *
         *
         * Plus 0, 1, or multiple of these:
         *
         * on [weekday], ..., (or) [weekday] the [monthday], [monthday], ... (or) [monthday]
         *
         * on [weekday], ..., (and) [weekday]
         *
         * on the [monthday], [monthday], ... (and) [monthday] (day of the month)
         *
         * on the [nth-weekday], ..., (and) [nth-weekday] (of the month/year)
         *
         *
         * Plus 0 or 1 of these:
         *
         * for [n] time(s)
         *
         * until [date]
         *
         * Plus (.)
         *
         *
         * Definitely no supported for parsing:
         *
         * (for year):
         *     in week(s) [n], ..., (and) [n]
         *
         *     on the [yearday], ..., (and) [n] day of the year
         *     on day [yearday], ..., (and) [n]
         *
         *
         * NON-TERMINALS
         *
         * [n]: 1, 2 ..., one, two, three ..
         * [month]: January, February, March, April, May, ... December
         * [weekday]: Monday, ... Sunday
         * [nth-weekday]: first [weekday], 2nd [weekday], ... last [weekday], ...
         * [monthday]: first, 1., 2., 1st, 2nd, second, ... 31st, last day, 2nd last day, ..
         * [date]:
         *     [month] (0-31(,) ([year])),
         *     (the) 0-31.(1-12.([year])),
         *     (the) 0-31/(1-12/([year])),
         *     [weekday]
         *
         * [year]: 0000, 0001, ... 01, 02, ..
         *
         * Definitely not supported for parsing:
         *
         * [yearday]: first, 1., 2., 1st, 2nd, second, ... 366th, last day, 2nd last day, ..
         *
         * @param {String} text
         * @return {Object, Boolean} the rule, or null.
         */
        var fromText = function (text, language) {
            return new RRule(parseText(text, language))
        }

        var parseText = function (text, language) {
            var options = {}
            var ttr = new Parser((language || ENGLISH).tokens)

            if (!ttr.start(text)) return null

            S()
            return options

            function S () {
                // every [n]
                var n

                ttr.expect('every')
                if ((n = ttr.accept('number'))) options.interval = parseInt(n[0], 10)
                if (ttr.isDone()) throw new Error('Unexpected end')

                switch (ttr.symbol) {
                    case 'day(s)':
                        options.freq = RRule.DAILY
                        if (ttr.nextSymbol()) {
                            AT()
                            F()
                        }
                        break

                    // FIXME Note: every 2 weekdays != every two weeks on weekdays.
                    // DAILY on weekdays is not a valid rule
                    case 'weekday(s)':
                        options.freq = RRule.WEEKLY
                        options.byweekday = [
                            RRule.MO,
                            RRule.TU,
                            RRule.WE,
                            RRule.TH,
                            RRule.FR
                        ]
                        ttr.nextSymbol()
                        F()
                        break

                    case 'week(s)':
                        options.freq = RRule.WEEKLY
                        if (ttr.nextSymbol()) {
                            ON()
                            F()
                        }
                        break

                    case 'hour(s)':
                        options.freq = RRule.HOURLY
                        if (ttr.nextSymbol()) {
                            ON()
                            F()
                        }
                        break

                    case 'month(s)':
                        options.freq = RRule.MONTHLY
                        if (ttr.nextSymbol()) {
                            ON()
                            F()
                        }
                        break

                    case 'year(s)':
                        options.freq = RRule.YEARLY
                        if (ttr.nextSymbol()) {
                            ON()
                            F()
                        }
                        break

                    case 'monday':
                    case 'tuesday':
                    case 'wednesday':
                    case 'thursday':
                    case 'friday':
                    case 'saturday':
                    case 'sunday':
                        options.freq = RRule.WEEKLY
                        options.byweekday = [RRule[ttr.symbol.substr(0, 2).toUpperCase()]]

                        if (!ttr.nextSymbol()) return

                        // TODO check for duplicates
                        while (ttr.accept('comma')) {
                            if (ttr.isDone()) throw new Error('Unexpected end')

                            var wkd
                            if (!(wkd = decodeWKD())) {
                                throw new Error('Unexpected symbol ' + ttr.symbol + ', expected weekday')
                            }

                            options.byweekday.push(RRule[wkd])
                            ttr.nextSymbol()
                        }
                        MDAYs()
                        F()
                        break

                    case 'january':
                    case 'february':
                    case 'march':
                    case 'april':
                    case 'may':
                    case 'june':
                    case 'july':
                    case 'august':
                    case 'september':
                    case 'october':
                    case 'november':
                    case 'december':
                        options.freq = RRule.YEARLY
                        options.bymonth = [decodeM()]

                        if (!ttr.nextSymbol()) return

                        // TODO check for duplicates
                        while (ttr.accept('comma')) {
                            if (ttr.isDone()) throw new Error('Unexpected end')

                            var m
                            if (!(m = decodeM())) {
                                throw new Error('Unexpected symbol ' + ttr.symbol + ', expected month')
                            }

                            options.bymonth.push(m)
                            ttr.nextSymbol()
                        }

                        ON()
                        F()
                        break

                    default:
                        throw new Error('Unknown symbol')

                }
            }

            function ON () {
                var on = ttr.accept('on')
                var the = ttr.accept('the')
                if (!(on || the)) return

                do {
                    var nth, wkd, m

                    // nth <weekday> | <weekday>
                    if ((nth = decodeNTH())) {
                        // ttr.nextSymbol()

                        if ((wkd = decodeWKD())) {
                            ttr.nextSymbol()
                            if (!options.byweekday) options.byweekday = []
                            options.byweekday.push(RRule[wkd].nth(nth))
                        } else {
                            if (!options.bymonthday) options.bymonthday = []
                            options.bymonthday.push(nth)
                            ttr.accept('day(s)')
                        }
                        // <weekday>
                    } else if ((wkd = decodeWKD())) {
                        ttr.nextSymbol()
                        if (!options.byweekday) options.byweekday = []
                        options.byweekday.push(RRule[wkd])
                    } else if (ttr.symbol === 'weekday(s)') {
                        ttr.nextSymbol()
                        if (!options.byweekday) options.byweekday = []
                        options.byweekday.push(RRule.MO)
                        options.byweekday.push(RRule.TU)
                        options.byweekday.push(RRule.WE)
                        options.byweekday.push(RRule.TH)
                        options.byweekday.push(RRule.FR)
                    } else if (ttr.symbol === 'week(s)') {
                        ttr.nextSymbol()
                        var n
                        if (!(n = ttr.accept('number'))) {
                            throw new Error('Unexpected symbol ' + ttr.symbol + ', expected week number')
                        }
                        options.byweekno = [n[0]]
                        while (ttr.accept('comma')) {
                            if (!(n = ttr.accept('number'))) {
                                throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday')
                            }
                            options.byweekno.push(n[0])
                        }
                    } else if ((m = decodeM())) {
                        ttr.nextSymbol()
                        if (!options.bymonth) options.bymonth = []
                        options.bymonth.push(m)
                    } else {
                        return
                    }
                } while (ttr.accept('comma') || ttr.accept('the') || ttr.accept('on'))
            }

            function AT () {
                var at = ttr.accept('at')
                if (!at) return

                do {
                    var n
                    if (!(n = ttr.accept('number'))) {
                        throw new Error('Unexpected symbol ' + ttr.symbol + ', expected hour')
                    }
                    options.byhour = [n[0]]
                    while (ttr.accept('comma')) {
                        if (!(n = ttr.accept('number'))) {
                            throw new Error('Unexpected symbol ' + ttr.symbol + '; expected hour')
                        }
                        options.byhour.push(n[0])
                    }
                } while (ttr.accept('comma') || ttr.accept('at'))
            }

            function decodeM () {
                switch (ttr.symbol) {
                    case 'january':
                        return 1
                    case 'february':
                        return 2
                    case 'march':
                        return 3
                    case 'april':
                        return 4
                    case 'may':
                        return 5
                    case 'june':
                        return 6
                    case 'july':
                        return 7
                    case 'august':
                        return 8
                    case 'september':
                        return 9
                    case 'october':
                        return 10
                    case 'november':
                        return 11
                    case 'december':
                        return 12
                    default:
                        return false
                }
            }

            function decodeWKD () {
                switch (ttr.symbol) {
                    case 'monday':
                    case 'tuesday':
                    case 'wednesday':
                    case 'thursday':
                    case 'friday':
                    case 'saturday':
                    case 'sunday':
                        return ttr.symbol.substr(0, 2).toUpperCase()
                    default:
                        return false
                }
            }

            function decodeNTH () {
                switch (ttr.symbol) {
                    case 'last':
                        ttr.nextSymbol()
                        return -1
                    case 'first':
                        ttr.nextSymbol()
                        return 1
                    case 'second':
                        ttr.nextSymbol()
                        return ttr.accept('last') ? -2 : 2
                    case 'third':
                        ttr.nextSymbol()
                        return ttr.accept('last') ? -3 : 3
                    case 'nth':
                        var v = parseInt(ttr.value[1], 10)
                        if (v < -366 || v > 366) throw new Error('Nth out of range: ' + v)

                        ttr.nextSymbol()
                        return ttr.accept('last') ? -v : v

                    default:
                        return false
                }
            }

            function MDAYs () {
                ttr.accept('on')
                ttr.accept('the')

                var nth
                if (!(nth = decodeNTH())) return

                options.bymonthday = [nth]
                ttr.nextSymbol()

                while (ttr.accept('comma')) {
                    if (!(nth = decodeNTH())) {
                        throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday')
                    }

                    options.bymonthday.push(nth)
                    ttr.nextSymbol()
                }
            }

            function F () {
                if (ttr.symbol === 'until') {
                    var date = Date.parse(ttr.text)

                    if (!date) throw new Error('Cannot parse until date:' + ttr.text)
                    options.until = new Date(date)
                } else if (ttr.accept('for')) {
                    options.count = ttr.value[0]
                    ttr.expect('number')
                    // ttr.expect('times')
                }
            }
        }

        // =============================================================================
        // Parser
        // =============================================================================

        var Parser = function (rules) {
            this.rules = rules
        }

        Parser.prototype.start = function (text) {
            this.text = text
            this.done = false
            return this.nextSymbol()
        }

        Parser.prototype.isDone = function () {
            return this.done && this.symbol == null
        }

        Parser.prototype.nextSymbol = function () {
            var best, bestSymbol
            var p = this

            this.symbol = null
            this.value = null
            do {
                if (this.done) return false

                var match, rule
                best = null
                for (var name in this.rules) {
                    rule = this.rules[name]
                    if ((match = rule.exec(p.text))) {
                        if (best == null || match[0].length > best[0].length) {
                            best = match
                            bestSymbol = name
                        }
                    }
                }

                if (best != null) {
                    this.text = this.text.substr(best[0].length)

                    if (this.text === '') this.done = true
                }

                if (best == null) {
                    this.done = true
                    this.symbol = null
                    this.value = null
                    return
                }
            } while (bestSymbol === 'SKIP')

            this.symbol = bestSymbol
            this.value = best
            return true
        }

        Parser.prototype.accept = function (name) {
            if (this.symbol === name) {
                if (this.value) {
                    var v = this.value
                    this.nextSymbol()
                    return v
                }

                this.nextSymbol()
                return true
            }

            return false
        }

        Parser.prototype.expect = function (name) {
            if (this.accept(name)) return true

            throw new Error('expected ' + name + ' but found ' + this.symbol)
        }

        // =============================================================================
        // i18n
        // =============================================================================

        var ENGLISH = {
            dayNames: [
                'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday'
            ],
            monthNames: [
                'January', 'February', 'March', 'April', 'May',
                'June', 'July', 'August', 'September', 'October',
                'November', 'December'
            ],
            tokens: {
                'SKIP': /^[ \r\n\t]+|^\.$/,
                'number': /^[1-9][0-9]*/,
                'numberAsText': /^(one|two|three)/i,
                'every': /^every/i,
                'day(s)': /^days?/i,
                'weekday(s)': /^weekdays?/i,
                'week(s)': /^weeks?/i,
                'hour(s)': /^hours?/i,
                'month(s)': /^months?/i,
                'year(s)': /^years?/i,
                'on': /^(on|in)/i,
                'at': /^(at)/i,
                'the': /^the/i,
                'first': /^first/i,
                'second': /^second/i,
                'third': /^third/i,
                'nth': /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
                'last': /^last/i,
                'for': /^for/i,
                'time(s)': /^times?/i,
                'until': /^(un)?til/i,
                'monday': /^mo(n(day)?)?/i,
                'tuesday': /^tu(e(s(day)?)?)?/i,
                'wednesday': /^we(d(n(esday)?)?)?/i,
                'thursday': /^th(u(r(sday)?)?)?/i,
                'friday': /^fr(i(day)?)?/i,
                'saturday': /^sa(t(urday)?)?/i,
                'sunday': /^su(n(day)?)?/i,
                'january': /^jan(uary)?/i,
                'february': /^feb(ruary)?/i,
                'march': /^mar(ch)?/i,
                'april': /^apr(il)?/i,
                'may': /^may/i,
                'june': /^june?/i,
                'july': /^july?/i,
                'august': /^aug(ust)?/i,
                'september': /^sep(t(ember)?)?/i,
                'october': /^oct(ober)?/i,
                'november': /^nov(ember)?/i,
                'december': /^dec(ember)?/i,
                'comma': /^(,\s*|(and|or)\s*)+/i
            }
        }

        // =============================================================================
        // Export
        // =============================================================================

        return {
            fromText: fromText,
            parseText: parseText,
            isFullyConvertible: ToText.isFullyConvertible,
            toText: function (rrule, gettext, language) {
                return new ToText(rrule, gettext, language).toString()
            }
        }
    }
}))

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/amd/shim/rrule-amd.js' */
define("tc/rrule", function () {
    var rrule = null;
    try {
        rrule = require("rrule");
    }catch(e) {
    }
    return rrule || RRule;
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-model.js' */
define("tc/repeat-model",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil
    ) {
        "use strict";

        /**
         * Backbone model which represent the whole RRULE
         */
        var repeatModel = Backbone.Model.extend({
            defaults: {
                isUnsupportedRrule: false,
                isDisable: false,
                freq: null,
                dtstart: null,
                interval: null,
                wkst: null,
                count: null,
                until: null,
                bysetpos: null,
                bymonth: null,
                bymonthday: null,
                byyearday: null,
                byweekno: null,
                byweekday: null,
                bynweekday: null,
                byhour: null,
                byminute: null,
                bysecond: null,
                byeaster: null
            },
            /**
             * Initialize model from RRRULE string (Ideally that value is from server)
             */
            initialize: function(params) {
                this.rruleStr = params.rruleStr ? params.rruleStr : "";
                // an current event object, we could find start date and end date here
                this.event = params.event;
                this._rrule = TCRRule.RRule.fromString(this.rruleStr);

                this.set(
                    {
                        isDisable: params.isDisable,
                        isUnsupportedRrule: false
                    });
                // set all rrule attribute
                this.set(this._rrule.origOptions);
            },
            /**
             * Get back iCalendar RRULE from this model
             */
            getRRuleAsString: function () {
                // all view need to update model according to it current state
                this.trigger("rrule-string", {model: this});
                if (this.attributes.freq === null || this.attributes.freq === -1) {
                    return "";
                }

                if (this.attributes.isDisable) {
                    // if repeat-model is disable then we won't generate new rule just return old one
                    return this.rruleStr;
                }

                var newRule = new TCRRule.RRule({
                    freq: this.attributes.freq,
                    dtstart: this.attributes.dtstart,
                    interval: this.attributes.interval,
                    wkst: this.attributes.wkst,
                    count: this.attributes.count,
                    until: this.attributes.until,
                    bysetpos: this.attributes.bysetpos,
                    bymonth: this.attributes.bymonth,
                    bymonthday: this.attributes.bymonthday,
                    byyearday: this.attributes.byyearday,
                    byweekno: this.attributes.byweekno,
                    byweekday: this.attributes.byweekday,
                    bynweekday: this.attributes.bynweekday,
                    byhour: this.attributes.byhour,
                    byminute: this.attributes.byminute,
                    bysecond: this.attributes.bysecond,
                    byeaster: this.attributes.byeaster
                });
                var rruleStr = newRule.toString();
                console.log("Computed RRULE: " + rruleStr);
                return rruleStr;
            },
            trigger: function() {
                console.debug('Event', arguments);
                Backbone.Model.prototype.trigger.apply(this, arguments);
            }
        });

        return repeatModel;
    });

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-base-child-component.js' */
define("tc/repeat-base-child-component",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone"
    ],
    function (
        $,
        TCRRule,
        Backbone
    ) {
        "use strict";

        var baseChildComponent = Backbone.View.extend({
            /**
             * Hacky to dynamically set $el on view
             *
             * @param new$el
             */
            setJQueryEl: function(new$el){
                this.undelegateEvents();
                this.$el = new$el;
                this.delegateEvents();
            },
            /**
             * Contain logic to hide dom element if condition does not match
             *
             * @param notShowInFrequencys array of frequency view want to hide
             * @param currentFrequency current selected frequency value
             * @param current$El current $el of the view
             * @return true if hidden and false if not
             * @private
             */
            hideIfNotMatch: function(notShowInFrequencys, currentFrequency, current$El) {
                if (notShowInFrequencys && notShowInFrequencys.indexOf(currentFrequency) >= 0 ) {
                    if (!current$El.hasClass("hidden")) {
                        current$El.addClass("hidden");
                    }
                    return true;
                }

                if (current$El.hasClass("hidden")) {
                    current$El.removeClass("hidden");
                }

                return false;
            }
        });

        return baseChildComponent;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-frequency.js' */
define("tc/repeat-frequency",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "underscore",
        "tc/repeat-base-child-component"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        _,
        BaseChildComponentView
    ) {
        "use strict";

        var repeatFrequencyView = BaseChildComponentView.extend({
            template: Confluence.TeamCalendars.Templates.Fields.repeatFrequency,
            _freqSelect: null,
            events: {
                "change select#freq-select": "updateModel"
            },
            /**
             * This view relies on freq attribute of model
             */
            initialize: function (options) {
                var modelAttributes = this.model.attributes;

                this.setJQueryEl(options.$el);

                this.$el.html($(this.template()).html());
                this._freqSelect = this.$el.find("select#freq-select");
                if ($.fn.auiSelect2) {
                    // only enable select2 if we have it
                    this._freqSelect.auiSelect2({
                        minimumResultsForSearch: -1
                    });
                }

                var frequencySelection = "";
                switch(TCRRule.FREQUENCIES[modelAttributes.freq]) {
                    case TCRRule.FREQUENCIES[TCRRule.WEEKLY]:
                    case TCRRule.FREQUENCIES[TCRRule.DAILY]:
                    case TCRRule.FREQUENCIES[TCRRule.MONTHLY]:
                    case TCRRule.FREQUENCIES[TCRRule.YEARLY]:
                        frequencySelection = TCRRule.FREQUENCIES[modelAttributes.freq];
                        break;
                    case TCRRule.FREQUENCIES[TCRRule.HOURLY]:
                    case TCRRule.FREQUENCIES[TCRRule.MINUTELY]:
                    case TCRRule.FREQUENCIES[TCRRule.SECONDLY]:
                    default:
                        // no value
                        frequencySelection = "";
                }
                // view model for this view
                this.model.set({frequencySelection: frequencySelection});
                this.model.on('change:isDisable', this.render, this);
                this.model.on('change:frequencySelection', this.render, this);
                this.model.on('rrule-string', this.updateModel, this);
            },
        /**
             *  For updating model
             */
            updateModel: function() {
                var modelAttributes = this.model.attributes;
                if (modelAttributes.isDisable){
                    console.debug("Won't update model for repeat frequency component because model is disable state");
                    return;
                }

                var selected = this._freqSelect.val();
                this.model.set({frequencySelection: selected});
                this.model.set({freq: TCRRule.FREQUENCIES.indexOf(selected)});
                console.debug("Update model for repeat frequency component");
            },
            /**
             * Rendering whatever value in model except WEEKLY
             *
             * @returns {repeatFrequencyView}
             */
            render: function() {
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    return;
                }

                if ($.fn.auiSelect2) {
                    this._freqSelect.auiSelect2("enable");
                    this._freqSelect.auiSelect2('val', modelAttributes.frequencySelection);
                } else {
                    this._freqSelect.removeAttr("disabled");
                    this._freqSelect.val(modelAttributes.frequencySelection);
                }

                console.debug("Render repeat frequency component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));

                // Disable after fill up data
                if (modelAttributes.isDisable) {
                    console.debug("Disable repeat frequency component because model is disable state");
                    if ($.fn.auiSelect2) {
                        console.debug("AUI disable only");
                        this._freqSelect.auiSelect2("disable");
                    } else {
                        console.debug("Normal disable");
                        this._freqSelect.attr("disabled", "disabled");
                    }
                }
            }
        });

        return repeatFrequencyView;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-interval.js' */
define("tc/repeat-interval",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "underscore",
        "tc/repeat-base-child-component"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        _,
        BaseChildComponentView
    ) {
        "use strict";

        var repeatIntervalView = BaseChildComponentView.extend({
            template: Confluence.TeamCalendars.Templates.Fields.repeatInterval,
            _intervalTxtField: null,
            _intervalLabel: null,
            _notShowInFrequency: [""],
            events: {
                "change input#repeat-interval-txtField": "updateModel"
            },
            /**
             * This view relies on freq and interval attributes of model
             */
            initialize: function (options) {
                this.setJQueryEl(options.$el);

                this.$el.html($(this.template()).html());
                this._intervalLabel = this.$el.find(".interval-label");
                this._intervalTxtField = this.$el.find("#repeat-interval-txtField");

                this.model.on('change:frequencySelection', this.render, this);
                this.model.on('change:isDisable', this.render, this);
                this.model.on('rrule-string', this.updateModel, this);

                this.model.set({interval: this.model.attributes.interval || 1});
            },
            /**
             *  For updating model.
             *  We call this method on both UI changes and 'rrule-string' which means that
             *  we won't remember last inputted value
             */
            updateModel: function() {
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    this.model.set({interval: null});
                    return;
                }

                var modelAttributes = this.model.attributes;
                if (modelAttributes.isDisable){
                    console.debug("Won't update model for repeat interval component because model is disable state");
                    return;
                }

                var intervalVal = this._intervalTxtField.val();
                intervalVal = parseInt(intervalVal);
                intervalVal = intervalVal >= 1 ? intervalVal : 1;
                this.model.set({interval: intervalVal});
                console.debug("update model for repeat interval component");
                this.render();
            },
            /**
             * Rendering interval setting
             */
            render: function (){
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    return;
                }

                this._intervalTxtField.removeAttr("readonly", "readonly");
                this._intervalTxtField.val(modelAttributes.interval);
                this._createLabelInterval(modelAttributes.frequencySelection, this._intervalTxtField.val(), this._intervalLabel);

                console.debug("Render repeat interval component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));

                // Disable after fill up data
                if (modelAttributes.isDisable) {
                    console.debug("Disable repeat interval because model is disable state");
                    this._intervalTxtField.attr("readonly", "readonly");
                    this._intervalTxtField.attr("disabled", "disabled");
                } else {
                    this._intervalTxtField.removeAttr("readonly", "readonly");
                    this._intervalTxtField.removeAttr("disabled", "disabled");
                }
            },
            /**
             * Update interval label according to selectedFreq value
             * @param selectedFreq
             * @param interval
             * @param intervalSpan
             * @private
             */
            _createLabelInterval : function(selectedFreq, interval, intervalSpan) {
                if (/^[1-9]\d*$/.test(interval) || interval === "0") {
                    if (selectedFreq === "DAILY") {
                        intervalSpan.text(
                            parseInt(interval) > 1 ? "\u65e5" :
                                "\u65e5");
                    } else if (selectedFreq === TCRRule.FREQUENCIES[TCRRule.WEEKLY]) {
                        intervalSpan.text(
                            parseInt(interval) > 1 ? "\u5468" :
                                "\u5468");
                    } else if (selectedFreq === TCRRule.FREQUENCIES[TCRRule.MONTHLY]) {
                        intervalSpan.text(
                            parseInt(interval) > 1 ? "\u6708" :
                                "\u6708");
                    } else if (selectedFreq === TCRRule.FREQUENCIES[TCRRule.YEARLY]) {
                        intervalSpan.text(
                            parseInt(interval) > 1 ? "\u5e74" :
                                "\u5e74");
                    }
                } else {
                    intervalSpan.text("");
                }
            }
        });


        return repeatIntervalView;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-on.js' */
define("tc/repeat-on",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "underscore",
        "tc/repeat-base-child-component"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        _,
        BaseChildComponentView
    ) {
        "use strict";

        var repeatOnView = BaseChildComponentView.extend({
            _WEEKDAY: [
                TCRRule.MO, TCRRule.TU, TCRRule.WE, TCRRule.TH, TCRRule.FR, TCRRule.SA, TCRRule.SU
            ],
            _templates: {
                "WEEKLY" :Confluence.TeamCalendars.Templates.Fields.repeatOnWeekly,
                "MONTHLY": Confluence.TeamCalendars.Templates.Fields.repeatOnMonthly
            },
            _notShowInFrequency: ["", "DAILY", "YEARLY"],
            _monthlyFreq: "MONTHLY",
            _weeklyFreq: "WEEKLY",
            _supportingFrequencies: ["MONTHLY", "WEEKLY"],
            options: null,
            events: {
                "change .repeat-on-container input[type='checkbox']": "updateModel"
            },
            /**
             * Initialize repeatOnView
             */
            initialize: function (options) {
                this.setJQueryEl(options.$el);

                this.options = options;
                this.initializeTemplate(this.options);

                if (!this.validateInput()){
                    this.model.set({isUnsupportedRrule: true});
                    return;
                }

                this.model.on('change:isDisable', this.render, this);
                this.model.on('change:frequencySelection', this.initializeTemplateAndRender, this);
                this.model.on('rrule-string', this.updateModel, this);
            },
            initializeTemplateAndRender: function() {
                this.initializeTemplate(this.options);
                this.render();
            },
            initializeTemplate: function(options) {
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    return;
                }

                // change template base on frequency
                var template = this._templates[modelAttributes.frequencySelection];

                this.$el.html($(template()).html());

                var component = this;
                var componentElement = this.$el;

                // because we replace el so it is safe to add UI event listener
                if (this._weeklyFreq === modelAttributes.frequencySelection) {

                    // event listening on UI component
                    componentElement.on("change", "input[type='checkbox']", function() {
                        var element = $(this);
                        element.bind(component.updateModel(), this);
                    });

                    // try to select default value for weekday
                    if (!modelAttributes.byweekday) {
                        modelAttributes.byweekday = [this.model.event ? this._dateToWeekday($.fullCalendar.parseDate(this.model.event.start)) : TCRRule.MO];

                        console.debug("The default value of weekday is ===========> " + modelAttributes.byweekday);
                    }
                }

                if (this._monthlyFreq === modelAttributes.frequencySelection){
                    if ($.fn.auiSelect2) {
                        componentElement.find("select.select").each(function (index, dropdownElement) {
                            $(dropdownElement).auiSelect2({
                                minimumResultsForSearch: -1,
                            });
                        })
                    }

                    componentElement.on("change", "select.select", function() {
                        var element = $(this);
                        element.bind(component.updateModel(), this);
                    });

                    componentElement.on("change", "input.radio", function() {
                        var element = $(this);
                        element.bind(component.updateModel(), this);
                    });

                    // if we don't have bymonthday then just set default value for byweekday as today
                    if (!this.model.rruleStr || this.model.rruleStr === "") {
                        // only set default value if we don't have rrule string input
                        if (!modelAttributes.bymonthday && this.model.event) {
                            if (!modelAttributes.byweekday) {
                                modelAttributes.byweekday = [this._dateToWeekday($.fullCalendar.parseDate(this.model.event.start))];

                                console.debug("The default value of weekday is ===========> " + modelAttributes.byweekday);
                            }
                        }
                    }
                }
            },
            validateInput: function () {
                var modelAttributes = this.model.attributes;
                if (this._supportingFrequencies.indexOf(modelAttributes.frequencySelection) === -1 && modelAttributes.byweekday) {
                    // it makes no sense if we have byweekday in unsupported frequencySelection
                    console.debug("Validate failed on repeat on because of invalid frequencySelection");
                    return false;
                }

                if (modelAttributes.byweekday && modelAttributes.bymonthday){
                    console.debug("Validate failed on repeat on because of 'byweekday' and 'bymonthday could not exist at the same time'");
                    return false;
                }

                if (this._monthlyFreq === modelAttributes.frequencySelection) {
                    var modelAttributes = this.model.attributes;
                    if (!modelAttributes.bymonthday && modelAttributes.byweekday){
                        var pos = modelAttributes.byweekday[0].n;
                        var supportedPos = [1, 2, 3, 4, -1];
                        if (supportedPos.indexOf(pos) === -1) {
                            console.debug("Validate failed on repeat on because of invalid pos in 'byweekday' on monthly: " + pos);
                            return false;
                        }
                    }
                }

                if (this._weeklyFreq === modelAttributes.frequencySelection) {
                    if (!modelAttributes.byweekday) {
                        return false;
                    }

                    var validationResult = true;
                    $.each(modelAttributes.byweekday, function(index, item) {
                        var pos = item.n;
                        if (pos > 1) {
                            console.debug("Validate failed on repeat on because of invalid pos " + pos + " in 'byweekday' on weekly: " + item );
                            validationResult = false;
                            return;
                        }
                    });

                    if (!validationResult) return validationResult;
                }

                return true;
            },
            /**
             *  For updating model
             */
            updateModel: function() {
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    // if not visible then those attributes should be empty
                    this.model.set({byweekday: null, bymonthday: null});
                    return;
                }

                if (modelAttributes.isDisable){
                    console.debug("Won't update model for repeat on component because model is disable state");
                    return;
                }

                if ("WEEKLY" === modelAttributes.frequencySelection) {
                    this._updateModelOnRepeatOnWeekly();
                    return;
                }

                if ("MONTHLY" === modelAttributes.frequencySelection) {
                    this._updateModelOnRepeatOnMonthly();
                }
                console.debug("Update model for repeat on component" + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));
                this.render();
            },
            _dateToWeekday: function(date) {
                if (!date) {
                    return  TCRRule.MO;
                }

                switch (date.getDay()) {
                    case 1:
                        return TCRRule.MO;
                    case 2:
                        return TCRRule.TU;
                    case 3:
                        return TCRRule.WE;
                    case 4:
                        return TCRRule.TH;
                    case 5:
                        return TCRRule.FR;
                    case 6:
                        return TCRRule.SA;
                    case 0:
                        return TCRRule.SU;
                    default:
                        return TCRRule.MO;
                }
            },
            /**
             * This will update 'byweekday' property only
             *
             * @private
             */
            _updateModelOnRepeatOnWeekly: function() {
                var byweekday = [];
                var component = this;
                var componentElement = this.$el;
                componentElement.find("input[type='checkbox']").each(function(index, element) {
                    if (element.checked) {
                        byweekday.push(component._WEEKDAY[$(element).val()]);
                    }
                });
                this.model.set({byweekday: byweekday, bymonthday: null});
            },
            /**
             * This will update :
             *  - Monthly only : 'byweekday' property
             *  - By day : 'bymonthday'
             *
             * @private
             */
            _updateModelOnRepeatOnMonthly: function() {
                var bypos = null;
                var byweekday = null;
                if (this.$el.find("#monthlyRepeatOnSameDay").is(":checked")){
                    bypos = this.$el.find("#monthlyRepeatOnSameDayByMonthDay").val();
                    byweekday = this.$el.find("#monthlyRepeatOnSameDayByWeekDay").val();
                }

                if ("day" === byweekday) {
                    this.model.set({bymonthday: bypos, byweekday: null});
                }else{
                    this.model.set(
                        {
                            bymonthday: null,
                            byweekday: this._WEEKDAY[byweekday] ? this._WEEKDAY[byweekday].nth(bypos) : null
                        });
                }
            },
            /**
             * Rendering repeat on
             */
            render: function (){
                var modelAttributes = this.model.attributes;
                var componentElement = this.$el;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)){
                    return;
                }

                if ("WEEKLY" === modelAttributes.frequencySelection) {
                   this._renderRepeatOnWeekly(componentElement);
                }

                if ("MONTHLY" === modelAttributes.frequencySelection) {
                    this._renderRepeatOnMonthly(componentElement);
                }

                // Disable after fill up data
                if (modelAttributes.isDisable){
                    this._disable(componentElement);
                    console.debug("Disable repeat on because model is disable state");
                }

                console.debug("Render repeat on component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));
            },
            _disable: function(componentElement) {
                var modelAttributes = this.model.attributes;
                if ("WEEKLY" === modelAttributes.frequencySelection) {
                    componentElement.find("input[type='checkbox']").attr("disabled", "disabled");
                }

                if ("MONTHLY" === modelAttributes.frequencySelection) {
                    componentElement.find("#monthlyRepeatOnSameDate").attr("disabled", "disabled");
                    componentElement.find("#monthlyRepeatOnSameDay").attr("disabled", "disabled");

                    if ($.fn.auiSelect2) {
                        componentElement.find("#monthlyRepeatOnSameDayByMonthDay").auiSelect2("disable");
                        componentElement.find("#monthlyRepeatOnSameDayByWeekDay").auiSelect2("disable");
                    } else {
                        componentElement.find("#monthlyRepeatOnSameDayByMonthDay").attr("disabled", "disabled");
                        componentElement.find("#monthlyRepeatOnSameDayByWeekDay").attr("disabled", "disabled");
                    }
                }
            },
            _renderRepeatOnMonthly: function(componentElement) {
                var modelAttributes = this.model.attributes;
                var container = componentElement.find("#monthlyRepeatOnSameDayContainer");

                container.removeClass("hidden");
                //Enable it first
                componentElement.find("#monthlyRepeatOnSameDate").removeAttr("disabled", "disabled");
                componentElement.find("#monthlyRepeatOnSameDay").removeAttr("disabled", "disabled");

                if ($.fn.auiSelect2) {
                    componentElement.find("#monthlyRepeatOnSameDayByMonthDay").auiSelect2("enable");
                    componentElement.find("#monthlyRepeatOnSameDayByWeekDay").auiSelect2("enable");
                } else {
                    componentElement.find("#monthlyRepeatOnSameDayByMonthDay").removeAttr("disabled", "disabled");
                    componentElement.find("#monthlyRepeatOnSameDayByWeekDay").removeAttr("disabled", "disabled");
                }

                // fill in data
                if (!modelAttributes.byweekday && !modelAttributes.bymonthday) {
                    componentElement.find("#monthlyRepeatOnSameDate").prop("checked", true);
                    componentElement.find("#monthlyRepeatOnSameDay").prop("checked", false);
                    container.addClass("hidden");
                } else {
                    componentElement.find("#monthlyRepeatOnSameDate").prop("checked", false);
                    componentElement.find("#monthlyRepeatOnSameDay").prop("checked", true);
                    // display setting options
                    container.removeClass("hidden");

                    var setValues = function (byMonthDay, byWeekday) {
                        if ($.fn.auiSelect2) {
                            container.find("#monthlyRepeatOnSameDayByMonthDay").auiSelect2('val', byMonthDay);
                            container.find("#monthlyRepeatOnSameDayByWeekDay").auiSelect2('val', byWeekday);
                        } else {
                            container.find("#monthlyRepeatOnSameDayByMonthDay").val(byMonthDay);
                            container.find("#monthlyRepeatOnSameDayByWeekDay").val(byWeekday);
                        }
                    };

                    if (modelAttributes.byweekday && modelAttributes.bymonthday){
                        // TODO unsupported
                        return;
                    } else {
                        if (modelAttributes.bymonthday) {
                            var pos = modelAttributes.bymonthday;
                            setValues(pos, "day");
                        } else {
                            var byweekday =  modelAttributes.byweekday[0] || modelAttributes.byweekday;
                            var pos = byweekday.n;
                            setValues(pos, byweekday.weekday);
                        }
                    }
                }
            },
            _renderRepeatOnWeekly: function(componentElement) {
                var modelAttributes = this.model.attributes;

                //Enable it first
                componentElement.find("input[type='checkbox']").removeAttr("disabled", "disabled");

                if (modelAttributes.byweekday) {
                    modelAttributes.byweekday.forEach(function (weekday) {
                        var item = componentElement.find("input[value='" + weekday.weekday +  "']");
                        $(item).prop('checked', true);
                    });
                }
            }
        });

        return repeatOnView;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-recur-end.js' */
define("tc/repeat-recur-end",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "underscore",
        "tc/repeat-base-child-component"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        _,
        BaseChildComponentView
    ) {
        "use strict";
        var recurEndView = BaseChildComponentView.extend({
            template: Confluence.TeamCalendars.Templates.Fields.repeatRecurEnd,
            _recurEndNeverChbox: null,
            _recurEndTimesChBox: null,
            _recurEndTimesTxt: null,
            _recurEndUtilChBox: null,
            _recurEndUtilDatePicker: null,
            _notShowInFrequency: [""],
            _calendarDiv: null,
            _calendarPlugin: null,
            /**
             * Function which come from outside which help to create date picker.
             * Ideally, a method in line 479 of event-field-handler will be passed in here.
             */
            createDatePicker: null,
            events: {
                "change input#recur-end-times-txtField": "updateModel",
                "change input[type='radio']": "updateModel",
            },
            /**
             * This view relies on count and until attributes of model
             */
            initialize: function (options) {
                if (!this.validateInput()){
                    this.model.set({isUnsupportedRrule: true});
                    return;
                }

                this.setJQueryEl(options.$el);

                this.$el.html($(this.template()).html());
                this._calendarDiv = options._calendarDiv;
                this._calendarPlugin = options._calendarPlugin;
                this._recurEndNeverChbox = this.$el.find("#recur-end-never");
                this._recurEndTimesChBox = this.$el.find("#recur-end-times");
                this._recurEndTimesTxt = this.$el.find("#recur-end-times-txtField");

                this._recurEndUtilChBox = this.$el.find("#recur-end-until");
                this._recurEndUtilDatePicker = this.$el.find("input.datepicker-field#until");
                this.createDatePicker = options.createDatePicker;
                // create datetimepicker and onSelect callback.
                // Sadly I don't know how to register datetimepicker's onSelect event with Backbone
                // noted remember createDatePicker has to support to call the callback with 'this' context
                this.createDatePicker(this._recurEndUtilDatePicker, _.bind(this.updateModel, this));
                this._isInitDatePicker = false;

                // register some attributes as view model for this view
                var attributes = this.model.attributes;
                var isSelectedEndNever = (attributes.count === null || attributes.count === 0) && attributes.until === null;
                var isSelectedEndTimes = isSelectedEndNever ? !isSelectedEndNever : attributes.count !== null;
                var isSelectedEndUntil = isSelectedEndNever ? !isSelectedEndNever : attributes.until !== null;

                if (attributes.until == null){
                    this.model.set({until: $.fullCalendar.parseDate(this.model.event.start)});
                }
                this.model.set({isSelectedEndNever: isSelectedEndNever});
                this.model.set({isSelectedEndTimes: isSelectedEndTimes});
                this.model.set({isSelectedEndUntil: isSelectedEndUntil});

                this.model.on('change:isDisable', this.render, this);
                this.model.on('change:frequencySelection', this.render, this);
                this.model.on('rrule-string', this.updateModel, this);
            },
            validateInput: function () {
                var attributes = this.model.attributes;
                if (attributes.count && attributes.until) {
                    console.debug("Validate failed on repeat end because having both 'count' and 'until'");
                    return false;
                }

                return true;
            },
            /**
             *  For updating model according to selected option
             *
             *  From UI to Model
             */
            updateModel: function() {
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    // if not visible then those attributes should be empty
                    this.model.set({count : null, until: null});
                    return;
                }

                if (modelAttributes.isDisable){
                    console.debug("Won't update model for repeat recur end component because model is disable state");
                    return;
                }

                var isSelectedEndNever = this._recurEndNeverChbox.is(':checked');
                var isSelectedEndTimes = this._recurEndTimesChBox.is(':checked');
                var isSelectedEndUntil = this._recurEndUtilChBox.is(':checked');
                var updatedCount = modelAttributes.count || 1;
                var updatedUntil = modelAttributes.until || $.fullCalendar.parseDate(this.model.event.start);

                if(isSelectedEndNever) {
                    updatedCount = null;
                    updatedUntil = null;
                } else if (isSelectedEndTimes) {
                    var count = this._recurEndTimesTxt.val();
                    updatedCount = count && count >= 1 ? count : updatedCount;
                    updatedUntil = null;
                } else if (isSelectedEndUntil) {
                    var selectedDate = this._recurEndUtilDatePicker.tcDatePicker('getDate');
                    var endUntilDate = selectedDate ? selectedDate : null;
                    if (endUntilDate) {
                        updatedUntil = endUntilDate;
                    }
                    updatedCount = null;
                }

                // Notify change to update UI
                this.model.set({count: updatedCount});
                this.model.set({until: updatedUntil});
                this.model.set({isSelectedEndNever: isSelectedEndNever});
                this.model.set({isSelectedEndTimes: isSelectedEndTimes});
                this.model.set({isSelectedEndUntil: isSelectedEndUntil});
                console.debug("Update model for repeat recur end component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));
                this.render();
            },
            /**
             * Rendering option based on value we have in our model
             *
             * From Model to UI
             */
            render: function (){
                var modelAttributes = this.model.attributes;
                if (this.hideIfNotMatch &&
                    this.hideIfNotMatch(this._notShowInFrequency, modelAttributes.frequencySelection, this.$el)) {
                    return;
                }

                // First enable UI component
                this._recurEndNeverChbox.removeAttr("disabled", "disabled");
                this._recurEndTimesChBox.removeAttr("disabled", "disabled");
                this._recurEndTimesTxt.removeAttr("disabled", "disabled");
                this._recurEndTimesTxt.removeAttr("readonly", "readonly");
                this._recurEndUtilChBox.removeAttr("disabled", "disabled");

                // Check option never end
                if (modelAttributes.isSelectedEndNever) {
                    this.changeStateOfEndNever(true);
                    this.changeStateOfEndTimes(false);
                    this.changeStateOfEndUtil(false);
                }

                // Check option end after times
                if (modelAttributes.isSelectedEndTimes) {
                    this.changeStateOfEndNever(false);
                    this.changeStateOfEndTimes(true);
                    this.changeStateOfEndUtil(false);
                }

                // Check option end until
                if (modelAttributes.isSelectedEndUntil) {
                    this.changeStateOfEndNever(false);
                    this.changeStateOfEndTimes(false);
                    this.changeStateOfEndUtil(true);
                }

                // Disable after fill up data
                if (modelAttributes.isDisable) {
                    console.debug("Disable repeat recur end because model is disable state");
                    this._recurEndNeverChbox.attr("disabled", "disabled");

                    this._recurEndTimesChBox.attr("disabled", "disabled");
                    this._recurEndTimesTxt.attr("disabled", "disabled");
                    this._recurEndTimesTxt.attr("readonly", "readonly");

                    this._recurEndUtilChBox.attr("disabled", "disabled");
                    this._recurEndUtilDatePicker.attr("readonly", "readonly").tcDatePicker("disable");
                }

                console.debug("Render repeat recur end component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: modelAttributes
                }));
            },
            changeStateOfEndNever: function(isEnable) {
                // enable by default
                this._recurEndNeverChbox.prop('checked', isEnable);
            },
            changeStateOfEndTimes: function(isEnable) {
                var attributes = this.model.attributes;
                var recurEndTimesTxt = this._recurEndTimesTxt;
                this._recurEndTimesChBox.prop('checked', isEnable);
                if (isEnable) {
                    recurEndTimesTxt.removeAttr("disabled", "disabled");
                    recurEndTimesTxt.removeAttr("readonly", "readonly");
                    recurEndTimesTxt.val(attributes.count ? attributes.count : 1);
                } else {
                    recurEndTimesTxt.attr("disabled", "disabled");
                    recurEndTimesTxt.attr("readonly", "readonly");
                    recurEndTimesTxt.val("");
                }
            },
            changeStateOfEndUtil: function (isEnable) {
                var attributes = this.model.attributes;
                var recurEndUtilDatePicker = this._recurEndUtilDatePicker;

                this._recurEndUtilChBox.prop('checked', isEnable);
                if (isEnable) {
                    recurEndUtilDatePicker.removeAttr("readonly").tcDatePicker("enable");
                    var dateToDisplay = attributes.until;
                    var localisedDate = null;
                    if (this.model.event) {
                        localisedDate = this.model.event.localisedDate;
                    }

                    recurEndUtilDatePicker.tcDatePicker("setDate", dateToDisplay);
                    recurEndUtilDatePicker.tcDatePicker("option", "defaultDate", dateToDisplay);
                    recurEndUtilDatePicker.data("date", localisedDate || this._formatDate(recurEndUtilDatePicker, dateToDisplay));
                } else {
                    if (!recurEndUtilDatePicker.is("[readonly]")) {
                        recurEndUtilDatePicker.attr("readonly", "readonly").tcDatePicker("disable");
                    }
                }
            },
            _formatDate: function(recurEndUtilDatePicker, date) {
                if (this._calendarPlugin) {
                    this._calendarPlugin.formatDate(this._calendarDiv, date, "date", function (value) {
                        recurEndUtilDatePicker.val(value);
                    });
                }
                return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
            }
        });

        return recurEndView;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/repeat-field/repeat-component.js' */
define("tc/repeat-component",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "tc/repeat-frequency",
        "tc/repeat-interval",
        "tc/repeat-recur-end",
        "tc/repeat-on",
        "underscore"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        RepeatFrequencyView,
        RepeatIntervalView,
        RecurEndView,
        RepeatOnView,
        _
    ) {
        "use strict";

        var repeatComponentView = Backbone.View.extend({
            template: Confluence.TeamCalendars.Templates.Fields.repeatComponent,
            unsupportedTemplate: Confluence.TeamCalendars.Templates.Fields.repeatComponentUnSupported,
            fieldsDiv: null,
            _calendarDiv: null,
            _calendarPlugin: null,
            _editThisInstanceOnlyContainer: null,
            _isEditRecurrenceEvent: false,
            frequencyView: null,
            intervalView: null,
            recurEndView: null,
            repeatOnView: null,
            initialize: function (options) {
                if (!this.validateInput()) {
                    this.model.set({isUnsupportedRrule: true});
                }

                // ideally $el will be fieldsDiv so we just append content of this component
                this.$el = $(this.template(this.model.attributes));
                this.fieldsDiv = options.fieldsDiv;
                this._calendarDiv = options._calendarDiv;
                this._calendarPlugin = options._calendarPlugin;
                this._isEditRecurrenceEvent = this.model.event.recur ? true : false;
                this._editThisInstanceOnlyContainer = this.$el.find(".edit-this-instance-only-container");
                this._editThisInstanceOnlyContainer.change(_.bind(this.updateModel, this));

                this.frequencyView = new RepeatFrequencyView({
                    model: this.model,
                    $el: this.$el.find(".field-group.frequency-container")
                });

                this.intervalView = new RepeatIntervalView({
                    model: this.model,
                    $el: this.$el.find(".field-group.interval-container")
                });

                this.repeatOnView = new RepeatOnView({
                    model: this.model,
                    $el: this.$el.find(".group.repeat-on-container")
                });

                this.recurEndView = new RecurEndView({
                    model: this.model,
                    $el: this.$el.find(".date-select.recur-ends-container"),
                    createDatePicker: options.createDatePicker,
                    _calendarDiv: this._calendarDiv,
                    _calendarPlugin: this._calendarPlugin
                });

                this.model.set({isDisable: this._isEditRecurrenceEvent});
                this.model.on("change:isUnsupportedRrule", this.render, this);
            },
            validateInput: function() {
                var modelAttribute = this.model.attributes;
                var unsupportedAttrs = ["bysetpos", "bymonth", "byyearday",
                    "byweekno", "bynweekday", "byhour", "byminute", "bysecond", "byeaster"];
                for (var key in modelAttribute) {
                    if (unsupportedAttrs.indexOf(key) !== -1) {
                        if (modelAttribute[key]) {
                            return false;
                        }
                    }
                }

                return true;
            },
            updateModel: function() {
                // Only update model if we are editing recurrence event
                if (this._isEditRecurrenceEvent) {
                    var isDisableRepeat = this._editThisInstanceOnlyContainer.find("#editthisinstanceonly").prop('checked');
                    this.model.set({isDisable: isDisableRepeat});
                }

                console.debug("Update model for repeat component");
            },
            render: function() {
                if (this.model.attributes.isUnsupportedRrule) {
                    this.$el.html($(this.unsupportedTemplate()).html());
                    this.$el.addClass("field-group");
                    if (!$.contains(this.fieldsDiv[0], this.$el[0])) {
                        this.fieldsDiv.append(this.$el);
                    }
                    return;
                }

                if (this._isEditRecurrenceEvent) {
                    if (this._editThisInstanceOnlyContainer.hasClass("hidden")) {
                        this._editThisInstanceOnlyContainer.removeClass("hidden");
                    }

                    this._editThisInstanceOnlyContainer.find("#editthisinstanceonly").prop('checked', this.model.attributes.isDisable);
                } else {
                    if (!this._editThisInstanceOnlyContainer.hasClass("hidden")) {
                        this._editThisInstanceOnlyContainer.addClass("hidden");
                    }
                }

                this.frequencyView.render();
                this.intervalView.render();
                this.recurEndView.render();
                this.repeatOnView.render();

                // concat el to fieldsDiv
                this.fieldsDiv.append(this.$el);

                console.debug("Render repeat component: " + JSON.stringify({
                    innerHtml : this.$el.html(),
                    modelAttrs: this.model.attributes
                }));
            }
        });

        return repeatComponentView;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-field-handlers.js' */
/**
 * This code creates the FieldHandler objects. Each FieldHandler object must implement the following methods:
 *   add() - This method adds a field to the fieldsDiv and sets up any Javascript needed to make the field work.
 *   init() - This initializes the field to either its default value, or a value taken from the event object.
 *   getData() - This returns the data contained in the fields as key-value pairs.
 *
 * Each field handler expects the field object to have different properties defined.
 *
 * See also:
 *   event-types.js - This is currently where the mappings of fields to event types lives.
 *   event-edit-dialog.js - The code that uses these FieldHandlers.
 *   event-fields.soy - The soy templates for the fields.
 */
define("tc/event-field-handlers",
    [
        "jquery",
        "tc/jira-event-field-process",
        "tc/calendar-util",
        "tc/repeat-model",
        "tc/repeat-component",
        "tc/form-state-control"
    ],
    function (
        $,
        JiraEventFieldProcess,
        CalUtil,
        RepeatModel,
        RepeatComponentView,
        FormStateControl
    )
    {
        "use strict";
        $.fn.tcDatePicker = $.fn.tcDatePicker.noConflict();
        var tcDatePicker = $.tcDatePicker.noConflict();

        function createDatePicker(datePickerElement, options){
            var $datePickerElement = datePickerElement instanceof $ ? datePickerElement : $(datePickerElement);
            $datePickerElement.tcDatePicker(options);
        }

        function createLabelInterval(selectedFreq, interval, intervalSpan) {
            if (/^[1-9]\d*$/.test(interval) || interval === "0") {
                if (selectedFreq === "DAILY") {
                    intervalSpan.text(
                        parseInt(interval) > 1 ? "\u65e5" : "\u65e5");
                } else if (selectedFreq === "WEEKLY") {
                    intervalSpan.text(
                        parseInt(interval) > 1 ? "\u5468" : "\u5468");
                } else if (selectedFreq === "MONTHLY") {
                    intervalSpan.text(
                        parseInt(interval) > 1 ? "\u6708" : "\u6708");
                } else if (selectedFreq === "YEARLY") {
                    intervalSpan.text(
                        parseInt(interval) > 1 ? "\u5e74" : "\u5e74");
                }
            } else {
                intervalSpan.text("");
            }
        }

        var eventFieldHandlers = {

            /**
             * A simple text field. Expects the field object to have the following properties:
             *   id - The id of the field.
             *   label - A label for the field.
             *   required - Is the field required?
             *   property - The property on the event object that the field value is taken from.
             *
             *   TODO: make id and property the same. Need to fix in event object.
             */
            text : function (field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(
                            Confluence.TeamCalendars.Templates.Fields.text({
                                "id" : field.id,
                                "label" : field.label,
                                "required" : field.required,
                                "readOnly" : field.readOnly
                            })
                        );
                    },
                    init : function () {
                        $("#" + field.id + "-text", fieldsDiv).val(event[field.property] || "").keydown(function() {
                            // This is to set a flag into the input field indicating that the value has been changed by the user.
                            // The use of this is by JIRA event types to not change the event series name after the user
                            // has typed in something for the name.
                            var nameInputField = $(this),
                                name = nameInputField.val();

                            if (!nameInputField.data("valueChangedByUser")) {
                                setTimeout(function() {
                                    if (name !== nameInputField.val()) {
                                        nameInputField.data("valueChangedByUser", true);
                                    }
                                }, 300);
                            }
                        });
                    },
                    setData: function(valueDefault) {
                        eventEditDialog.getField(fieldsDiv, field.id).val(valueDefault);
                    },
                    getData : function() {
                        var data = {};

                        data[field.id] = eventEditDialog.getField(fieldsDiv, field.id).val();
                        return data;
                    },
                    getElementId : function() {
                        return "#field-text-" + field.id;
                    }
                };
            },

            /**
             * A textarea field. Expects the field object to have the following properties:
             *   id - The id of the field.
             *   size - The size of the textarea in lines.
             *   label - A label for the field.
             *   required - Is the field required?
             *   property - The property on the event object that the field value is taken from.
             *
             *   TODO: make id and property the same. Need to fix in event object.
             */
            textarea : function (field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(
                            Confluence.TeamCalendars.Templates.Fields.textarea({
                                "id" :  field.id,
                                "size" : field.size,
                                "required" : field.required,
                                "label" : field.label,
                                "readOnly" : field.readOnly
                            })
                        );
                    },
                    init : function() {
                        $("#" + field.id + "-textarea", fieldsDiv).val(event[field.property] || "");
                    },
                    getData : function() {
                        var data = {};
                        data[field.id] = $("textarea[name=" + field.id + "]", fieldsDiv).val();
                        return data;
                    },
                    getElementId : function() {
                        return "#field-textarea-" + field.id;
                    }
                };
            },

            /**
             * A Page field, can be used to enter a url or confluence page. Includes confluence page drop down.
             * Expects the field object to have the following properties:
             *   id - The id of the field.
             *   label - A label for the field.
             *   required - Is the field required?
             *   property - The property on the event object that the field value is taken from.
             *
             *   TODO: make id and property the same. Need to fix in event object.
             */
            page : function (field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(
                            Confluence.TeamCalendars.Templates.Fields.page({
                                "id" : field.id,
                                "label" : field.label,
                                "required" : field.required,
                                "readOnly" : field.readOnly
                            })
                        );
                    },
                    init : function () {
                        $("#" + field.id + "-text", fieldsDiv).val(event[field.property] || "");

                        CalendarPlugin.makeAutoCompleteSearch(
                                calendarDiv,
                                $("input[name='" + field.id + "']", fieldsDiv),
                                { type: [ "page", "blogpost" ] },
                                $("." + field.id + "-suggestions", fieldsDiv),
                                function(searchField, suggestionLink) {
                                    searchField.val(suggestionLink.attr("href"));
                                }
                        );

                    },
                    getData : function() {
                        var data = {},
                            theField = eventEditDialog.getField(fieldsDiv, field.id);

                        data[field.id] = theField.hasClass("with-hint") ? "" : theField.val();
                        return data;
                    },
                    getElementId : function() {
                        return "#field-page-" + field.id;
                    }
                };
            },

            /**
             * Adds a 'when' field to the form. Consists of a start and end date and time pickers, and an all-day checkbox.
             * Expects the field object to have the following properties:
             *   id - id of the field.
             *
             */
            when : function (field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        var startTimeField, endTimeField, allDayEventCheckbox, timeSuggestions;

                        fieldsDiv.append(Confluence.TeamCalendars.Templates.Fields.when({
                            "id" : field.id,
                            "disableStartDateTime" : field.disableStartDateTime,
                            "disableEndDateTime" : field.disableEndDateTime,
                            "disableAllDay" : field.disableAllDay
                        }));

                        startTimeField = eventEditDialog.getField(fieldsDiv, "startTime");
                        endTimeField = eventEditDialog.getField(fieldsDiv, "endTime");
                        allDayEventCheckbox = eventEditDialog.getField(fieldsDiv, "allDayEvent");

                        //Setup autocomplete for time fields
                        timeSuggestions = CalendarPlugin.getParameter(calendarDiv, "timeSuggestion");
                        startTimeField.autocompleteTC({ source : timeSuggestions, minLength : 2 });
                        endTimeField.autocompleteTC({ source : timeSuggestions, minLength : 2 });

                        //Set up All Day Event checkbox
                        allDayEventCheckbox.click(function() {
                            if (this.checked) {
                                startTimeField.addClass("hidden");
                                endTimeField.addClass("hidden");
                            } else {
                                startTimeField.removeClass("hidden");
                                endTimeField.removeClass("hidden");
                                if (!startTimeField.val()) {
                                    startTimeField.val(CalendarPlugin.getDefaultStartTime(calendarDiv));
                                }
                                if (!endTimeField.val()) {
                                    endTimeField.val(CalendarPlugin.getDefaultEndTime(calendarDiv));
                                }
                            }
                        });
                    },
                    init : function() {
                        $(".start, .end", fieldsDiv).each(function() {
                            var datePicker = $(this);
                            createDatePicker(datePicker, {
                                "dateFormat" : "ddmmyy",
                                "dayNames" : CalendarPlugin.getDayNames(),
                                "dayNamesMin": CalendarPlugin.getDayNamesShort(),
                                "dayNamesShort" : CalendarPlugin.getDayNamesShort(),
                                "firstDay" : CalendarPlugin.getParameter(calendarDiv, "firstDayOfWeek"),
                                "monthNames" : CalendarPlugin.getMonthNames(),
                                "monthNamesShort" : CalendarPlugin.getMonthNamesShort(),
                                "beforeShow" : function() {
                                    $("#ui-datepicker-div").addClass("tc-datepicker");
                                },
                                "onClose" : function() {
                                    $("#ui-datepicker-div").removeClass("tc-datepicker");
                                },
                                "onSelect": function(dateText) {
                                    var selectedDate = tcDatePicker.parseDate("ddmmyy", dateText);

                                    if (datePicker.hasClass("start")) {
                                        var endDatePicker = $(".end", fieldsDiv),
                                            oldStartDate = new Date(parseInt(datePicker.data("date"))),
                                            newEndDate = new Date(endDatePicker.data("date") - (oldStartDate.getTime() - selectedDate.getTime()));

                                        endDatePicker.tcDatePicker("option", "defaultDate", newEndDate);
                                        endDatePicker.tcDatePicker("setDate", newEndDate);

                                        endDatePicker.data("date", newEndDate.getTime()).val(function() {
                                            CalendarPlugin.formatDate(calendarDiv, newEndDate, "date", function(formattedDate) {
                                                endDatePicker.val(formattedDate);
                                            });
                                            return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                        });

                                    }

                                    datePicker.tcDatePicker("option", "defaultDate", selectedDate);
                                    datePicker.tcDatePicker("setDate", selectedDate);

                                    datePicker.data("date", selectedDate.getTime()).val(function() {
                                        CalendarPlugin.formatDate(calendarDiv, selectedDate, "date", function(formattedDate) {
                                            datePicker.val(formattedDate);
                                        });
                                        return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                    });
                                },
                                "showAnim" : ""
                            });
                        });

                        var startTimeField = eventEditDialog.getField(fieldsDiv, "startTime"),
                            endTimeField = eventEditDialog.getField(fieldsDiv, "endTime"),
                            allDayEventField = eventEditDialog.getField(fieldsDiv, "allDayEvent"),

                            setDateField = function(name, date, localisedDate) {
                                var dateField = $("input[name=" + name + "]", fieldsDiv);

                                dateField.tcDatePicker("option", "defaultDate", date);
                                dateField.tcDatePicker("setDate", date);

                                dateField.data("date", date.getTime()).val(localisedDate || function() {
                                    CalendarPlugin.formatDate(calendarDiv, date, "date", function(value) {
                                        dateField.val(value);
                                    });
                                    return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                });
                            };

                        event.start && setDateField("startDate", event.start, event.localizedStartDate);
                        setDateField("endDate", event.end || event.start, event.localizedEndDate);

                        if (event.allDay) {
                            startTimeField.val("").addClass("hidden");
                            endTimeField.val("").addClass("hidden");
                            allDayEventField.attr("checked", "checked");
                        } else {
                            startTimeField.val(event.originalStartTime || event.localizedStartTime || function() {
                                        CalendarPlugin.formatDate(calendarDiv, event.start, "time", function(value) {
                                            startTimeField.val(value);
                                        });
                                        return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                    }
                            ).removeClass("hidden");
                            endTimeField.val(event.originalEndTime || event.localizedEndTime || function() {
                                        CalendarPlugin.formatDate(calendarDiv, event.end || new Date(event.start.getTime() + 3600000), "time", function(value) {
                                            endTimeField.val(value);
                                        });
                                        return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                    }
                            ).removeClass("hidden");

                            allDayEventField.removeAttr("checked", "checked");
                        }
                    },
                    getData : function() {
                        return {
                            startDate : eventEditDialog.getField(fieldsDiv, "startDate").val(),
                            startTime : eventEditDialog.getField(fieldsDiv, "startTime").val(),
                            endDate : eventEditDialog.getField(fieldsDiv, "endDate").val(),
                            endTime : eventEditDialog.getField(fieldsDiv, "endTime").val(),
                            allDayEvent : eventEditDialog.getField(fieldsDiv, "allDayEvent").is(":checked")
                        };
                    },
                    getElementId : function() {
                        return "#field-when";
                    }
                };
            },
            repeats2Model: null,
            repeats2 : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                var that = this;
                return {
                    model: null,
                    view: null,
                    add : function () {
                       var createDatePickerFactory = function($datePickerField, callback) {
                            createDatePicker($datePickerField, {
                                "dateFormat" : "ddmmyy",
                                "dayNames" : CalendarPlugin.getDayNames(),
                                "dayNamesMin": CalendarPlugin.getDayNamesShort(),
                                "dayNamesShort" : CalendarPlugin.getDayNamesShort(),
                                "firstDay" : CalendarPlugin.getParameter(calendarDiv, "firstDayOfWeek"),
                                "monthNames" : CalendarPlugin.getMonthNames(),
                                "monthNamesShort" : CalendarPlugin.getMonthNamesShort(),
                                "beforeShow" : function() {
                                    $("#ui-datepicker-div").addClass("tc-datepicker");
                                },
                                "onClose" : function() {
                                    $("#ui-datepicker-div").removeClass("tc-datepicker");
                                },
                                "onSelect": function(dateText) {
                                    var datePicker = $(this),
                                        selectedDate = tcDatePicker.parseDate("ddmmyy", dateText);

                                    datePicker.tcDatePicker("option", "defaultDate", selectedDate);
                                    datePicker.tcDatePicker("setDate", selectedDate);

                                    datePicker.data("date", selectedDate.getTime()).val(function() {
                                        CalendarPlugin.formatDate(calendarDiv, selectedDate, "date", function(formattedDate) {
                                            datePicker.val(formattedDate);
                                        });

                                        return "\u6b63\u5728\u8fdb\u884c\u683c\u5f0f\u5316...";
                                    });

                                    if (callback) {
                                        callback();
                                    }
                                },
                                "showAnim" : ""
                            });
                        };

                        that.repeats2Model = this.model = new RepeatModel({
                            rruleStr: event.rruleStr ? event.rruleStr : "",
                            event: event
                        });

                        this.view = new RepeatComponentView({
                            model: this.model,
                            fieldsDiv: fieldsDiv,
                            _calendarDiv: calendarDiv,
                            _calendarPlugin: CalendarPlugin,
                            createDatePicker: createDatePickerFactory
                        });
                    },
                    init : function() {
                        var setDateField = function(name, date, localisedDate) {
                            var dateField = $("input[name=" + name + "]", fieldsDiv);
                            dateField.tcDatePicker("option", "defaultDate", date);
                            dateField.tcDatePicker("setDate", date);
                            dateField.data("date", date.getTime()).val(localisedDate);
                        };

                        var disableFields = function(that, subCalendarSelect){
                            eventEditDialog.disableCalSelect();
                            eventEditDialog.showToolTip();
                            subCalendarSelect.attr("disabled", "disabled");
                            setDateField("startDate", event.start, event.localizedStartDate);
                            setDateField("endDate", event.end || event.start, event.localizedEndDate);
                        };

                        var enableFields = function(that, subCalendarSelect) {
                            eventEditDialog.enableCalSelect();
                            eventEditDialog.hiddenToolTip();
                            subCalendarSelect.removeAttr("disabled");

                            var originalStartDateTime = tcDatePicker.parseDate("yy-mm-dd", event.originalStartDateTime.split("T")[0]);
                            var originalEndDateTime = tcDatePicker.parseDate("yy-mm-dd", event.originalEndDateTime.split("T")[0]);
                            setDateField("startDate", originalStartDateTime, event.localizedOriginalStartDate);
                            setDateField("endDate", originalEndDateTime, event.localizedOriginalEndDate);
                        };

                        this.view.render();

                        var subCalendarSelect = $("select[name='calendar']", fieldsDiv);
                        var that = this;
                        if (event.recur) {
                            disableFields(that, subCalendarSelect);
                        }

                        $("input[name='editthisinstanceonly']", fieldsDiv).change(function() {
                            if ($(this).is(":checked")) {
                                disableFields(that, subCalendarSelect);
                            } else {
                                enableFields(that, subCalendarSelect);
                            }
                        });
                    },
                    getData : function() {
                        var model = this.model || that.repeats2Model;
                        var rruleStr = model.getRRuleAsString();
                        console.log("Final RRULE string is " + rruleStr);
                        return {
                            "rruleStr": rruleStr,
                            "editAllInRecurrenceSeries": !model.attributes.isDisable
                        }
                    },
                    getElementId : function() {
                        return "#field-repeats";
                    }
                };
            },
            /**
             * Allows selection of multiple users.
             */
            user : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function() {
                        fieldsDiv.append (
                            Confluence.TeamCalendars.Templates.Fields.user({
                                id :  field.id,
                                label : field.label,
                                required : field.required
                            })
                        );
                        //This makes the user dropdown component work.
                        Confluence.runBinderComponents();
                    },
                    init : function() {
                        var inviteeList = $(".invitees", fieldsDiv),

                            deleteInviteeHandler = function() {
                                $(this).closest("li").remove();

                                if (!$("li", inviteeList).length) {
                                    inviteeList.addClass("hidden");
                                }
                            },

                            ellipsisInviteeNames = function() {
                                $(".invitee-left", inviteeList).filter(function() {
                                    return !$(this).attr("threedots");
                                }).ThreeDots({
                                    max_rows : 1,
                                    text_span_class: "invitee-name-display",
                                    whole_word: false
                                });
                            };

                        $("#" + field.id + "-user-picker", fieldsDiv).bind("selected.autocomplete-user", function(e, selection) {
                            var selectedUserId = selection.content.userKey || selection.content.username,
                                userSelection,
                                userAlreadyAdded = $(".invitee", inviteeList).filter(function() {
                                    return $(this).data("entity").id === selectedUserId;
                                }).length > 0;

                            if (!userAlreadyAdded) {
                                if ($("li", inviteeList).length === 3) {
                                    inviteeList.addClass("boxed");
                                }

                                userSelection = $(Confluence.TeamCalendars.Templates.Fields.userSelection({
                                    "fullName" : selection.content.title,
                                    "userName" : selection.content.username,
                                    "imgPath" : selection.content.thumbnailLink.href
                                }));

                                userSelection.data("entity", {
                                    "id" : selectedUserId,
                                    "displayName" : selection.content.title
                                }).find(".delete-invitee").click(deleteInviteeHandler);

                                inviteeList.prepend(userSelection).removeClass("hidden");

                                ellipsisInviteeNames();
                            }

                            // focus() to workaround https://studio.plugins.atlassian.com/browse/TEAMCAL-229
                            $(this).val("").focus();

                            var whoErrorDiv = $(".who-error", fieldsDiv);
                            if (whoErrorDiv.children().length) {
                                // Only empty and resize dialog if the error div has elements in it to fix the
                                // problem where the dialog footer is longer than it should be in Chrome 12 + OS X Lion
                                whoErrorDiv.empty();
                            }
                        });

                        if (event.invitees && event.invitees.length) {
                            $.each(event.invitees, function(inviteeIdx, invitee) {
                                inviteeList.append(
                                    $(Confluence.TeamCalendars.Templates.Fields.userSelection({
                                        "fullName" : invitee.displayName,
                                        "userName" : invitee.name,
                                        "imgPath" : invitee.avatarIconUrl
                                    })).data("entity", {
                                            "id" : invitee.id,
                                            "displayName" : invitee.displayName
                                    })
                                );
                            });

                            $(".delete-invitee", inviteeList.removeClass("hidden")).unbind("click").click(deleteInviteeHandler);
                            ellipsisInviteeNames();
                        }
                    },
                    getData : function() {
                        var data = {};
                        var invitees = $(".invitee", fieldsDiv);

                        if (invitees.length) {
                            data.person = $.map(invitees, function(invitee) {
                                return $(invitee).data("entity").id;
                            });
                        }

                        if (field.setTitle) {
                            data.what = invitees.length ? $.map(invitees, function(invitee) {
                                return $(invitee).data("entity").displayName;
                            }).join(", ") : "";
                        }

                        return data;
                    },
                    getElementId : function() {
                        return "#field-user-" + field.id;
                    }
                };
            },

            getEventField : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog, valueDefault) {
                var fieldHandler = eventFieldHandlers[field.type](field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog);

                var fieldSelected = $(fieldHandler.getElementId(), fieldsDiv);
                //check if exist field, enable that field.
                if (fieldSelected.length) {
                    //check dose who field has required?
                    if (field.required) {
                        var fieldRequired = fieldSelected.find("label:first span.icon-required");
                        if (fieldRequired.length === 0) {
                            fieldSelected.find("label:first").append($("<span/>", {"class": "aui-icon icon icon-required" }));
                        }
                    } else {
                        fieldSelected.find("label:first span.icon-required").remove();
                    }
                    fieldsDiv.append(fieldSelected.show());

                    if (field.type === "repeats2") {
                        if (field.defaultRecur) {
                            eventFieldHandlers.repeats2Model.set({frequencySelection: field.defaultRecur.freq});
                        }
                    }
                } else {
                    fieldHandler.add();
                    fieldHandler.init();
                }

                if(field.copyto && valueDefault !== undefined) {
                    fieldHandler.setData(valueDefault);
                }

                return fieldHandler;
            },

            reminder : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                   add : function () {
                       var eventTypeReminder = CalendarPlugin.getCurrentReminderForEventType(calendarDiv, eventEditDialog);
                       $(fieldsDiv).find("#field-text-" + field.id).remove(); //remove old field reminder
                       var hasReminderPeriod = eventTypeReminder && eventTypeReminder.periodInMins > 0;
                       //Add field reminder when edit/create
                       fieldsDiv.append(
                           Confluence.TeamCalendars.Templates.Fields.inforReminderLabel({
                               "id" : field.id,
                               "label" : field.label,
                               "reminderPeriodText" : hasReminderPeriod ? AJS.format("{0}\u524d", CalUtil.showInforReminder(eventTypeReminder.periodInMins)) : "\u65e0\u3002",
                               "reminderPeriod": hasReminderPeriod ? eventTypeReminder.periodInMins : 0
                           })
                       );
                   },
                   init : function() {
                   },
                   getData : function() {
                       return {};
                   },
                   getElementId : function() {
                       return ""; //always create new field reminder when change event type
                   }
                };
            },

            /**
            * Adds hidden fields found on all JIRA event forms
            */
            "jira-hidden-fields" : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(Confluence.TeamCalendars.Templates.hiddenJiraFields());
                    },
                    init : function() {
                        var subCalendar = JiraEventFieldProcess.getSubCalendarForEvent(CalendarPlugin, calendarDiv, event),
                            callbackHandler = CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                            helper = Confluence.TeamCalendars.getEditCalendarDialogHelper(fieldsDiv, subCalendar, callbackHandler);

                        if (!subCalendar || !subCalendar.id) {
                            helper.setSubCalendarIdField("");
                            helper.setNameField("");
                            helper.setColorField("");
                            helper.setSpaceToDefault();
                        } else {
                            helper.setSubCalendarIdField(subCalendar.id);
                            helper.setNameField(subCalendar.name);
                            helper.setColorField(subCalendar.color);
                            helper.setSpaceKeyField(subCalendar.spaceKey);
                        }
                    },
                    getData : function() {
                        //Should never be called as JIRA events use a custom handler
                    }
                };
            },

            /*
            * A jira server selector
            */
            "jira-server-select" : function (field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(Confluence.TeamCalendars.Templates.Fields.serverSelector());
                        FormStateControl.disableElement(JiraEventFieldProcess.getServerSelect(fieldsDiv));
                    },
                    init : function() {
                        var serverSelect = JiraEventFieldProcess.getServerSelect(fieldsDiv),
                            spinner = $(".field-group-jira-server .spinner");

                        // clean up callbacks
                        AJS.unbind("server-select-ready.teamcalendars");
                        AJS.unbind("server-select-change.teamcalendars");

                        function populateDropDown (data) {
                            var subCalendar = JiraEventFieldProcess.getSubCalendarForEvent(CalendarPlugin, calendarDiv, event);

                            $.each(data.jiraLinks, function (jiraLinkIdx, jiraLink) {
                                var optionItem = $("<option/>", {
                                    "value":            jiraLink.id,
                                    "text":             jiraLink.name,
                                    "data-display-url": jiraLink.displayUrl
                                });

                                if (data.jiraLinks.length === 1) {
                                    //TEAMCAL-1719 - if there is only one option an then selected by default
                                    optionItem.prop('selected', true);
                                    var fieldGroup = serverSelect.parent();
                                    fieldGroup.children().hide();
                                    //stype layout when hide all children field
                                    fieldGroup.css("min-height", 0);
                                    // if already hide don't need to hide it again
                                    $('.oauth-error', fieldGroup).show();
                                }
                                optionItem.appendTo(serverSelect);
                            });

                            if (data.jiraLinks.length > 1)
                                $(".field-group-jira-server", fieldsDiv).removeClass("hidden");
                            
                            if(subCalendar) {
                                if(subCalendar.applicationId) {
                                    serverSelect.val(subCalendar.applicationId);
                                }
                                else if(subCalendar.sourceSubCalendar && subCalendar.sourceSubCalendar.applicationId){
                                        serverSelect.val(subCalendar.sourceSubCalendar.applicationId);
                                }
                            }
                        }

                        serverSelect.change(function() {
                            AJS.trigger("server-select-change.teamcalendars", fieldsDiv);
                        });

                        //Do ajax call to get available JIRA servers
                        $.ajax({
                            cache: false,
                            error: function(jqXHR, textStatus, errorThrown) {
                                CalendarPlugin.showAjaxError(fieldsDiv.parent().parent(), jqXHR, textStatus, errorThrown);
                            },
                            success: function(data) {
                                populateDropDown(data);
                                //Fire an event for anyone waiting for the drop down to be populated
                                AJS.trigger("server-select-ready.teamcalendars", fieldsDiv);
                            },
                            complete: function() {
                                FormStateControl.enableElement(serverSelect);
                                spinner.hide();
                            },
                            timeout : Confluence.TeamCalendars.ajaxTimeout,
                            url: Confluence.TeamCalendars.getCalendarServiceBaseUrl("/jira/jiraLinks")
                        });
                        //Set default value
                    },
                    getData : function() {
                        //Should never be called as JIRA events use a custom handler
                    }
                };
            },

            /*
            * A JIRA project selector.
            */
            "jira-project-select" : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(Confluence.TeamCalendars.Templates.Fields.projectSelector());
                        FormStateControl.disableElement($(".tc-jira-project", fieldsDiv));
                    },
                    init : function() {
                        function serverChanged(context) {
                            if (context.id === fieldsDiv[0].id) { //event may have been fired from another panel
                                $(".oauth-approve", fieldsDiv).remove();
                                JiraEventFieldProcess.populateProjectList(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog);
                            }
                        }

                        AJS.bind("server-select-ready.teamcalendars", function(event, context) {
                            serverChanged(context);
                        });

                        AJS.bind("server-select-change.teamcalendars", function(event, context) {
                            serverChanged(context);
                        });
                    },
                    getData : function() {
                        //Should never be called as JIRA events use a custom handler
                    }
                };
            },

            /*
             * Handles most of the fields on the JIRA issues date fields form. Lumped together for historical reasons.
             */
            "jira-dates" : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                return {
                    add : function () {
                        fieldsDiv.append(Confluence.TeamCalendars.Templates.editJiraCalendar());
                    },
                    init : function () {
                        //This is fired by the jira-server-select field in event-field-handlers.js
                        AJS.bind("server-select-ready.teamcalendars", function() {
                            JiraEventFieldProcess.initJiraDate(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog);
                        });

                        AJS.bind("server-select-change.teamcalendars", function() {
                            JiraEventFieldProcess.initJiraDate(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog);
                        });
                    },
                    getData : function() {
                         //Should never be called as JIRA events use a custom handler
                    }
                };
            }
        };

        return eventFieldHandlers;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/jira-event-field-process.js' */
define("tc/jira-event-field-process",
    [
        "jquery",
        "tc/calendar-util",
        "tc/form-state-control"
    ],
    function (
        $,
        CalUtil,
        FormStateControl
    )
    {
        "use strict";
        function sendJiraCalendar(requestData, fieldsDiv, callbackHandler, onErrorCallback, onSuccessCallback) {
            function onSubmitStart() {
               if (!$("input[name='subCalendarId']", fieldsDiv).val()) {
                   Confluence.TeamCalendars.fireEventForAnalytics(
                       "event.create.default." + requestData.type + ".context." + callbackHandler.getParameter("calendarContext"),
                       {}
                   );
               }
            }

            if (callbackHandler.isProcessingSubCalendar()) {
               return false;
            }

            var spinnerDefer = callbackHandler.setSubCalendarSpinnerIconVisible(true);
            onSubmitStart();

            if (callbackHandler.getIncludedCalendars()) {
               requestData.include = callbackHandler.getIncludedCalendars();
            }

            var subCalendarId = requestData.subCalendarId;
            CalUtil.putCalendarContextParams(requestData);

            $.ajax({
               cache : false,
               converters : {
                   "text json" : function(jsonObject) {
                       return jsonObject;
                   }
               },
               data : requestData,
               dataFilter : function(data) {
                   var subCalendarsResponseEntity = $.parseJSON(data);
                   if (subCalendarsResponseEntity.success) {
                       Confluence.TeamCalendars.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                   }
                   return subCalendarsResponseEntity;
               },
               dataType : "json",
               error : function(XMLHttpRequest, textStatus, errorThrown) {
                   callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                   onErrorCallback();
               },
               success : function(responseEntity) {
                  callbackHandler.setGenericUpdateError();

                   if (responseEntity.success) {
                       Confluence.TeamCalendars.setFieldErrors(fieldsDiv, null);

                       var subCalendarEdited = subCalendarId;
                       if (subCalendarEdited) {
                           callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                           callbackHandler.reloadSubCalendar(subCalendarId);
                       } else {
                           subCalendarId = responseEntity.modifiedSubCalendarId;
                           callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                       }

                       onSuccessCallback();
                       if (!responseEntity.modifiedSubCalendarId && callbackHandler.shouldShowFeatureDiscoveryDialog(subCalendarId)) {
                           callbackHandler.getSubCalendarFeatureDiscoveryDialog(subCalendarId);
                       }
                   } else {
                       Confluence.TeamCalendars.setFieldErrors(fieldsDiv, responseEntity.fieldErrors);
                       onErrorCallback();
                   }

               },
                complete: function(){
                    if (spinnerDefer) spinnerDefer.resolve();
                },
               type : "PUT",
               timeout: Confluence.TeamCalendars.ajaxTimeout,
               url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendars.json")
            });

            return false;
        }

        function getSimpleJiraFormData(fieldsDiv, name, parentSubCalendarId, field, type) {
            return {
               type : type,
               parentId: parentSubCalendarId,
               subCalendarId : $("input[name='subCalendarId']", fieldsDiv).val(),
               name : name,
               description : "",
               color : $("input[name='color']", fieldsDiv).val(),
               location : "jira://".concat(
                               encodeURIComponent(JiraEventFieldProcess.getServerSelect(fieldsDiv).val() || ""),
                               "?projectKey=",
                               encodeURIComponent($("select[name='tc-jira-project'] option:selected", fieldsDiv).val()),
                               "&dateFieldName=",
                               field
                           )
            };
        }

        var JiraEventFieldProcess = {
            getServerSelect : function(fieldsDiv) {
                return $(".tc-jira-server", fieldsDiv);
            },

            getJiraOptions : function(onError, onSuccess, server) {
                $.ajax({
                    cache:    false,
                    dataType: "json",
                    error:    function (XMLHttpRequest, textStatus, errorThrown) {
                        onError(XMLHttpRequest, textStatus, errorThrown);
                    },
                    success:  function (queryOptions) {
                        onSuccess(queryOptions);
                        var message = AJS.format("\u6211\u4eec\u672a\u627e\u5230\u4efb\u4f55\u9879\u76ee\u3002\u003ca href=\u0022{0}\u0022 target=\u0022_blank\u0022\u003e \u521b\u5efa\u4e00\u4e2a Jira \u9879\u76ee \u003c/a\u003e \u7ee7\u7eed\u3002", $(".tc-jira-server option:selected").data("display-url"));
                        $(".option-project .unavailable-message").html(message);
                    },
                    timeout:  Confluence.TeamCalendars.ajaxTimeout,
                    url:      Confluence.getBaseUrl() + "/rest/calendar-services/1.0/calendar/jira/" + encodeURIComponent(server) + "/query/options.json"
                });
            },

            getSubCalendarForEvent : function(CalendarPlugin, calendarDiv, event) {
                if (event.eventType === "jira-calendar" ||
                    event.eventType === "jira-agile-sprint-calendar" ||
                    event.eventType === "jira-project-releases-calendar") {
                        //This is not a new event, so get the child subCalendar it is associated with
                        return CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId);
                }

                return null;
            },

            showOauthRequitedMessage : function(XMLHttpRequest, fieldsDiv, eventEditDialog, controlsToToggleVisibleOnOAuthError, populateForm) {
                var responseEntity = $.parseJSON(XMLHttpRequest.responseText);
                var oAuthErrorContainer = $(".oauth-error", fieldsDiv).empty().removeClass("hidden");

                eventEditDialog.disableOkButton({"buttonText" : "\u786e\u5b9a" });
                $(document.createElement("div")).addClass("oauth-approve aui-message aui-message-hint hint").html(
                                AJS.format(
                                        "\u003ca href=\u0022#\u0022 class=\u0022approve-dance\u0022\u003e{0}\u003c/a\u003e \u67e5\u770b\u9879\u76ee\u5217\u8868",
                                        $(document.createElement("span")).text("\u767b\u5f55\u5e76\u5141\u8bb8").html()
                                )
                        ).appendTo(oAuthErrorContainer).find(".approve-dance").click(function () {
                            AppLinks.authenticateRemoteCredentials(
                                    responseEntity.oAuthUrl,
                                    function () {
                                        controlsToToggleVisibleOnOAuthError.removeClass("hidden");
                                        oAuthErrorContainer.addClass("hidden");
                                        eventEditDialog.enableOkButton();
                                        populateForm();
                                    },
                                    function () {
                                        alert("\u672a\u6210\u529f\u83b7\u5f97\u5ba1\u6279\u3002 \u53ef\u4ee5\u7684\u8bdd\uff0c\u60a8\u8fd8\u60f3\u518d\u8bd5\u4e00\u6b21\u5417\uff1f");
                                    }
                            );

                            return false;
                        });
            },

            populateProjectList : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                var jiraProjectSelector = $(".tc-jira-project", fieldsDiv),
                    spinner = $(".field-group-jira-project .spinner"),
                    jiraEventType = eventEditDialog.getSelectedEventType(),
                    server = JiraEventFieldProcess.getServerSelect().val(),

                    updateEventSeriesNameField = function() {
                        var nameInputField = $("input[name='name']", fieldsDiv),
                            subCalendar = JiraEventFieldProcess.getSubCalendarForEvent(CalendarPlugin, calendarDiv, event),

                            getName = function(computedName) {
                                if (!nameInputField.data("valueChangedByUser")) {
                                    return computedName;
                                }

                                return nameInputField.val();
                            };

                        if (!subCalendar) {
                            // Only do this when creating a new JIRA event type.
                            if (jiraEventType === "jira-agile-sprint-calendar") {
                                nameInputField.val(getName(AJS.format("{0} - \u51b2\u523a", $("option:selected", jiraProjectSelector).text())));
                            } else if (jiraEventType === "jira-project-releases-calendar") {
                                nameInputField.val(getName(AJS.format("{0} - \u53d1\u5e03", $("option:selected", jiraProjectSelector).text())));
                            }
                        }
                    };

                jiraProjectSelector.change(updateEventSeriesNameField);
                FormStateControl.disableElement(jiraProjectSelector);
                spinner.show();

                JiraEventFieldProcess.getJiraOptions(
                    function(jqXHR, textStatus, errorThrown) {
                        spinner.hide();

                        if (Confluence.TeamCalendars.isRequireOauth(jqXHR)) {
                            jiraProjectSelector.empty();
                            JiraEventFieldProcess.showOauthRequitedMessage(jqXHR, fieldsDiv, eventEditDialog, jiraProjectSelector, function() {
                                JiraEventFieldProcess.populateProjectList(server);
                            });
                        } else {
                            FormStateControl.enableElement(jiraProjectSelector);
                            CalendarPlugin.showAjaxError(fieldsDiv.parent().parent(), jqXHR, textStatus, errorThrown);
                        }
                    },
                    function(queryOptions) {
                        var projects = queryOptions.projects,
                            projectList = jiraProjectSelector.empty(),
                            subCalendar = JiraEventFieldProcess.getSubCalendarForEvent(CalendarPlugin, calendarDiv, event);

                        spinner.hide();
                        FormStateControl.enableElement(jiraProjectSelector);

                        $.each(projects, function (projectIdx, project) {
                            $(document.createElement("option")).val(project.key).text(project.name).appendTo(projectList);
                        });

                        if (subCalendar) {
                            projectList.val(subCalendar.projectKey);
                        } else {
                            updateEventSeriesNameField();
                        }
                    },
                    server
                );
            },

            initJiraDate : function(field, fieldsDiv, event, CalendarPlugin, calendarDiv, eventEditDialog) {
                //Holy crap there is a lot of code here! A brave person should try to refactor it.
                var subCalendar = JiraEventFieldProcess.getSubCalendarForEvent(CalendarPlugin, calendarDiv, event),
                    callbackHandler = CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),

                    projectSelect = $("select[name='project']", fieldsDiv),
                    updateJiraEventSeriesName = function() {
                        if (!subCalendar) {
                            var nameInputField = $("input[name='name']", fieldsDiv);

                            // Only do this for new JIRA event type
                            nameInputField.val(function() {
                                if (!nameInputField.data("valueChangedByUser")) {
                                    return $("option:selected", projectSelect).val() ? AJS.format("{0} - \u95ee\u9898", $("option:selected", projectSelect).text()) : "";
                                }

                                return nameInputField.val();
                            });

                            cleanErrorInForm();
                        }
                    };

                projectSelect
                    .off("change")
                    .on("change", updateJiraEventSeriesName);

                var cleanErrorInForm = function() {
                    //clean error
                    $(".project-error", fieldsDiv).empty();
                    $(".name-error", fieldsDiv).empty();
                    $(".dateFieldName-error", fieldsDiv).empty();
                };

                var setDateFieldsHidden = function(hideDateFields) {
                        var dateFieldsGroup = $(".field-group-jira-show", fieldsDiv);
                        if (hideDateFields) {
                            dateFieldsGroup.css("display", "none");
                        } else {
                            dateFieldsGroup.css("display", "block");
                        }
                    };

                var populateForm = function() {
                    var formMode = $(".form-mode", fieldsDiv),
                        serverSelect = JiraEventFieldProcess.getServerSelect(fieldsDiv),
                        projectOption = $(".jira-query-options .option-project", fieldsDiv),
                        projectSelect = $("select[name='project']", projectOption),
                        timeZoneIdDisplay = $(".timeZoneIdDisplay", fieldsDiv),
                        helper = Confluence.TeamCalendars.getEditCalendarDialogHelper(fieldsDiv, subCalendar, callbackHandler);

                    Confluence.TeamCalendars.setFieldErrors(fieldsDiv, null);

                    $("input[name='searchFilterName']", fieldsDiv).addClass("with-hint").val("\u641c\u7d22\u8fc7\u6ee4\u5668");
                    $("textarea[name='jql']", fieldsDiv).addClass("with-hint").val("JQL \u7591\u95ee");

                    if (!subCalendar || !subCalendar.id) {
                        helper.setFormModeCreate();
                        helper.setSubCalendarIdField("");
                        helper.setNameField("");
                        helper.setDescriptionField("");
                        helper.setColorField("");
                        helper.setSpaceToDefault();
                        helper.setTimeZoneIdDisplayField("");
                        timeZoneIdDisplay.hide();

                        populateQueryOptions(null, function () {
                            populateFieldsList(function () {
                                updateJiraEventSeriesName();
                            });
                        });
                    }
                    else
                    {
                        helper.setFormModeEdit();
                        helper.setSubCalendarIdField(subCalendar.id);
                        helper.setNameField(subCalendar.name);
                        helper.setDescriptionField(subCalendar.description);
                        helper.setColorField(subCalendar.color);
                        helper.setSpaceKeyField(subCalendar.spaceKey);
                        helper.setSpaceKeyAutocompleteField(subCalendar.spaceName);

                        populateQueryOptions(null, function () {
                            var jiraQueryOptionsContainer = $(".jira-query-options", fieldsDiv),
                                allPossibleSelectedOptionsClasses = "option-project-selected option-search-filter-selected option-jql-selected",
                                hideDateFields;

                            $(".matrix input.radio", jiraQueryOptionsContainer).removeAttr("checked");

                            var jiraSubCalendar = subCalendar.sourceSubCalendar || subCalendar;

                            if (jiraSubCalendar.projectKey) {
                                var isProjectInList = false;

                                //Set the project selector
                                $("option", projectSelect).removeAttr("selected").each(function () {
                                    var aProjectOption = $(this);
                                    if (aProjectOption.val() === jiraSubCalendar.projectKey) {
                                        aProjectOption.attr("selected", "selected");
                                        isProjectInList = true;
                                        return false;
                                    }
                                });

                                //If project not found append to selector
                                if (!isProjectInList) {
                                    projectSelect.append(
                                            $(document.createElement("option")).val(jiraSubCalendar.projectKey).text(
                                                jiraSubCalendar.projectName || jiraSubCalendar.projectKey
                                            ).attr("selected", "selected")
                                    );
                                }

                                $(".radio-project input.radio", jiraQueryOptionsContainer.removeClass(allPossibleSelectedOptionsClasses).addClass("option-project-selected")).attr("checked", "checked");
                                hideDateFields = projectOption.data("hiddenDateFields");

                            } else if (jiraSubCalendar.searchFilterId) {
                                //Set search filter
                                var searchFilterOption = $(".option-search-filter", jiraQueryOptionsContainer);

                                var searchFilterInput = $("input[name='searchFilterName']", searchFilterOption);
                                $("input[name='searchFilter']", searchFilterOption).val(jiraSubCalendar.searchFilterId);

                                var searchFilterName = jiraSubCalendar.searchFilterName || jiraSubCalendar.searchFilterId;
                                var searchFilterObjs = $(searchFilterInput).data("searchFilters");
                                if(searchFilterObjs) {
                                    searchFilterName = $.map(searchFilterObjs, function(searchFilter) {
                                        if(searchFilter.id === jiraSubCalendar.searchFilterId && searchFilter.name.length > 0)
                                            return searchFilter.name;
                                    });
                                }

                                $(searchFilterInput).removeClass("with-hint").val(searchFilterName);

                                $(".radio-search-filter input.radio", jiraQueryOptionsContainer.removeClass(allPossibleSelectedOptionsClasses).addClass("option-search-filter-selected")).attr("checked", "checked");
                                hideDateFields = searchFilterOption.data("hideDateFields");

                            } else if (jiraSubCalendar.jql) {
                                //Set JQL
                                var jqlOption = $(".option-jql", jiraQueryOptionsContainer);

                                $("textarea[name='jql']", jqlOption).removeClass("with-hint").val(jiraSubCalendar.jql);
                                $(".radio-jql input.radio", jiraQueryOptionsContainer.removeClass(allPossibleSelectedOptionsClasses).addClass("option-jql-selected")).attr("checked", "checked");
                            }

                            populateFieldsList(function () {
                                var singleDateFields = $(".field-group-jira-show .single-dates .date-fields div.checkbox", fieldsDiv),
                                    availableDateFields = {},
                                    jiraCalendarDateFields = jiraSubCalendar.dateFieldNames || [];

                                $(".date-fields input", fieldsDiv).removeAttr("checked");

                                //Set single date fields
                                singleDateFields.each(function() {
                                    var dateFieldInput = $("input", this),
                                        dateFieldKey = dateFieldInput.val();

                                    if ($.inArray(dateFieldKey, jiraCalendarDateFields) !== -1) {
                                        dateFieldInput.attr("checked", "checked");
                                    }

                                    availableDateFields[dateFieldKey] = $("label", this).text();
                                });

                                //Set durations
                                $.each(
                                    jiraSubCalendar.durations || [],
                                    function(durationIdx, subCalendarDuration) {
                                        var startDateFieldLabel = availableDateFields[subCalendarDuration.startDateFieldName || ""],
                                            endDateFieldLabel = availableDateFields[subCalendarDuration.endDateFieldName || ""];

                                        if (startDateFieldLabel && endDateFieldLabel) {
                                            // Both fields are valid
                                            var durationFieldsListContainer = $(".field-group-jira-show .duration .date-fields", fieldsDiv),
                                                durationFieldKey = subCalendarDuration.startDateFieldName + "/" + subCalendarDuration.endDateFieldName,
                                                durationFieldId = "duration-" + durationFieldKey;

                                            $("<div/>", { "class" : "checkbox" }).append(
                                                $("<input/>", {
                                                    "id" : durationFieldId,
                                                    "name" : "dateFieldName",
                                                    "type" : "checkbox",
                                                    "value" : durationFieldKey,
                                                    "checked" : "checked"
                                                })
                                            ).append(
                                                $("<label/>", {
                                                    "for" : durationFieldId,
                                                    "html" : AJS.format("\u5f00\u59cb\u4e8e: {0}", $("<span/>", { "text" : startDateFieldLabel }).html()) +
                                                        "<br>" +
                                                        AJS.format("\u7ed3\u675f\u4e8e: {0}", $("<span/>", { "text" : endDateFieldLabel }).html())
                                                })
                                            ).appendTo(durationFieldsListContainer);

                                            durationFieldsListContainer.parent().addClass("has-selected-duration");
                                        }
                                    }
                                );

                                if (hideDateFields) {
                                    setDateFieldsHidden(hideDateFields);
                                }
                            });
                        });

                        timeZoneIdDisplay.text(subCalendar.timeZoneId);
                    }

                    //Set read / read only
                    var textInputs = $("input[name='name'], input[name='description'], input[name='spaceKeyAutocomplete'], input[name='searchFilterName'], textarea[name='jql']", fieldsDiv);
                    if (callbackHandler.isCalendarInEditMode()) {
                        textInputs.removeAttr("readonly");
                        serverSelect.removeAttr("disabled");
                        projectSelect.removeAttr("disabled");
                    } else {
                        formMode.removeClass().addClass("form-mode read-only");
                        textInputs.attr("readonly", "readonly");
                        serverSelect.attr("disabled", "disabled");
                        projectSelect.attr("disabled", "disabled");
                    }
                };

                var setupFields = function() {
                    $("select[name='server']", fieldsDiv).change(function() {
                        var selectedJiraServer = $("select[name='server'] option:selected", fieldsDiv);
                        if (selectedJiraServer.length && selectedJiraServer.val()) {
                            populateQueryOptions(null, function() {
                                populateFieldsList();
                            });
                        }
                    });

                    $("input[name='spaceKeyAutocomplete']", fieldsDiv).bind("selected.autocomplete-content", function(e, selection) {
                        $("input[name='spaceKey']", fieldsDiv).val(selection.content.key);
                        $(this).val(selection.content.name);
                        $(".spaceKeyAutocomplete-error", fieldsDiv).empty();
                    });

                    $(".jira-query-options .query-group input.radio", fieldsDiv)
                        .off("change")
                        .on("change", function() {
                            var value = $(this).val(),
                                jiraQueryOptionsContainer = $(".jira-query-options", fieldsDiv)
                                    .removeClass("option-project-selected option-search-filter-selected option-jql-selected")
                                    .addClass(value + "-selected"),
                                option = $("." + value, jiraQueryOptionsContainer);

                            $("input", option).focus(function() {
                                var input = $(this);
                                if (input.hasClass("with-hint")) {
                                    input.removeClass("with-hint").val("");
                                }
                            });

                            if ("option-jql" === value) {
                                $("textarea", option).trigger("keydown", [ true ]);
                            }

                            populateFieldsList(function() {
                                setDateFieldsHidden(option.data("hideDateFields") || !$(".option-value", option).val());

                                var durationContainer = $(".duration", fieldsDiv);
                                if ($(".date-fields", durationContainer).children().length) {
                                    durationContainer.addClass("has-selected-duration");
                                } else {
                                    durationContainer.removeClass("has-selected-duration");
                                }
                            });
                        });

                    var searchFilterOption = $(".option-search-filter", fieldsDiv);
                    var searchFilterAutoCompleteContainer = $(".search-filter-suggestions", searchFilterOption);

                    $("input[name='searchFilterName']", searchFilterOption).keydown(function() {
                        var searchFilterNameInput = $(this);
                        var previousValue = searchFilterNameInput.val();

                        setTimeout(function() {
                            var currentValue = searchFilterNameInput.val();
                            if (!currentValue || currentValue !== previousValue) {
                                searchFilterAutoCompleteContainer.empty();
                            }

                            if (currentValue !== previousValue) {
                                currentValue = currentValue.toLowerCase();
                                var searchFilters = $.grep(searchFilterNameInput.data("searchFilters") || [], function(searchFilter) {
                                    return searchFilter.name.toLowerCase().indexOf(currentValue) !== -1;
                                });

                                if (searchFilters.length) {
                                    var dropDownContainer = $(document.createElement("div")).addClass("dropdown-container").append(
                                            $(document.createElement("div")).addClass("aui-dd-parent").append(
                                                    $(document.createElement("a")).addClass("aui-dd-trigger").attr("href", "#").text("Show autocomplete")
                                            ).append(
                                                    $(document.createElement("ul")).addClass("aui-dropdown")
                                            )
                                    );
                                    var dropDown = $(".aui-dropdown", dropDownContainer).appendTo($(".aui-dd-parent", dropDownContainer));

                                    $.each(searchFilters, function (searchFilterIdx, searchFilter) {
                                        var searchFilterItem = $(document.createElement("li")).append(
                                                $(document.createElement("a")).attr("href", "#").text(searchFilter.name)
                                        ).data("searchFilter", searchFilter).appendTo(dropDown
                                        ).click(function () {
                                                    searchFilterNameInput.val(searchFilter.name);
                                                    $("input[name='searchFilter']", searchFilterOption).val(searchFilter.id);
                                                    $(".error", searchFilterOption).empty();
                                                    populateFieldsList();
                                                });

                                        if (searchFilter.description) {
                                            searchFilterItem.attr("title", searchFilter.description);
                                        }
                                    });

                                    dropDownContainer.appendTo(searchFilterAutoCompleteContainer).dropDown("Standard", { alignment:"left" });
                                    searchFilterAutoCompleteContainer.removeClass("hidden");
                                }
                            }
                        }, 300);
                    });

                    $("select[name='project']", fieldsDiv).change(function() {
                        populateFieldsList();
                    });

                    $(".jira-query-options input[name='searchFilterName']", fieldsDiv).keydown(function(jsEvent) {
                        var keyCode = jsEvent.keyCode;
                        var searchFilterNameInput = $(this);

                        if (!(keyCode === 38 || keyCode === 40  || keyCode === 13)) {
                            setTimeout(function() {
                                fieldsDiv.click(); // Hide autocomplete

                                var searchFilterName = searchFilterNameInput.val().toLowerCase();
                                if (searchFilterName) {
                                    var searchFilters = searchFilterNameInput.data("searchFilters");
                                    if (searchFilters && $.isArray(searchFilters)) {
                                        var searchFilterItems = $(".search-filter-suggestions .aui-dropdown li", fieldsDiv).each(function() {
                                            var searchFilterItem = $(this);

                                            if (searchFilterItem.data("searchFilter").name.toLowerCase().indexOf(searchFilterName) === -1) {
                                                searchFilterItem.addClass("hidden");
                                            } else {
                                                searchFilterItem.removeClass("hidden");
                                            }
                                        });

                                        if (searchFilterItems.filter(function() { return !$(this).hasClass("hidden"); }).length) {
                                            $(".search-filter-suggestions .aui-dd-trigger", fieldsDiv).trigger("click");
                                        }
                                    }
                                }
                            }, 300);
                        } else if (keyCode === 13) {
                            jsEvent.preventDefault();

                            var selectedSearchFilterItem = $(".search-filter-suggestions .aui-dropdown li.active", fieldsDiv);

                            if (selectedSearchFilterItem.length) {
                                var selectedSearchFilter = selectedSearchFilterItem.data("searchFilter");

                                searchFilterNameInput.val(selectedSearchFilter.name);
                                $("input[name='searchFilter']", fieldsDiv).val(selectedSearchFilter.id);
                                $(".option-search-filter .error", fieldsDiv).empty();

                                fieldsDiv.click(); // Hide autocomplete, but don't trigger form submission
                                populateFieldsList();
                            }
                        }
                    });

                    $(".add-duration", fieldsDiv).unbind().click(function() {
                        AJS.log("Open Jira Duration Dialog");
                        var addDurationDialog = new AJS.Dialog({
                            "height": 423,
                            "width" : 520,
                            "id" : "add-jira-duration-dialog"
                        });

                        addDurationDialog.addHeader("\u5728\u65e5\u671f\u4e4b\u95f4\u52a0\u5165\u6301\u7eed\u65f6\u95f4");
                        addDurationDialog.addPanel(
                            "",
                            Confluence.TeamCalendars.Templates.editJiraSubCalendarDurations(),
                            "calendar-dialog-panel"
                        );

                        var addDurationDialogPanel = addDurationDialog.getCurrentPanel().body,
                            durationFieldsListContainer = $(".field-group-jira-show .duration .date-fields", fieldsDiv),
                            dateFieldsListContainer = $(".field-group-jira-show .single-dates .date-fields", fieldsDiv);

                        addDurationDialog.addSubmit("\u6dfb\u52a0", function() {
                            var selectedStartDateFieldOption = $(".duration-start select option:selected", addDurationDialogPanel),
                                selectedEndDateFieldOption = $(".duration-end select option:selected", addDurationDialogPanel),
                                selectedDurationFieldKey = selectedStartDateFieldOption.val() + "/" + selectedEndDateFieldOption.val(),
                                selectedDurationField = $("div.checkbox", durationFieldsListContainer).filter(function() {
                                    return $("input", this).val() === selectedDurationFieldKey;
                                });

                            if (selectedDurationField.length) {
                                // Retick, just in case the user ticked it off when opening up the add durations dialog.
                                $("input", selectedDurationField).attr("checked", "checked");
                            } else {
                                var durationFieldId = "duration-" + selectedDurationFieldKey;

                                $("<div/>", { "class" : "checkbox" }).append(
                                    $("<input/>", {
                                        "id" : durationFieldId,
                                        "type" : "checkbox",
                                        "name" : "dateFieldName",
                                        "value" : selectedDurationFieldKey,
                                        "checked" : "checked"
                                    })
                                ).append(
                                    $("<label/>", {
                                        "for" : durationFieldId,
                                        "html" : AJS.format("\u5f00\u59cb\u4e8e: {0}", selectedStartDateFieldOption.html()) +
                                            "<br>" +
                                            AJS.format("\u7ed3\u675f\u4e8e: {0}", selectedEndDateFieldOption.html())
                                    })
                                ).prependTo(durationFieldsListContainer);
                                durationFieldsListContainer.parent().addClass("has-selected-duration");
                            }

                            addDurationDialog.remove();
                            eventEditDialog.show();
                        });

                        addDurationDialog.addCancel("\u53d6\u6d88", function() {
                            addDurationDialog.remove();
                            eventEditDialog.show();
                        });

                        var mappableDateFields = $.map(
                                $("div.checkbox", dateFieldsListContainer).filter(function() {
                                    return $(this).data("mappableAsDuration");
                                }),
                                function(aField) {
                                    return $("<option/>", {
                                        "value" : $("input", aField).val(),
                                        "text" : $("label", aField).text()
                                    });
                                }
                            ),
                            startDateFieldSelect = $(".duration-start select", addDurationDialogPanel),
                            endDateFieldSelect = $(".duration-end select", addDurationDialogPanel),

                            setSubmitButtonDisabledState = function(startField, endField) {
                                var okButton = addDurationDialog.popup.element.find(".button-panel-submit-button");

                                if (endField && startField && endField !== startField) {
                                    okButton.prop("disabled", false).removeClass("ui-state-disabled");
                                } else {
                                    okButton.prop("disabled", true).addClass("ui-state-disabled");
                                }
                            };

                        // Populate each date field dropdowns for selection
                        $.each(mappableDateFields, function(mappableDateFieldIdx, mappableDateField) {
                            $(mappableDateField).appendTo(startDateFieldSelect).clone().appendTo(endDateFieldSelect);
                        });

                        if (!mappableDateFields.length) {
                            $(".duration-fields", addDurationDialogPanel).addClass("hidden");
                            $(".add-fields", $(".no-selectable-date-fields", addDurationDialogPanel).removeClass("hidden")).html(
                                AJS.format("\u5982\u679c\u60a8\u662f\u4e00\u540d Jira \u7ba1\u7406\u5458\uff0c\u5219\u003ca href=\u0027\u0027{0}/secure/admin/ViewCustomFields.jspa\u0027\u0027 target=\u0022_blank\u0022\u003e\u53ef\u4ee5\u521b\u5efa\u81ea\u5b9a\u4e49\u65e5\u671f\u003c/a\u003e\uff0c\u5b83\u4eec\u5c06\u663e\u793a\u4e3a\u201c\u4e8b\u52a1\u5f00\u59cb\u65e5\u671f\u201d\u548c\u201c\u4e8b\u52a1\u7ed3\u675f\u65e5\u671f\u201d\u9009\u9879\u3002",
                                    $(".field-group-jira-server select option:checked", fieldsDiv).data("display-url")
                                )
                            );
                        }

                        var adjustSelectableDateFieldOptions = function(selectedDateField, otherDateFieldSelect) {
                            var initialSelectedEndDateField = $("option:selected", otherDateFieldSelect).val();

                            // Remove all date fields.
                            $("option", otherDateFieldSelect).filter(function() {
                                return $(this).val();
                            }).remove();

                            $.each(mappableDateFields, function(mappableDateFieldIdx, mappableDateField) {
                                if (mappableDateField.val() !== selectedDateField) {
                                    mappableDateField.clone().appendTo(otherDateFieldSelect);
                                }
                            });

                            $("option", otherDateFieldSelect).removeAttr("selected").filter(
                                function() {
                                    return $(this).val() === initialSelectedEndDateField;
                                }
                            ).attr("selected", "selected");
                        };

                        startDateFieldSelect.change(function() {
                            var selectedStartDateField = $("option:selected", this).val();

                            adjustSelectableDateFieldOptions(selectedStartDateField, endDateFieldSelect);
                            setSubmitButtonDisabledState(selectedStartDateField, $("option:selected", endDateFieldSelect).val());
                        });

                        endDateFieldSelect.change(function() {
                            var selectedEndDateField = $("option:selected", this).val();

                            adjustSelectableDateFieldOptions(selectedEndDateField, startDateFieldSelect);
                            setSubmitButtonDisabledState(selectedEndDateField, $("option:selected", startDateFieldSelect).val());
                        });

                        eventEditDialog.hide();
                        setSubmitButtonDisabledState();
                        addDurationDialog.show();
                        return false;
                    });

                    $(".subcalendar-cancel", fieldsDiv).click(function() {
                        eventEditDialog.remove();
                        return false;
                    });

                    return fieldsDiv;
                };

                var populateQueryOptions = function(onError, onSuccess) {
                    var jiraQueryOptionsContainer = $(".jira-query-options", fieldsDiv);
                    var queryRadioButtons = $(".query-group input.radio", jiraQueryOptionsContainer).attr("disabled", "disabled").removeAttr("checked", "checked");
                    var jqlNotSupportedControls = $(".field-group .project-select-label", jiraQueryOptionsContainer);
                    var jqlSupportedControls = $(".query-group", jiraQueryOptionsContainer);
                    var controlsToToggleVisibleOnOAuthError = $(".compatibility-group, .field-group-jira-show", jiraQueryOptionsContainer);
                    var formMode = $(".form-mode", fieldsDiv).addClass("jira-query-options-loading");
                    var server = JiraEventFieldProcess.getServerSelect(fieldsDiv).val();
                    var handleGetOptionsError = function(XMLHttpRequest, textStatus, errorThrown) {
                        formMode.removeClass("jira-query-options-loading");
                        jqlSupportedControls.addClass("hidden");
                        jqlNotSupportedControls.removeClass("hidden");
                        controlsToToggleVisibleOnOAuthError.addClass("hidden");

                        if (Confluence.TeamCalendars.isRequireOauth(XMLHttpRequest)) {
                            JiraEventFieldProcess.showOauthRequitedMessage(XMLHttpRequest, fieldsDiv, eventEditDialog, controlsToToggleVisibleOnOAuthError, populateForm);
                        } else {
                            if (onError && $.isFunction(onError)) {
                                onError(XMLHttpRequest, textStatus, errorThrown);
                            }
                        }
                    };
                    var handleGetOptionsSuccess = function(queryOptions) {
                        controlsToToggleVisibleOnOAuthError.removeClass("hidden");
                        formMode.removeClass("jira-query-options-loading");
                        queryRadioButtons.removeAttr("disabled", "disabled");
                        if (!queryOptions.searchRequests) {
                            $(".radio-search-filer input", fieldsDiv).attr("disabled", "disabled");
                        }

                        // Selects the project list again - so we're resetting the previous query mode and defaulting it back to "project".
                        if (!jiraQueryOptionsContainer.hasClass("option-project-selected")) {
                            jiraQueryOptionsContainer.removeClass("option-search-filter-selected option-jql-selected").addClass("option-project-selected");
                        }

                        $(".radio-project input", jiraQueryOptionsContainer).attr("checked", "checked");
                        if (queryOptions.jqlNotSupported) {
                            jqlSupportedControls.addClass("hidden");
                            jqlNotSupportedControls.removeClass("hidden");
                        } else {
                            jqlNotSupportedControls.addClass("hidden");
                            jqlSupportedControls.removeClass("hidden");

                            var currentTimeMs = new Date().getTime();
                            var newJqlInputid = "jql-" + currentTimeMs;

                            $("textarea[name='jql']", jiraQueryOptionsContainer).before(
                                    $(document.createElement("textarea")).attr({
                                        autocomplete: "off",
                                        cols:         "20",
                                        id:           newJqlInputid,
                                        name:         "jql",
                                        rows:         1,
                                        wrap:         "off",
                                        placeholder:  "JQL \u7591\u95ee"
                                    }).addClass("textarea with-hint"
                                            ).focus(function () {
                                                var thisTextArea = $(this);
                                                if (thisTextArea.hasClass("with-hint")) {
                                                    thisTextArea.removeClass("with-hint").val("");
                                                }
                                            }).val("")
                            ).remove();

                            var jqlAutoCompleteUrlRegex = /.+\/jql\/autocomplete.json\?fieldName=[^&]+&fieldValue=.*/;
                            var jqlAutoCompleteSpinner = $(".jqlAutoCompleteSpinner", jiraQueryOptionsContainer);

                            jiraQueryOptionsContainer.ajaxSend(function (event, jqXHR, ajaxOptions) {
                                if (jqlAutoCompleteUrlRegex.test(ajaxOptions.url || "")) {
                                    jqlAutoCompleteSpinner.removeClass("hidden");
                                }

                            }).ajaxComplete(function (event, jqXHR, ajaxOptions) {
                                        if (jqlAutoCompleteUrlRegex.test(ajaxOptions.url || "")) {
                                            jqlAutoCompleteSpinner.addClass("hidden");
                                        }
                                    });

                            $(".option-jql label", jiraQueryOptionsContainer).attr("for", newJqlInputid);

                            var newJqlErrorContainerId = "jql-error-" + currentTimeMs;
                            $(".jql-error", jiraQueryOptionsContainer).before(
                                    $(document.createElement("div")).addClass("error jql-error").attr("id", newJqlErrorContainerId)
                            ).remove();

                            $(".dropdown-ready", jiraQueryOptionsContainer).remove();

                            JIRA.JQLAutoComplete({
                                fieldID:            newJqlInputid,
                                parser:             JIRA.JQLAutoComplete.MyParser($.parseJSON(queryOptions.jqlReservedKeywordsJson || "[]")),
                                queryDelay:         .65,
                                jqlFieldNames:      $.parseJSON(queryOptions.visibleFieldNamesJson || "[]"),
                                jqlFunctionNames:   $.parseJSON(queryOptions.visibleFunctionNamesJson || "[]"),
                                minQueryLength:     0,
                                allowArrowCarousel: true,
                                autoSelectFirst:    false,
                                errorID:            newJqlErrorContainerId,
                                jiraApplicationId:  JiraEventFieldProcess.getServerSelect().val(),
                                baseUrl:            Confluence.getBaseUrl()
                            });

                            $("textarea[name='jql']", fieldsDiv).keydown(function (jsEvent, validateRegardless) {
                                var jqlInput = $(this);
                                var initialJql = jqlInput.val();

                                if (validateRegardless || jsEvent.keyCode !== 27) {
                                    setTimeout(function () {
                                        var jql = jqlInput.val();
                                        var jqlErrorContainer = $(".jql-error", fieldsDiv);

                                        if (jql && !jqlInput.hasClass("with-hint") && (validateRegardless || jql !== initialJql)) {
                                            $.ajax({
                                                cache:   false,
                                                data:    {
                                                    jql: jql
                                                },
                                                error:   function () {
                                                    jqlErrorContainer.empty().text("\u65e0\u6cd5\u9488\u5bf9\u9009\u5b9a\u7684 Jira \u505a JQL \u9a8c\u8bc1\u3002");
                                                },
                                                success: function (jqlValidationResult) {
                                                    var jqlOk = $(".jql-ok", fieldsDiv),
                                                            jqlBad = $(".jql-bad", fieldsDiv),
                                                            durationContainer = $(".duration", fieldsDiv);

                                                    if (jqlValidationResult.valid) {
                                                        jqlOk.removeClass("hidden");
                                                        jqlBad.addClass("hidden");

                                                        populateFieldsList(function () {
                                                            durationContainer.addClass("can-add-duration");
                                                            if ($(".date-fields div.checkbox", durationContainer).length) {
                                                                durationContainer.addClass("has-selected-duration");
                                                            } else {
                                                                durationContainer.removeClass("has-selected-duration");
                                                            }
                                                        });
                                                        jqlInput.focus();
                                                    } else {
                                                        jqlOk.addClass("hidden");
                                                        jqlBad.removeClass("hidden");

                                                        $(".date-fields", fieldsDiv).empty();
                                                        setDateFieldsHidden(true);
                                                        durationContainer.removeClass("can-add-duration");
                                                    }
                                                },
                                                type:    "PUT",
                                                url:     Confluence.getBaseUrl().concat(
                                                                "/rest/calendar-services/1.0/calendar/jira/",
                                                                encodeURIComponent(JiraEventFieldProcess.getServerSelect(fieldsDiv).val()),
                                                                "/jql/validate.json"
                                                            ),
                                                timeout: Confluence.TeamCalendars.ajaxTimeout
                                            });
                                        }
                                    }, 300);

                                } else {
                                    var suggestionsContainer = $(".option-jql .suggestions", jiraQueryOptionsContainer);
                                    if (suggestionsContainer.is(":visible")) {
                                        suggestionsContainer.hide();
                                        return false;
                                    }
                                }
                            });
                        }

                        var searchFilters = queryOptions.searchRequests;
                        var searchFilterOption = $(".option-search-filter", fieldsDiv);
                        var searchFilterNameInput = $("input[name='searchFilterName']", searchFilterOption).removeData("searchFilters");
                        if (searchFilters && $.isArray(searchFilters) && searchFilters.length) {
                            searchFilterNameInput.data("searchFilters", searchFilters);
                            $(".option-content", searchFilterOption.removeData("hideDateFields")).removeClass("disabled");
                        } else {
                            searchFilterNameInput.attr("disabled", "disabled");
                            $(".option-content", searchFilterOption.data("hideDateFields", true)).addClass("disabled");
                        }

                        var projects = queryOptions.projects;
                        var projectOption = $(".option-project", fieldsDiv);
                        if (projects && $.isArray(projects) && projects.length) {
                            var projectList = $("select", projectOption).empty();

                            //need add select project first line for improvement performance jira project
                            $(document.createElement("option")).val("").text("\u9009\u62e9").appendTo(projectList);

                            $.each(projects, function (projectIdx, project) {
                                $(document.createElement("option")).val(project.key).text(project.name).appendTo(projectList);
                            });

                            $(".option-content", projectOption.removeData("hideDateFields")).removeClass("disabled");
                        } else {
                            $(".option-content", projectOption.data("hideDateFields", true)).addClass("disabled");
                        }

                        if (!queryOptions.dateRangeSupported) {
                            $(".duration", fieldsDiv).css("visibility", "hidden");
                        } else {
                            $(".duration", fieldsDiv).css("visibility", "visible");
                        }

                        eventEditDialog.enableOkButton();

                        if (onSuccess && $.isFunction(onSuccess)) {
                            onSuccess(queryOptions);
                        }
                    };
                    JiraEventFieldProcess.getJiraOptions(handleGetOptionsError, handleGetOptionsSuccess, server);
                };

                var populateFieldsList = function(successCallback) {
                        var selectedDateFields = $(".field-group-jira-show div.checkbox", fieldsDiv).filter(function() {
                            return $("input", this).is(":checked");
                        }),
                        selectedQuery = $(".jira-query-options .matrix .radio:checked", fieldsDiv).val(),
                        durationContainer = $(".duration", fieldsDiv),
                        dateFieldsData = {},
                        dateFieldsUrl = "";

                    // Figure out how to query for date fields
                    if ("option-project" === selectedQuery) {
                        var projectKey = encodeURIComponent($(".jira-query-options .option-project select option:selected", fieldsDiv).val());
                        if(projectKey) {
                            dateFieldsUrl = "/project/" + projectKey;
                        }
                    } else if ("option-search-filter" === selectedQuery) {
                        var searchFilterId = $(".jira-query-options .option-search-filter input[name='searchFilter']", fieldsDiv).val();
                        if (searchFilterId) {
                            dateFieldsUrl = "/filter/" + encodeURIComponent(searchFilterId);
                        }
                    } else if ("option-jql" === selectedQuery) {
                        dateFieldsData.query = $(".jira-query-options .option-jql textarea", fieldsDiv).val() || "";
                        if (dateFieldsData.query) {
                            dateFieldsUrl = "/jql";
                        }
                    }

                    durationContainer.removeClass("can-add-duration");

                    if (dateFieldsUrl) {
                        var dateFieldsSpinnerContainer = $(".date-fields-spinner-container", fieldsDiv).removeClass("hidden"),
                            singleDateFieldsListContainer = $(".single-dates .date-fields", fieldsDiv).empty(),
                            durationDateFieldsListContainer = $(".date-fields", durationContainer).empty();

                        $.ajax({
                            cache: false,
                            data : dateFieldsData,
                            dataType: "json",
                            error: function() {
                                dateFieldsSpinnerContainer.addClass("hidden");
                                $(".dateFieldName-error", fieldsDiv).text("\u83b7\u53d6\u65e5\u671f\u5b57\u6bb5\u7684\u5217\u8868\u65f6\u53d1\u751f\u9519\u8bef\u3002");
                            },
                            success: function(dateFields) {
                                dateFieldsSpinnerContainer.addClass("hidden");

                                var singleDateFieldsList = $("<div/>"),
                                    selectedDateFieldKeys = $.map(selectedDateFields, function(selectedDateField) {
                                        return $("input", selectedDateField).val();
                                    }),
                                    selectableDateFieldKeys = $.map(dateFields, function(dateField) {
                                        return dateField.key;
                                    });

                                // Repopulate single date fields
                                $.each(dateFields, function(dateFieldIdx, dateField) {
                                    $("<div/>", { "class" : "checkbox" }).append(
                                        $("<input/>", {
                                            "id" : "option-" + dateField.key,
                                            "name" : "dateFieldName",
                                            "type" : "checkbox",
                                            "value" : dateField.key,
                                            "checked" : $.inArray(dateField.key, selectedDateFieldKeys) !== -1
                                        })
                                    ).append(
                                        $("<label/>", {
                                            "for" : "option-" + dateField.key,
                                            "text" : dateField.name
                                        })
                                    ).data("mappableAsDuration", dateField.customfield || dateField.key === "duedate" || dateField.key === "created" || dateField.key === "resolution"
                                    ).appendTo(singleDateFieldsList);
                                });

                                // Repopulate durations
                                selectedDateFields.filter(function() {
                                    var durationFields = $("input", this).val();
                                    if (durationFields.indexOf("/") !== -1) {
                                        var durationFieldTokens = durationFields.split("/", 2);
                                        return durationFieldTokens.length === 2 &&
                                            $.inArray(durationFieldTokens[0], selectableDateFieldKeys) !== -1 &&
                                            $.inArray(durationFieldTokens[1], selectableDateFieldKeys) !== -1;
                                    }

                                    return false;
                                }).appendTo(
                                        // Empty the container again because it may have been populated by another instance of this AJAX request
                                        // after the container was initially emptied (just before the start of this AJAX request).
                                        durationDateFieldsListContainer.empty()
                                );

                                singleDateFieldsList.appendTo(
                                    // See comment regarding emptying durationDateFieldsListContainer
                                    singleDateFieldsListContainer.empty()
                                );

                                if (singleDateFieldsList.children().length) {
                                    setDateFieldsHidden(false);
                                    durationContainer.addClass("can-add-duration");
                                } else {
                                    durationContainer.removeClass("can-add-duration");
                                }

                                if (successCallback && $.isFunction(successCallback)) {
                                    successCallback(dateFields);
                                }
                            },
                            timeout : Confluence.TeamCalendars.ajaxTimeout,
                            url : Confluence.getBaseUrl().concat(
                                    "/rest/calendar-services/1.0/calendar/jira/",
                                    encodeURIComponent(JiraEventFieldProcess.getServerSelect(fieldsDiv).val()),
                                    "/date-fields",
                                    dateFieldsUrl,
                                    ".json")
                        });
                    } else {
                        setDateFieldsHidden(true);
                        if (successCallback && $.isFunction(successCallback)) {
                            successCallback();
                        }
                    }
                };

                setupFields();
                populateForm();
            },

            CustomSubmitter : {
                JiraIssues : {
                    submitForm : function(fieldsDiv, name, parentSubCalendarId, callbackHandler, onSuccessCallback, onErrorCallback) {
                        function getFormDataAsAjaxData() {
                            var dateFieldQueryParam = "",
                                selectedDateFields = $(".field-group-jira-show .date-fields div.checkbox").filter(function() {
                                    return $("input:checked", this).length;
                                });

                            //Build date field query
                            $.each(selectedDateFields, function() {
                                var dateFieldKey = $("input", this).val();

                                //handle durations
                                if (dateFieldKey.indexOf("/") !== -1) {
                                    var durationFieldTokens = dateFieldKey.split("/", 2);
                                    if (dateFieldQueryParam) {
                                        dateFieldQueryParam += "&";
                                    }

                                    dateFieldQueryParam += "duration=" + encodeURIComponent(durationFieldTokens[0] + "/" + durationFieldTokens[1]);
                                } else {  //Single dates
                                    if (dateFieldQueryParam) {
                                        dateFieldQueryParam += "&";
                                    }

                                    dateFieldQueryParam += "dateFieldName=" + encodeURIComponent(dateFieldKey);
                                }
                            });

                            var data = {
                                    type : "jira",
                                    parentId: parentSubCalendarId,
                                    subCalendarId : $("input[name='subCalendarId']", fieldsDiv).val(),
                                    name : name,
                                    description : "",
                                    color : $("input[name='color']", fieldsDiv).val()
                                },
                                location = "jira://" + encodeURIComponent(JiraEventFieldProcess.getServerSelect(fieldsDiv).val() || "") + "?",
                                selectedQueryOption = $(".jira-query-options .matrix input.radio:checked", fieldsDiv).val();

                            if ("option-project" === selectedQueryOption) {
                                location += "projectKey=" + encodeURIComponent($("select[name='project'] option:selected", fieldsDiv).val());
                            } else if ("option-search-filter" === selectedQueryOption) {
                                location += "searchFilterId=" + $("input[name='searchFilter']", fieldsDiv).val();
                            } else {
                                location += "jql=" + encodeURIComponent($("textarea[name='jql']", fieldsDiv).val());
                            }

                            if (dateFieldQueryParam) {
                                location += "&" + dateFieldQueryParam;
                            }

                            data.location = location;
                            return data;
                        }

                        sendJiraCalendar(getFormDataAsAjaxData(), fieldsDiv, callbackHandler, onErrorCallback, onSuccessCallback);
                    }
                },

                JiraAgileSprints : {
                    submitForm : function(fieldsDiv, name, parentSubCalendarId, callbackHandler, onSuccessCallback, onErrorCallback) {
                        var formData = getSimpleJiraFormData(fieldsDiv, name, parentSubCalendarId, "sprint", "jira-agile-sprint");
                        sendJiraCalendar(formData, fieldsDiv, callbackHandler, onErrorCallback, onSuccessCallback);
                    }
                },

                JiraProjectReleases : {
                    submitForm : function(fieldsDiv, name, parentSubCalendarId, callbackHandler, onSuccessCallback, onErrorCallback) {
                        var formData = getSimpleJiraFormData(fieldsDiv, name, parentSubCalendarId, "versiondue", "jira-project-releases");
                        sendJiraCalendar(formData, fieldsDiv, callbackHandler, onErrorCallback, onSuccessCallback);
                    }
                }
            }
        };

        return JiraEventFieldProcess;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-types.js' */
define("tc/event-types",
    [
        "jquery",
        "tc/jira-event-field-process"
    ],
    function (
        $,
        JiraEventFieldProcess
    )
    {
        "use strict";
        var basePeopleEventType = {
            "fields" : [
                {
                    "type" : "user",
                    "id" : "who",
                    "label" : "\u4f55\u4eba",
                    "required" : true,
                    "property" : "what",
                    "setTitle" : true
                },
                {
                    "type" : "text",
                    "id" : "description",
                    "required" : true,
                    "property" : "description",
                    "label" : "\u6458\u8981",
                    "copyto" : "what"
                },
                {
                    "type" : "when",
                    "id" : "people"
                },
                {
                    "type" : "repeats2",
                    "id" : "people"
                },
                {
                    "type" : "reminder",
                    "id" : "reminder",
                    "label" : "\u63d0\u9192"
                },
                {
                    "type" : "page",
                    "id" : "url",
                    "property" : "workingUrl",
                    "label" : "\u76f8\u5173\u9875"
                }
            ]
        };

        var EventTypes = {
            DefaultEventType : {
                "travel" : $.extend(
                    {}, basePeopleEventType,
                    {
                        "id" : "travel",
                        "name" : "\u51fa\u5dee"
                    }
                ),

                "leaves" : $.extend(
                    {}, basePeopleEventType,
                    {
                        "id" : "leaves",
                        "name" : "\u4f11\u5047"
                    }
                ),

                "birthdays" : $.extend(
                    true, // support recursive
                    {}, basePeopleEventType,
                    {
                        "id" : "birthdays",
                        "name" : "\u751f\u65e5",
                        "fields": [
                            {},
                            {},
                            {
                                defaultRecur: {
                                    freq: "YEARLY"
                                }
                            }
                        ]
                    }
                ),

                "jira" : {
                    "id" : "jira",
                    "name" : "Jira \u95ee\u9898\u65e5\u671f",
                    "hiddenFromEventCreation" : true,
                    "fields" : [
                        {
                            "type" : "text",
                            "id" : "what",
                            "property" : "title",
                            "label" : "\u4f55\u4e8b",
                            "required" : true,
                            "readOnly" : true
                        },
                        {
                            "type" : "when",
                            "id" : "simple",
                            "disableEndDateTime" : true,
                            "disableAllDay" : true
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        },
                        {
                            "type" : "page",
                            "id" : "url",
                            "property" : "workingUrl",
                            "label" : "\u76f8\u5173\u9875",
                            "readOnly" : true
                        },
                        {
                            "type" : "textarea",
                            "id" : "description",
                            "property" : "description",
                            "label" : "\u63cf\u8ff0",
                            "size" : 5,
                            "readOnly" : true
                        }
                    ]
                },

                "jira-agile-sprint" : {
                    "id" : "jira-agile-sprint",
                    "name" : "Jira Agile Sprints",
                    "hiddenFromEventCreation" : true,
                    "fields" : [
                        {
                            "type" : "text",
                            "id" : "what",
                            "property" : "title",
                            "label" : "\u4f55\u4e8b",
                            "required" : true,
                            "readOnly" : true
                        },
                        {
                            "type" : "when",
                            "id" : "simple",
                            "disableEndDateTime" : true,
                            "disableAllDay" : true
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        },
                        {
                            "type" : "page",
                            "id" : "url",
                            "property" : "workingUrl",
                            "label" : "\u76f8\u5173\u9875",
                            "readOnly" : true
                        },
                        {
                            "type" : "textarea",
                            "id" : "description",
                            "property" : "description",
                            "label" : "\u63cf\u8ff0",
                            "size" : 5,
                            "readOnly" : true
                        }
                    ]
                },

                "jira-project-releases" : {
                    "id" : "jira-project-releases",
                    "name" : "Jira \u9879\u76ee\u53d1\u5e03",
                    "hiddenFromEventCreation" : true,
                    "fields" : [
                        {
                            "type" : "text",
                            "id" : "what",
                            "property" : "title",
                            "label" : "\u4f55\u4e8b",
                            "required" : true,
                            "readOnly" : true
                        },
                        {
                            "type" : "when",
                            "id" : "simple",
                            "disableEndDateTime" : true,
                            "disableAllDay" : true

                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        },
                        {
                            "type" : "page",
                            "id" : "url",
                            "property" : "workingUrl",
                            "label" : "\u76f8\u5173\u9875",
                            "readOnly" : true
                        },
                        {
                            "type" : "textarea",
                            "id" : "description",
                            "property" : "description",
                            "label" : "\u63cf\u8ff0",
                            "size" : 5,
                            "readOnly" : true
                        }
                    ]
                },

                "other" : {
                    "id" : "other",
                    "name" : "\u4e8b\u4ef6",
                    "fields" : [
                        {
                            "type" : "text",
                            "id" : "what",
                            "property" : "title",
                            "label" : "\u4f55\u4e8b",
                            "required" : true,
                            "copyto" : "description"
                        },
                        {
                            "type" : "user",
                            "id" : "who",
                            "label" : "\u4f55\u4eba",
                            "property" : "what"
                        },
                        {
                            "type" : "when",
                            "id" : "simple"
                        },
                        {
                            "type" : "repeats2",
                            "id" : "simple"
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        },
                        {
                            "type" : "text",
                            "id" : "where",
                            "property" : "where",
                            "label" : "\u5730\u70b9"
                        },
                        {
                            "type" : "page",
                            "id" : "url",
                            "property" : "workingUrl",
                            "label" : "\u76f8\u5173\u9875"
                        },
                        {
                            "type" : "textarea",
                            "id" : "description",
                            "property" : "description",
                            "label" : "\u63cf\u8ff0",
                            "size" : 5
                        }
                    ]
                },

                "jira-calendar" : {
                    "id" : "jira-calendar",
                    "name" : "Jira \u95ee\u9898\u65e5\u671f",
                    "customHandler" : JiraEventFieldProcess.CustomSubmitter.JiraIssues,
                    "hiddenFromEventCreation" : !Confluence.TeamCalendars.hasJiraLink,
                    "fields" : [
                        {
                            "type" : "jira-server-select",
                            "id" : "server",
                            "property" : "server",
                            "label" : "\u670d\u52a1\u5668",
                            "required" : true
                        },
                        {
                            "type" : "text",
                            "id" : "name",
                            "property" : "name",
                            "required" : true,
                            "label" : "\u540d\u79f0"
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        },
                        {
                            "type" : "jira-dates",
                            "id" : "jira-dates"
                        }
                    ]
                },

                "jira-agile-sprint-calendar" : {
                    "id" : "jira-agile-sprint-calendar",
                    "name" : "Jira Agile Sprints",
                    "customHandler" : JiraEventFieldProcess.CustomSubmitter.JiraAgileSprints,
                    "hiddenFromEventCreation" : !Confluence.TeamCalendars.hasJiraLink,
                    "fields" : [
                        {
                            "type" : "jira-hidden-fields",
                            "id" : "",
                            "property" : "",
                            "required" : true,
                            "label" : ""
                        },
                        {
                            "type" : "jira-server-select",
                            "id" : "server",
                            "property" : "server",
                            "label" : "\u670d\u52a1\u5668",
                            "required" : true
                        },
                        {
                            "type" : "jira-project-select",
                            "id" : "project",
                            "property" : "project",
                            "label" : "\u9879\u76ee",
                            "required" : true
                        },
                        {
                            "type" : "text",
                            "id" : "name",
                            "property" : "title",
                            "required" : true,
                            "label" : "\u540d\u79f0"
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        }
                    ]
                },

                "jira-project-releases-calendar" : {
                    "id" : "jira-project-releases-calendar",
                    "name" : "Jira \u9879\u76ee\u53d1\u5e03",
                    "customHandler" : JiraEventFieldProcess.CustomSubmitter.JiraProjectReleases,
                    "hiddenFromEventCreation" : !Confluence.TeamCalendars.hasJiraLink,
                    "fields" : [
                        {
                            "type" : "jira-hidden-fields",
                            "id" : "",
                            "property" : "",
                            "required" : true,
                            "label" : ""
                        },
                        {
                            "type" : "jira-server-select",
                            "id" : "server",
                            "property" : "server",
                            "label" : "\u670d\u52a1\u5668",
                            "required" : true
                        },
                        {
                            "type" : "jira-project-select",
                            "id" : "project",
                            "property" : "project",
                            "label" : "\u9879\u76ee",
                            "required" : true
                        },
                        {
                            "type" : "text",
                            "id" : "name",
                            "property" : "title",
                            "required" : true,
                            "label" : "\u540d\u79f0"
                        },
                        {
                            "type" : "reminder",
                            "id" : "reminder",
                            "label" : "\u63d0\u9192"
                        }
                    ]
                }
            },
            CustomEventType : {
                "id" : "custom",
                "name" : "\u4e8b\u4ef6",
                "fields" : [
                    {
                        "type" : "text",
                        "id" : "what",
                        "property" : "title",
                        "label" : "\u4f55\u4e8b",
                        "required" : true,
                        "copyto" : "description"
                    },
                    {
                        "type" : "user",
                        "id" : "who",
                        "label" : "\u4f55\u4eba",
                        "property" : "what"
                    },
                    {
                        "type" : "when",
                        "id" : "simple"
                    },
                    {
                        "type" : "repeats2",
                        "id" : "simple"
                    },
                    {
                        "type" : "reminder",
                        "id" : "reminder",
                        "label" : "\u63d0\u9192"
                    },
                    {
                        "type" : "text",
                        "id" : "where",
                        "property" : "where",
                        "label" : "\u5730\u70b9"
                    },
                    {
                        "type" : "page",
                        "id" : "url",
                        "property" : "workingUrl",
                        "label" : "\u76f8\u5173\u9875"
                    },
                    {
                        "type" : "textarea",
                        "id" : "description",
                        "property" : "description",
                        "label" : "\u63cf\u8ff0",
                        "size" : 5
                    }
                ]
            }
        };
        return EventTypes;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-edit', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/event-edit/event-edit-dialog-combat.js' */
//This is here to make the existing API work.
require(["tc/event-edit-dialog"], function (EventEditDialog) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getEditEventDialog = function(event, subCalendar, _CalendarPlugin, _calendarDiv){
        return new EventEditDialog().getEditEventDialog(event, subCalendar, _CalendarPlugin, _calendarDiv);
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-list.js' */
define("tc/customeventtype-list",
    [
        "jquery",
        "tc-backbone",
        "tc/customeventtype-model",
        "underscore"
    ],
    function (
        $,
        Backbone,
        CustomeEventTypeModel,
        _)
    {
        "use strict";
        var customeEventTypeList = Backbone.Collection.extend({
            model: CustomeEventTypeModel,

            // localStorage: new LocalStorage("customeventtypes-backbone"),

            select : function(selectedId){
                this.selectedId = selectedId;
                var resultItem = this.selectedItem();
                this.trigger("selected", this);
                return resultItem;
            },

            selectedItem : function(){
                if (this.selectedId)
                {
                    return this.findWhere({ id : this.selectedId});
                }

                return undefined;
            },

            defaultEventTypes: function() {
                return this.where({isCustomEvent : false});
            },

            customEventTypes: function() {
                return this.where({isCustomEvent : true});
            },

            initialize: function () {
                // Default sort field and direction
                this.sortField = "name";
                this.sortDirection = "ASC";
            },

            setSortField: function (field, direction) {
                this.sortField = field;
                this.sortDirection = direction;
            },

            comparator: function (modelItem) {
                return modelItem.get(this.sortField);
            },

            // Overriding sortBy
            sortBy: function (iterator, context) {
                var obj = this.models,
                    direction = this.sortDirection;

                return _.pluck(_.map(obj, function (value, index, list) {
                    return {
                        value: value,
                        index: index,
                        criteria: iterator.call(context, value, index, list)
                    };
                }).sort(function (left, right) {
                    // swap a and b for reverse sort
                    var itemA = direction === "ASC" ? left.criteria : right.criteria,
                        itemB = direction === "ASC" ? right.criteria : left.criteria;

                    if (itemA !== itemB) {
                      if (itemA > itemB || itemA === void 0) {
                          return 1;
                      }
                      if (itemA < itemB || itemB === void 0) {
                          return -1;
                      }
                    }
                    return left.index < right.index ? -1 : 1;
                }), 'value');
            }
        });

        return customeEventTypeList;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-model.js' */
define("tc/customeventtype-model",
    [
        "jquery",
        "tc-backbone"
    ],
    function (
        $,
        Backbone)
    {
        "use strict";
        var customeEventTypeModel = Backbone.Model.extend({
            defaults : function (){
                return {
                    title: "",
                    icon: "",
                    subCalendar: "",
                    disable: false,
                    isCustomEvent: false,
                    id: "",
                    created: "",
                    periodInMins: ""
                };
            },
            validate: function (attrs) {
                if (!attrs.isCustomEvent){
                    return false;
                }

                var errors = [];
                if (!attrs.title)
                {
                    errors.push({field : "title", message : "\u9700\u586b\u4e8b\u4ef6\u540d"});
                }

                attrs.title = $.trim(attrs.title);
                if (attrs.title.length <= 0){
                    errors.push({field : "title", message : "\u9700\u586b\u4e8b\u4ef6\u540d"});
                }else {
                    if (attrs.title.length > 256){
                        errors.push({field : "title", message : "\u4e8b\u4ef6\u540d\u79f0\u5e94\u5c0f\u4e8e\u7b49\u4e8e256\u4e2a\u5b57\u7b26"});
                    }
                }

                if (!attrs.icon)
                {
                    errors.push({field : "icon", message : "\u9700\u586b\u4e8b\u4ef6\u56fe\u6807"});
                }

                return errors.length > 0 ? errors : false;
            },
            toggle: function() {
                this.set({disable: !this.get("disable")});
            }
        });

        return customeEventTypeModel;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-view/customeventtype-view.js' */
define("tc/customeventtype-view",
    [
        "jquery",
        "tc-backbone",
        "tc/dialogs",
        "tc/templates",
        "tc/customeventtype-edit",
        "tc/calendar-util"
    ],
    function (
        $,
        Backbone,
        Dialog,
        Templates,
        CustomEventTypeEditInlineDialogView,
        CalUtil
        )
    {
        "use strict";
        var CustomEventTypeView = Backbone.View.extend({
            tagName : "tr",
            mediator : null,
            confirmDialog : null,
            events: {
                "click .hidden-link" : "_toggle",
                "click .edit-eventtypes-link" : "_edit",
                "click .remove-eventtypes-link" : "_removeFromCollection"
            },
            initialize: function(option) {
                this.mediator = option.mediator;
                this.listenTo(this.model, "change", this.render);
                this.listenTo(this.model, 'destroy', this.remove);
                this.listenTo(this.model.collection, "selected" , this.selected);
            },
            render: function() {
                if (!this.$el.hasClass("event-type-item")){
                    this.$el.addClass("event-type-item");
                }

                if (this.model.get("disable")){
                    this.$el.addClass("event-type-item-hidden");
                }else {
                    this.$el.removeClass("event-type-item-hidden");
                }

                // remove tipsy before we change to new dom
                this.$el.find(".eventtypes-icon-link a").each(function(index, item){
                    var tipsy = $(item).data("tipsy");
                    if(tipsy) {
                        tipsy.disable();
                        tipsy.hide();
                    }
                });

                var modelObj = $.extend(
                    {}, this.model,
                    {
                        "showInforReminder" : CalUtil.showInforReminder(this.model.attributes.periodInMins)
                    }
                );

                this.$el.html(Confluence.TeamCalendars.Templates.viewCustomEventType({"eventTypeModel": modelObj}));

                 //add tooltip
                var $disableLink = this.$el.find(".eventtypes-icon-link a");
                if ($disableLink.tooltip)
                {
                    $disableLink.tooltip({aria:true});
                }

                return this;
            },
            removeEventListener : function (){
                this.$el.off('click', '.hide-eventtypes-link');
            },
            remove: function(){
                // detach from DOM
                this.$el.remove();
            },
            selected : function(collection){
                var selectedItem = collection.selectedItem();
                if (selectedItem.id === this.model.id) {
                    this._edit();
                }
            },
            _toggle: function(){
                this.model.toggle();
            },
            _edit: function() {
                var eventTypeEditDialogView = new CustomEventTypeEditInlineDialogView({model : this.model, parentCustomEventTypeDiv: this.$el, mediator : this.mediator});
                eventTypeEditDialogView.render();
                //scroll to bottom
                $("#edit-calendar-dialog").find(".eventtypes-edit-dialog-panel").scrollTop(eventTypeEditDialogView.$el.position().top);
            },
            _removeFromCollection: function(){
                var that = this;
                that.mediator.trigger("close-edit-custom-event-dialog");
                that._showConfirmCustomEventTypeDeleteDialog(that.model);
            },
            _getCustomEventTypeData: function(newCustomEventTypeModel) {
                return {
                    subCalendarId: newCustomEventTypeModel.get("subCalendar").id,
                    customEventTypeId: newCustomEventTypeModel.get("id")
                };
            },
            _showConfirmCustomEventTypeDeleteDialog: function(model) {
                var that = this;

                //bind escape when open confirm custom event type dialog
                function _bindEscapeCloseConfirmDialog(e) {
                   if (e.keyCode === 27) {
                       that._calltrigerOpenEditCustomEventTypeDialog(_bindEscapeCloseConfirmDialog);
                   }
                }
                $(document).keyup(_bindEscapeCloseConfirmDialog);

                var confirmCustomEventTypeDeleteDialog = new AJS.Dialog(450, "auto", "confirm-delete-custom-event-type");
                confirmCustomEventTypeDeleteDialog.addHeader("\u5220\u9664\u4e8b\u4ef6\u7c7b\u578b");
                confirmCustomEventTypeDeleteDialog.addPanel(
                    "",
                    Confluence.TeamCalendars.Templates.confirmCustomEventNameDelete({"customEventName": model.get("title")}),
                    "tc-confirm-delete-custom-event-type-dialog");

                confirmCustomEventTypeDeleteDialog.addButton("\u662f", function () {
                    that._removeCustomEventType(model, confirmCustomEventTypeDeleteDialog, _bindEscapeCloseConfirmDialog);
                });

                confirmCustomEventTypeDeleteDialog.addLink("\u53d6\u6d88", function () {
                    confirmCustomEventTypeDeleteDialog.hide();
                    that._calltrigerOpenEditCustomEventTypeDialog(_bindEscapeCloseConfirmDialog);
                    return false;
                });

                that.confirmDialog = confirmCustomEventTypeDeleteDialog;

                that.confirmDialog.show();
                that.confirmDialog.updateHeight();

                return confirmCustomEventTypeDeleteDialog;
            },
            _removeCustomEventType: function(model, confirmCustomEventTypeDeleteDialog, bindEscapeCloseConfirmDialog) {
                var that = this;
                var requestData = that._getCustomEventTypeData(model);
                //call rest to remove new custom event type
                $.ajax({
                    cache : false,
                    data : requestData,
                    dataType : "json",
                    error : function(XMLHttpRequest, textStatus, errorThrown) {
                        confirmCustomEventTypeDeleteDialog.hide();
                    },
                    success : function() {
                        model.collection.remove(model);
                        confirmCustomEventTypeDeleteDialog.hide();
                        that._calltrigerOpenEditCustomEventTypeDialog(bindEscapeCloseConfirmDialog);

                        //analytic for delete a custom event type
                        var property = {
                            customEventTypeName: model.get("title")
                        };
                        Confluence.TeamCalendars.fireEventForAnalytics("customeventtype.delete", property);
                    },
                    type : "DELETE",
                    timeout: Confluence.TeamCalendars.ajaxTimeout,
                    url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/eventtype/custom.json")
                });
            },
            _calltrigerOpenEditCustomEventTypeDialog: function(bindEscapeCloseConfirmDialog) {
                this.mediator.trigger("open-edit-custom-event-dialog");
                if (this.confirmDialog)
                {
                    this.confirmDialog.hide();
                    this.confirmDialog.remove();
                }

                $(document).unbind("keyup", bindEscapeCloseConfirmDialog);
            }
        });

        return CustomEventTypeView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtype-view/customeventtype-view.soy' */
// This file was automatically generated from customeventtype-view.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.viewCustomEventType = function(opt_data, opt_ignored) {
  return '<td class="custom-event-type-title" data-id="' + soy.$$escapeHtml(opt_data.eventTypeModel.attributes.id) + '" data-title="' + soy.$$escapeHtml(opt_data.eventTypeModel.attributes.title) + '"><span class="event-type-link" title="' + soy.$$escapeHtml(opt_data.eventTypeModel.attributes.title) + '">' + Confluence.TeamCalendars.Templates.renderCustomImagePrinting({eventType: opt_data.eventTypeModel.attributes.icon, customClasses: ['event-type-table-item', opt_data.eventTypeModel.attributes.icon]}) + '<span class="event-type-label">' + soy.$$escapeHtml(opt_data.eventTypeModel.attributes.title) + '</span></span></td><td class="event-type-reminder-title"><span class="event-type-reminder-info" title="' + soy.$$escapeHtml(opt_data.eventTypeModel.showInforReminder) + '">' + soy.$$escapeHtml(opt_data.eventTypeModel.showInforReminder) + '</span></td><td class="eventtypes-icon-link">' + ((opt_data.eventTypeModel.attributes.isCustomEvent) ? '<a href="#" class="aui-icon edit-eventtypes-link" title="' + soy.$$escapeHtml('\u7f16\u8f91\u4e8b\u4ef6') + '"></a><a href="#" class="aui-icon hidden-link ' + ((opt_data.eventTypeModel.attributes.disable) ? ' show-eventtypes-link ' : ' hide-eventtypes-link ') + '" title="' + ((opt_data.eventTypeModel.attributes.disable) ? ' ' + soy.$$escapeHtml('\u663e\u793a\u4e8b\u4ef6') + ' ' : ' ' + soy.$$escapeHtml('\u9690\u85cf\u4e8b\u4ef6') + ' ') + '"/><a href="#" class="aui-icon remove-eventtypes-link" title="' + soy.$$escapeHtml('\u5220\u9664\u4e8b\u4ef6') + '"></a>' : '<a href="#" class="aui-icon edit-eventtypes-link" title="' + soy.$$escapeHtml('\u7f16\u8f91\u4e8b\u4ef6') + '"></a><a href="#" class="aui-icon hidden-link ' + ((opt_data.eventTypeModel.attributes.disable) ? ' show-eventtypes-link ' : ' hide-eventtypes-link ') + '" title="' + ((opt_data.eventTypeModel.attributes.disable) ? ' ' + soy.$$escapeHtml('\u663e\u793a\u4e8b\u4ef6') + ' ' : ' ' + soy.$$escapeHtml('\u9690\u85cf\u4e8b\u4ef6') + ' ') + '"/>') + '</td>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.viewCustomEventType.soyTemplateName = 'Confluence.TeamCalendars.Templates.viewCustomEventType';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtypes-edit-dialog/customeventtypes-edit-dialog.js' */
define("tc/eventtypes-edit-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/dialogs",
        "tc/templates",
        "tc/customeventtype-view",
        "tc/customeventtype-edit",
        "tc/customeventtype-model",
        "tc/customeventtype-list",
        "tc/event-types"
    ], function (
        $,
        _,
        Backbone,
        Dialog,
        Templates,
        CustomEventTypeView,
        CustomEventTypeEditInlineDialogView,
        CustomeEventTypeModel,
        CustomEventTypeList,
        EventTypes)
    {
        "use strict";
        var EventTypesEditDialogView = Backbone.View.extend({
            editDialog: null,
            subCalendar: null,
            callbackHandler: null,
            mediator : null,
            events: {
                "click .add-custom-event-type-item span": "_showAddEventypeForm"
            },
            initialize: function(options){
                this.options = $.extend({}, this.defaults, options);
                this.mediator = _.extend({}, Backbone.Events);
                this.subCalendar = this.options.subCalendar;
                this.callbackHandler = this.options.callbackHandler;
                this.collection = this._buildCustomEventTypeCollection();

                // build a custom event collection for event type
                this.editDialog = this.options.editDialog;
                this.listenTo(this.collection, 'reset add remove', this.render);
                this.mediator.on("Custom-Event-Type.save", _.bind(this._updateEventType, this, this.callbackHandler));
                this.mediator.on("close-edit-custom-event-dialog", _.bind(this._closeEditCustomEventTypeDialog, this));
                this.mediator.on("open-edit-custom-event-dialog", _.bind(this._openEditCustomEventTypeDialog, this));

                this.$el.html(Templates.editCalendarEventTypes({"subCalendarId": this.subCalendar.id, "eventTypes": this.collection}));
                this.editDialog.addPanel("\u4e8b\u4ef6\u7c7b\u578b", this.$el, "eventtypes-edit-dialog-panel");
            },
            render: function() {
                if (this.collection.customEventTypes().length === 0){
                    // render instructional text
                    this.$el.find(".custom-event-type-items-instructional").removeClass("hidden");
                } else {
                    this.$el.find(".custom-event-type-items-instructional").addClass("hidden");
                }

                this.$el.find(".event-type-item").remove();
                // render default eventTypes
                this._renderCustomeEventTypes(this.$el.find(".default-event-type-items"), this.collection.defaultEventTypes());

                // render custom eventTypes
                this.collection.setSortField("created", "DESC"); //order sort for custom event
                this.collection.sort();
                this._renderCustomeEventTypes(this.$el.find(".custom-event-type-items"), this.collection.customEventTypes());

                //process behaviour when event type panel active
                this.editDialog.getCurrentPanel().onselect = function() {
                    $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");
                };

                return this.editDialog;
            },
            selectCustomEvent: function(id) {
                this.collection.select(id);
            },
            getDisableEventTypes : function (){
                var disableEventType = this.collection.chain()
                    .filter(function(model) { return model.get('disable') === true; })
                    .map(function(model) { return  model.id; })
                    .value();

                return disableEventType;
            },
            showAddEventypeForm : function(){
                // trigger click to show add event type form
                $('.add-custom-event-type-item span').click();
            },
            _renderCustomeEventTypes : function($rootElement, eventTypes){
                var that = this;
                $(eventTypes).each(function(index, eventTypeModel){
                    var customEventTypeView = new CustomEventTypeView({model : eventTypeModel, mediator : that.mediator});
                    $rootElement.after(customEventTypeView.render().el);
                });
            },
            _buildCustomEventTypeCollection : function (){
                var that = this;
                var listDisableEventType = that.subCalendar.disableEventTypes;
                var listCustomEventType = that.subCalendar.customEventTypes;
                var sanboxEventTypeReminders = that.subCalendar.sanboxEventTypeReminders;
                var eventTypes = EventTypes.DefaultEventType;
                var customEventTypeCollection = new CustomEventTypeList();

                var isDisableEventType = function(eventType) {
                    for (var item in listDisableEventType) {
                        if (eventType === listDisableEventType[item])
                        {
                            return true;
                        }
                    }
                    return false;
                };

                var getPeriodForSanboxEventType = function(eventTypeId) {
                    for(var item in sanboxEventTypeReminders) {
                        if(eventTypeId === sanboxEventTypeReminders[item].eventTypeId) {
                            return sanboxEventTypeReminders[item].periodInMins;
                        }
                    }
                }

                var customeEventModels = new Array();
                //load default sanbox event type
                $.each(eventTypes, function(i, type) {
                    if (!type.hiddenFromEventCreation) {
                        var customeEventModel = new CustomeEventTypeModel({
                            title : type.name,
                            subCalendar : that.subCalendar,
                            disable : isDisableEventType(type.id),
                            id : type.id,
                            icon : type.id,
                            periodInMins: getPeriodForSanboxEventType(type.id)
                        });
                        customeEventModels.push(customeEventModel);
                    }
                });

                //load custom event type
                if(listCustomEventType) {
                    $.each(listCustomEventType, function(i, type) {
                        var customeEventModel = new CustomeEventTypeModel({
                            title : type.title,
                            subCalendar : that.subCalendar,
                            disable : isDisableEventType(type.customEventTypeId),
                            id : type.customEventTypeId,
                            icon : type.icon,
                            isCustomEvent: true,
                            created: type.created,
                            periodInMins: type.periodInMins
                        });
                        customeEventModels.push(customeEventModel);
                    });
                }

                customEventTypeCollection.add(customeEventModels);
                return customEventTypeCollection;
            },
            _showAddEventypeForm: function(event) {
                var $addCustomEventTypeBtn = $(event.target).closest(".add-custom-event-type-item");

                var newCustomEventNewModel = new CustomeEventTypeModel({
                    id : null,
                    subCalendar : this.subCalendar,
                    isCustomEvent: true
                });
                newCustomEventNewModel.collection = this.collection;

                var eventTypesEditDialogView = new CustomEventTypeEditInlineDialogView({model : newCustomEventNewModel, parentCustomEventTypeDiv: $addCustomEventTypeBtn, mediator : this.mediator});
                eventTypesEditDialogView.render();
                //scroll to bottom
                this.$el.parent().scrollTop(this.$el.find("#edit-custom-event-type-form form").position().top);
            },
            _updateEventType: function(_callbackHandler, newEventTypeModel) {
               if(newEventTypeModel.get("isCustomEvent") === true) {
                   this._updateCustomEventType(_callbackHandler, newEventTypeModel);
               } else {
                   this._updateSanboxEventType(_callbackHandler, newEventTypeModel);
               }
            },
            _updateCustomEventType : function(_callbackHandler, newCustomEventTypeModel) {
                var that = this;
                var requestData = that._getCustomEventTypes(newCustomEventTypeModel);

                //disable button submit
                var submitButton = this.$el.find("#save-custom-event-type");
                $(submitButton).val("\u6b63\u5728\u4fdd\u5b58...").attr("disabled", "disabled").addClass("ui-state-disabled");

                //call rest to add new custom event type
                $.ajax({
                     cache : false,
                     data : requestData,
                     dataType : "json",
                     error : function(XMLHttpRequest, textStatus, errorThrown) {
                         _callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                     },
                     success : function(responseEntity) {
                         var customEventTypeModel = new CustomeEventTypeModel({
                             subCalendar : that.subCalendar,
                             isCustomEvent: true,
                             title: responseEntity.title,
                             icon: responseEntity.icon,
                             id: responseEntity.customEventTypeId,
                             created: responseEntity.created,
                             periodInMins: responseEntity.periodInMins
                         });

                         //analytic for add/update a custom event type
                         var property = {
                                customEventTypeName: responseEntity.title
                             };
                         var isCreateNew = true;
                         var customEventTypes = that.collection.where({id: responseEntity.customEventTypeId});
                         if(customEventTypes && customEventTypes.length > 0) {
                             isCreateNew = false;
                         }
                         if (isCreateNew) {
                             Confluence.TeamCalendars.fireEventForAnalytics("customeventtype.create", property);
                         } else {
                             Confluence.TeamCalendars.fireEventForAnalytics("customeventtype.update", property);
                         }

                         that.collection.add(customEventTypeModel);
                         //scroll to bottom
                         that.$el.parent().scrollTop(that.$el.find(".add-custom-event-type-item").position().top);
                     },
                     type : "PUT",
                     timeout: Confluence.TeamCalendars.ajaxTimeout,
                     url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/eventtype/custom.json")
                });
            },
            _updateSanboxEventType : function(_callbackHandler, newEventTypeModel) {
                var that = this;
                var requestData = that._getSanboxEventTypes(newEventTypeModel);

                //disable button submit
                var submitButton = this.$el.find("#save-custom-event-type");
                $(submitButton).val("\u6b63\u5728\u4fdd\u5b58...").attr("disabled", "disabled").addClass("ui-state-disabled");

                //call rest to add new custom event type
                $.ajax({
                     cache : false,
                     data : requestData,
                     dataType : "json",
                     error : function(XMLHttpRequest, textStatus, errorThrown) {
                         _callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                     },
                     success : function(responseEntity) {
                         that.collection.add(newEventTypeModel);
                         //scroll to bottom
                         that.$el.parent().scrollTop(that.$el.find(".add-custom-event-type-item").position().top);
                     },
                     type : "PUT",
                     timeout: Confluence.TeamCalendars.ajaxTimeout,
                     url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/eventtype/sandbox.json")
                });
            },
            _selectIconCustomEventType: function(event) {
                // stop default link click behaviour
                event.preventDefault();

                // unmark any previously selected image and mark clicked selected
                $(event.target).siblings('.icon-teamcals').removeClass('selected');
                $(event.target).addClass('selected');
            },
            _getCustomEventTypes: function(newCustomEventTypeModel) {
                return {
                    title: newCustomEventTypeModel.get("title"),
                    icon: newCustomEventTypeModel.get("icon"),
                    subCalendarId: newCustomEventTypeModel.get("subCalendar").id,
                    customEventTypeId: newCustomEventTypeModel.get("id"),
                    created: newCustomEventTypeModel.get("created"),
                    periodInMins: newCustomEventTypeModel.get("periodInMins")
                };
            },
            _getSanboxEventTypes: function(newEventTypeModel) {
                return {
                    title: newEventTypeModel.get("title"),
                    icon: newEventTypeModel.get("icon"),
                    subCalendarId: newEventTypeModel.get("subCalendar").id,
                    eventTypeId: newEventTypeModel.get("id"),
                    created: newEventTypeModel.get("created"),
                    periodInMins: newEventTypeModel.get("periodInMins")
                };
            },
            _closeEditCustomEventTypeDialog: function() {
                this.editDialog.hide();
            },
            _openEditCustomEventTypeDialog: function() {
                this.editDialog.show();
            }
        });
        return EventTypesEditDialogView;
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:eventtypes-edit', location = 'com/atlassian/confluence/extra/calendar3/components/customeventype/customeventtypes-edit-dialog/customeventtypes-edit-dialog.soy' */
// This file was automatically generated from customeventtypes-edit-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.editCalendarEventTypes = function(opt_data, opt_ignored) {
  return '<form name="editSubCalendarEventTypesForm" class="sub-calendar-edit-event-types-form aui" method="POST" action="#"><input type="hidden" name="subCalendarId" value="' + soy.$$escapeHtml(opt_data.subCalendarId) + '"><div class="form-mode create"><table id="eventtypes-edit-table" class="tc-event-type-item aui"><colgroup><col span="1" class="aui-restfultable-order"><col span="1"><col span="1" class="aui-restfultable-operations"></colgroup><tbody class="ui-sortable"><tr class="default-event-type-items"><td class="event-types-title">' + soy.$$escapeHtml('\u9ed8\u8ba4\u4e8b\u4ef6\u7c7b\u578b') + '</td><td class="event-types-title">' + soy.$$escapeHtml('\u63d0\u9192') + '</td><td class="event-types-title"/></tr><tr class="custom-event-type-items"><td class="event-types-title">' + soy.$$escapeHtml('\u81ea\u5b9a\u4e49\u4e8b\u4ef6\u7c7b\u578b') + '</td><td class="event-types-title">' + soy.$$escapeHtml('\u63d0\u9192') + '</td><td class="event-types-title"/></tr><tr class="custom-event-type-items-instructional"><td class="custom-event-types-instructional" colspan="3">' + soy.$$escapeHtml('\u8ba1\u5212\u4efb\u610f\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c\u5982\u57f9\u8bad\u3001\u6392\u73ed\u7b49\u5404\u7c7b\u6d3b\u52a8\uff01') + '</td></tr><tr class="add-custom-event-type-item"><td><span class="custom-event-type-link" title="' + soy.$$escapeHtml('\u6dfb\u52a0\u65b0\u4e8b\u4ef6\u7c7b\u578b') + '"><span class="aui-icon aui-icon-small aui-iconfont-add add-event-type-icon">Add custom event</span><span class="add-event-type-label">' + soy.$$escapeHtml('\u6dfb\u52a0\u65b0\u4e8b\u4ef6\u7c7b\u578b') + '</span></span></td><td class="event-types-title"/></tr></tbody></table></div></form>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.editCalendarEventTypes.soyTemplateName = 'Confluence.TeamCalendars.Templates.editCalendarEventTypes';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:mycalendar-tour-resources', location = 'com/atlassian/confluence/extra/calendar3/components/local-stogare/local-storage.js' */
/**
 * An abstract module to work around Confluence.storageManager does not available in older Confluence
 */
define("tc/localStorage",
    [
        "jquery"
    ],
    function ($)
    {
        var cookieStorage = function() {
            return {
                getItem: function(key) {
                    $.cookie(key)
                },

                setItem: function(key, value, expire) {
                    $.cookie(key, value, expire)
                }
            }
        }();

        var id = "team-calendars",
            tcStorageManger = Confluence.storageManager ? Confluence.storageManager(id) : (localStorage ? localStorage : cookieStorage),
            user = AJS.Meta.get("remote-user"),
            namespace = "confluence" + "." +  user + "." + id;

        var getKeyStore = function(key) {
            return Confluence.storageManager ? key : namespace + "." + key;
        };

        return {
            getItem: function(key) {
                return tcStorageManger.getItem(getKeyStore(key));
            },

            setItem: function(key, value, expire) {
                try {
                    tcStorageManger.setItem(getKeyStore(key), value, expire);
                } catch(e){
                    console.log(e);
                }
            }
        };
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:mycalendar-tour-resources', location = 'com/atlassian/confluence/extra/calendar3/components/local-stogare/local-storage-compat.js' */
//This is here to make the existing API work.
require(["tc/localStorage"],
    function (LocalStorage) {
    "use strict";

    Confluence.TeamCalendars.LocalStorage = LocalStorage;
});

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:mycalendar-tour-resources', location = 'com/atlassian/confluence/extra/calendar3/components/my-calendar-tour/my-calendar-tour.js' */
/**
 * Introduction tour for Team Calendar
 */
define("tc/myCalendarTour",
    [
        "jquery",
        "underscore",
        "tc/localStorage"
    ],
    function (
        $,
        _,
        LocalStorage)
    {
        var identifier = "team.calendar";
        var externalClickNamespace = identifier + ".tour";
        var hasBoundOnExternalClick = false;
        var isPausing = false;
        var isStoppingTour = true;
        var currentLegIndexKey = externalClickNamespace + ".currentLegIndex";
        var currentAttachedCalendarKey = externalClickNamespace + ".currentAttachedCalendar";
        var tourFinishKey =  externalClickNamespace + ".done";
        var selectorStringTemplate = "div[data-sub-calendar-id='#calendarID']";

        var getSelectorString = function(context) {
            var calendarID = context.calendarID;
            if (!calendarID){
                return null;
            }

            return selectorStringTemplate.replace("#calendarID", calendarID);
        };

        var menuHelper = {
            selectMenuItem : function (context, menuItemSelector) {
                var selectorString = getSelectorString(context);
                if (!selectorString) {
                    return;
                }

                var targetString = selectorString + menuItemSelector ;
                $(targetString).parent().addClass("active");
            },
            unSelectMenuItem : function (context, menuItemSelector) {
                var selectorString = getSelectorString(context);
                if (!selectorString) {
                    return;
                }

                var targetString = selectorString + menuItemSelector ;
                $(targetString).parent().removeClass("active");
            }
        };
        // actions could be apply before or after leg
        var actionList = {
            openMenu : function (context) {
                // open menu
                var selectorString = getSelectorString(context);

                if ($(selectorString + " .subcalendar-dropdown-menu.parent-subCalendar.active").size() > 0) {
                   // if menu is already open then we won;t do anything
                   return;
                }

                $(selectorString + " .subcalendar-dropdown-menu .subcalendar-dropdown-menu-button .aui-button.aui-button-compact").click();
            },
            closeMenu : function (context) {
                // close menu if it is open
                var selectorString = getSelectorString(context);
                if ($(selectorString + " .subcalendar-dropdown-menu.parent-subCalendar.active").size() > 0) {
                    // click again to close
                    isStoppingTour = false;
                    $(".calendar-panel").click();
                }
            },
            hightLightEditMenuItem : function (context) {
                return menuHelper.selectMenuItem (context, " .parent-subCalendar a.subcalendar-edit");
            },
            unHightLightEditMenuItem : function (context) {
                 return menuHelper.unSelectMenuItem (context, " .parent-subCalendar a.subcalendar-edit");
            },
            hightLightRestrictionMenuItem : function (context) {
                return menuHelper.selectMenuItem (context, " .parent-subCalendar a.subcalendar-restrict");
            },
            unHightLightRestrictionMenuItem : function (context) {
                return menuHelper.unSelectMenuItem (context, " .parent-subCalendar a.subcalendar-restrict");
            },
            hightLightShareMenuItem : function (context) {
                return menuHelper.selectMenuItem (context, " .parent-subCalendar a.subcalendar-share-or-embed");
            },
            unHightLightShareMenuItem : function (context) {
                return menuHelper.unSelectMenuItem (context, " .parent-subCalendar a.subcalendar-share-or-embed");
            }
        };

        var bindHideEvents = function(tourbus) {
            /**
             * Catch click events on the body to see if the click target occurs outside of this popup
             * If it does, the popup will be hidden
             */
            bindHideOnExternalClick(tourbus);
            bindHideOnEscPressed(tourbus);
            bindWindowResize(tourbus);
        };

        var unbindHideEvents = function(tourbus) {
            unbindHideOnExternalClick(tourbus);
            unbindHideOnEscPressed(tourbus);
            unbindWindowResize();
        };

        var bindHideOnEscPressed = function(tourbus) {

            $(document).on("keydown", onKeydown);
        };

        var unbindHideOnEscPressed = function(tourbus) {
            $(document).off("keydown", onKeydown);
        };

        var onKeydown = function(e) {
            if (e.keyCode === 27) {
                isPausing = true;
                bus.stop();
            }
        };

        var bindHideOnExternalClick = function (tourbus) {
            var that = this;
            if (!hasBoundOnExternalClick) {
                $("body").on("click." + externalClickNamespace, function(e) {
                    var $target = $(e.target);
                    // just prevent infinity loop when force close dropdown menu
                    if (!isStoppingTour) {
                       isStoppingTour = true;
                        return;
                    }

                    // hide the popup if the target of the event is not in the dialog
                    if ($target.closest('.tourbus-leg-inner').length === 0) {
                        isPausing = true;
                        tourbus.stop();
                    }
                });
                hasBoundOnExternalClick = true;
            }
        };

        var unbindHideOnExternalClick = function (tourbus) {
            if (hasBoundOnExternalClick) {
                $("body").off("click." + externalClickNamespace);
            }
            hasBoundOnExternalClick = false;
        };

        var bindWindowResize = function(tourbus) {
            $(window).bind("resize." + externalClickNamespace, function(e) {
                tourbus.repositionLegs();
            });
        };

        var unbindWindowResize = function() {
            $(window).unbind("resize." + externalClickNamespace);
        };

        var attachTourTo = function(calendarID) {
            // we only attach to the first one that we found
            var selectorString = getSelectorString({"calendarID" : calendarID});
            if ($(selectorString).is(selectorString)) {
                _.each($("ol.tourbus-legs li.tc-tour-dynamic"), function(tourItem) {
                    var $tourItem = $(tourItem);
                    var targetId = $tourItem.data("el");
                    // update the actual targetId base on calendar
                    $tourItem.attr("data-el", selectorString + " " + targetId);
                });

                return true;
            }

            return false;
        };

        var executeActions = function(calendarID, actionsString) {
            if (!calendarID || !actionsString) {
                AJS.log("Team Calendar tour - could not execute action because invalid calendarID or actionsString");
                return;
            }

            _.each(actionsString.split(" "), function (actionID) {
                var action = actionList[actionID];
                if (action) {
                    AJS.log("Team Calendar tour - leg actions - " + actionID);
                    action ({"calendarID" : calendarID});
                    AJS.log("Team Calendar tour - leg actions - " + actionID + " done");
                }
            });


        };

        var markDoneTheTour = function() {
            AJS.log("Team Calendar tour - mark as DONE");
            LocalStorage.setItem(tourFinishKey, "done");
        };

        var isAlreadyDoneTour = function() {
            return LocalStorage.getItem(tourFinishKey) === "done";
        };

        var hideDropdown = function (){
            if (AJS.dropDown.current && AJS.dropDown.current.hide ) {
                AJS.log("Team Calendar tour - hidding dropdown menu");
                AJS.dropDown.current.hide()
            }
        };

        var tour = undefined;
        var bus = undefined;
        return {
            // this only available if we already start the tour
            tcStorage : LocalStorage,
            tourBus : bus,
            start : function(calendarID) {
                // we don't allow to start if there's license error message announced because calendars are readonly
                if ($(".aui-message.error.license-invalid").size() > 0) {
                    AJS.log("Team Calendar tour - is available when license is valid");
                    return;
                }

                // we don't allow to start if user already finish the tour
                if (isAlreadyDoneTour()){
                    AJS.log("Team Calendar tour - is already done");
                    return;
                }

                // should not show tour on page
                if ($(".plugin-calendar-container.page").size() > 0) {
                    AJS.log("Team Calendar tour - is only available on MyCalendar");
                    return
                }

                if (!calendarID) {
                    // go and get attached calendar Id from our storage
                    calendarID = LocalStorage.getItem(currentAttachedCalendarKey);
                } else {
                    LocalStorage.setItem(currentLegIndexKey, 0);
                    LocalStorage.setItem(currentAttachedCalendarKey, calendarID);
                }

                // get last leg index from localStorage
                var lastLegIndex = LocalStorage.getItem(currentLegIndexKey);
                if (!lastLegIndex) {
                    lastLegIndex = 0;
                }

                // try to find the calendar to attach the tour
                if (!attachTourTo(calendarID)) {
                    AJS.log("Team Calendar tour - could not attached to target elements");
                    return;
                }

                // clean up the previous tour if it exist
                if (bus) {
                    // close the previous bus
                    isPausing = true;
                    hideDropdown();
                    bus.stop();
                    bus.destroy();
                    isPausing = false;
                }

                tour = $('#my-calendar-tour').tourbus( {
                    startAt: lastLegIndex,
                    onDepart: function( tourbus ) {
                        AJS.log("Team Calendar tour - depart");
                        bindHideEvents(tourbus);
                    },
                    onStop: function( tourbus ) {
                        AJS.log("Team Calendar tour - stop");
                        unbindHideEvents(tourbus);

                        actionList.closeMenu({"calendarID": calendarID});

                        if (!isPausing) {
                            markDoneTheTour();
                            LocalStorage.setItem(currentLegIndexKey, 0);
                            Confluence.TeamCalendars.fireEventForAnalytics("tour.finish", {stepNumber : -1});
                            isPausing = false;
                        }
                    },
                    onLegStart: function( leg, tourbus ) {
                        AJS.log("Team Calendar tour - leg start");
                        // will store current leg index for go back case
                        LocalStorage.setItem(currentLegIndexKey, tourbus.currentLegIndex);

                        // update template items
                        var $order = leg.$el.find(".order");
                        var currentIndex = tourbus.currentLegIndex;
                        var orderHtml = $order.html();
                        orderHtml = orderHtml.replace("#legIndex", ++currentIndex);
                        orderHtml = orderHtml.replace("#totalLegs", tourbus.totalLegs);
                        $order.html(orderHtml)

                        // execute generic actions before leg start
                        AJS.log("Team Calendar tour - leg - executing before actions");
                        var actionsString = leg.$original.data("before-leg-actions");
                        executeActions(calendarID, actionsString);
                        AJS.log("Team Calendar tour - leg start - before actions executed");

                        leg.reposition();

                        var property = {
                            stepNumber: tourbus.currentLegIndex
                        };
                        Confluence.TeamCalendars.fireEventForAnalytics("tour.step", property);
                    },
                    onLegEnd: function( leg, tourbus ) {
                        AJS.log("Team Calendar tour - leg end");

                        // execute generic actions after leg execute
                        AJS.log("Team Calendar tour - leg - executing after actions");
                        var actionsString = leg.$original.data("after-leg-actions");
                        executeActions(calendarID, actionsString);
                        AJS.log("Team Calendar tour - leg end - after actions executed");
                    },
                    leg: {
                        zindex: 2400,
                        width : 270,
                        margin: 15
                    }
                });
                bus = tour.data('tourbus');

                // only depart if the tour is not running state
                if (!bus.running) bus.depart();
            },
            stop : function() {
                if (bus){
                    markDoneTheTour();
                    bus.stop();
                }
            },
            softStop : function () {
                if (bus){
                    markDoneTheTour();
                    bus.hideLeg();
                }
            },
            destroy : function() {
                if (bus)  bus.destroy();
            },
            // only available after start the tour
            showLeg : function(index) {
                if (bus) bus.showLeg(index);
            },
            // only available after start the tour
            hideLeg : function() {
                if (bus) {
                    bus.hideLeg();

                    var property = {
                        stepNumber: bus.currentLegIndex
                    };
                    //  Confluence.TeamCalendars.fireEventForAnalytics("tour.paused", property);
                }
            },
            isShowCustomEventTypeFrom : function(calendarId){
                if (isAlreadyDoneTour()) {
                    return false;
                }

                var currentAttachedCalID = LocalStorage.getItem(currentAttachedCalendarKey);
                if (currentAttachedCalID === "" || !currentAttachedCalID) {
                    return false;
                }

                var currentTourIndex = LocalStorage.getItem(currentLegIndexKey);
                if (currentTourIndex !== "0") {
                    return false;
                }

                if (currentAttachedCalID !== calendarId) {
                    return false;
                }

                return true;
            },
            reposition: function(){
                if (bus && !isAlreadyDoneTour()) {
                    bus.repositionLegs();
                }
            }

        };
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:mycalendar-tour-resources', location = 'com/atlassian/confluence/extra/calendar3/components/my-calendar-tour/my-calendar-tour.soy' */
// This file was automatically generated from my-calendar-tour.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.calendarTourContent = function(opt_data, opt_ignored) {
  return '<ol class="tourbus-legs" id="my-calendar-tour" ><li class="tc-tour-dynamic" data-el=".parent-subCalendar a.subcalendar-edit" data-orientation="left" data-align="left" data-arrow="50%" data-before-leg-actions="openMenu hightLightEditMenuItem" data-after-leg-actions="unHightLightEditMenuItem closeMenu"><span class="tourbus-title">' + soy.$$escapeHtml('\u7f16\u8f91\u65e5\u5386') + '</span><p>' + soy.$$escapeHtml('\u81ea\u5b9a\u4e49\u672c\u65e5\u5386\u4e2d\u9700\u8981\u7ba1\u7406\u7684\u4e8b\u4ef6\u7c7b\u578b\u3002') + '</p><button class="tourbus-btn tourbus-next aui-button">Next</button><button class="tourbus-btn tourbus-stop aui-button aui-button-link">Skip tour</button><span class="order">#legIndex/#totalLegs</span></li><li class="tc-tour-dynamic" data-el=".parent-subCalendar a.subcalendar-restrict" data-orientation="left" data-align="left" data-arrow="50%" data-before-leg-actions="openMenu hightLightRestrictionMenuItem" data-after-leg-actions="unHightLightRestrictionMenuItem closeMenu"><span class="tourbus-title">' + soy.$$escapeHtml('\u9650\u5236\u65e5\u5386') + '</span><p>' + soy.$$escapeHtml('\u53ef\u9009\u9879\uff0c \u9650\u5236\u8c01\u53ef\u4ee5\u67e5\u770b\u6216\u6dfb\u52a0\u65e5\u7a0b\u3002') + '</p><button class="tourbus-btn tourbus-next aui-button">Next</button><button class="tourbus-btn tourbus-stop aui-button aui-button-link">Skip tour</button><span class="order">#legIndex/#totalLegs</span></li><li class="tc-tour-dynamic" data-el=".parent-subCalendar a.subcalendar-share-or-embed" data-orientation="left" data-align="left" data-arrow="50%" data-before-leg-actions="openMenu hightLightShareMenuItem" data-after-leg-actions="unHightLightShareMenuItem  closeMenu"><span class="tourbus-title">' + soy.$$escapeHtml('\u4e0e\u56e2\u961f\u5171\u4eab') + '</span><p>' + soy.$$escapeHtml('\u83b7\u53d6\u65e5\u5386\u7684URL\uff0c\u53d1\u9001\u7ed9\u56e2\u961f\u8fdb\u884c\u5171\u4eab\uff0c\u6216\u8005\u5d4c\u5165\u5230\u9875\u9762\u4e0a\u8fdb\u884c\u5c55\u793a\u3002') + '</p><button class="tourbus-btn tourbus-next aui-button">Next</button><button class="tourbus-btn tourbus-stop aui-button aui-button-link">Skip tour</button><span class="order">#legIndex/#totalLegs</span></li><li data-el="#add-event-link" data-orientation="left" data-arrow="17%" ><span class="tourbus-title">' + soy.$$escapeHtml('\u6dfb\u52a0\u4e8b\u4ef6') + '</span><p>' + soy.$$escapeHtml('\u65e5\u5386\u5df2\u7ecf\u53ef\u7528\uff01\u70b9\u51fb\u65e5\u671f\u6216\u8005\u70b9\u51fb\u6dfb\u52a0\u4e8b\u4ef6\u6309\u94ae\uff0c\u8fdb\u884c\u65e5\u7a0b\u5b89\u6392\u3002') + '</p><button class="tourbus-btn tourbus-next aui-button">Next</button><button class="tourbus-btn tourbus-stop aui-button aui-button-link">Skip tour</button><span class="order">#legIndex/#totalLegs</span></li><li data-el="#subscribe-calendar-link" data-orientation="left" data-arrow="17%" ><span class="tourbus-title">' + soy.$$escapeHtml('\u8ba2\u9605') + '</span><p>' + soy.$$escapeHtml('\u4f7f\u7528\u60a8\u6700\u559c\u6b22\u7684\u65e5\u5386\u5ba2\u6237\u7aef\u8ba2\u9605\u65e5\u5386\u3002') + '</p><button class="tourbus-btn tourbus-stop aui-button">Done</button><span class="order">#legIndex/#totalLegs</span></li></ol>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.calendarTourContent.soyTemplateName = 'Confluence.TeamCalendars.Templates.calendarTourContent';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:mycalendar-tour-resources', location = 'com/atlassian/confluence/extra/calendar3/components/my-calendar-tour/my-calendar-tour-compat.js' */
//This is here to make the existing API work.
require(["tc/myCalendarTour"], function (CalendarTour) {
    //HACK
    if (!Confluence.TeamCalendars) {
        Confluence.TeamCalendars = {};
    }

    Confluence.TeamCalendars.CalendarTour = function () {
        return CalendarTour;
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-share-embedded', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-share-dialog/calendar-share-dialog.js' */
define("tc/calendar-share-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util"
    ], function
        (
            $,
            _,
            Backbone,
            Templates,
            CalUtil
            )
    {
        "use strict";
        var ShareCalendarDialog = Backbone.View.extend({
            _calendarDiv: null,
            subCalendar: null,
            _calendarPlugin : null,
            editDialog: null,
            initialize: function(options){
                this._calendarDiv = options._calendarDiv;
                this.subCalendar = options.subCalendar;
                this._calendarPlugin = options._calendarPlugin;

                this.editDialog = options.editDialog;
                this.$el.html(Templates.shareSubCalendar({ "elementIdSuffix" : CalUtil.getParameter(this._calendarDiv, "elementIdSuffix") }));
                this.editDialog.addPanel("\u5d4c\u5165", this.$el, "calendar-share-dialog-panel");
            },
            render: function() {
                var that = this;

                var isSubCalendarRestricted = this._calendarPlugin.doesSubCalendarHaveRestrictions(that.subCalendar),
                    dialogBody,
                    restrictionsLink;

                dialogBody = that.editDialog.getCurrentPanel().body;
                restrictionsLink = $(".share-restrictions-link", dialogBody);

                var link = "";

                if (that.subCalendar.spaceKey) {
                    link = AJS.format("{0}/display/{1}/calendar/{2}?calendarName={3}",
                            CalUtil.getParameter(that._calendarDiv, "baseUrl"),
                            encodeURIComponent(that.subCalendar.spaceKey),
                            encodeURIComponent(that.subCalendar.subscriptionId || that.subCalendar.id),
                            encodeURIComponent(that.subCalendar.name));
                } else {
                    link = AJS.format("{0}/calendar/previewcalendar.action?subCalendarId={1}",
                            CalUtil.getParameter(that._calendarDiv, "baseUrl"),
                            encodeURIComponent(that.subCalendar.subscriptionId || that.subCalendar.id));
                }

                $(".share-address-field", this.editDialog.getCurrentPanel().body).val(link);

                if (isSubCalendarRestricted) {
                    if (that._calendarPlugin.isSubCalendarAdministratable(that._calendarDiv, that.subCalendar)) {
                        restrictionsLink.click(function() {
                            that.editDialog.hide();
                            that._calendarPlugin.getSubCalendarRestrictionsDialog(that._calendarDiv, that.subCalendar).show();
                        });
                    } else {
                        restrictionsLink.addClass("hidden");
                    }
                } else {
                    $(".description", dialogBody).addClass("hidden");
                    var autoConvertMessage = $(".autoconvert", dialogBody);
                    if (that._calendarPlugin.isAutoConvertSupported(that._calendarDiv))
                        autoConvertMessage.removeClass("hidden");
                    else
                        autoConvertMessage.addClass("hidden");
                }

                //process behaviour when share panel active
                this.editDialog.getCurrentPanel().onselect = function() {
                    $("#edit-calendar-dialog").find(".button-panel-button.submit").addClass("hidden");
                    $(".share-address-field", that.editDialog.getCurrentPanel().body).focus().select();
                };

                return that.editDialog;
            }

        });

        return ShareCalendarDialog;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-share-embedded', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-share-dialog/subcalendar-share-dialog.soy' */
// This file was automatically generated from subcalendar-share-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.shareSubCalendar = function(opt_data, opt_ignored) {
  return '<div><label for="share-address-' + soy.$$escapeHtml(opt_data.elementIdSuffix) + '" class="share-address-label">' + soy.$$escapeHtml('\u65e5\u7a0b\u8868\u94fe\u63a5\uff1a') + '</label><input type="text" name="share-address" id="share-address-' + soy.$$escapeHtml(opt_data.elementIdSuffix) + '" class="share-address-field"><div class="description autoconvert hidden">' + soy.$$escapeHtml('\u7c98\u8d34\u6b64\u94fe\u63a5\u81f3 Confluence\u9875\u9762\u53ef\u5c06\u65e5\u7a0b\u8868\u5d4c\u5165\u5230\u5185\u5bb9\u4e2d\u3002') + '</div><div class="description icon-lock">' + soy.$$filterNoAutoescape('\u4e3a\u6b64\u65e5\u7a0b\u8868\u6dfb\u52a0\u9650\u5236\u3002 \x3ca class\x3d\x22share-restrictions-link\x22 href\x3d\x22#\x22\x3e\u68c0\u67e5\u9650\u5236\u4fe1\u606f\u3002\x3c/a\x3e') + '</div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.shareSubCalendar.soyTemplateName = 'Confluence.TeamCalendars.Templates.shareSubCalendar';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-ical-address', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-reset-url-dialog/calendar-reset-url-dialog.js' */
define("tc/calendar-reset-url-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util",
        "tc/util"
    ], function
        (
            $,
            _,
            Backbone,
            Templates,
            CalUtil,
            Util
        )
    {
        "use strict";
        var ResetUrlSubCalendarDialog = Backbone.View.extend({
            resetUrlSubCalendarDialog : null,
            _calendarDiv: null,
            _calendarPlugin : null,
            _subCalendar: null,
            _subCalendars: null,
            initialize: function(options){
                this._calendarDiv = options.calendarDiv;
                this._calendarPlugin = options.calendarPlugin;
                this._subCalendar = options.subCalendar;
                this._subCalendars = options.subCalendars;

                this.resetUrlSubCalendarDialog = $('#calendar-reset-private-urls-dialog');
            },
            render: function() {
                var that = this;
                if (this.resetUrlSubCalendarDialog) {
                    this.resetUrlSubCalendarDialog.remove();
                }

                var resetPrivateUrlsDialog = new AJS.Dialog({
                        width: 512,
                        height: 250,
                        id: "calendar-reset-private-urls-dialog"
                    }),
                    closeDialog = function() {
                        resetPrivateUrlsDialog.hide();
                        resetPrivateUrlsDialog.remove();
                    };

                resetPrivateUrlsDialog.addHeader("\u91cd\u7f6e\u8ba2\u9605");
                resetPrivateUrlsDialog.addPanel("", Templates.resetSubCalendarPrivateUrl(), "calendar-private-url-reset-dialog-panel");

                var resetPrivateUrlsDialogBody =  resetPrivateUrlsDialog.getCurrentPanel().body;
                resetPrivateUrlsDialog.addButton("\u91cd\u7f6e", function() {
                    var spinnerDefer = that._calendarPlugin.setSubCalendarSpinnerIconVisible(true);

                    var resetProgress = $(".reset-progress", resetPrivateUrlsDialogBody).addClass("reset-in-progress");
                    var resetButton = $("#calendar-reset-private-urls-dialog .subcalendar-private-url-reset-button").attr("disabled", "disabled");

                    $.ajax({
                        cache: false,
                        success: function() {
                            resetProgress.removeClass("reset-in-progress").addClass("reset-done");
                            $("#calendar-reset-private-urls-dialog .reset-cancel").text("\u53d6\u6d88");
                            resetButton.removeAttr("disabled");
                        },
                        type: "PUT",
                        timeout : CalUtil.ajaxTimeout,
                        url: that._calendarPlugin.getCalendarServiceBaseUrl(that._calendarDiv, "/subcalendar/privateurl/reset/" + encodeURIComponent(that._subCalendar.id)),
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            resetButton.removeAttr("disabled");
                            CalUtil.showAjaxError(that._calendarDiv, XMLHttpRequest, textStatus, errorThrown,
                                that._calendarPlugin.ERROR_CLASS_RESET_PRIVATE_URLS);
                        },
                        complete: function(){
                            if(spinnerDefer) spinnerDefer.resolve();
                        }
                    });
                }, "subcalendar-private-url-reset-button");
                resetPrivateUrlsDialog.addLink("\u53d6\u6d88", function() {
                    closeDialog();
                    return false;
                }, "reset-cancel");

                $(".calendar-title", resetPrivateUrlsDialogBody).text(that._subCalendar.name);
                $(".subscribe-to-calendar", resetPrivateUrlsDialogBody).click(function() {
                    closeDialog();
                    that._calendarPlugin.getCalendarSubscribeDialog(that._calendarDiv, that._subCalendars, that._subCalendar);
                    return false;
                });
                resetPrivateUrlsDialog.show();

                return resetPrivateUrlsDialog;
            }

        });

        return ResetUrlSubCalendarDialog;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-edit', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-restriction-dialog/calendar-restrictons-dialog.js' */
define("tc/calendar-restriction-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util"
    ], function
        (
            $,
            _,
            Backbone,
            Templates,
            CalUtil
        )
    {
        "use strict";

        var RestrictionDialog = Backbone.View.extend({
            restrictionDialog : null,
            _calendarDiv: null,
            subCalendar: null,
            _calendarPlugin : null,
            calendarCache : null,
            editDialog: null,
            initialize: function(options){
                this._calendarDiv = options._calendarDiv;
                this.subCalendar = options.subCalendar;
                this._calendarPlugin = options._calendarPlugin;
                this.calendarCache = options.calendarCache;
                this.editDialog = options.editDialog;
                this.$el.html(Templates.restrictSubCalendar({
                        "elementIdSuffix" : this._calendarPlugin.getParameter(this._calendarDiv, "elementIdSuffix"),
                        "pdlEnabled" : CalUtil.isPDLEnabled()
                    }));
                this.editDialog.addPanel("\u9650\u5236", this.$el, "setup-calendar-panel");
            },
            render: function() {
                var that = this;

                //process behaviour when restriction panel active
                this.editDialog.getCurrentPanel().onselect = function() {
                    $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");
                };

                var restrictionsForm = $("form", that.editDialog.getCurrentPanel().body);
                $("input[name='subCalendarId']", restrictionsForm).val(that.subCalendar.id || "");
                $(".field-group-permissions", restrictionsForm).each(function() {
                  var restrictionsFieldGroup = $(this);

                  $(".permissions-details", restrictionsFieldGroup).each(function(permissionsFieldGroupIdx) {
                      var permissionsFieldGroup = $(this);
                      var userAutoCompleteInput = $(".autocomplete-user", restrictionsFieldGroup);

                      userAutoCompleteInput.bind("selected.autocomplete-user", function(e, selection) {
                          that._addUsersToPermissionFieldGroup(restrictionsFieldGroup, {
                              "id" : selection.content.userKey || selection.content.username,
                              "name" : selection.content.username,
                              "fullName" : selection.content.title,
                              "avatarUrl" : selection.content.thumbnailLink.href
                          }, true);
                          userAutoCompleteInput.val("");
                      }).focus(function() {
                          if (userAutoCompleteInput.hasClass("with-hint")) {
                              userAutoCompleteInput.removeClass("with-hint").val("");
                          }
                      }).blur(function() {
                          if (!userAutoCompleteInput.val()) {
                              userAutoCompleteInput.addClass("with-hint").val("\u8f93\u5165\u7528\u6237\u540d");
                          }
                      }).keydown(function(jsEvent) {
                          if (jsEvent.keyCode === 13 && !$(".autocomplete .aui-dropdown .active").length) {
                              setTimeout(function() {
                                  var userAutoCompleteInputValue = userAutoCompleteInput.val();
                                  if (userAutoCompleteInputValue) {
                                      that._addGroupsToPermissionFieldGroup(restrictionsFieldGroup, userAutoCompleteInputValue.split(","), true, true);
                                      userAutoCompleteInput.val("");
                                  } else {
                                      that.submitRestrictionsDialog(that.editDialog);
                                  }
                              }, 300);

                              // Hide no results
                              $(".autocomplete .aui-dropdown .no-results").trigger("click");
                              return false;
                          }
                      });

                      $(".group-picker-trigger", permissionsFieldGroup).click(function() {
                          var callbackName = "Team_Calendars_group_picker_callback_" + that._calendarPlugin.getParameter(that._calendarDiv, "elementIdSuffix") + "_" + permissionsFieldGroupIdx;
                          window[callbackName] = function(groupNames) {
                              that._addGroupsToPermissionFieldGroup(restrictionsFieldGroup, groupNames.split(","), false, true);
                          };
                          window.open(
                                  that._calendarPlugin.getParameter(that._calendarDiv, "baseUrl") + "/spaces/opengrouppicker.action?key=ds&startIndex=0&actionName=dosearchgroups.action&onPopupSubmit=" + encodeURIComponent(callbackName),
                              callbackName,
                              "dependent=1,height=512,width=384,resizable=1,status=0"
                          ).focus();
                          return false;
                      });
                  });
                });

                $(".field-group-permissions", restrictionsForm).each(function() {
                  var restrictionsFieldGroup = $(this);
                  var viewRestrictionsRadio = $(".option-view-restrictions", restrictionsFieldGroup);
                  var editRestrictionsRadio = $(".option-edit-restrictions", restrictionsFieldGroup);

                  that._addUsersToPermissionFieldGroup(restrictionsFieldGroup, that.subCalendar.usersPermittedToEdit || []);
                  that._addGroupsToPermissionFieldGroup(restrictionsFieldGroup, that.subCalendar.groupsPermittedToEdit|| []);

                  editRestrictionsRadio.removeAttr("checked");
                  viewRestrictionsRadio.attr("checked", "checked");
                  that._addUsersToPermissionFieldGroup(restrictionsFieldGroup, that.subCalendar.usersPermittedToView || []);
                  that._addGroupsToPermissionFieldGroup(restrictionsFieldGroup, that.subCalendar.groupsPermittedToView || []);
                });

                return that.editDialog;
            },
            submitRestrictionsDialog : function (restrictionsDialog) {
                var that = this;

                var restrictionsForm = $("form", restrictionsDialog.getCurrentPanel().body);
                var getUserRestrictions = function(restrictionsGroup) {
                    return $.map($(".permitted-entity", restrictionsGroup), function(permittedEntity) {
                        var entity = $(permittedEntity).data("entity");
                        return $.isPlainObject(entity) ? entity.id : null;
                    });
                };
                var getGroupRestrictions = function(permissionsGroup) {
                    return $.map($(".permitted-entity", permissionsGroup), function(permittedEntity) {
                        var entity = $(permittedEntity).data("entity");
                        return typeof entity === "string" ? entity : null;
                    });
                };

                var requestData = {subCalendarId: $("input[name='subCalendarId']", restrictionsForm).val()};
                CalUtil.putCalendarContextParams(requestData);

                var viewRestrictionsGroup = $(".view-permissions", restrictionsForm);
                if (viewRestrictionsGroup.length) {
                    requestData.updateUsersPermittedToView = true;
                    requestData.usersPermittedToView = getUserRestrictions(viewRestrictionsGroup);
                    if (!requestData.usersPermittedToView.length) {
                        delete requestData.usersPermittedToView;
                    }

                    requestData.updateGroupsPermittedToView = true;
                    requestData.groupsPermittedToView = getGroupRestrictions(viewRestrictionsGroup);
                    if (!requestData.groupsPermittedToView.length) {
                        delete requestData.groupsPermittedToView;
                    }
                }

                var editRestrictionsGroup = $(".edit-permissions", restrictionsForm);
                if (editRestrictionsGroup.length) {
                    requestData.updateUsersPermittedToEdit = true;
                    requestData.usersPermittedToEdit = getUserRestrictions(editRestrictionsGroup);
                    if (!requestData.usersPermittedToEdit.length) {
                        delete requestData.usersPermittedToEdit;
                    }

                    requestData.updateGroupsPermittedToEdit = true;
                    requestData.groupsPermittedToEdit = getGroupRestrictions(editRestrictionsGroup);
                    if (!requestData.groupsPermittedToEdit.length) {
                        delete requestData.groupsPermittedToEdit;
                    }
                }

                if (that._calendarPlugin.getParameter(that._calendarDiv, "include")) {
                    requestData.include = that._calendarPlugin.getParameter(that._calendarDiv, "include");
                }

                if (!that._calendarPlugin.isProcessingSubCalendar(that._calendarDiv)) {
                    var spinnerDefer = that._calendarPlugin.setSubCalendarSpinnerIconVisible(true);

                    $.ajax({
                        cache: false,
                        converters : {
                            "text json" : function(jsonObject) {
                                return jsonObject;
                            }
                        },
                        data : requestData,
                        dataType : "json",
                        dataFilter : function(data) {
                            var subCalendarsResponseEntity = $.parseJSON(data);
                            if (subCalendarsResponseEntity.success) {
                                that._calendarPlugin.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                            }
                            return subCalendarsResponseEntity;
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            that._calendarPlugin.showAjaxError(that._calendarDiv, XMLHttpRequest, textStatus, errorThrown, that._calendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                            that._calendarPlugin.setProcessingSubCalendar(that._calendarDiv, false);
                        },
                        success : function(responseEntity) {
                            that.calendarCache.removeCalendar(that.subCalendar.id);
                            that._calendarPlugin.setGenericErrors(that._calendarDiv, null, that._calendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                            that._calendarPlugin.setSubCalendars(that._calendarDiv, responseEntity.payload);
                            that._calendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(that._calendarDiv);
                            that._calendarPlugin.setProcessingSubCalendar(that._calendarDiv, false);

                            restrictionsDialog.hide();
                        },
                        complete: function(){
                            if (spinnerDefer) spinnerDefer.resolve();
                        },
                        type : "PUT",
                        timeout : that._calendarPlugin.ajaxTimeout,
                        url : that._calendarPlugin.getCalendarServiceBaseUrl(that._calendarDiv, "/subcalendars/restrictions.json")
                    });
                }

                return false;

            },
            _showHideHint : function(restrictionGroup) {
                var permissionsTable = $(".permission-table", restrictionGroup);
                var permittedEntities = $(".permitted-entities", permissionsTable);

                if ($(".permitted-entity", permittedEntities).length) {
                    restrictionGroup.addClass("has-restrictions");
                    permissionsTable.removeClass("hidden");
                } else {
                    restrictionGroup.removeClass("has-restrictions");
                    permissionsTable.addClass("hidden");
                }
            },
            _getRestrictionGroup : function(restrictionsFieldGroup) {
                return $("input[name='restriction-type']:checked", restrictionsFieldGroup).val() === "view" ?
                       $(".view-permissions", restrictionsFieldGroup) : $(".edit-permissions", restrictionsFieldGroup);
            },
            _addUsersToPermissionFieldGroup : function(restrictionsFieldGroup, users, addUsersToOfList) {
                var that = this;
                var restrictionGroup = that._getRestrictionGroup(restrictionsFieldGroup);
                var permittedEntities = $(".permitted-entities", restrictionGroup);
                var isUserAdded = function(user) {
                    return $(".permitted-entity", permittedEntities).filter(function() {
                        var permittedEntity = $(this).data("entity");
                        return $.isPlainObject(permittedEntity) && permittedEntity.id === user.id;
                    }).length;
                };

                var usersArray;
                if ($.isPlainObject(users)) {
                    usersArray = [ users ];
                } else if ($.isArray(users)) {
                    usersArray = users;
                }

                if ($.isArray(usersArray)) {
                    $.each(usersArray, function(userIdx, user) {
                        if (!isUserAdded(user)) {
                            var permittedEntity = $(document.createElement("tr")).addClass("permitted-entity").append(
                                $(document.createElement("td")).append(
                                    $(document.createElement("img")).attr("src", user.avatarUrl)
                                ).append(
                                    $(document.createElement("span")).text(user.fullName).append(
                                        $(document.createElement("span")).addClass("user-name").text("(" + user.name + ")")
                                    )
                                )
                            ).append(
                                $(document.createElement("td")).addClass("delete-permitted-entity").append(
                                    $(document.createElement("a")).addClass("remove").attr("href", "#").attr("title", "\u5220\u9664"
                                    ).text("\u5220\u9664"
                                    ).click(function() {
                                            $(this).closest("tr").remove();
                                            that._showHideHint(restrictionGroup);
                                            return false;
                                        })
                                )
                            ).data("entity", user);

                            if (addUsersToOfList) {
                                permittedEntity.prependTo(permittedEntities);
                            } else {
                                permittedEntities.append(permittedEntity);
                            }
                        }
                    });
                    $(".error", restrictionsFieldGroup).empty();
                }

                that._showHideHint(restrictionGroup);
            },
            _addGroupsToPermissionFieldGroup : function(restrictionsFieldGroup, groupNames, validate, addGroupsToTopOfList) {
                var that = this;
                var restrictionGroup = that._getRestrictionGroup(restrictionsFieldGroup),
                    permittedEntities = $(".permitted-entities", restrictionGroup),
                    isGroupAdded = function(_groupName) {
                        return $(".permitted-entity", permittedEntities).filter(function() {
                            var permittedEntity = $(this).data("entity");
                            return (typeof permittedEntity === "string") && permittedEntity === _groupName;
                        }).length;
                    },
                    createGroupAvatarCell = function(_groupName) {
                        if (Confluence.TeamCalendars.isPDLEnabled()) {
                            return $("<td/>").append(
                                $("<span/>", { "class" : "group", "text" : _groupName })
                            );
                        } else {
                            return $("<td/>").append(
                                $("<img/>", { "src" : Confluence.getBaseUrl() + "/images/icons/group_16.gif" })
                            ).append(
                                $("<span/>", { "text" : _groupName })
                            );
                        }
                    };

                if (groupNames.length) {
                    var addGroupNames = function(groupNamesToBuild) {
                        $.each(groupNamesToBuild, function(groupNameIdx, groupName) {
                            groupName = $.trim(groupName);
                            if (groupName && !isGroupAdded(groupName)) {
                                var permittedEntity = $(document.createElement("tr")).addClass("permitted-entity").append(
                                    createGroupAvatarCell(groupName)
                                ).append(
                                    $(document.createElement("td")).addClass("delete-permitted-entity").append(
                                        $(document.createElement("a")).addClass("remove").attr("href", "#").attr("title", "\u5220\u9664"
                                        ).text("\u5220\u9664"
                                        ).click(function() {
                                                $(this).closest("tr").remove();
                                                that._showHideHint(restrictionGroup);
                                                return false;
                                            })
                                    )
                                ).data("entity", groupName);

                                if (addGroupsToTopOfList) {
                                    permittedEntity.prependTo(permittedEntities);
                                } else {
                                    permittedEntities.append(permittedEntity);
                                }
                            }
                        });
                    };

                    var errorContainer = $(".error", restrictionsFieldGroup);
                    if (validate) {
                        var validGroupNames;
                        var invalidGroupNames;

                        $.ajax({
                            cache: false,
                            data : {
                                "groupNames": $.map(groupNames, function(groupName) {
                                    return $.trim(groupName);
                                })
                            },
                            dataType: "json",
                            success : function(_validGroupNames) {
                                validGroupNames = _validGroupNames;
                                invalidGroupNames = $.map(groupNames, function(groupName) {
                                    return $.inArray($.trim(groupName), validGroupNames) === -1 ? $.trim(groupName) : null;
                                });
                                addGroupNames(validGroupNames);

                                errorContainer.empty();
                                if (invalidGroupNames.length) {
                                    errorContainer.text(AJS.format("\u6307\u5b9a\u7684\u7ec4\u540d\u79f0\uff1a{0}\u65e0\u6548", invalidGroupNames.join(", ")));
                                }

                                that._showHideHint(restrictionGroup);
                            },
                            type: "GET",
                            timeout: that._calendarPlugin.ajaxTimeout,
                            url: that._calendarPlugin.getCalendarServiceBaseUrl(that._calendarDiv, "/util/validate/group.json")
                        });
                    } else {
                        errorContainer.empty();
                        addGroupNames(groupNames);
                        that._showHideHint(restrictionGroup);
                    }
                }
            }
        });

        return RestrictionDialog;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-edit', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-edit-dialog/calendar-edit-dialog.js' */
define("tc/calendar-edit-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/calendar-util",
        "tc/util",
        "tc/myCalendarTour",
        "tc/eventtypes-edit-dialog",
        "tc/calendar-restriction-dialog",
        "tc/calendar-share-dialog",
    ], function
        (
            $,
            _,
            Backbone,
            CalUtil,
            Util,
            CalendarTour,
            EventTypesEditDialogView,
            RestrictionDialog,
            ShareCalendarDialogView
        )
    {
        "use strict";
        var CalendarEditDialog = Backbone.View.extend({
            subCalendarType: null,
            editForm: null,
            subCalendarTypeObj: null,
            editDialog: null,
            subCalendar: null,
            callbackHandler: null,
            submitButton: null,
            eventTypesEditDialogView: null,
            shareCalendarDialogView: null,
            calendarIcalAddressDialog: null,
            _calendarDiv: null,
            _calendarPlugin: null,
            calendarCache: null,
            restrictionDialog: null,
            initialize: function (options) {
                this.options = $.extend({}, this.defaults, options);

                if (!this.options.subCalendar) {
                    AJS.debug("tc/eventtypes-edit-dialog: requires 'subCalendar' object");
                }

                if (!this.options.callbackHandler) {
                    AJS.debug("tc/eventtypes-edit-dialog: requires 'callbackHandler' object");
                }

                this.callbackHandler = this.options.callbackHandler;
                this.subCalendar = this.options.subCalendar;

                this.subCalendarType = (typeof this.subCalendar === "string") ? this.subCalendar : this.subCalendar.type;
                this.subCalendarTypeObj = Confluence.TeamCalendars.subcalendar[this.subCalendarType];

                this._calendarDiv = options._calendarDiv;

                this._calendarPlugin = options._calendarPlugin;

                this.calendarCache = options.calendarCache;
            },
            render: function () {
                this._editCalendarDialog();

                //just allow owner subcalendar have permission edit custom event type
                if (CalUtil.isInternalSubscriptionSubCalendar(this.subCalendar) &&
                    CalUtil.isJiraSubCalendar(this.subCalendar)) {
                    return this.editDialog;
                }

                //TODO: should we move this define panel to new class
                //panel id = 1
                this.eventTypesEditDialogView = new EventTypesEditDialogView(
                    {
                        editDialog: this.editDialog,
                        subCalendar: this.subCalendar,
                        callbackHandler: this.callbackHandler
                    }
                );
                this.eventTypesEditDialogView.render();

                //panel id = 2 for restriction
                this.restrictionDialog = new RestrictionDialog(
                    {
                        editDialog: this.editDialog,
                        _calendarPlugin: this._calendarPlugin,
                        _calendarDiv: this._calendarDiv,
                        subCalendar: this.subCalendar,
                        calendarCache: this.calendarCache
                    }
                );
                this.restrictionDialog.render();

                //panel id = 3 for share-embedded
                this.shareCalendarDialogView = new ShareCalendarDialogView(
                    {
                        editDialog: this.editDialog,
                        subCalendar: this.subCalendar,
                        _calendarPlugin: this._calendarPlugin,
                        _calendarDiv: this._calendarDiv
                    }
                );
                this.shareCalendarDialogView.render();
                return this.editDialog;
            },
            showRestrictionOption: function () {
                this.editDialog.gotoPanel(CalUtil.panelEditCalendar.RESTRICTION_PANEL);
            },
            showShareOption: function () {
                this.editDialog.gotoPanel(CalUtil.panelEditCalendar.SHARE_EMBEDDED_PANEL);
            },
            showSubscriptionOption: function () {
                this.editDialog.gotoPanel(CalUtil.panelEditCalendar.SUBSCRIBE_PANEL);
            },
            selectCustomEvent: function (id) {
                this.editDialog.gotoPanel(CalUtil.panelEditCalendar.EVENT_TYPE_PANEL);
                this.eventTypesEditDialogView.selectCustomEvent(id);
            },
            showAddEventTypeForm: function () {
                this.editDialog.gotoPanel(CalUtil.panelEditCalendar.EVENT_TYPE_PANEL);
                this.eventTypesEditDialogView.showAddEventypeForm();
            },
            _editCalendarDialog: function () {
                var that = this;
                that.editDialog = new AJS.ConfluenceDialog({
                        width: that.subCalendarTypeObj.dialogWidth || 630,
                        height: that.subCalendarTypeObj.dialogHeight || 537,
                        onSubmit: function () {
                            that.editForm.submit();
                            return false;
                        },
                        onCancel: function () {
                            that._callBackCancel(that.editDialog, that.callbackHandler);
                            that.editDialog.remove();
                        },
                        id: "edit-calendar-dialog"
                    }
                );
                that.subCalendarTypeHandler = that.subCalendarTypeObj.getDialog(
                    that.editDialog,
                    $.isPlainObject(that.subCalendar) ? that.subCalendar : null,
                    that.callbackHandler
                );

                //Make overflow visible so that the JQL autocomplete etc are not cut off
                that.editDialog.popup.element.css("overflow", "visible");

                that.editForm = that.subCalendarTypeHandler.initializeForm(_.bind(that._callBackCancel, that, that.editDialog, that.callbackHandler));

                that.submitButton = that.editDialog.popup.element.find(".submit");

                that.editForm.submit(function () {
                    if (that.editDialog.getCurrentPanel() !== undefined) {
                        if (that.editDialog.getCurrentPanel().id === CalUtil.panelEditCalendar.GENERAL_PANEL) { //General Panel
                            return that._submitCalendarEdit(that.callbackHandler, that.subCalendarTypeHandler, that.editDialog, that.editForm, that.subCalendarTypeObj);
                        } else if (that.editDialog.getCurrentPanel().id === CalUtil.panelEditCalendar.EVENT_TYPE_PANEL) {  //custom event type panel
                            var panelBodyForm = that.editDialog.getCurrentPanel().body;
                            var eventTypeEditForm = $("form.sub-calendar-edit-event-types-form", panelBodyForm);

                            //show warning and process behaviour in edit custom event type form
                            var editCustomEventTypeForm = $("#edit-custom-event-type-form", eventTypeEditForm);
                            if ($(editCustomEventTypeForm).length) {
                                $(editCustomEventTypeForm).find(".tooltip-warning").removeClass("hidden");
                                $(panelBodyForm).scrollTop($(editCustomEventTypeForm).find("form.form-add-custom").position().top);
                                $(editCustomEventTypeForm).find('.custom-event-title input').focus();
                                return false;
                            }
                            return that._submitEventTypesEdit(eventTypeEditForm, that.editDialog, that.callbackHandler, that.subCalendarTypeHandler, that.submitButton);
                        } else if (that.editDialog.getCurrentPanel().id === CalUtil.panelEditCalendar.RESTRICTION_PANEL) { //restriction
                            return that._submitRestrictionEdit(that.editDialog);
                        }
                    }
                });
            },
            _submitCalendarEdit: function (callbackHandler, subCalendarTypeHandler, editDialog, editForm, subCalendarTypeObj) {
                if (callbackHandler.isProcessingSubCalendar()) {
                    return false;
                }

                callbackHandler.setProcessingSubCalendar(true);
                var spinnerDefer = callbackHandler.setSubCalendarSpinnerIconVisible(true);

                subCalendarTypeHandler.onSubmitStart();

                var requestData = subCalendarTypeHandler.getFormDataAsAjaxData();
                if (callbackHandler.getIncludedCalendars()) {
                    requestData.include = callbackHandler.getIncludedCalendars();
                }

                var subCalendarId = requestData.subCalendarId;
                var requestedSpaceKey = requestData.spaceKey;
                var viewingSpaceKey = requestData.viewingSpaceKey;
                var currentSpaceKey = this.subCalendar.spaceKey;
                var calendarPlugin = this._calendarPlugin;
                var calendarDiv = this._calendarDiv;
                var childSubCalendars = this.subCalendar.childSubCalendars;

                $.ajax({
                    cache: false,
                    converters: {
                        "text json": function (jsonObject) {
                            return jsonObject;
                        }
                    },
                    data: requestData,
                    dataFilter: function (data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success) {
                            CalUtil.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        }
                        return subCalendarsResponseEntity;
                    },
                    dataType: "json",
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                        subCalendarTypeHandler.onSubmitEnd();
                        callbackHandler.setProcessingSubCalendar(false);
                    },
                    success: function (responseEntity) {
                        callbackHandler.setGenericUpdateError();

                        if (responseEntity.success) {
                            CalUtil.setFieldErrors(editForm, null);

                            if ((requestedSpaceKey !== currentSpaceKey) && (viewingSpaceKey !== ""))
                            {
                                subCalendarId = responseEntity.modifiedSubCalendarId;
                                $("input[name='subCalendarId']", editForm).val(subCalendarId);
                                calendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendarId);
                                calendarPlugin.removeSubCalendarEventSource(calendarDiv, childSubCalendars);
                                callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                            } else {
                                if (subCalendarId) {
                                    callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                                    callbackHandler.reloadSubCalendar(subCalendarId);
                                } else {
                                    subCalendarId = responseEntity.modifiedSubCalendarId;
                                    $("input[name='subCalendarId']", editForm).val(subCalendarId);
                                    callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                                }
                            }
                            callbackHandler.refreshCalendarInfo(responseEntity.payload);

                            callbackHandler.updateAvailableSubCalendarsInSubCalendarPanel();
                            subCalendarTypeHandler.onSubmitEnd();
                            editDialog.remove();
                        } else {
                            CalUtil.setFieldErrors(editForm, responseEntity.fieldErrors);
                            subCalendarTypeHandler.onSubmitEnd();

                            if (!subCalendarTypeObj.dynamicDialogHeight) {
                                Util.showDialogInUpdatedHeight(editDialog);
                            }
                        }
                        callbackHandler.setProcessingSubCalendar(false);
                    },
                    complete: function(){
                        if (spinnerDefer) spinnerDefer.resolve();
                    },
                    type: "PUT",
                    timeout: CalUtil.ajaxTimeout,
                    url: CalUtil.getCalendarServiceBaseUrl("/subcalendars.json")
                });
                return false;
            },
            _submitEventTypesEdit: function (eventTypeEditForm, editDialog, callbackHandler, subCalendarTypeHandler, submitButton) {
                var requestData = this._getEventTypeData(eventTypeEditForm);
                var subCalendarId = requestData.subCalendarId;

                var spinnerDefer = callbackHandler.setSubCalendarSpinnerIconVisible(true);
                //disable button submit
                $(submitButton).text("\u66f4\u65b0...").attr("disabled", "disabled").addClass("ui-state-disabled");

                $.ajax({
                    cache: false,
                    converters: {
                        "text json": function (jsonObject) {
                            return jsonObject;
                        }
                    },
                    data: requestData,
                    dataFilter: function (data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success) {
                            CalUtil.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        }
                        return subCalendarsResponseEntity;
                    },
                    dataType: "json",
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                        subCalendarTypeHandler.onSubmitEnd();
                        $(submitButton).text("\u786e\u5b9a").removeAttr("disabled").removeClass("ui-state-disabled");
                        AJS.trigger("remove-dialog-edit-event.teamcalendar");
                    },
                    success: function (responseEntity) {
                        if (responseEntity.success) {
                            if (subCalendarId) {
                                callbackHandler.setSubCalendar(subCalendarId, responseEntity.payload);
                                callbackHandler.reloadSubCalendar(subCalendarId);
                            }
                            callbackHandler.updateAvailableSubCalendarsInSubCalendarPanel();
                            subCalendarTypeHandler.onSubmitEnd();
                            editDialog.remove();
                            AJS.trigger("show-dialog-edit-event.teamcalendar");
                        }
                    },
                    complete: function(){
                        if (spinnerDefer) spinnerDefer.resolve();
                    },
                    type: "PUT",
                    timeout: CalUtil.ajaxTimeout,
                    url: CalUtil.getCalendarServiceBaseUrl("/eventtype/disable.json")
                });
                return false;
            },
            _getEventTypeData: function (eventTypeEditForm) {
                var listDisableEventTypes = this.eventTypesEditDialogView.getDisableEventTypes();

                return {
                    subCalendarId: $("input[name='subCalendarId']", eventTypeEditForm).val(),
                    disableEventTypes: listDisableEventTypes
                };
            },
            _callBackCancel: function (editDialog, callbackHandler) {
                // Show the tour again if have
                if (this.CalendarTour) {
                    this.CalendarTour.start();
                }

                var spinnerDefer = callbackHandler.setSubCalendarSpinnerIconVisible(true);
                var subCalendarId = $("input[name='subCalendarId']", editDialog.getCurrentPanel().body).val();
                $.ajax({
                    cache: false,
                    converters: {
                        "text json": function (jsonObject) {
                            return jsonObject;
                        }
                    },
                    data: {"subCalendarId": subCalendarId},
                    dataFilter: function (data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success)
                            CalUtil.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        return subCalendarsResponseEntity;
                    },
                    dataType: "json",
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                    },
                    success: function (responseEntity) {
                        if (responseEntity.success) {
                            if (subCalendarId && responseEntity.payload && responseEntity.payload.length) {
                                $.each(responseEntity.payload, function (index, payload) {
                                    if (payload.id === subCalendarId) {
                                        callbackHandler.setSubCalendar(subCalendarId, payload);
                                        callbackHandler.reloadSubCalendar(subCalendarId);
                                    }
                                });
                            }

                            callbackHandler.updateAvailableSubCalendarsInSubCalendarPanel();
                            AJS.trigger("show-dialog-edit-event.teamcalendar");
                        }
                    },
                    complete: function(){
                        spinnerDefer.resolve();
                    },
                    type: "GET",
                    timeout: CalUtil.ajaxTimeout,
                    url: CalUtil.getCalendarServiceBaseUrl("/subcalendars.json")
                });
            },
            _submitRestrictionEdit: function (editDialog) {
                this.restrictionDialog.submitRestrictionsDialog(editDialog);
                return false;
            }
        });
        return CalendarEditDialog;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-edit', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-edit-dialog/calendar-edit-dialog-compat.js' */
//This is here to make the existing API work.
require(["tc/calendar-edit-dialog"], function (CalendarEditDialog) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getSubCalendarEditDialog = function(subCalendar, callbackHandler, calendarDiv, CalendarPlugin, cache){
        return new CalendarEditDialog({
            subCalendar: subCalendar,
            callbackHandler: callbackHandler,
            _calendarDiv: calendarDiv,
            _calendarPlugin: CalendarPlugin,
            calendarCache: cache
        });
//        return editDialog.render();
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-caldav-subscribe-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-caldav-subscribe-dialog/calendar-caldav-subscribe-service.js' */
define("tc/calendar-caldav-subscribe-service",
    [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil
    ) {
        "use strict";

        var subscriptionService = function (calendarPlugin, calendarDiv) {
            this.calendarPlugin = calendarPlugin;
            this.calendarDiv = calendarDiv;

            return {
                calendarPlugin: this.calendarPlugin,
                calendarDiv: this.calendarDiv,
                getPrivateUrlProvider: function(subCalendarId) {
                    return $.ajax({
                        cache: false,
                        type: "GET",
                        timeout: CalUtil.ajaxTimeout,
                        url: this.calendarPlugin.getCalendarServiceBaseUrl(
                            this.calendarDiv,
                            "/subcalendar/privateurl/" + encodeURIComponent(subCalendarId))
                    });
                },
                getSubCalendarsInUserView: function() {
                    return $.ajax({
                        cache: false,
                        type: "GET",
                        timeout: CalUtil.ajaxTimeout,
                        url: this.calendarPlugin.getCalendarServiceBaseUrl(
                            this.calendarDiv,
                            "/subcalendars/user/view")
                    });
                },
                updateSubCalendarInUserView: function (subCalendarIds) {
                    return $.ajax({
                        cache: false,
                        type: "PUT",
                        dataType : "json",
                        contentType: 'application/json',
                        data: JSON.stringify(
                            subCalendarIds
                        ),
                        timeout: CalUtil.ajaxTimeout,
                        url: this.calendarPlugin.getCalendarServiceBaseUrl(
                            this.calendarDiv,
                            "/subcalendars/user/view")
                    });
                }
            }
        };

        return subscriptionService;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-caldav-subscribe-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-caldav-subscribe-dialog/calendar-caldav-subscribe-model.js' */
define("tc/calendar-caldav-subscribe-model",
        [
        "jquery",
        "tc/rrule",
        "tc-backbone",
        "tc/calendar-util",
        "underscore"
    ],
    function (
        $,
        TCRRule,
        Backbone,
        CalUtil,
        _
    ) {
        "use strict";

        /**
         * Backbone model of subscription url
         */
        var subscribeModel = Backbone.Model.extend({
            calDavEndpoint: "/plugins/servlet/team-calendars/caldav/",
            /**
             * mapping between value of cal app selection and a function which return
             * a promise value of subscription url
             */
            mapper: {},
            defaults: {
                subCalendars: [],
                baserUrl: "",
                selectedSubCalId: null,
                selectedSubCalName: null,
                selectedApp: null,
                isPrivateUrlsEnabled: false,
                privateUrlProvider: null,
                subCalendarIdInUserView: null,
            },
            /**
             * Initialize function which accept list of sub calendars
             * @param params
             */
            initialize: function(params) {
                this.baseUrl = params.baseUrl;
                this.subCalendars = params.subCalendars ? params.subCalendars : [];
                this.privateUrlProvider = params.privateUrlProvider;
                this.set({
                    isPrivateUrlsEnabled: params.isPrivateUrlsEnabled,
                    selectedSubCalId: params.selectedSubCalId,
                });

                var that = this;

                var autoDiscorverFunc = function(subCalendarId) {
                    var defer = $.Deferred();
                    var promise = defer.promise();
                    var urlParts = that.baseUrl.split("/");
                    var origin = urlParts[0] + "//" + urlParts[2];
                    var caldavUrl = origin.charAt(origin.length) === '/' ?  origin : origin + "/";
                    defer.resolve(caldavUrl);
                    return promise;
                };

                var directCalDAVFunc = function(subCalendarId) {
                    var defer = $.Deferred();
                    var promise = defer.promise();
                    defer.resolve(that.baseUrl + that.calDavEndpoint + encodeURIComponent(subCalendarId));
                    return promise;
                };

                var icalFunc = function(subCalendarId) {
                    if (this.attributes["isPrivateUrlsEnabled"] === "true") {
                        return icalPrivateFunc(subCalendarId);
                    }

                    return icalBasicFunc(subCalendarId);
                };

                var icalBasicFunc = function(subCalendarId) {
                    var defer = $.Deferred();
                    var promise = defer.promise();
                    defer.resolve(
                        that.baseUrl +
                        "/rest/calendar-services/1.0/calendar/export/subcalendar/" +
                        encodeURIComponent(subCalendarId) +
                        ".ics?os_authType=basic&isSubscribe=true");
                    return promise;
                };

                var icalPrivateFunc = function(subCalendarId) {
                    var subcribeUrlPromise = that.privateUrlProvider(subCalendarId);
                    return subcribeUrlPromise;
                }

                this.mapper = {
                    "OUTLOOK-WIN" : autoDiscorverFunc,
                    "OUTLOOK-BRO" : icalFunc,
                    "APPLECAL-MAC": autoDiscorverFunc,
                    "APPLECAL-IOS": autoDiscorverFunc,
                    "GCAL-BRO": icalFunc,
                    "GCAL-AND": autoDiscorverFunc,
                    "THUNDERBIRD": directCalDAVFunc,
                    "CALDAV": autoDiscorverFunc,
                    "ICAL": icalFunc
                };
            },
            /**
             * Public method will be called on UI to get value of subscription url
             * @returns {string}
             */
            getEndpoint: function(selectedSubCalId) {
                var modelAttributes = this.attributes;
                console.debug("Get endpoint for: " + modelAttributes.selectedApp);
                var returnVal = this.mapper[modelAttributes.selectedApp] ? _.bind(this.mapper[modelAttributes.selectedApp], this, selectedSubCalId)() : "Could not detected endpoint";
                return returnVal;
            }
        });

        return subscribeModel
    }
)
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-caldav-subscribe-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-caldav-subscribe-dialog/calendar-caldav-subscribe-dialog.js' */
define("tc/subcalendar-subscribe-dialog",
    [
        "jquery",
        "ajs",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-reset-url-dialog",
        "tc/calendar-caldav-subscribe-service"
    ],
    function (
        $,
        AJS,
        Backbone,
        Template,
        CalendarResetUrlDialog,
        CalDavSubscribeService
    ) {
        "use strict";
        var subscriptionTemplate = Template.subCalendarSubscribeDialog;
        var addToMyCalendarsButtonTemplate = Template.addToMyCalendarsButton;
        var addToMyCalendarsButtonStatusTemplate = Template.addToMyCalendarsButtonStatus;

        var subscribeDialogView = Backbone.View.extend({
            template: subscriptionTemplate,
            events: {
                "change select#cal-select": "updateModel",
                "change select#cal-app-select": "updateModel",
                "click #subscribe-url-copy": "handleCopyButton",
                "click #subscribe-url-reset": "handleResetButton",
                "click #add-to-mycalendars": "handleAddToMyCalendars",
                "click #remove-form-mycalendars": "handleRemoveToMyCalendars",
                "click #reload-action": "handleReloadAction"
            },
            /**
             * Hacky to dynamically set $el on view
             *
             * @param new$el
             */
            setJQueryEl: function(new$el){
                this.undelegateEvents();
                this.$el = new$el;
                this.delegateEvents();
            },
            initialize: function (options) {
                this.setJQueryEl($(this.template({subCalendars: this.model.subCalendars})));
                this.calendarPlugin = options.calendarPlugin;
                this.calendarDiv = options.calendarDiv;
                this.dialog = AJS.dialog2(this.$el);
                this.$calendarSelection = this.$el.find("#cal-select");
                this.$calendarAppSelection = this.$el.find("#cal-app-select");
                this.service = options.calDavSubscribeService ? options.calDavSubscribeService : new CalDavSubscribeService(this.calendarPlugin, this.calendarDiv);
                this.previousAction = null;

                var modelAttributes = this.model.attributes;
                if (modelAttributes.selectedSubCalId) {
                    console.debug("Going to select sub calendar: " + modelAttributes.selectedSubCalId);
                    this.$calendarSelection.val(modelAttributes.selectedSubCalId).trigger('change');
                }
            },
            _showSpinner: function() {
                var $spinner = this.$el.find(".add-to-mycalendars-panel .spinner");
                var $panel = this.$el.find(".add-to-mycalendars-panel-container");
                $spinner.removeClass("hidden");
                $panel.addClass("hidden");
            },
            _hideSpinner: function () {
                var $spinner = this.$el.find(".add-to-mycalendars-panel .spinner");
                var $panel = this.$el.find(".add-to-mycalendars-panel-container");
                $panel.removeClass("hidden");
                $spinner.addClass("hidden");
            },
            _setSubCalendarIdInUserView: function(data) {
                var modelAttributes = this.model.attributes;
                modelAttributes["subCalendarIdInUserView"] = data;
                modelAttributes['allowAddSubCalendarIntoUserView'] =
                    data.indexOf(modelAttributes.selectedSubCalId) < 0;
            },
            handleReloadAction: function(e) {
                e.preventDefault();
                if (this.previousAction) {
                    this.previousAction(e);
                }
            },
            handleRemoveToMyCalendars : function(e) {
                console.info("Removing calendar from user view");
                e.preventDefault();
                var that = this;
                var modelAttributes = this.model.attributes;
                var $panel = this.$el.find(".add-to-mycalendars-panel-container");
                this.previousAction = this.handleRemoveToMyCalendars;

                console.log("Old calendars in view:" + modelAttributes.subCalendarIdInUserViewOld);
                this._showSpinner();
                this.service.updateSubCalendarInUserView(modelAttributes.subCalendarIdInUserViewOld)
                    .then(function(data) {
                        that._setSubCalendarIdInUserView(data);
                        $panel.html(addToMyCalendarsButtonTemplate());

                        that._hideSpinner();
                    }, function(error) {
                        $panel.html(addToMyCalendarsButtonStatusTemplate(
                            {
                                isError:true,
                                message: AJS.format("\u6211\u4eec\u65e0\u6cd5\u64a4\u6d88\u6b64\u66f4\u6539\u3002\u8f6c\u5230\u003ca href=\u0022{0}\u0022\u003e\u6211\u7684\u65e5\u5386\u003c/a\u003e\u4ee5\u5220\u9664\u65e5\u5386\u3002", AJS.contextPath() + "/calendar/mycalendar.action")
                            }));
                        that._hideSpinner();
                    });
            },
            handleAddToMyCalendars: function(e) {
                console.info("Adding calendar into user view");
                e.preventDefault();
                var that = this;
                var modelAttributes = this.model.attributes;
                var $panel = this.$el.find(".add-to-mycalendars-panel-container");
                this.previousAction = this.handleAddToMyCalendars;

                console.log("Old calendars in view:" + modelAttributes.subCalendarIdInUserView);
                that._showSpinner();
                modelAttributes["subCalendarIdInUserViewOld"] = modelAttributes.subCalendarIdInUserView.slice();
                modelAttributes.subCalendarIdInUserView.push(modelAttributes.selectedSubCalId)
                this.service.updateSubCalendarInUserView(modelAttributes.subCalendarIdInUserView)
                    .then(function( data ) {
                        that._setSubCalendarIdInUserView(data);
                        $panel.html(addToMyCalendarsButtonStatusTemplate(
                            {
                                isError:false,
                                message: AJS.format("\u5c06\u201c{0}\u201d\u6dfb\u52a0\u5230\u65e5\u5386\u4e2d\u3002\u003ca id=\u0022remove-form-mycalendars\u0022 href=\u0022#\u0022\u003e\u64a4\u9500\u003c/href\u003e", modelAttributes.selectedSubCalName)
                            }));

                        that._hideSpinner();
                    }, function(error) {
                        $panel.html(addToMyCalendarsButtonStatusTemplate(
                            {
                                isError:true,
                                message: "\u6211\u4eec\u65e0\u6cd5\u6dfb\u52a0\u60a8\u7684\u65e5\u5386\u3002 \u003ca id=\u0022reload-action\u0022 href=\u0022#\u0022\u003e\u8bf7\u91cd\u8bd5\u003c/a\u003e\u003cbr/\u003e\u5982\u679c\u53d1\u751f\u8fd9\u79cd\u60c5\u51b5\uff0c\u8bf7\u4e0e\u60a8\u7684\u7ba1\u7406\u5458\u8054\u7cfb\u3002"
                            }));

                        that._hideSpinner();
                    });
            },
            handleCopyButton: function() {
                var $urlSubcriptionTxt = this.$el.find(".subscribe-dialog-url-txt input.long-field");
                var $copyMessage = this.$el.find(".subscribe-dialog-url .copy-message");
                $urlSubcriptionTxt.select();
                document.execCommand("Copy");
                console.debug("Copy subscription url into clipboard");

                $copyMessage.removeClass("hidden");
                setTimeout(function(){ $copyMessage.addClass("hidden"); }, 5000);
                return false;
            },
            handleResetButton: function() {
                var modelAttributes = this.model.attributes;
                this.dialog.hide();
                var calendarResetUrlDialog = new CalendarResetUrlDialog(
                    {
                        calendarPlugin : this.calendarPlugin,
                        calendarDiv: this.calendarDiv,
                        subCalendar: this.calendarPlugin.getSubCalendar(this.calendarDiv, modelAttributes.selectedSubCalId),
                        subCalendars: this.model.subCalendars
                    });
                calendarResetUrlDialog.render();
                return false;
            },
            updateModel: function() {
                var modelAttributes = this.model.attributes;
                console.debug("Updating model value");
                this.model.set({"selectedSubCalId": this.$calendarSelection.val()});
                this.model.set({"selectedSubCalName": this.$calendarSelection.find('option:selected').text()});
                this.model.set({"selectedApp": this.$calendarAppSelection.val()});

                var that = this;
                this.service.getSubCalendarsInUserView()
                    .then(function( data, textStatus, jqXHR ) {
                        if (jqXHR.status === 200) {
                            console.info("Load 'subCalendarIdInUserView' successfully");
                            that.model.attributes['subCalendarIdInUserView'] = data;
                            that.model.attributes['allowAddSubCalendarIntoUserView'] =
                                data.indexOf(modelAttributes.selectedSubCalId) < 0;
                        } else {
                            console.error("Could not load 'subCalendarIdInUserView' from server")
                            that.model.attributes['subCalendarIdInUserView'] = [];
                            that.model.attributes['allowAddSubCalendarIntoUserView'] = false;
                        }

                        that.render();
                    });
            },
            render: function() {
                var modelAttributes = this.model.attributes;
                var $outputContent = this.$el.find(".subscribe-dialog-output");
                var $helpContentHelp = this.$el.find(".subscribe-dialog-help");

                if ($.fn.auiSelect2) {
                    // only enable select2 if we have it
                    this.$calendarSelection.auiSelect2({
                        minimumResultsForSearch: -1
                    });

                    this.$calendarAppSelection.auiSelect2({
                        minimumResultsForSearch: -1
                    });
                }

                $outputContent.removeClass("hidden");
                var spinnerDefer = this.calendarPlugin.setSubCalendarSpinnerIconVisible(true);
                var that = this;

                switch (modelAttributes.selectedApp) {
                    case "OUTLOOK-WIN":
                        $helpContentHelp.html(Template.outlookHelpWin({
                            "isInUserView": !modelAttributes.allowAddSubCalendarIntoUserView,
                            "selectedCalendarName": modelAttributes.selectedSubCalName}));

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "OUTLOOK-BRO":
                        $helpContentHelp.html(Template.outlookHelpBro());

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "APPLECAL-MAC":
                        $helpContentHelp.html(Template.appleCalHelpMac({
                            "isInUserView": !modelAttributes.allowAddSubCalendarIntoUserView,
                            "selectedCalendarName": modelAttributes.selectedSubCalName}));

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "APPLECAL-IOS":
                        $helpContentHelp.html(Template.appleCalHelpIos({
                            "isInUserView": !modelAttributes.allowAddSubCalendarIntoUserView,
                            "selectedCalendarName": modelAttributes.selectedSubCalName}));

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "GCAL-BRO":
                        $helpContentHelp.html(Template.gcalHelpBro());

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "GCAL-AND":
                        $helpContentHelp.html(Template.gcalHelpAndroid({
                            "isInUserView": !modelAttributes.allowAddSubCalendarIntoUserView,
                            "selectedCalendarName": modelAttributes.selectedSubCalName}));

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "THUNDERBIRD":
                        $helpContentHelp.html(Template.thunderbirdHelp());

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "CALDAV":
                        $helpContentHelp.html(Template.otherCalDAVHelp({
                            "isInUserView": !modelAttributes.allowAddSubCalendarIntoUserView,
                            "selectedCalendarName": modelAttributes.selectedSubCalName}));

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        $helpContentUrl.html(Template.calDAVLinkOutput());
                        break;
                    case "ICAL":
                        $helpContentHelp.html(Template.otherIcalHelp());

                        var $helpContentUrl = $helpContentHelp.find(".subscribe-dialog-url");
                        if (modelAttributes["isPrivateUrlsEnabled"] === "true") {
                            $helpContentUrl.html(Template.icalLinkOutput());
                        } else {
                            $helpContentUrl.html(Template.calDAVLinkOutput());
                        }
                        break;
                    case "UNKNOWN":
                        $helpContentHelp.html(Template.otherUnknown());
                        break;
                    default:
                        $outputContent.addClass("hidden");
                }

                var $urlSubcriptionTxt = this.$el.find(".subscribe-dialog-url-txt input.long-field");
                $.when(this.model.getEndpoint(modelAttributes.selectedSubCalId))
                    .then(
                        function(subscriptionUrl) {
                            console.debug("Set subscription url: " + subscriptionUrl);
                            $urlSubcriptionTxt.val(subscriptionUrl).focus().select();
                            if (spinnerDefer) spinnerDefer.resolve();
                        },
                        function(XMLHttpRequest, textStatus, errorThrown){
                            console.debug("set subscription error:");
                            that.calendarPlugin.showAjaxError(
                                that.calendarDiv,
                                XMLHttpRequest,
                                textStatus,
                                errorThrown,
                                that.calendarPlugin.ERROR_CLASS_PRIVATE_URL
                            );
                            if (spinnerDefer) spinnerDefer.resolve();
                        }
                    );

                this.dialog.show();
            }
        });

        return subscribeDialogView;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-caldav-subscribe-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-caldav-subscribe-dialog/calendar-caldav-subscribe-dialog.soy' */
// This file was automatically generated from calendar-caldav-subscribe-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.subCalendarSubscribeDialog = function(opt_data, opt_ignored) {
  var output = '<section id="calendar-subscribe-dialog" class="aui-dialog2 aui-dialog2-medium aui-layer" data-aui-remove-on-hide="true" role="dialog" aria-hidden="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml('\u8ba2\u9605\u65e5\u5386') + '</h2><a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">Close</span></a></header><div class="aui-dialog2-content"><div class="subscribe-dialog-description">' + soy.$$escapeHtml('\u67e5\u770b\u60a8\u7684\u65e5\u5386\u5e76\u5728\u60a8\u559c\u6b22\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4e2d\u7f16\u8f91\u6d3b\u52a8\u3002') + '</div><form class="aui"><fieldset><div class="field-group"><label for="d-fname">' + soy.$$escapeHtml('\u65e5\u5386') + '</label><select name="cal-select" id="cal-select" class="select">';
  var subCalList10 = opt_data.subCalendars;
  var subCalListLen10 = subCalList10.length;
  for (var subCalIndex10 = 0; subCalIndex10 < subCalListLen10; subCalIndex10++) {
    var subCalData10 = subCalList10[subCalIndex10];
    output += (subCalData10.dummy) ? '<option value="' + soy.$$escapeHtml(subCalData10.childSubCalendars[0].id) + '">' + soy.$$escapeHtml(subCalData10.name) + '</option>' : '<option value="' + soy.$$escapeHtml(subCalData10.id) + '">' + soy.$$escapeHtml(subCalData10.name) + '</option>';
  }
  output += '</select></div><div class="field-group"><label for="d-fname">' + soy.$$escapeHtml('\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f') + '</label><select name="cal-app-select" id="cal-app-select" class="select"><option value="NONE">' + soy.$$escapeHtml('\u9009\u62e9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f') + '</option><optgroup label="' + soy.$$escapeHtml('\u5e94\u7528\u7a0b\u5e8f') + '" ><option value="OUTLOOK-WIN">' + soy.$$escapeHtml('Microsoft Outlook\uff08Windows \u684c\u9762\uff09') + '</option><option value="OUTLOOK-BRO">' + soy.$$escapeHtml('Microsoft Outlook\uff08\u6d4f\u89c8\u5668\uff09') + '</option><option value="APPLECAL-MAC">' + soy.$$escapeHtml('Apple \u65e5\u5386\uff08MacOS\uff09') + '</option><option value="APPLECAL-IOS">' + soy.$$escapeHtml('Apple \u65e5\u5386\uff08iOS\uff09') + '</option><option value="GCAL-BRO">' + soy.$$escapeHtml('Google \u65e5\u5386\uff08\u6d4f\u89c8\u5668\uff09') + '</option><option value="GCAL-AND">' + soy.$$escapeHtml('Google \u65e5\u5386\uff08Android\uff09') + '</option><option value="THUNDERBIRD">' + soy.$$escapeHtml('Thunderbird') + '</option><option value="UNKNOWN">' + soy.$$escapeHtml('\u6211\u7684\u5e94\u7528\u7a0b\u5e8f\u6ca1\u6709\u5217\u51fa') + '</option></optgroup><optgroup label="' + soy.$$escapeHtml('\u5176\u5b83') + '" ><option value="CALDAV">' + soy.$$escapeHtml('CalDAV') + '</option><option value="ICAL">' + soy.$$escapeHtml('iCal') + '</option><optgroup></select></div></fieldset></form><div class="subscribe-dialog-output"><div class="subscribe-dialog-help" /></div></div></section>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.subCalendarSubscribeDialog.soyTemplateName = 'Confluence.TeamCalendars.Templates.subCalendarSubscribeDialog';
}


Confluence.TeamCalendars.Templates.calDAVLinkOutput = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-url-txt calDAVLinkOutput"><form class="aui"><input class="text long-field" id="d-lname" name="d-lname" type="text"><button id="subscribe-url-copy" class="aui-button">' + soy.$$escapeHtml('\u590d\u5236') + '</button></form></div><div class="copy-message hidden"><div class="subscribe-url-copy-icon aui-icon"></div>' + soy.$$escapeHtml('\u94fe\u63a5\u5df2\u590d\u5236\u3002 \u62e5\u6709\u6b64\u94fe\u63a5\u7684\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u67e5\u770b\u6b64\u65e5\u5386') + '</div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.calDAVLinkOutput.soyTemplateName = 'Confluence.TeamCalendars.Templates.calDAVLinkOutput';
}


Confluence.TeamCalendars.Templates.icalLinkOutput = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-url-txt icalLinkOutput"><form class="aui"><input class="text long-field with-reset" id="d-lname" name="d-lname" title="last name" type="text"><button id="subscribe-url-copy" class="aui-button">' + soy.$$escapeHtml('\u590d\u5236') + '</button><button id="subscribe-url-reset" class="aui-button aui-button-link">' + soy.$$escapeHtml('\u91cd\u7f6e\u94fe\u63a5') + '</button></form></div><div class="copy-message hidden"><div class="subscribe-url-copy-icon aui-icon"></div>' + soy.$$escapeHtml('\u94fe\u63a5\u5df2\u590d\u5236\u3002 \u62e5\u6709\u6b64\u94fe\u63a5\u7684\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u67e5\u770b\u6b64\u65e5\u5386') + '</div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.icalLinkOutput.soyTemplateName = 'Confluence.TeamCalendars.Templates.icalLinkOutput';
}


Confluence.TeamCalendars.Templates.thunderbirdHelp = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-help-step thunderbirdCal"><div class="list list-margin"><div class="num-list"><h7>1.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>2.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Thunderbird\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.thunderbirdHelp.soyTemplateName = 'Confluence.TeamCalendars.Templates.thunderbirdHelp';
}


Confluence.TeamCalendars.Templates.appleCalHelpMac = function(opt_data, opt_ignored) {
  var output = '';
  var numHeading__soy78 = opt_data.isInUserView ? 1 : 2;
  output += '<div class="subscribe-dialog-help-step appleCal">' + Confluence.TeamCalendars.Templates.additionalStepForDiscovery(opt_data) + '<div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy78) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy78 + 1) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Apple+Calendar\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.appleCalHelpMac.soyTemplateName = 'Confluence.TeamCalendars.Templates.appleCalHelpMac';
}


Confluence.TeamCalendars.Templates.appleCalHelpIos = function(opt_data, opt_ignored) {
  var output = '';
  var numHeading__soy96 = opt_data.isInUserView ? 1 : 2;
  output += '<div class="subscribe-dialog-help-step appleCal">' + Confluence.TeamCalendars.Templates.additionalStepForDiscovery(opt_data) + '<div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy96) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy96 + 1) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Apple+iOS+Calendar\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.appleCalHelpIos.soyTemplateName = 'Confluence.TeamCalendars.Templates.appleCalHelpIos';
}


Confluence.TeamCalendars.Templates.addToMyCalendarsButton = function(opt_data, opt_ignored) {
  return '<form class="aui" ><button id="add-to-mycalendars" class="aui-button">' + soy.$$escapeHtml('\u6dfb\u52a0\u5230\u6211\u7684\u65e5\u5386') + '</button></form>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.addToMyCalendarsButton.soyTemplateName = 'Confluence.TeamCalendars.Templates.addToMyCalendarsButton';
}


Confluence.TeamCalendars.Templates.addToMyCalendarsButtonStatus = function(opt_data, opt_ignored) {
  return ((opt_data.isError) ? '<div class="subscribe-error-icon aui-icon aui-icon-small aui-iconfont-error"></div>' : '<div class="subscribe-success-icon aui-icon"></div>') + '<div class="subscribe-error-message">' + soy.$$filterNoAutoescape(opt_data.message) + '</div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.addToMyCalendarsButtonStatus.soyTemplateName = 'Confluence.TeamCalendars.Templates.addToMyCalendarsButtonStatus';
}


Confluence.TeamCalendars.Templates.additionalStepForDiscovery = function(opt_data, opt_ignored) {
  return '' + ((! opt_data.isInUserView) ? '<div class="list list-margin"><div class="num-list"><h7>1.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml(AJS.format('\u5c06\u201c{0}\u201d\u6dfb\u52a0\u5230\u60a8\u7684\u65e5\u5386\u4e2d',opt_data.selectedCalendarName)) + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail add-to-mycalendars-panel"><div class="spinner aui-icon aui-icon-wait hidden"></div><div class="add-to-mycalendars-panel-status-message"></div><div class="add-to-mycalendars-panel-container" >' + Confluence.TeamCalendars.Templates.addToMyCalendarsButton(null) + '</div></div></div>' : '');
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.additionalStepForDiscovery.soyTemplateName = 'Confluence.TeamCalendars.Templates.additionalStepForDiscovery';
}


Confluence.TeamCalendars.Templates.outlookHelpWin = function(opt_data, opt_ignored) {
  var output = '';
  var numHeading__soy136 = opt_data.isInUserView ? 1 : 2;
  output += '<div class="subscribe-dialog-help-step outlookCal">' + Confluence.TeamCalendars.Templates.additionalStepForDiscovery(opt_data) + '<div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy136) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy136 + 1) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Microsoft+Outlook\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.outlookHelpWin.soyTemplateName = 'Confluence.TeamCalendars.Templates.outlookHelpWin';
}


Confluence.TeamCalendars.Templates.outlookHelpBro = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-help-step outlookCal"><div class="list list-margin"><div class="num-list"><h7>1.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>2.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Outlook+on+the+web\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.outlookHelpBro.soyTemplateName = 'Confluence.TeamCalendars.Templates.outlookHelpBro';
}


Confluence.TeamCalendars.Templates.gcalHelpBro = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-help-step gCal"><div class="list list-margin"><div class="num-list"><h7>1.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>2.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Google+Calendar\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.gcalHelpBro.soyTemplateName = 'Confluence.TeamCalendars.Templates.gcalHelpBro';
}


Confluence.TeamCalendars.Templates.gcalHelpAndroid = function(opt_data, opt_ignored) {
  var output = '';
  var numHeading__soy172 = opt_data.isInUserView ? 1 : 2;
  output += '<div class="subscribe-dialog-help-step gCal">' + Confluence.TeamCalendars.Templates.additionalStepForDiscovery(opt_data) + '<div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy172) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy172 + 1) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u9700\u8981\u5e2e\u52a9\uff1f \u8bf7\u67e5\u770b\u6211\u4eec\u7684\x3ca href\x3d\x22https://confluence.atlassian.com/display/TEAMCAL/Subscribe+to+Team+Calendars+from+Android+Calendar\x22\x3e\u5206\u6b65\u6307\u5357\x3c/a\x3e\u3002') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.gcalHelpAndroid.soyTemplateName = 'Confluence.TeamCalendars.Templates.gcalHelpAndroid';
}


Confluence.TeamCalendars.Templates.otherIcalHelp = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-help-step otherICal"><div class="list list-margin"><div class="num-list"><h7>1.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>2.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u8bf7\u53c2\u9605\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u7684\u6587\u6863\uff0c\u4e86\u89e3\u5982\u4f55\u6dfb\u52a0 iCal \u65e5\u5386\u3002') + '</div></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.otherIcalHelp.soyTemplateName = 'Confluence.TeamCalendars.Templates.otherIcalHelp';
}


Confluence.TeamCalendars.Templates.otherCalDAVHelp = function(opt_data, opt_ignored) {
  var output = '';
  var numHeading__soy199 = opt_data.isInUserView ? 1 : 2;
  output += '<div class="subscribe-dialog-help-step otherCalDAV">' + Confluence.TeamCalendars.Templates.additionalStepForDiscovery(opt_data) + '<div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy199) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u590d\u5236\u56e2\u961f\u65e5\u5386\u7f51\u5740') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail"><div class="subscribe-dialog-url"></div></div></div><div class="list list-margin"><div class="num-list"><h7>' + soy.$$escapeHtml(numHeading__soy199 + 1) + '.</h7></div><div class="num-detail"><h7>' + soy.$$escapeHtml('\u524d\u5f80\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u4ee5\u8bbe\u7f6e\u65e5\u5386') + '</h7></div></div><div class="list"><div class="num-list"></div><div class="num-detail">' + soy.$$filterNoAutoescape('\u8bf7\u53c2\u9605\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u7684\u6587\u6863\uff0c\u4e86\u89e3\u5982\u4f55\u6dfb\u52a0 CalDAV \u65e5\u5386\u3002') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.otherCalDAVHelp.soyTemplateName = 'Confluence.TeamCalendars.Templates.otherCalDAVHelp';
}


Confluence.TeamCalendars.Templates.otherUnknown = function(opt_data, opt_ignored) {
  return '<div class="subscribe-dialog-help-step otherCalDAV"><div class="list list-margin"><h7>' + soy.$$escapeHtml('\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u5f88\u53ef\u80fd\u652f\u6301 iCal \u6216 CalDav\u3002') + '</h7></div><div class="list list-margin"><p>' + soy.$$escapeHtml('\u68c0\u67e5\u60a8\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u7684\u6587\u6863\u4ee5\u627e\u51fa\u5b83\u652f\u6301\u7684\u5185\u5bb9\uff0c\u7136\u540e\u5728\u4e0a\u9762\u7684\u65e5\u5386\u5e94\u7528\u7a0b\u5e8f\u5b57\u6bb5\u4e2d\u9009\u62e9 iCal \u6216 CalDav\u3002') + '</p></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.otherUnknown.soyTemplateName = 'Confluence.TeamCalendars.Templates.otherUnknown';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-add-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-add-dialog/calendar-add-dialog.js' */
define("tc/calendar-add-dialog",
    [
        "jquery",
        "tc-backbone",
        "tc/templates",
        "tc/dialogs",
        "tc/util",
        "tc/calendar-util"
    ],
    function (
        $,
        Backbone,
        Templates,
        Dialogs,
        Util,
        CalUtil) {
    "use strict";
    var dialog;

    var CalendarAddDialogView = Backbone.View.extend({
        events: {
            "click .option-new": "addNewCalendar",
            "click .option-existing": "addExistingCalendar",
            "click .option-subscription": "subscribeByUrl",
            "click .option-import": "importCalendar"

        },

        defaults: {
            title: "\u65b0\u589e\u65e5\u7a0b\u8868"
        },

        initialize: function(options) {
            options = options || {};
            this.callbackHandler = options.callbackHandler;
            this.dialogOptions = $.extend({}, this.defaults, options.dialogOptions);
        },

        hide: function() {
            dialog.hide();

            //Backbone.View.prototype.remove.call(this, arguments);
        },

        render: function () {
            if (!dialog) {
                dialog = this.dialog = new AJS.Dialog(600, 320, "add-calendar-dialog");

                dialog.addHeader(this.dialogOptions.title);

                dialog.addPanel(
                    this.dialogOptions.title,
                    Templates.addDialog(),
                    "add-calendar-panel"
                );

                if (this.dialogOptions.addClass) {
                    $("#add-calendar-dialog").addClass(this.dialogOptions.addClass);
                }

                dialog.addCancel("\u53d6\u6d88", function () {
                    dialog.hide();
                    return false;
                });

                this.setElement(dialog.getCurPanel().body);
            }

            dialog.show();
        },

        addNewCalendar: function() {
            var subCalendarDialog = Dialogs.getSubCalendarCreateDialog("parent", this.callbackHandler);
            Util.showDialogInUpdatedHeight(subCalendarDialog);
            $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();
            CalUtil.fireEventForAnalytics("add.calendar.click.new." + CalUtil.getCalendarContext());
            this.hide();
        },

        addExistingCalendar: function() {
            var inPage = $("meta[name='ajs-page-id']").length >= 1;

            var subCalendarSubscribeDialog = Dialogs.getSubCalendarSubscribeDialog(
                $.extend({
                    callbackHandler: this.callbackHandler,
                    heading: inPage ? "\u6dfb\u52a0\u73b0\u6709\u7684\u56e2\u961f\u65e5\u7a0b\u8868" : "\u70ed\u95e8\u56e2\u961f\u65e5\u7a0b\u8868",
                    showSearch: inPage,
                    searchParams: {
                        "showSubCalendarsInView": AJS.Meta.get("space-key") !== undefined || inPage
                    },
                    disableWatching: inPage,
                    id: "internal-subscription-calendar-dialog"
                })
            );

            Util.showDialogInUpdatedHeight(subCalendarSubscribeDialog);
            CalUtil.fireEventForAnalytics("add.calendar.click.existing." + CalUtil.getCalendarContext());
            this.hide();
        },

        subscribeByUrl: function() {
            var subCalendarDialog = Dialogs.getSubCalendarCreateDialog("subscription", this.callbackHandler);
            Util.showDialogInUpdatedHeight(subCalendarDialog);
            $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();
            CalUtil.fireEventForAnalytics("add.calendar.click.subscribe." + CalUtil.getCalendarContext());
            this.hide();
        },

        importCalendar: function() {
            var subCalendarDialog = Dialogs.getSubCalendarImportDialog(this.callbackHandler);
            Util.showDialogInUpdatedHeight(subCalendarDialog);
            $("input[name='name']", subCalendarDialog.getCurrentPanel()).focus();
            CalUtil.fireEventForAnalytics("add.calendar.click.import." + CalUtil.getCalendarContext());
            this.hide();
        }
    });

    return CalendarAddDialogView;
});

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-add-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-add-dialog/calendar-add-dialog-compat.js' */
//This is here to make the existing API work.
require(["tc/calendar-add-dialog"], function (CalendarAddDialogView) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getAddDialog = function (callbackHandler, dialogOptions) {
        return new CalendarAddDialogView({
            callbackHandler: callbackHandler,
            dialogOptions: dialogOptions
        }).render();
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-add-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-add-dialog/calendar-add-dialog.soy' */
// This file was automatically generated from calendar-add-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.addDialog = function(opt_data, opt_ignored) {
  return '<div class="add-calendar subcalendar-wizard"><div><ul class="add-calendar-options"><li class="option-new"><div class="title">' + soy.$$escapeHtml('\u6dfb\u52a0\u65b0\u7684\u65e5\u7a0b\u8868') + '</div></li><li class="option-import"><div class="title">' + soy.$$escapeHtml('\u5bfc\u5165\u65e5\u7a0b\u8868') + '</div></li></ul><ul class="add-calendar-options"><li class="option-existing"><div class="title">' + soy.$$escapeHtml('\u6dfb\u52a0\u5df2\u6709\u7684\u65e5\u7a0b\u8868') + '</div></li><li class="option-subscription"><div class="title">' + soy.$$escapeHtml('\u901a\u8fc7 URL \u8ba2\u9605') + '</div></li></ul></div></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.addDialog.soyTemplateName = 'Confluence.TeamCalendars.Templates.addDialog';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-add-inline-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-add-inline-dialog/calendar-add-inline-dialog.js' */
define("tc/calendar-add-inline-dialog",
    [
        "jquery",
        "tc-backbone",
        "tc/templates",
        "tc/dialogs",
        "tc/util"
    ],
    function (
        $,
        Backbone,
        Templates,
        Dialogs,
        Util) {
    "use strict";

    var CalendarAddInlineDialogView = Backbone.View.extend({

        initialize: function(options) {
            options = options || {};
            this.callbackHandler = options.callbackHandler;
        },

        hide: function() {
            this.dialog.hide();
        },

        render: function () {

            var handler = this.callbackHandler;
            if (!this.dialog) {
                this.dialog = AJS.InlineDialog($("#inline-dialog-more"), "inline-dialog-more", function (content, trigger, showPopup) {
                    content.html(Templates.addInlineDialog());

                    content.find(".option-new").on("click", function() {
                        var subCalendarDialog = Dialogs.getSubCalendarCreateDialog("parent", handler);
                        Util.showDialogInUpdatedHeight(subCalendarDialog);
                        $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();
                        $("#inline-dialog-more").removeClass("active");
                        $("#inline-dialog-inline-dialog-more").hide();
                        Confluence.TeamCalendars.fireEventForAnalytics("add.calendar.click.new." + Confluence.TeamCalendars.getCalendarContext());
                    });

                    content.find(".option-import").on("click", function() {
                        var subCalendarDialog = Dialogs.getSubCalendarImportDialog(handler);
                        Util.showDialogInUpdatedHeight(subCalendarDialog);
                        $("input[name='name']", subCalendarDialog.getCurrentPanel()).focus();
                        $("#inline-dialog-more").removeClass("active");
                        $("#inline-dialog-inline-dialog-more").hide();
                        Confluence.TeamCalendars.fireEventForAnalytics("add.calendar.click.import." + Confluence.TeamCalendars.getCalendarContext());
                    });

                    content.find(".option-existing").on("click", function() {
                        var inPage = $("meta[name='ajs-page-id']").length >= 1;

                        var subCalendarSubscribeDialog = Dialogs.getSubCalendarSubscribeDialog(
                            $.extend({
                                callbackHandler: handler,
                                heading: inPage ? "\u6dfb\u52a0\u73b0\u6709\u7684\u56e2\u961f\u65e5\u7a0b\u8868" : "\u70ed\u95e8\u56e2\u961f\u65e5\u7a0b\u8868",
                                showSearch: inPage,
                                searchParams: {
                                    "showSubCalendarsInView": AJS.Meta.get("space-key") !== undefined || inPage
                                },
                                disableWatching: inPage,
                                id: "internal-subscription-calendar-dialog"
                            })
                        );
                        Util.showDialogInUpdatedHeight(subCalendarSubscribeDialog);
                        $("#inline-dialog-more").removeClass("active");
                        $("#inline-dialog-inline-dialog-more").hide();
                        Confluence.TeamCalendars.fireEventForAnalytics("add.calendar.click.existing." + Confluence.TeamCalendars.getCalendarContext());
                    });

                    content.find(".option-subscription").on("click", function() {
                        var subCalendarDialog = Dialogs.getSubCalendarCreateDialog("subscription", handler);
                        Util.showDialogInUpdatedHeight(subCalendarDialog);
                        $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();
                        $("#inline-dialog-more").removeClass("active");
                        $("#inline-dialog-inline-dialog-more").hide();
                        Confluence.TeamCalendars.fireEventForAnalytics("add.calendar.click.subscribe." + Confluence.TeamCalendars.getCalendarContext());
                    });

                    showPopup();
                    return false;
                });
            }
        }
    });

    return CalendarAddInlineDialogView;
});

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-add-inline-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-add-inline-dialog/calendar-add-inline-dialog.soy' */
// This file was automatically generated from calendar-add-inline-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.addInlineDialog = function(opt_data, opt_ignored) {
  return '<div id="add-calendar-inline-dialog" class="add-calendar subcalendar-wizard"><ul class="add-calendar-options"><li class="option-new"><div class="title">' + soy.$$escapeHtml('\u6dfb\u52a0\u65b0\u65e5\u5386') + '</div><div class="description">' + soy.$$escapeHtml('\u521b\u5efa\u4e00\u4e2a\u5168\u65b0\u7684\u65e5\u5386') + '<div></li></ul><ul class="add-calendar-options"><li class="option-existing"><div class="title">' + soy.$$escapeHtml('\u6dfb\u52a0\u4e00\u4e2a\u5df2\u5b58\u5728\u7684\u65e5\u5386') + '</div><div class="description">' + soy.$$escapeHtml('\u4ece Confluence \u5bfb\u627e\u5e76\u6dfb\u52a0\u4e00\u4e2a\u65e5\u5386') + '<div></li></ul><ul class="add-calendar-options"><li class="option-import"><div class="title">' + soy.$$escapeHtml('\u5bfc\u5165\u65e5\u7a0b\u8868') + '</div><div class="description">' + soy.$$escapeHtml('\u5bfc\u5165 ICS \u6587\u6863\uff0c\u521b\u5efa\u4e00\u4e2a\u65e5\u5386') + '<div></li></ul><ul class="add-calendar-options"><li class="option-subscription"><div class="title">' + soy.$$escapeHtml('\u901a\u8fc7 URL \u8ba2\u9605') + '</div><div class="description">' + soy.$$escapeHtml('\u4f7f\u7528 URL \u8ba2\u9605\u65e5\u5386') + '<div></li></ul></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.addInlineDialog.soyTemplateName = 'Confluence.TeamCalendars.Templates.addInlineDialog';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:manage-event', location = 'com/atlassian/confluence/extra/calendar3/components/manage-event/manage-event.js' */
define("tc/manage-event",
    [
        "jquery",
        "tc/event-delete-dialog",
        "tc/calendar-util"
    ],
    function (
        $,
        deleteEventDialog,
        CalUtil
        )
    {
        "use strict";
        var ManageEvent = function(CalendarPlugin, cache) {
            var eventDisplayDialog;

            //drop or resize event
            function eventDropOrResizeCallback(calendarDiv, event, dayDelta, minuteDelta, allDay, revertFunc) {
                if (!event.end && !allDay)
                    event.end = new Date(event.start.getTime() + (1000 * 60 * 60 * 2));

                CalendarPlugin.setProcessingEvent(calendarDiv, true);
                CalendarPlugin.setSuppressEventToolTip(calendarDiv, true);
                ManageEvent(CalendarPlugin, cache).updateEvent(calendarDiv, (function() {
                    var eventSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId),
                        data = {
                            "subCalendarId" : eventSubCalendar.parentId,
                            "uid" : event.id,
                            "eventType" : event.eventType,
                            "originalStartDate" : event.originalStart || "",
                            "what" : event.title,
                            "url" : event.workingUrl, //TEAMCAL-993
                            "dragAndDropUpdate" : true,
                            "start" : $.fullCalendar.formatDate(event.start, "ddMMyyyyHHmm"), // I should probably use "u", but FullCalendar sends the wrong time zone
                            "end" : $.fullCalendar.formatDate(event.end || event.start, "ddMMyyyyHHmm"),
                            "allDayEvent" : allDay,
                            "where" : event.where,
                            "description" : event.description,
                            "freq" : event.recur ? event.recur.freq : "",
                            "byday" : event.recur ? event.recur.byDay : "",
                            "interval" : event.recur ? event.recur.interval : "",
                            "until" : event.recur ? event.recur.localizedUntil || "" : "",
                            "recurrenceId" : event.recurId || "",
                            "editAllInRecurrenceSeries" : "false",
                            "customEventTypeId": event.customEventTypeId,
                            "childSubCalendarId": event.subCalendarId || ""
                        };

                    if (eventSubCalendar.eventInviteesSupported) {
                        data.person = $.map(event.invitees || [], function(invitee) {
                            return invitee.id;
                        });
                    }

                    return data;

                })(), function(XMLHttpRequest, textStatus, errorThrown) {
                    CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_EVENT_UPDATE);
                    revertFunc();
                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                    CalendarPlugin.setProcessingEvent(calendarDiv, false);
                }, function(responseEntity) {
                    if (responseEntity.success) {
                        CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_EVENT_UPDATE);
                        var updatedEvent = responseEntity.event;
                        // Due to subscriptions, an event may appear more than once a calendar. We need to update all instances of it.
                        $.each(CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("clientEvents", event.id), function(eventIdx, event) {
                            event.localizedStartDate = updatedEvent.localizedStartDate;
                            event.localizedStartTime = updatedEvent.localizedStartTime;
                            event.localizedEndDate = updatedEvent.localizedEndDate;
                            event.localizedEndTime = updatedEvent.localizedEndTime;
                            event.recurId = updatedEvent.recurId;
                            event.invitees = updatedEvent.invitees;
                            event.iconUrl = updatedEvent.iconUrl;
                            event.confluenceFormattedStartDate = updatedEvent.confluenceFormattedStartDate;
                            event.expandDates = updatedEvent.expandDates;
                            //update jira product release event when drap drop
                            if (updatedEvent.extraProperties) {
                                event.extraProperties = updatedEvent.extraProperties;
                            }
                        });

                        if (event.calendarReloadRequiredOnUpdate) { // Only reload if required, as with JIRA calendar events with some old version of TC.
                            CalendarPlugin.reloadSubCalendar(calendarDiv, [event.subCalendarId]);
                        }
                    } else {
                        CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_EVENT_UPDATE);
                        revertFunc(); // Won't happen, but just in case, we revert it.
                    }

                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                    CalendarPlugin.setProcessingEvent(calendarDiv, false);
                });
            }

            return {
                //get event detail dialog
                getEventDetailsDialog : function(calendarDiv, event, target, inlineDialogOptions) {
                    var eventSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId),
                        parentSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, eventSubCalendar.parentId),
                        hideSubCalendarName = (function() {
                            return ($.inArray(CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("getView").name, [ "month", "agendaWeek" ]) !== -1
                                ) || CalendarPlugin.getParameter(calendarDiv, "showSubCalendarNameInEventPopup") !== "true";
                        })(),
                        getPeriodEvent = function() {
                            var period = null;
                            var calendar = parentSubCalendar ? parentSubCalendar : eventSubCalendar;
                            if(CalUtil.isCustomEventType(event.eventType)) {
                                var customEventTypes = calendar.customEventTypes;
                                $.each(customEventTypes, function(index, customEventType) {
                                    if(customEventType.customEventTypeId === event.customEventTypeId && customEventType.periodInMins > 0) {
                                        period = AJS.format("{0}\u524d", CalUtil.showInforReminder(customEventType.periodInMins));
                                        return false;
                                    }
                                });
                            } else {
                                var sanboxEventTypeReminders = calendar.sanboxEventTypeReminders;
                                if(sanboxEventTypeReminders && sanboxEventTypeReminders.length > 0) {
                                    var eventType = event.eventType;
                                    if(CalUtil.isJiraType(eventType)) {
                                        eventType += "-calendar";
                                    }
                                    $.each(sanboxEventTypeReminders, function(index, sanboxEventTypeReminder){
                                       if(sanboxEventTypeReminder.eventTypeId === eventType && sanboxEventTypeReminder.periodInMins > 0) {
                                           period = AJS.format("{0}\u524d", CalUtil.showInforReminder(sanboxEventTypeReminder.periodInMins));
                                           return false;
                                       }
                                    });
                                }
                            }
                            return period;
                        },
                        renderEventPopupContent = function() {
                            return $("<div/>").html(
                                Confluence.TeamCalendars.Templates.eventPopup({
                                    "contextClass" : hideSubCalendarName ? "mycalendars" : "",
                                    "baseUrl" : CalendarPlugin.getParameter(calendarDiv, "baseUrl"),
                                    "event" : $.extend(
                                        $.extend({}, event),
                                        {
                                            "colour" : eventSubCalendar.color,
                                            "subCalendarDisplayName" : parentSubCalendar && !Confluence.TeamCalendars.isSubscriptionSubCalendar(eventSubCalendar) ? parentSubCalendar.name : eventSubCalendar.name,
                                            "subCalendarId" : parentSubCalendar ? parentSubCalendar.id : eventSubCalendar.id,
                                            "inviteesSupported" : eventSubCalendar.inviteesSupported,
                                            "period": getPeriodEvent()
                                        }
                                    )
                                })
                            );
                        },

                        eventDisplayDialog = AJS.InlineDialog(target, CalendarPlugin.dialogSequence++, function(contents, trigger, showPopup) {
                            var eventDetailsContainer = renderEventPopupContent();
                            $(".field-duration", eventDetailsContainer).each(function() {
                                var durationField = $(this);
                                if (event.localizedStartDate !== event.localizedEndDate) {
                                    //TEAMCAL-1711: replace "formating..." by spinner
                                    durationField.empty().html("<span class='aui-icon aui-icon-wait'></span>");

                                    // Multiday event. We use _start and _end because fullcalendar seems to change the start date for
                                    // it's own purposes.
                                    CalendarPlugin.formatDate(calendarDiv, [ event._start, event._end ], "dd MMM", function(formattedDates) {
                                        if (typeof formattedDates === "string") {
                                            durationField.text(formattedDates);
                                            return;
                                        }

                                        if (event.allDayFlipped ? !event.allDay : event.allDay) {
                                            durationField.empty().text(AJS.format("{0} - {1}", formattedDates[0], formattedDates[1]));
                                        } else {
                                            durationField.empty().text(AJS.format("{0}, {1} - {2}, {3}", formattedDates[0], event.localizedStartTime, event.localizedEndTime, formattedDates[1]));
                                        }
                                    });
                                } else {
                                    // Single day event
                                    if (!((event.allDayFlipped ? !event.allDay : event.allDay))) {
                                        durationField.empty().text(event.localizedStartTime + " - " + event.localizedEndTime);
                                    }
                                }
                            });

                            var editControls = $(".edit-controls", eventDetailsContainer);
                            if (CalendarPlugin.isEventEditable(calendarDiv, event)) {
                                editControls.each(function() {
                                    if (CalendarPlugin.getParameter(calendarDiv, "redirectEditInEventPopup") === "true") {
                                        $(".event-edit", this).unbind("click").attr(
                                            "href",
                                            CalendarPlugin.getParameter(calendarDiv, "baseUrl").concat(
                                                "/calendar/mycalendar.action",
                                                "?startDayOfMonth=",
                                                $.fullCalendar.formatDate(event.start, "d"),
                                                "&startMonthOfYear=",
                                                (parseInt($.fullCalendar.formatDate(event.start, "M")) - 1),
                                                "&startYear=",
                                                $.fullCalendar.formatDate(event.start, "yyyy"),
                                                "&editSubCalendarId=",
                                                encodeURIComponent(CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId).id),
                                                "&editEventId=",
                                                encodeURIComponent(event.id),
                                                "&editView=month")
                                        );
                                    } else {
                                        $(".event-edit", this).unbind("click").click(function() {
                                            eventDisplayDialog.hide();
                                            var eventSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId),
                                                dialog = Confluence.TeamCalendars.Dialogs.getEditEventDialog(
                                                    $.extend(
                                                        { },
                                                        event,
                                                        {
                                                            "eventType" : eventSubCalendar.subscriptionType || eventSubCalendar.type,
                                                            "subCalendarId" : eventSubCalendar.parentId,
                                                            "originalEventSubCalendarId" : eventSubCalendar.id,
                                                            "childSubCalendarId": event.subCalendarId || ""
                                                        }
                                                    ),
                                                    null,
                                                    CalendarPlugin,
                                                    calendarDiv);

                                            dialog.show();
                                            return false;
                                        });
                                    }

                                    var deleteControl = $(".event-delete", this);
                                    if (CalendarPlugin.isEventDeletable(calendarDiv, event) && CalendarPlugin.getParameter(calendarDiv, "hideDeleteInEventPopup") === "false") {
                                        deleteControl.click(function() {
                                            eventDisplayDialog.hide();
                                            deleteEventDialog(calendarDiv, event, CalendarPlugin).show();
                                            return false;
                                        });
                                    } else {
                                        deleteControl.remove();
                                    }
                                });
                            } else {
                                editControls.each(function() {
                                    $(".edit-control", this).remove();
                                });
                            }

                            // Clean up leading/trailing separators
                            editControls.each(function() {
                                $(".event-hyperlink-separator:first-child, .event-hyperlink-separator:last-child", this).remove();
                            });

                            eventDetailsContainer.appendTo(contents.empty());
                            showPopup();
                        }, (function() {
                            var defaultOptions = {
                                hideDelay: 0,
                                noBind : true,
                                isRelativeToMouse : true,
                                showDelay : 0,
                                width : Confluence.TeamCalendars.isPDLEnabled() && $.inArray("jira-version", event.className) !== -1 ? 380 : 360,
                                hideCallback : function() {
                                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                                    if (AJS.InlineDialog.current && AJS.InlineDialog.current.popup) {
                                        // hide current inline dialog if have
                                        AJS.InlineDialog.current.popup.hide();
                                    }
                                },
                                initCallback : function() {
                                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, true);

                                    $(".event-field.reminder-icon").tooltip({gravity: 's'});
                                }
                            };

                            return inlineDialogOptions ? $.extend(defaultOptions, inlineDialogOptions) : defaultOptions;
                        })());

                    eventDisplayDialog.addClass("event-display-dialog");
                    return eventDisplayDialog;
                },

                //call rest for create/update event
                updateEvent : function(calendarDiv, data, errorCallback, successCallback) {
                    data.userTimeZoneId = Confluence.TeamCalendars.getUserTimeZone();

                    var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(true);
                    /*
                     * Data format
                     * 1) originalSubCalendarName - The name of the sub-calendar that contains the event to be moved. Leave blank if the update does not move the event to a different sub-calendar
                     * 2) subCalendarName - The name of the event's new containing sub-calendar
                     * 3) uid - The event's UID
                     * 4) originalStartDate - The originalStart property event object
                     * 5) what - New summary
                     * 6) dragAndDropUpdate - Flag indicating if the update is done via dragging and/or dropping
                     * 7) start - The new start date. Ignored if dragAndDropUpdate is false.
                     * 8) end - The new end date. Ignored if dragAndDropUpdate is false.
                     * 9) startDate - The new start date. Ignored if dragAndDropUpdate is true.
                     * 10) startTime - The new start time. Ignored if dragAndDropUpdate is true.
                     * 11) endDate - The new end date. Ignored if either dragAndDropUpdate or allDayEvent is true.
                     * 12) endTime - The new end time. Ignored if either dragAndDropUpdate or allDayEvent is true.
                     * 13) allDayEvent - Flag indicating if the event should be an all day event. If this is false, startTime and endTime must be set.
                     * 14) where - New location (optional)
                     * 15) description - New description (optional)
                     * 16) url - New URL (optional)
                     * 17) freq - The event's new repeating frequency (e.g. daily, weekly). See iCalendar RFC. Optional
                     * 18) byday - The days in the frequency (e.g. mo, tu, we). See iCalendar RFC. Optional. Ignored if freq is not defined.
                     * 19) interval - The frequency interval (_2_ weeks once, _2_ days once, etc). See iCalendar RFC. Optional. Ignored if freq is not defined.
                     * 20) repeatEnds - The flag indicating if the recurring event would end. Optional. Ignored if freq is not defined.
                     * 21) until - The repeat end date. Optional. Ignored if freq is not defined.
                     * 22) recurrenceId - The ID of the rescheduled recurring event
                     * 23) editAllInRecurrenceSeries - Whether the edit would apply to all instances of a recurring event (ignored if event is not of a recurring set)
                     */
                    $.ajax({
                        cache : false,
                        data : data,
                        dataFilter : function(data) {
                            var responseEntity = $.parseJSON(data);

                            if (responseEntity.success) {
                                Confluence.TeamCalendars.mergeSubCalendarObjectsToArray([ responseEntity.subCalendar ]);
                            }

                            return responseEntity;
                        },
                        dataType : "text",
                        error : function(XMLHttpRequest, textStatus, errorThrown) {
                            if (errorCallback) {
                                errorCallback(XMLHttpRequest, textStatus, errorThrown);
                            }
                        },
                        success : function(responseEntity) {
                            var eventType = data.eventType,
                                calendarContext = CalendarPlugin.getParameter(calendarDiv, "calendarContext");
                            var property;
                            if(eventType === "custom") {
                                if(responseEntity.subCalendar && responseEntity.subCalendar.customEventTypes) {
                                    $.each(responseEntity.subCalendar.customEventTypes, function(index, item){
                                        if(item.customEventTypeId === data.customEventTypeId) {
                                            property = {
                                                customEventTypeName: item.title
                                            };
                                        }
                                    });
                                }
                            }
                            if (data.uid) {
                                // Fire analytics event for event update
                                Confluence.TeamCalendars.fireEventForAnalytics("event.update.default." +  eventType + ".context." + calendarContext, property);
                            } else {
                                // Fire analytics event for event creation
                                Confluence.TeamCalendars.fireEventForAnalytics("event.create.default." +  eventType + ".context." + calendarContext, property);
                            }

                            cache.removeCalendar(data.subCalendarId);
                            cache.removeCalendar(data.originalSubCalendarId);
                            if (successCallback) {
                                successCallback(responseEntity);
                            }
                            CalendarPlugin.reloadSubCalendarDisableEvent(calendarDiv, data);
                        },
                        complete: function(){
                            if(spinnerDefer) spinnerDefer.resolve();
                        },
                        type : "PUT",
                        timeout : CalendarPlugin.ajaxTimeout,
                        url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/events.json")
                    });
                },
                //call rest for delete event
                deleteEvent : function(calendarDiv, params, errorCallback, successCallback) {
                    $.ajax({
                        cache : false,
                        data : params,
                        dataType : "json",
                        error : function(XMLHttpRequest, textStatus, errorThrown) {
                            if (errorCallback) {
                                errorCallback(XMLHttpRequest, textStatus, errorThrown);
                            }
                        },
                        success : function(responseEntity) {
                            cache.removeCalendar(params.subCalendarId);
                            if (successCallback) {
                                successCallback(responseEntity);
                            }
                        },
                        type : "DELETE",
                        timeout: CalendarPlugin.ajaxTimeout,
                        url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/events.json")
                    });
                },

                //trigger event click in fullcalendar.js
                eventClick : function(event, jsEvent, calendarDiv) {
                    CalendarPlugin.setEventTooltipVisible(calendarDiv);

                    if (jsEvent.shiftKey) {
                        if (CalendarPlugin.isEventEditable(calendarDiv, event)) {
                            var eventSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId);
                            Confluence.TeamCalendars.Dialogs.getEditEventDialog(
                                $.extend(
                                    { },
                                    event,
                                    {
                                        "eventType" : eventSubCalendar.subscriptionType || eventSubCalendar.type,
                                        "subCalendarId" : eventSubCalendar.parentId,
                                        "originalEventSubCalendarId" : eventSubCalendar.id,
                                        "childSubCalendarId": event.subCalendarId || ""
                                    }
                               ),
                               null,
                               CalendarPlugin,
                               calendarDiv).show();
                        }
                        return false;
                    }

                    // Ctrl click in a Mac brings up the context menu - we need another key
                    // See TEAMCAL-993 for why this is called workingUrl
                    if ((jsEvent.ctrlKey || jsEvent.metaKey) && event.workingUrl) {
                        window.location = event.workingUrl;
                        return false;
                    }

                    CalendarPlugin.getEventDetailsDialog(calendarDiv, event, $(jsEvent.currentTarget)).show(jsEvent);
                    return false;
                },
                //trigger eventRender in fullcalendar.js
                eventRender : function(event, eventDiv, view, calendarDiv) {
                    if (event.disableResizing) {
                        $(".ui-resizable-handle", eventDiv).hide();
                    }

                    eventDiv.mousemove(function(jsEvent) {
                        eventDiv.data("mouseCoords", { pageX : jsEvent.pageX, pageY : jsEvent.pageY });
                    }).hover(
                            function() {
                                setTimeout(function() {
                                    var mouseCoords = eventDiv.data("mouseCoords");
                                    if (!CalendarPlugin.isEventToolTipSuppressed(calendarDiv) && mouseCoords) {
                                        CalendarPlugin.setEventTooltipVisible(calendarDiv, event, mouseCoords, true);
                                    }
                                }, 5000);
                            },
                            function() {
                                eventDiv.removeData("mouseCoords");
                                CalendarPlugin.setEventTooltipVisible(calendarDiv);
                                CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                            }
                    );
                    $(".fc-event-time, .fc-event-title", eventDiv).css("color", eventDiv.css("color"));

                    if ("agendaWeek" === view.name) {
                        eventDiv.parent().addClass(event.allDay ? "fc-agenda-head" : "fc-agenda-body");
                        if (!event.allDay) {
                            $(".fc-event-inner", eventDiv).css({
                                "border-right-color": event.secondaryBorderColor || event.borderColor,
                                "border-bottom-color": event.secondaryBorderColor || event.borderColor,
                                "border-left-color": event.secondaryBorderColor || event.borderColor
                            });
                        }
                    }

                    if ("month" === view.name || "agendaWeek" === view.name) {
                        var renderedEventTitle;


                        if ($.inArray("other", event.className) !== -1 || event.eventType === "custom") {
                            if (event.shortTitle) {
                                renderedEventTitle = event.shortTitle + ": " + event.title;
                            } else {
                                if (event.invitees && event.invitees.length) {
                                    renderedEventTitle = event.invitees[0].displayName + ": " + event.title;
                                } else {
                                    renderedEventTitle = event.title;
                                }
                            }
                        } else {
                            renderedEventTitle = event.shortTitle || event.title;
                        }

                        $(".fc-event-title", eventDiv).text(renderedEventTitle);

                        //add image event for printing
                        if("month" === view.name || ("agendaWeek" === view.name && event.allDay)) {
                            $(".fc-event-inner", eventDiv).before(Confluence.TeamCalendars.Templates.renderCustomImagePrinting({"eventType" : event.className}));
                        }
                    }
                },
                //trigger event drop in fullcalendar.js
                eventDrop : function(event, dayDelta, minuteDelta, allDay, revertFunc, calendarDiv) {
                    if (CalendarPlugin.isEventEditable(calendarDiv, event) && !CalendarPlugin.isProcessingEvent(calendarDiv)) {
                        eventDropOrResizeCallback(calendarDiv, event, dayDelta, minuteDelta, allDay, revertFunc);
                    } else {
                        revertFunc();
                    }
                },
                //trigger event resize in fullcalendar.js
                eventResize : function(event, dayDelta, minuteDelta, revertFunc, calendarDiv) {
                    if (CalendarPlugin.isEventEditable(calendarDiv, event) && !CalendarPlugin.isProcessingEvent(calendarDiv)) {
                        eventDropOrResizeCallback(calendarDiv, event, dayDelta, minuteDelta, event.allDay, revertFunc);
                    } else {
                        revertFunc();
                    }
                },
                //trigger event drap start in fullcalendar.js
                eventDragStart : function(calendarDiv) {
                        CalendarPlugin.setSuppressEventToolTip(calendarDiv, true);
                        CalendarPlugin.setEventTooltipVisible(calendarDiv);
                        CalendarPlugin.hideInlineAuiDialogs();
                },
                //trigger event drap end in fullcalendar.js
                eventDragEnd : function(calendarDiv) {
                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                },
                //trigger event resize start in fullcalendar.js
                eventResizeStart : function(calendarDiv) {
                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, true);
                    CalendarPlugin.setEventTooltipVisible(calendarDiv);
                    CalendarPlugin.hideInlineAuiDialogs();
                },
                //trigger event resize end in fullcalendar.js
                eventResizeStop : function(calendarDiv) {
                    CalendarPlugin.setSuppressEventToolTip(calendarDiv, false);
                }
            };
        };
        return ManageEvent;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:manage-i18n-text', location = 'com/atlassian/confluence/extra/calendar3/components/manage-i18n-text/manage-i18n-text.js' */
define("tc/manage-i18n-text",
    [
        "jquery"
    ],
    function (
        $
    )
    {
        "use strict";
        var ManageI18nText = function(i18nMessages) {
            return {
                getEventTypeNames : function (key){
                    var eventTypeNames = {
                        "calendar3.subcalendar.type.parent" : "\u65e5\u7a0b\u8868",
                        "calendar3.subcalendar.type.local" : "\u4e8b\u5b9c\u65e5\u7a0b\u8868",
                        "calendar3.subcalendar.type.subscription" : "\u8ba2\u9605",
                        "calendar3.subcalendar.type.jira" : "Jira\u65e5\u7a0b\u8868",
                        "calendar3.subcalendar.type.people" : "\u6210\u5458\u65e5\u7a0b\u8868",
                        "calendar3.subcalendar.type.other" : "\u4e8b\u4ef6",
                        "calendar3.subcalendar.type.generic-people" : "\u4eba\u5458",
                        "calendar3.subcalendar.type.travel" : "\u51fa\u5dee",
                        "calendar3.subcalendar.type.leaves" : "\u4f11\u5047",
                        "calendar3.subcalendar.type.birthdays" : "\u751f\u65e5",
                        "calendar3.subcalendar.type.jira-agile-sprint" : "Jira Agile Sprints",
                        "calendar3.subcalendar.type.jira-project-releases" : "Jira \u9879\u76ee\u53d1\u5e03",
                        "calendar3.subcalendar.type.jira-issue-dates" : "Jira \u95ee\u9898\u65e5\u671f",
                        "calendar3.subcalendar.type.unknown" : "\u672a\u77e5\u7c7b\u578b"
                        };

                    return eventTypeNames[key] ? eventTypeNames[key] : eventTypeNames;
                },

                getMonthNames : function() {
                    return [
                        this.getText("calendar3.month.long.january"),
                        this.getText("calendar3.month.long.february"),
                        this.getText("calendar3.month.long.march"),
                        this.getText("calendar3.month.long.april"),
                        this.getText("calendar3.month.long.may"),
                        this.getText("calendar3.month.long.june"),
                        this.getText("calendar3.month.long.july"),
                        this.getText("calendar3.month.long.august"),
                        this.getText("calendar3.month.long.september"),
                        this.getText("calendar3.month.long.october"),
                        this.getText("calendar3.month.long.november"),
                        this.getText("calendar3.month.long.december")
                    ];
                },

                getMonthNamesShort : function() {
                    return [
                        this.getText("calendar3.month.short.january"),
                        this.getText("calendar3.month.short.february"),
                        this.getText("calendar3.month.short.march"),
                        this.getText("calendar3.month.short.april"),
                        this.getText("calendar3.month.short.may"),
                        this.getText("calendar3.month.short.june"),
                        this.getText("calendar3.month.short.july"),
                        this.getText("calendar3.month.short.august"),
                        this.getText("calendar3.month.short.september"),
                        this.getText("calendar3.month.short.october"),
                        this.getText("calendar3.month.short.november"),
                        this.getText("calendar3.month.short.december")
                    ];
                },

                getDayNames : function() {
                    return [
                        this.getText("calendar3.day.long.sunday"),
                        this.getText("calendar3.day.long.monday"),
                        this.getText("calendar3.day.long.tuesday"),
                        this.getText("calendar3.day.long.wednesday"),
                        this.getText("calendar3.day.long.thursday"),
                        this.getText("calendar3.day.long.friday"),
                        this.getText("calendar3.day.long.saturday")
                    ];
                },

                getDayNamesShort : function() {
                    return [
                        this.getText("calendar3.day.short.sunday"),
                        this.getText("calendar3.day.short.monday"),
                        this.getText("calendar3.day.short.tuesday"),
                        this.getText("calendar3.day.short.wednesday"),
                        this.getText("calendar3.day.short.thursday"),
                        this.getText("calendar3.day.short.friday"),
                        this.getText("calendar3.day.short.saturday")
                    ];
                },
                getText : function(i18nKey) {
                     return this.getI18nMessages()[i18nKey];
                },
                getI18nMessages : function() {
                    if (!i18nMessages) {
                        i18nMessages = {};

                        //See http://bugs.jquery.com/ticket/6827 for why we use .html() here instead of .text()
                        $("fieldset input", $("<div/>", { "html" : $("#team-calendars-messages").html() })).each(function() {
                            i18nMessages[this.name] = this.value;
                        });
                    }

                    return i18nMessages;
                }
            };
        };
        return ManageI18nText;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:full-calendar-option', location = 'com/atlassian/confluence/extra/calendar3/components/full-calendar/full-calendar-option.js' */
define("tc/full-calendar-option",
    [
        "jquery",
        "tc/manage-event"
    ],
    function (
        $,
        ManageEvent)
    {
        "use strict";
        var FullCalendarOption = function(CalendarPlugin, calendarDiv, cache) {
            return {
                _calendarDiv : calendarDiv,
                _calendarPlugin : CalendarPlugin,
                defaultView : CalendarPlugin.getParameter(calendarDiv, "defaultView") || "month",
                year : parseInt(CalendarPlugin.getParameter(calendarDiv, "startingYear")),
                month : parseInt(CalendarPlugin.getParameter(calendarDiv, "startingMonth")),
                date : parseInt(CalendarPlugin.getParameter(calendarDiv, "startingDay")),
                header : false,
                firstDay : CalendarPlugin.getParameter(calendarDiv, "firstDayOfWeek"),
                weekends : CalendarPlugin.getParameter(calendarDiv, "hideWeekends") === "false",
                viewRender : function(view) {
                    var highlightViewButton = function() {
                            if (Confluence.TeamCalendars.isPDLEnabled()) {
                                $(".change-view", calendarDiv).removeClass("active");
                                $(".change-view-" + view.name, calendarDiv).addClass("active");
                            } else {
                                $(".change-view", calendarDiv).each(function() {
                                    $(this).closest("li").removeClass("active");
                                });
                                $(".change-view-" + view.name, calendarDiv).closest("li").addClass("active");
                            }
                        };

                    Confluence.TeamCalendars.updateDateDisplay(calendarDiv, view.title);
                    highlightViewButton();

                    if (view.name === "basicDay") {
                        CalendarPlugin.getCalendarPanel(calendarDiv).addClass("borderless");
                    } else {
                        CalendarPlugin.getCalendarPanel(calendarDiv).removeClass("borderless");
                    }

                    if (CalendarPlugin.isCalendarInEditMode(calendarDiv)) {
                        var lastSelectedView = calendarDiv.data("lastSelectedView");
                        if (!lastSelectedView) {
                            calendarDiv.data("lastSelectedView", view.name);
                        } else if (view.name !== lastSelectedView) {
                            calendarDiv.data("lastSelectedView", view.name);
                            $.ajax({
                                cache : false,
                                data : {
                                    view : view.name
                                },
                                dataType : "json",
                                error : function(XMLHttpRequest, textStatus, errorThrown) {
                                    CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_CONFIG_UPDATE);
                                },
                                success : function() {
                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_CONFIG_UPDATE);
                                },
                                type: "PUT",
                                timeout: CalendarPlugin.ajaxTimeout,
                                url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/preferences/view.json")
                            });
                        }
                    }
                },
                allDayText: "\u5168\u5929",
                firstHour: 8,
                columnFormat : {
                    week: "ddd d"
                },
                titleFormat : {
                    week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d, yyyy}"
                },
                buttonText : {
                    today : "\u4eca\u65e5",
                    month : "\u6708",
                    week : "\u5468",
                    day : "\u5217\u8868"
                },
                monthNames : CalendarPlugin.getMonthNames(),
                monthNamesShort : CalendarPlugin.getMonthNamesShort(),
                dayNames : CalendarPlugin.getDayNames(),
                dayNamesShort : CalendarPlugin.getDayNamesShort(),
                dayClick : function(date, allDay, jsEvent) {
                    if ($(".event-details-popup:visible").length === 0) {
                        if (CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv).length) {
                            Confluence.TeamCalendars.Dialogs.getEditEventDialog({
                                    start : date,
                                    localizedStartTime : allDay ? CalendarPlugin.getDefaultStartTime(calendarDiv) : null,
                                    localizedEndTime : allDay ? CalendarPlugin.getDefaultEndTime(calendarDiv) : null,
                                    allDay : (function() {
                                        if (CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("getView").name === "month") {
                                            return (calendarDiv.data(CalendarPlugin.PREF_LAST_ALL_DAY_USED) || allDay.toString()) === "true";
                                        }
                                        return allDay;
                                    })()
                                },
                                null,
                                CalendarPlugin,
                                calendarDiv
                            ).show();
                        }
                    } else {
                        jsEvent.stopPropagation();
                        CalendarPlugin.hideInlineAuiDialogs();
                    }

                },
                eventClick : function(event, jsEvent) {
                    return ManageEvent(CalendarPlugin).eventClick(event, jsEvent, calendarDiv);
                },
                eventRender : function(event, eventDiv, view) {
                    ManageEvent(CalendarPlugin).eventRender(event, eventDiv, view, calendarDiv);
                },
                eventDrop : function(event, dayDelta, minuteDelta, allDay, revertFunc) {
                    ManageEvent(CalendarPlugin, cache).eventDrop(event, dayDelta, minuteDelta, allDay, revertFunc, calendarDiv);
                },
                eventDragStart : function() {
                    ManageEvent(CalendarPlugin, cache).eventDragStart(calendarDiv);
                },
                eventDragEnd : function() {
                    ManageEvent(CalendarPlugin, cache).eventDragEnd(calendarDiv);
                },
                eventResize : function(event, dayDelta, minuteDelta, revertFunc) {
                    ManageEvent(CalendarPlugin, cache).eventResize(event, dayDelta, minuteDelta, revertFunc, calendarDiv);
                },
                eventResizeStart : function() {
                    ManageEvent(CalendarPlugin, cache).eventResizeStart(calendarDiv);
                },
                eventResizeStop : function() {
                    ManageEvent(CalendarPlugin, cache).eventResizeStop(calendarDiv);
                },
                loading : function(isLoading) {
                    if (!isLoading) {
                        window.isTeamCalendarsLoaded = true;
                    }

                    if (!isLoading && this.spinnerDefer) {
                        this.spinnerDefer.resolve();
                    }

                    if (isLoading) {
                        this.spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, isLoading);
                    }
                },
                selectable : true,
                selectHelper : true,
                select : function(startDate, endDate, allDay, jsEvent) {
                    if (!$(".event-details-popup:visible").length && CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv).length) {
                        Confluence.TeamCalendars.Dialogs.getEditEventDialog({
                            start : startDate,
                            end : endDate,
                            localizedStartTime : allDay ? CalendarPlugin.getDefaultStartTime(calendarDiv) : null,
                            localizedEndTime : allDay ? CalendarPlugin.getDefaultEndTime(calendarDiv) : null,
                            allDay : (function() {
                                if (CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("getView").name === "month") {
                                    //for select multi-day event
                                    if(endDate.getTime() - startDate.getTime() > 0) {
                                        return allDay.toString() === "true";
                                    }
                                    return (calendarDiv.data(CalendarPlugin.PREF_LAST_ALL_DAY_USED) || allDay.toString()) === "true";
                                }
                                return allDay;
                            })()},
                            null,
                            CalendarPlugin,
                            calendarDiv).show();
                    } else {
                        if (jsEvent) {
                            jsEvent.stopPropagation();
                        }
                        CalendarPlugin.hideInlineAuiDialogs();
                    }
                }
            };
        };

        return FullCalendarOption;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/subcalendar-panel.js' */
define("tc/subcalendar-panel",
    [
        "jquery",
        "tc/calendar-util",
        "tc/myCalendarTour",
        "tc/subcalendar-entry-view",
        "tc/subcalendar-menu-builder",
        "tc/non-space-calendars-handler",
        "tc/event-edit-dialog",
        "tc/calendar-caldav-subscribe-model",
        "tc/subcalendar-subscribe-dialog",
        "tc/calendar-caldav-subscribe-service"
    ],
    function (
        $,
        CalUtil,
        CalendarTour,
        SubCalendarEntryView,
        SubCalendarMenuBuilder,
        nonSpaceCalendarsHandler,
        EventEditDialog,
        CalendarSubscribeModel,
        CalendarSubscribeDialog,
        CalendarSubscribeService
    )
    {
        "use strict";
        var SubCalendarPanel = function(CalendarPlugin, calendarDiv, cache) {
            var subCalendarNamesDiv = $("div.sub-calendar-names", calendarDiv);

            //Add an entry to the subCalendar panel for subcalendar
            var createCalendarEntry = function(subCalendar) {

                var subCalendarEntry = (function() {
                    var theEntry = new SubCalendarEntryView({
                        "CalendarPlugin": CalendarPlugin,
                        "subCalendar": subCalendar,
                        "_calendarDiv": calendarDiv,
                        "cache": cache
                    }).render();

                    return theEntry;
                })();

                return subCalendarEntry;
            };

            //Show/hide the quick create event button
            var initAddEventButton = function() {
                if (CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv).length) {
                    $(".add-event-button", calendarDiv).removeClass("hidden");
                    $(".toolbar-group-addevent, .add-event-button", calendarDiv).removeClass("hidden");
                } else {
                    $(".add-event-button", calendarDiv).addClass("hidden");
                    $(".toolbar-group-addevent, .add-event-button", calendarDiv).addClass("hidden");
                }
            };

            var initSubscribeButton = function () {
                if (CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv).length &&
                    CalendarPlugin.getSubCalendars(calendarDiv).length) {
                    $(".subscribe-calendar-button").removeClass("hidden");
                }
                else {
                    $(".subscribe-calendar-button").addClass("hidden");
                }
            };

            //Show/hide the add calendar button
            //Note: In conf versions < 5 there is both an 'Add Calendar' and 'Add Jira Calendar' button.
            //In conf 5+ we use a single split button.
            var initAddCalendarButton = function() {
                if ("true" === CalendarPlugin.getParameter(calendarDiv, "readOnly")) {
                    $("#add-calendar-menu").addClass("hidden");
                }
                else {
                    $("#add-calendar-menu").removeClass("hidden");
                }
            };

            var showNoCalendarsMessage = function() {
                $("<div/>", {
                    "class" :"no-subcalendars-msg",
                    "text" : "\u60a8\u5e76\u672a\u521b\u5efa\uff0c\u4e5f\u5e76\u672a\u8ba2\u9605\u4efb\u4f55\u65e5\u7a0b\u8868"
                }).appendTo(subCalendarNamesDiv);
            };

            var updateWatchingStatusForSubCalendarMenuOptions = function (subCalendarNamesDiv, subCalendars) {
                var parentSubCalendars = $.grep(subCalendars, function (element, index) {
                    return element.type === "parent" || element.subscriptionType === "parent";
                });

                var successCallback = function(watchingStatuses) {
                    var $items = $(subCalendarNamesDiv).find(".subcalendar-item");

                    $items.each(function (index, item) {
                        var $item = $(item);
                        var subCalendarId = $item.data("sub-calendar-id");
                        var matchedItems = $.grep(watchingStatuses, function(ws){ return ws.subCalendarId == subCalendarId; });
                        var isHideWatchMenuItem = CalendarPlugin.getParameter(calendarDiv, "hideWatchMenuItem") === "true";

                        if (matchedItems.length > 0 && matchedItems[0].isWatchable && !isHideWatchMenuItem) {
                            var className = "not-watched";
                            if (matchedItems[0].watchedViaContent) {
                                className = "watching-via-content";
                            } else if (matchedItems[0].watched) {
                                className = "watched";
                            }

                            $item.addClass(className);
                        }

                        //disable loading watching status
                        $item.addClass("disable-loading-watching-status");
                        CalendarTour.reposition();
                    });

                    AJS.trigger("calendar.watch.statuses.loaded", watchingStatuses);
                };

                var requestData = { };
                var parentSubCalendarIds = $.map(parentSubCalendars , function (parentSubCalendar, i) {
                    return parentSubCalendar.id;
                });
                requestData.include = parentSubCalendarIds ;

                $.ajax({
                    cache : false,
                    data : requestData,
                    dataType : "json",
                    error : function(XMLHttpRequest, textStatus, errorThrown) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                    },
                    success : function(responseEntity) {
                        if (responseEntity.success) {
                            var watchingStatuses = responseEntity.payload;
                            successCallback(watchingStatuses);

                            CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                        } else {
                            CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                        }
                    },
                    type: "GET",
                    timeout: CalendarPlugin.ajaxTimeout,
                    url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendars/watching/status.json")
                });
            };

            //Set the menu options and display name for each subcalendar and child subcalendar
            var setSubCalendarMenuOptions = function(subCalendars) {
                SubCalendarMenuBuilder.build(calendarDiv, CalendarPlugin, subCalendars);
            };

            return {
                initSubCalendarPanel: function() {
                    var showAddEventDialog = function(_calendarDiv) {
                        new EventEditDialog().getEditEventDialog({
                                start : new Date(),
                                localizedStartTime : CalendarPlugin.getDefaultStartTime(_calendarDiv),
                                localizedEndTime : CalendarPlugin.getDefaultEndTime(_calendarDiv),
                                allDay : (_calendarDiv.data(CalendarPlugin.PREF_LAST_ALL_DAY_USED) || "true") === "true"
                            },
                            null,
                            CalendarPlugin,
                            calendarDiv).show();
                    };

                    $(".toolbar-group-addevent .trigger-addevent, .calendar-toolbar .add-event, .add-event-button", calendarDiv).click(function() {
                        showAddEventDialog(calendarDiv);
                        return false;
                    });

                    $(".subscribe-calendar-button", calendarDiv).click(function(){
                        var subCalendars = CalendarPlugin.getSubCalendars(calendarDiv);
                        var service = new CalendarSubscribeService(CalendarPlugin, calendarDiv);
                        var model = new CalendarSubscribeModel({
                            subCalendars: subCalendars,
                            baseUrl: CalUtil.getParameter(calendarDiv, "baseUrl"),
                            isPrivateUrlsEnabled: CalendarPlugin.getParameter(calendarDiv, "privateUrlsEnabled"),
                            privateUrlProvider: _.bind(service.getPrivateUrlProvider, service)
                        });
                        var subscribeDialogView = new CalendarSubscribeDialog({
                            calendarPlugin: CalendarPlugin,
                            calendarDiv: calendarDiv,
                            model: model
                        });
                        subscribeDialogView.render();
                        return false;
                    });

                    var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(true);
                    var resolveSpinner = function(){
                        if (spinnerDefer) spinnerDefer.resolve();
                    };

                    CalendarPlugin.refreshCachedSubCalendars(calendarDiv, function(subCalendars) {
                        if ("true" === CalendarPlugin.getParameter(calendarDiv, "showHiddenSubCalendars") && $.isArray(subCalendars)) {
                            $.each(subCalendars, function(subCalendarIdx, subCalendar) {
                                subCalendar.eventsHidden = false;
                            });
                        }

                        CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                        resolveSpinner();

                        if (CalendarPlugin.isCalendarInEditMode(calendarDiv)) {
                            var popupDialogForFirstUses = function() {
                                calendarDiv.unbind("calendar-plugin.resized", popupDialogForFirstUses);

                                if ("true" === CalendarPlugin.getParameter(calendarDiv, "isShowCalendarWizard"))
                                {
                                    var showPopularDialog = function() {
                                        Confluence.TeamCalendars.Dialogs.getSubCalendarSubscribeDialog({
                                            heading: "\u6b22\u8fce\u4f7f\u7528\u56e2\u961f\u65e5\u7a0b\u8868\uff01",
                                            callbackHandler: CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv)
                                        }).show();
                                    };

                                    var showCalendarDialog = function() {
                                        Confluence.TeamCalendars.Dialogs.getAddDialog(
                                            CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                                            {
                                                title : "\u6b22\u8fce\u4f7f\u7528\u56e2\u961f\u65e5\u7a0b\u8868\uff01",
                                                addClass : "create-calendar-first-time"
                                            }
                                        );
                                    };

                                    CalUtil.showCalendarPopupHaveAnEmptySubcalendar(showPopularDialog, showCalendarDialog);
                                }
                            };

                            calendarDiv.bind("calendar-plugin.resized", popupDialogForFirstUses);
                        }
                    }, function() {
                        resolveSpinner();
                    });
                },

                updateAvailableSubCalendarsInSubCalendarPanel : function() {
                    subCalendarNamesDiv.empty();
                    initAddEventButton();
                    initSubscribeButton();
                    initAddCalendarButton();

                    var subCalendars = CalUtil.getSortedSubCalendarsByTypeAndName(CalendarPlugin.getSubCalendars(calendarDiv));
                    setSubCalendarMenuOptions(subCalendars);

                    window.isTeamCalendarsLoaded = true;

                    // if no calendars
                    if (!subCalendars.length) {
                        CalUtil.toggleNoCalendarPage(true);
                        $(".no-calendar-page #add-button").click(function (event) {
                            Confluence.TeamCalendars.Dialogs.getAddDialog(CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv));
                            event.preventDefault();
                        });
                        showNoCalendarsMessage();
                    } else {
                        CalUtil.toggleNoCalendarPage(false);
                    }

                    $.each(subCalendars, function (idx, subCalendar) {
                        subCalendarNamesDiv.append(createCalendarEntry(subCalendar));
                    });

                    if(!CalUtil.isSingleCalendarView(calendarDiv)) {
                        CalendarTour.start();
                    }


                    updateWatchingStatusForSubCalendarMenuOptions(subCalendarNamesDiv, subCalendars);


                    nonSpaceCalendarsHandler.handle(CalendarPlugin, calendarDiv, cache, subCalendars);

                }
            };
        };
        return SubCalendarPanel;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/subcalendar-entry-view.js' */
define("tc/subcalendar-entry-view",
    [
        "jquery",
        "underscore",
        "tc/calendar-util",
        "tc-backbone",
        "tc/child-subcalendar-entry-view",
        "tc/subcalendar-menu-view",
        "tc/subcalendar-displayer"
    ],
    function (
        $,
        _,
        CalUtil,
        Backbone,
        ChildSubCalendarEntryView,
        SubCalendarMenuView,
        SubCalendarDisplayer
    ) {

        "use strict";

        var SubCalendarEntryView = Backbone.View.extend({
            initialize: function(options) {
                this.cache = options.cache;
                this.CalendarPlugin = options.CalendarPlugin;
                this.subCalendar = options.subCalendar;
                this._calendarDiv = options._calendarDiv;
                this.template = Confluence.TeamCalendars.Templates.subCalendarPanelEntry;

                this.childSubCalendarIds = [];
                this.childSubCalendarViews = [];

                AJS.trigger("calendar.loaded", this.subCalendar);
            },

            events: {
                "click .subcalendar-name" : "_onClick"
            },

            render: function() {
                this.$el.html(this.template({
                    "subCalendar": this.subCalendar,
                    "autoConvertSupported": this.CalendarPlugin.isAutoConvertSupported(this._calendarDiv),
                    "subCalendarClasses": this.CalendarPlugin.getParameter(this._calendarDiv, "subCalendarColorClass")
                }));

                this.entryView = this.$(".subcalendar-item");

                this._ellipsisLongCalendarNames();
                this._renderChildSubCalendars();
                this._initEventsVisibility();

                if(!CalUtil.isSingleCalendarView(this._calendarDiv)) {
                    this.subcalendarDisplayer = new SubCalendarDisplayer({
                        CalendarPlugin: this.CalendarPlugin,
                        _calendarDiv: this._calendarDiv,
                        entryView: this.entryView,
                        subCalendar: this.subCalendar,
                        childSubCalendarIds: this.childSubCalendarIds,
                        childSubCalendarViews: this.childSubCalendarViews
                    });
                }

                if(CalUtil.isSpaceCalendarView(this._calendarDiv) && !CalUtil.isDummySubscriptionParentSubCalendar(this.subCalendar) && this.subCalendar.spaceKey !== undefined){
                    this.$(".subcalendar-name").addClass("header-color");
                }

                this.menuView = new SubCalendarMenuView({
                    "cache": this.cache,
                    "CalendarPlugin": this.CalendarPlugin,
                    "_calendarDiv": this._calendarDiv,

                    "subCalendar": this.subCalendar,
                    "subCalendarEntryView": this.entryView,

                    "autoConvertSupported": this.CalendarPlugin.isAutoConvertSupported(this._calendarDiv),
                    "subCalendarClasses": this.CalendarPlugin.getParameter(this._calendarDiv, "subCalendarColorClass"),
                    "template": Confluence.TeamCalendars.Templates.subCalendarMenu,

                    "subcalendarDisplayer": this.subcalendarDisplayer
                });
                this.$(".subcalendar-info").append(this.menuView.render());

                return this.$el;
            },

            _ellipsisLongCalendarNames: function() {
                this.$(".subcalendar-name").attr("title", this.$(".ellipsis_text").text());
            },

            _renderChildSubCalendars: function() {
                if (this.subCalendar.childSubCalendars) {
                    this.childSubCalendarIds = [];
                    this.childSubCalendarViews = [];

                    var that = this;

                    _.each(this.subCalendar.childSubCalendars, function (childSubCalendar) {
                        var customEventTypes = childSubCalendar.customEventTypes;
                        if (customEventTypes && customEventTypes.length) {
                            _.each(customEventTypes, function (customEventType) {
                                that._renderChildSubCalendar(childSubCalendar, customEventType);
                            });
                        } else {
                            that._renderChildSubCalendar(childSubCalendar);
                        }
                    });
                }
            },

            _renderChildSubCalendar: function(childSubCalendar, customEventType) {
                var $childSubCalendarDiv = this.$(".child-subcalendars");
                var options = {
                    "cache": this.cache,
                    "CalendarPlugin": this.CalendarPlugin,
                    "_calendarDiv": this._calendarDiv,
                    "parentView": this.entryView,
                    "parentSubCalendar": this.subCalendar,
                    "childSubCalendar": childSubCalendar
                };

                if(customEventType) {
                    options.customEventType = customEventType;
                    options.template = Confluence.TeamCalendars.Templates.customEventTypePanelEntry;
                } else {
                    options.template = Confluence.TeamCalendars.Templates.childSubCalendarPanelEntry;
                }

                var $childView = new ChildSubCalendarEntryView(options).render();

                $childSubCalendarDiv.append($childView);

                this.childSubCalendarIds.push(childSubCalendar.id);
                this.childSubCalendarViews.push($childView.find(".child-subcalendar"));
            },

            _onClick: function () {
                // do not allow to click on calendar to hide/show it in single calendar page
                if(!CalUtil.isSpaceCalendarView(this._calendarDiv) || CalUtil.isDummySubscriptionParentSubCalendar(this.subCalendar) || this.subCalendar.spaceKey === undefined) {
                    return;
                }

                Confluence.TeamCalendars.fireEventForAnalytics("view.calendar.detail.click");

                window.location.href = AJS.contextPath() + "/display/"
                    + encodeURIComponent(this.subCalendar.spaceKey)
                    + "/calendar/" + encodeURIComponent(this.subCalendar.subscriptionId || this.subCalendar.id)
                    + "?calendarName=" + encodeURIComponent(this.subCalendar.name);
            },

            // Display events of sub-calendar (and its child sub-calendars) if not disabled.
            _initEventsVisibility: function () {
                var enabledSubCalendarIds = [];
                var disabledSubCalendarIds = [];

                if (CalUtil.isSubscriptionSubCalendar(this.subCalendar)) {
                    if (this.subCalendar.eventsHidden || $.inArray(this.subCalendar.id, disabledSubCalendarIds) !== -1) {
                        this.entryView.addClass("subcalendar-disabled");
                        disabledSubCalendarIds.push(this.subCalendar.id);
                    } else {
                        if (!CalUtil.isDummySubscriptionParentSubCalendar(this.subCalendar)) {
                            enabledSubCalendarIds.push(this.subCalendar.id);
                        }
                    }
                }

                _.each(this.childSubCalendarViews, function (view) {
                    var childSubCalendar = this.CalendarPlugin.getSubCalendar(this._calendarDiv, view.data("subCalendarId"));

                    if (!CalUtil.isSingleCalendarView(this._calendarDiv) && (childSubCalendar.eventsHidden || $.inArray(childSubCalendar.id, disabledSubCalendarIds) !== -1)) {
                        view.addClass("subcalendar-disabled");
                        view.find(".child-subcalendar-checkbox").prop("checked", false);
                        disabledSubCalendarIds.push(childSubCalendar.id);
                    } else {
                        enabledSubCalendarIds.push(childSubCalendar.id);
                        view.find(".child-subcalendar-checkbox").prop("checked", true);
                    }
                }, this);


                if (enabledSubCalendarIds.length) {
                    this.CalendarPlugin.addSubCalendarEventSource(this._calendarDiv, enabledSubCalendarIds);
                }

                if (disabledSubCalendarIds.length) {
                    this.entryView.addClass("subcalendar-disabled");
                }
                if (this.childSubCalendarViews.length) {
                    this.CalendarPlugin.checkCalendarHasAllChildDisable(this.entryView);
                } else {
                    if (!CalUtil.isSingleCalendarView(this._calendarDiv) && this.subCalendar.eventsHidden) {
                        this.entryView.addClass("subcalendar-disabled");
                    }
                }
            }
        });

        return SubCalendarEntryView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/subcalendar-menu-view.js' */
define("tc/subcalendar-menu-view",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/myCalendarTour",
        "tc/calendar-util",
        "tc/calendar-caldav-subscribe-model",
        "tc/subcalendar-subscribe-dialog",
        "tc/calendar-caldav-subscribe-service"
    ],
    function (
        $,
        _,
        Backbone,
        CalendarTour,
        CalUtil,
        CalendarSubscribeModel,
        CalendarSubscribeDialog,
        CalendarSubscribeService
    ) {

        "use strict";

        var SubCalendarMenuView = Backbone.View.extend({
            initialize: function (options) {
                this.cache = options.cache;
                this.CalendarPlugin = options.CalendarPlugin;
                this._calendarDiv = options._calendarDiv;

                this.subCalendar = options.subCalendar;
                this.parentSubCalendar = options.parentSubCalendar;

                this.$subCalendarEntryView = options.subCalendarEntryView;

                this.template = options.template;
                this.subcalendarDisplayer = options.subcalendarDisplayer;
            },

            events: {
                "click .subcalendar-addevent": "_onAddEventClick",

                "click .subcalendar-watch": "_onWatchClick",
                "click .subcalendar-unwatch": "_onUnWatchClick",

                "click .subcalendar-edit, .subcalendar-view": "_onEditClick",

                "click .subcalendar-restrict": "_onRestrictClick",

                "click .subcalendar-remove": "_onRemoveClick",

                "click .subcalendar-share, .subcalendar-share-or-embed": "_onShareClick",

                "click .subcalendar-subscribe": "_onSubscribeClick",

                "click .subcalendar-reload": "_onRefreshClick",

                "click .subcalendar-reminder": "_onReminderClick",

                "click .custom-event-type-edit, .setting-reminder-setting": "_onEditEventTypeClick",

                "click .color-cell": "_onColorCellClick",

                "click .subcalendar-display-hide, .subcalendar-display-show": "_onDisplayClick"
            },

            render: function () {
                this.$el.html(this.template({
                    "subCalendar": this.subCalendar,
                    "autoConvertSupported": this.CalendarPlugin.isAutoConvertSupported(this._calendarDiv),
                    "subCalendarClasses": this.CalendarPlugin.getParameter(this._calendarDiv, "subCalendarColorClass"),
                    "parentSubCalendar": this.parentSubCalendar
                }));

                this._initExportLink();
                this._initDetailLink();
                this._initMenuItemsDropDown();

                return this.$el;
            },

            // Initialises the sub-calendar menu items drop down.
            _initMenuItemsDropDown: function() {
                this.$(".subcalendar-dropdown-menu").dropDown("Standard", {
                    "alignment": "right",
                    "hideHandler" : function() {
                        // close the tour if have
                        CalendarTour.hideLeg();
                    }
                });
            },

            _initExportLink: function() {
                this.$(".subcalendar-icalexport").attr("href", this.CalendarPlugin.getCalendarServiceBaseUrl(this._calendarDiv, "/export/subcalendar/" + encodeURIComponent(this.subCalendar.id + ".ics") + "?os_authType=basic&isSubscribe=false"));
            },

            _initDetailLink: function() {
                this.$(".subcalendar-page").attr(
                        "href",
                        AJS.contextPath() + "/display/" + encodeURIComponent(this.subCalendar.spaceKey)
                            + "/calendar/" + encodeURIComponent(this.subCalendar.subscriptionId || this.subCalendar.id) + "?calendarName=" + encodeURIComponent(this.subCalendar.name)
                );
            },

            // === Menu items click handlers ===
            _onAddEventClick: function (event) {
                Confluence.TeamCalendars.Dialogs.getEditEventDialog({
                            start: new Date(),
                            localizedStartTime: this.CalendarPlugin.getDefaultStartTime(this._calendarDiv),
                            localizedEndTime: this.CalendarPlugin.getDefaultEndTime(this._calendarDiv),
                            allDay: (this._calendarDiv.data(this.CalendarPlugin.PREF_LAST_ALL_DAY_USED) || "true") === "true",
                            subCalendarId: this.subCalendar.id
                        },
                        this.subCalendar,
                        this.CalendarPlugin,
                        this._calendarDiv
                ).show();

                event.preventDefault();
            },

            _onWatchClick: function(event) {
                setSubCalendarWatch(this.CalendarPlugin, this._calendarDiv, this.subCalendar, true, _.bind(function() {
                    this.$subCalendarEntryView.addClass("watched").removeClass("not-watched");
                }, this));

                event.preventDefault();
            },

            _onUnWatchClick: function(event) {
                setSubCalendarWatch(this.CalendarPlugin, this._calendarDiv, this.subCalendar, false, _.bind(function() {
                    this.$subCalendarEntryView.removeClass("watched").addClass("not-watched");
                }, this));

                event.preventDefault();
            },

            _onEditClick: function (event) {
                this.CalendarPlugin.showSubCalendarEdit(this._calendarDiv, this.subCalendar);
                //process behaviour when event type panel active
                $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");

                event.preventDefault();
            },

            _onRestrictClick: function(event) {
                this.CalendarPlugin.getSubCalendarRestrictionsDialog(this._calendarDiv, this.subCalendar);

                event.preventDefault();
            },

            _onRemoveClick: function (event) {
                if (this.CalendarPlugin.isSubCalendarDeletable(this._calendarDiv, this.subCalendar)) {
                    if (CalUtil.isJiraSubCalendar(this.subCalendar)) {
                        this.CalendarPlugin.deleteSubCalendar(this._calendarDiv, this.subCalendar);
                    } else {
                        this.CalendarPlugin.removeSubCalendarDialog(this._calendarDiv, this.subCalendar);
                    }
                } else {
                    this.CalendarPlugin.unsubscribeFromSubcalendar(this._calendarDiv, this.subCalendar);
                }
                event.preventDefault();
            },

            _onShareClick: function(event) {
                this.CalendarPlugin.getSubCalendarShareDialog(this._calendarDiv, this.subCalendar);

                event.preventDefault();
            },

            _onSubscribeClick: function(event) {
                var CalendarPlugin = this.CalendarPlugin;
                var calendarDiv = this._calendarDiv;
                var subCalendars = CalendarPlugin.getSubCalendars(calendarDiv);
                var service = new CalendarSubscribeService(CalendarPlugin, calendarDiv);
                var model = new CalendarSubscribeModel({
                    subCalendars: subCalendars,
                    selectedSubCalId: this.subCalendar.id,
                    baseUrl: CalUtil.getParameter(calendarDiv, "baseUrl"),
                    isPrivateUrlsEnabled: CalendarPlugin.getParameter(calendarDiv, "privateUrlsEnabled"),
                    privateUrlProvider: _.bind(service.getPrivateUrlProvider, service)
                });
                var subscribeDialogView = new CalendarSubscribeDialog({
                    calendarPlugin: CalendarPlugin,
                    calendarDiv: calendarDiv,
                    model: model
                });
                subscribeDialogView.render();
                event.preventDefault();
            },

            _onRefreshClick: function(event) {
                if (!this.CalendarPlugin.isSubCalendarEventsUpdatable(this._calendarDiv, this.subCalendar) || isSubCalendarOrAnyOfItsChildrenJiraSubCalendar(this.subCalendar) || CalUtil.isSubscriptionSubCalendar(this.subCalendar)) {
                    var that = this;

                    $.ajax({
                        cache : false,
                        data : {
                            subCalendarId : this.subCalendar.id
                        },
                        dataType : "json",
                        error : function(XMLHttpRequest, textStatus, errorThrown) {
                            that.CalendarPlugin.showAjaxError(that._calendarDiv, XMLHttpRequest, textStatus, errorThrown, that.CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + that.CalendarPlugin.getStringAsHex(that.subCalendar.id));
                        },
                        success : function(responseEntity) {
                            that.CalendarPlugin.setGenericErrors(that._calendarDiv, null, that.CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + that.CalendarPlugin.getStringAsHex(that.subCalendar.id));
                            if (responseEntity.success) {
                                that.CalendarPlugin.reloadSubCalendar(that._calendarDiv, that.subCalendar.id);
                            }
                        },
                        type : "PUT",
                        timeout : this.CalendarPlugin.ajaxTimeout,
                        url : this.CalendarPlugin.getCalendarServiceBaseUrl(this._calendarDiv, "/subcalendars/admin/refresh.json")
                    });
                } else {
                    // Just reload if the sub-calendar is not sourced externally - the cached data need not to be flushed for the reload
                    // because the plugin will keep it updated
                    this.CalendarPlugin.reloadSubCalendar(this._calendarDiv, this.subCalendar.id);
                }

                event.preventDefault();
            },

            _onReminderClick: function(event) {
                setSubCalendarReminderMe(this.CalendarPlugin, this._calendarDiv, this.subCalendar, this.subCalendar.id, _.bind(function () {
                    this.$subCalendarEntryView.find(".reminder-me").toggleClass("hidden");
                    this.$subCalendarEntryView.find(".unreminder-me").toggleClass("hidden");
                }, this), this.$subCalendarEntryView.find(".reminder-me.hidden").length ? false : true);

                event.preventDefault();
            },

            _onEditEventTypeClick: function(event) {
                var eventTypeName = this.$subCalendarEntryView.data("customEventTypeId");

                if(!eventTypeName) {
                    eventTypeName = CalUtil.isInternalSubscriptionSubCalendar(this.subCalendar) ? this.subCalendar.subscriptionType : this.subCalendar.type;
                }

                this.CalendarPlugin.showCustomEventEditForm(this._calendarDiv, this.parentSubCalendar, eventTypeName);

                event.preventDefault();
            },

            _onColorCellClick: function(event) {
                if (!this.CalendarPlugin.isProcessingSubCalendar(this._calendarDiv)) {
                    this.CalendarPlugin.setProcessingSubCalendar(this._calendarDiv, true);

                    var colourCell = $(event.target);


                    var childSubCalendarToUpdate = this.subCalendar;
                    var that = this;
                    setSubCalendarColour(
                            this.CalendarPlugin,
                            this._calendarDiv,
                            childSubCalendarToUpdate,
                            colourCell.data("colour"),
                            function (responseEntity) {
                                if (responseEntity.success) {
                                    that.cache.removeCalendar(childSubCalendarToUpdate.id);
                                    that.CalendarPlugin.setGenericErrors(that._calendarDiv, null, that.CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                                    that.CalendarPlugin.setSubCalendars(that._calendarDiv, responseEntity.payload);
                                    that.CalendarPlugin.removeSubCalendarEventSource(that._calendarDiv, childSubCalendarToUpdate.id);
                                    that.CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(that._calendarDiv);

                                    that.$subCalendarEntryView.removeClass().addClass("aui-dd-parent " + colourCell.data("colour"));

                                } else {
                                    // Ideally, we should allow the edit to go through, even if the user hasn't authenticated with JIRA,
                                    // but because it is an existing bug, and so far, no one has complained about it, it might not be
                                    // worth the effort.
                                    //
                                    // A warning like the below would prompt the user to do the right (tm) thing, and it does fix
                                    // https://jira.atlassian.com/browse/TEAMCAL-1537
                                    //
                                    that.CalendarPlugin.setGenericErrors(that._calendarDiv, "\u4e0d\u80fd\u4fee\u6539\u65e5\u7a0b\u7684\u989c\u8272\uff0c\u8bf7\u5148\u83b7\u5f97\u6388\u6743\u3002", that.CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                                }

                                setNotProcessingSubCalendar(that.CalendarPlugin, that._calendarDiv);
                            },
                            setNotProcessingSubCalendar(that.CalendarPlugin, that._calendarDiv)
                    );
                }

                event.preventDefault();
            },

            _onDisplayClick: function(event) {
                this.subcalendarDisplayer.toggleVisibility();
                event.preventDefault();
            }
        });

        // private methods
        var setSubCalendarWatch = function (CalendarPlugin, calendarDiv, subCalendar, watch, successCallback) {
            $.ajax({
                cache: false,
                data: {
                    subCalendarId: subCalendar.id
                },
                dataType: "json",
                error: function (XMLHttpRequest, textStatus, errorThrown) {
                    CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_WATCH + CalendarPlugin.getStringAsHex(subCalendar.id));
                },
                success: function () {
                    if (successCallback) {
                        successCallback();
                    }
                },
                type: watch ? "PUT" : "DELETE",
                timeout: CalendarPlugin.ajaxTimeout,
                url: CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/preferences/subcalendars/watch.json")
            });
        };

        var isSubCalendarOrAnyOfItsChildrenJiraSubCalendar = function(subCalendar) {
            return subCalendar && (
                    CalUtil.isJiraSubCalendar(subCalendar) ||
                    $.grep(subCalendar.childSubCalendars || [], function (childSubCalendar) {
                        return isSubCalendarOrAnyOfItsChildrenJiraSubCalendar(childSubCalendar);
                    }).length
                    );
        };

        var setSubCalendarReminderMe = function(CalendarPlugin, calendarDiv, subCalendar, subCalendarChildrenId, successCallback, isReminder) {
            $.ajax({
                cache: false,
                data: {
                    subCalendarId: subCalendarChildrenId,
                    isReminder: isReminder
                },
                dataType: "json",
                error: function(XMLHttpRequest, textStatus, errorThrown) {
                    CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_WATCH + CalendarPlugin.getStringAsHex(subCalendar.id));
                },
                success : function() {
                    if (successCallback) {
                        successCallback();
                    }
                },
                type: "PUT",
                timeout: CalendarPlugin.ajaxTimeout,
                url: CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/preferences/subcalendars/setreminder.json")
            });
        };

        var setNotProcessingSubCalendar = function(CalendarPlugin, calendarDiv) {
            CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
        };

        var setSubCalendarColour = function(CalendarPlugin, calendarDiv, subCalendar, colour, successCallback, errorCallback) {
            var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(true);

            $.ajax({
                cache: false,
                converters : {
                    "text json" : function(jsonObject) {
                        return jsonObject;
                    }
                },
                data : (function() {
                    var ajaxData = {
                        subCalendarId : subCalendar.id,
                        color: colour
                    };
                    if (CalendarPlugin.getParameter(calendarDiv, "include")) {
                        ajaxData.include = CalendarPlugin.getParameter(calendarDiv, "include");
                    }

                    CalUtil.putCalendarContextParams(ajaxData);

                    return ajaxData;
                })(),
                dataType : "json",
                dataFilter : function(data) {
                    var subCalendarsResponseEntity = $.parseJSON(data);
                    if (subCalendarsResponseEntity.success) {
                        CalendarPlugin.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                    }
                    return subCalendarsResponseEntity;
                },
                error: function(XMLHttpRequest, textStatus, errorThrown) {
                    CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);

                    if (errorCallback) {
                        errorCallback(XMLHttpRequest, textStatus, errorThrown);
                    }
                },
                success : function(responseEntity) {
                    if (successCallback) {
                        successCallback(responseEntity);
                    }

                },
                complete: function(){
                    if (spinnerDefer) spinnerDefer.resolve();
                },
                type : "PUT",
                timeout : CalendarPlugin.ajaxTimeout,
                url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/subcalendars/color.json")
            });
        };

        return SubCalendarMenuView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/child-subcalendar-entry-view.js' */
define("tc/child-subcalendar-entry-view",
    [
        "jquery",
        "tc-backbone",
        "tc/calendar-util",
        "tc/subcalendar-menu-view",
        "tc/subcalendar-displayer"
    ],
    function (
        $,
        Backbone,
        CalUtil,
        SubCalendarMenuView,
        SubCalendarDisplayer
    ) {

        "use strict";

        var ChildSubCalendarEntryView = Backbone.View.extend({
            initialize: function(options) {
                this.cache = options.cache;
                this.parentSubCalendar = options.parentSubCalendar;
                this.childSubCalendar = options.childSubCalendar;
                this.customEventType = options.customEventType;
                this.CalendarPlugin = options.CalendarPlugin;
                this._calendarDiv = options._calendarDiv;

                this.parentView = options.parentView;
                this.template = options.template;
            },

            events: {
                "hover .child-subcalendar": "_onHover",
                "click .child-subcalendar": "_onClick" // Encompasses entire lozenge including checkbox
            },

            render: function() {
                this.$el.html(this.template({
                    "childSubCalendar": this.childSubCalendar,
                    "customEventType": this.customEventType
                }));

                this.entryView = this.$(".child-subcalendar");

                var options = {
                    "cache": this.cache,
                    "CalendarPlugin": this.CalendarPlugin,
                    "_calendarDiv": this._calendarDiv,

                    "subCalendar": this.childSubCalendar,
                    "parentSubCalendar": this.parentSubCalendar,
                    "subCalendarEntryView": this.entryView,

                    "autoConvertSupported": this.CalendarPlugin.isAutoConvertSupported(this._calendarDiv),
                    "subCalendarClasses": this.CalendarPlugin.getParameter(this._calendarDiv, "subCalendarColorClass")
                };

                if (this.customEventType) {
                    options.template = Confluence.TeamCalendars.Templates.customEventTypeMenu;
                } else {
                    options.template = Confluence.TeamCalendars.Templates.childSubCalendarMenu;
                }

                this.entryView.append(new SubCalendarMenuView(options).render());

                this._ellipsisChildSubCalendarName();

                this.subcalendarDisplayer = new SubCalendarDisplayer({
                    CalendarPlugin: this.CalendarPlugin,
                    _calendarDiv: this._calendarDiv,
                    entryView: this.entryView,
                    subCalendar: this.childSubCalendar,
                    parentView: this.parentView,
                    parentSubCalendar: this.parentSubCalendar
                });

                return this.$el;
            },

            _ellipsisChildSubCalendarName: function () {
                var $childSubCalendarName = this.$(".child-subcalendar-name");
                if(!$childSubCalendarName.attr("threedots")) {
                    $childSubCalendarName.attr("title", this.$(".ellipsis_text").text());
                }
            },

            _onHover: function() {
                this.entryView.toggleClass("active-child-subcalendar");
            },

            _onClick: function() {
                this.subcalendarDisplayer.toggleVisibility();
            }
        });

        return ChildSubCalendarEntryView;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/subcalendar-menu-builder.js' */
define("tc/subcalendar-menu-builder",
    [
        "jquery",
        "underscore",
        "tc/calendar-util"

    ],
    function (
        $,
        _,
        CalUtil
    ) {

        var build = function(calendarDiv, CalendarPlugin, subCalendars) {
            //Things that are set per macro, and not per calendar
            var readOnly = CalendarPlugin.getParameter(calendarDiv, "readOnly") === "true",
                    notificationsEnabled = CalendarPlugin.getParameter(calendarDiv, "isNotificationsEnabled") === "true",
                    hideEditMenuItem = CalendarPlugin.getParameter(calendarDiv, "hideEditMenuItem") === "true",
                    hideRemoveMenuItem = CalendarPlugin.getParameter(calendarDiv, "hideRemoveMenuItem") === "true",
                    hideColourGrid = CalendarPlugin.getParameter(calendarDiv, "hideColorGrid") === "true",
                    userLogin = AJS.Meta.get("remote-user");

            function buildMenuOptions(subCalendar, isChildSubCalendar) {
                if (CalUtil.isSingleCalendarView(calendarDiv)) {
                    _buildSingleCalendarPageMenu(subCalendar, isChildSubCalendar);
                } else {
                    _buildCommonMenu(subCalendar, isChildSubCalendar);
                }
            }

            function _buildCommonMenu(subCalendar, isChildSubCalendar) {
                var isJiraSubCalendar = CalUtil.isJiraSubCalendar(subCalendar),
                        subscriptionSubCalendar = CalUtil.isSubscriptionSubCalendar(subCalendar);

                subCalendar.displayName = subCalendar.name;

                if (CalUtil.isSubscriptionSubCalendar(subCalendar) && !isChildSubCalendar) {
                    subCalendar.menuOptions = {showMenu: false};
                } else {
                    subCalendar.menuOptions = {
                        "showMenu": true,
                        "showAddEvent": !readOnly && !isJiraSubCalendar && subCalendar.eventsEditable,
                        "showWatch": !readOnly,
                        "showNotifications": notificationsEnabled && !isChildSubCalendar,
                        "showEdit": _isEditable(subCalendar) || (CalUtil.isSubscriptionSubCalendar(subCalendar) && subCalendar.administrable),
                        "showView": !hideEditMenuItem && !readOnly && !subCalendar.editable,
                        "showRestrictions": !readOnly && subCalendar.administrable && !isJiraSubCalendar,
                        "showRemove": !hideRemoveMenuItem && !readOnly && subCalendar.editable && ((!isChildSubCalendar || CalUtil.isSubscriptionSubCalendar(subCalendar)) ? true : subCalendar.eventsEditable),
                        "showShareAndSubscribe": subCalendar.eventsViewable && !isJiraSubCalendar,
                        "showSubscribe": !isJiraSubCalendar,
                        "showColourGrid": !hideColourGrid && (subscriptionSubCalendar || isJiraSubCalendar) && userLogin.length > 0,
                        "showReload": subCalendar.reloadable,
                        "showDisplayLink": true
                    };
                }
            }

            function _buildSingleCalendarPageMenu(subCalendar, isChildSubCalendar) {
                _buildCommonMenu(subCalendar, isChildSubCalendar);
                var menuOptions = subCalendar.menuOptions;

                menuOptions.showEdit = false;
                menuOptions.showRemove = false;
                if (CalUtil.isJiraSubCalendar(subCalendar)) {
                    menuOptions.showEdit = true;
                    menuOptions.showRemove = true;
                }
                menuOptions.showRestrictions = false;
                menuOptions.showDisplayLink = false;

                subCalendar.menuOptions = menuOptions;
            }

            function _isEditable(subCalendar) {
                return !readOnly && subCalendar.editable && subCalendar.eventsEditable;
            }

            function _hasReminderSetting(subCalendar, childrenSubCalendar) {
                var eventType = childrenSubCalendar.subscriptionType || childrenSubCalendar.type;
                if (CalUtil.isEventTypeSanbox(eventType) || CalUtil.isJiraType(eventType)) {
                    var period = CalUtil.getPeriodReminderEventTypeSanboxOrJira(subCalendar, eventType);
                    return period !== undefined && period > 0;
                } else if (CalUtil.isCustomEventType(eventType)) {
                    return childrenSubCalendar.customEventTypes[0].periodInMins > 0;
                }
            }

            _.each(subCalendars, function (subCalendar) {
                //Set menu options for parent calendar
                buildMenuOptions(subCalendar, false);

                if (subCalendar.childSubCalendars) {
                    _.each(subCalendar.childSubCalendars, function (childSubCalendar) {

                        var typeNameKey = childSubCalendar.typeKey;
                        var typeName = CalendarPlugin.getEventTypeNames(typeNameKey);
                        if (CalUtil.isSubscriptionSubCalendar(childSubCalendar)) {
                            buildMenuOptions(childSubCalendar, true);

                            childSubCalendar.menuOptions = $.extend(childSubCalendar.menuOptions, {
                                "showDisplayLink": false
                            });
                        } else if (CalUtil.isJiraSubCalendar(childSubCalendar)) {
                            buildMenuOptions(childSubCalendar, true);

                            childSubCalendar.menuOptions = $.extend(childSubCalendar.menuOptions, {
                                "showReminder": userLogin.length > 0 && _hasReminderSetting(subCalendar, childSubCalendar),
                                "showSettingReminder": userLogin.length > 0 && !_hasReminderSetting(subCalendar, childSubCalendar) && _isEditable(subCalendar),
                                "showDisplayLink": false
                            });
                        } else {
                            //Simple case for uninteresting child calendars
                            childSubCalendar.menuOptions = {
                                "showMenu": true,
                                "showColourGrid": userLogin.length > 0,
                                "showReload": true,
                                "showReminder": userLogin.length > 0 && _hasReminderSetting(subCalendar, childSubCalendar),
                                "showSettingReminder": userLogin.length > 0 && !_hasReminderSetting(subCalendar, childSubCalendar) && _isEditable(subCalendar)
                            };
                            childSubCalendar.displayName = typeName;
                        }

                    });
                }
            });
        };

        return {
            build: build
        };
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:subcalendar-panel', location = 'com/atlassian/confluence/extra/calendar3/components/subcalendar-panel/subcalendar-displayer.js' */
define("tc/subcalendar-displayer",
    [
        "jquery",
        "underscore",
        "tc/calendar-util"
    ],
    function (
        $,
        _,
        CalUtil
    ) {
        "use strict";

        var SubCalendarDisplayer = function(options) {

            var CalendarPlugin = options.CalendarPlugin,
                calendarDiv = options._calendarDiv,
                entryView = options.entryView,
                subCalendar = options.subCalendar,
                // for parent entry
                childSubCalendarIds = options.childSubCalendarIds,
                childSubCalendarViews = options.childSubCalendarViews,
                // for child entry
                parentView = options.parentView,
                parentSubCalendar = options.parentSubCalendar;

            var displayCalendar = function() {
                var subCalendarIds;
                var isChildEntryView = entryView.hasClass("child-subcalendar");

                if (isChildEntryView) {
                    subCalendarIds = [subCalendar.id];
                } else {
                    subCalendarIds = _.clone(childSubCalendarIds);
                }

                var isEventsHidden = !entryView.hasClass("subcalendar-disabled");

                entryView.toggleClass("subcalendar-disabled", isEventsHidden);

                // toggle all child entries if this is parent entry
                if (!isChildEntryView) {
                    entryView.toggleClass("allchildsubcalendar-disabled", isEventsHidden);

                    _.each(childSubCalendarViews, _.bind(function ($view) {
                        $view.toggleClass("subcalendar-disabled", isEventsHidden);
                        $view.find(".child-subcalendar-checkbox").prop("checked", !isEventsHidden);
                    }, this));
                }
                else {
                    entryView.find(".child-subcalendar-checkbox").prop("checked", !isEventsHidden);
                }

                if (!CalUtil.isDummySubscriptionParentSubCalendar(isChildEntryView ? parentSubCalendar : subCalendar)) {
                    subCalendarIds.push(subCalendar.id);
                }

                if(!CalUtil.isSingleCalendarView(calendarDiv)) {
                    CalendarPlugin.setSubCalendarEventsHidden(calendarDiv, subCalendarIds, isEventsHidden, parentView);
                }

                if (isEventsHidden) {
                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendarIds);
                } else {
                    CalendarPlugin.addSubCalendarEventSource(calendarDiv, subCalendarIds);
                }

                var analyticsEvent = "";
                if(isChildEntryView){
                    if(isEventsHidden){
                        analyticsEvent = "hide.event.click.";
                    } else {
                        analyticsEvent = "show.event.click.";
                    }
                } else {
                    if(isEventsHidden){
                        analyticsEvent = "hide.calendar.click.";
                    } else {
                        analyticsEvent = "show.calendar.click.";
                    }
                }

                if(CalUtil.isSingleCalendarView(calendarDiv)){
                    analyticsEvent += "singleCalendar";
                } else {
                    analyticsEvent += Confluence.TeamCalendars.getCalendarContext();
                }

                Confluence.TeamCalendars.fireEventForAnalytics(analyticsEvent);
            };

            return {
                toggleVisibility: function() {
                    displayCalendar();
                }
            }
        };

        return SubCalendarDisplayer;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendars-in-space', location = 'com/atlassian/confluence/extra/calendar3/components/calendars-in-space/calendar-navigation-buttons-view.js' */
define("tc/subcalendar-navigation-buttons-view",
    [
        "jquery",
        "underscore",
        "tc/calendar-util",
        "tc/util",
        "tc/calendar-add-inline-dialog",
        "tc-backbone"
    ],
    function (
        $,
        _,
        CalUtil,
        Util,
        CalendarAddInlineDialogView,
        Backbone
    ) {

        var CalendarNavigationButtonsView = Backbone.View.extend({
            events: {
                "click .edit-calendar-button, #editCalendarLink" : "_onEditButtonClick",
                "click .add-calendar-button" : "_onAddButtonClick"
            },

            initialize: function(options) {
                this._calendarDiv = options._calendarDiv;
                this.CalendarPlugin = options.CalendarPlugin;

                AJS.bind("calendar.loaded", _.bind(this._onCalendarLoaded, this));
                AJS.bind("calendar.removed", _.bind(this._onCalendarRemoved, this));
                AJS.bind("calendar.watch.statuses.loaded", _.bind(this._onWatchStatusLoaded, this));

                this.inlineAddCalendarDialog = new CalendarAddInlineDialogView({callbackHandler: this.CalendarPlugin.getRenderedMacroCallbackHandler(this._calendarDiv)});

            },

            render: function() {
                // share button
                this._initShareButton();

                if (CalUtil.isSpaceCalendarView(this._calendarDiv)) {
                    // add calendar button
                    var hasCalendar = !$(".no-calendar-page").is(":visible");
                    this.$(".add-calendar-button").toggleClass("hidden", !hasCalendar);
                    this.$(".add-calendar-button-more").toggleClass("hidden", !hasCalendar);

                } else if(CalUtil.isSingleCalendarView(this._calendarDiv)) {
                    // edit button
                    if(this.subCalendar) {
                        var editable = this.CalendarPlugin.getParameter(this._calendarDiv, "readOnly") !== "true" && this.subCalendar.editable && this.subCalendar.eventsEditable;
                        this.$(".edit-calendar-button").toggleClass("hidden", !editable);
                    }
                }

                this.inlineAddCalendarDialog.render();
            },

            _initShareButton: function() {
                var hasCalendar = !$(".no-calendar-page").is(":visible");
                var enableShareCalendar = CalUtil.getParameter(this._calendarDiv, "enableShareCalendar");

                // should not show share when users do not have permission to view calendar
                var hasViewPermission = true;
                if(this.subCalendar) {
                    hasViewPermission = this.subCalendar.eventsViewable;
                }

                this.$(".share-calendar-button").toggleClass("hidden", !hasCalendar || !enableShareCalendar || !hasViewPermission);

                if (AJS.Confluence.SharePage && !this.shareDialogLoaded) {
                    AJS.Confluence.SharePage.initDialog($(".share-calendar-button"), "shareContentPopup", {offsetX: -110});
                    this.shareDialogLoaded = true;

                    var context = "spaceCalendars";
                    if(CalUtil.isSingleCalendarView(this._calendarDiv)){
                        context ="singleCalendar";
                    }
                    $(".share-calendar-button").click(function(event){
                        Confluence.TeamCalendars.fireEventForAnalytics("share.calendar.click." + context);
                    });
                }
            },

            _onEditButtonClick: function(event) {
                this.CalendarPlugin.showSubCalendarEdit(this._calendarDiv, this.subCalendar);
                //process behaviour when event type panel active
                $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");

                event.preventDefault();

                return false;
            },

            _onCalendarLoaded: function(event, subCalendar) {
                // show/hide edit button in when calendar loaded in single view
                if(CalUtil.isSingleCalendarView(this._calendarDiv)) {
                    this.subCalendar = subCalendar;
                }

                var contentId = this.CalendarPlugin.getParameter(this._calendarDiv, "contentId");
                AJS.params.pageId = contentId ? contentId : AJS.params.pageId;

                this.render();
            },

            _onCalendarRemoved: function() {
                this.render();
            },

            _onWatchStatusLoaded: function(event, watchStatues) {
                //TODO: showing watch status of calendar
            },

            _onAddButtonClick: function(event) {
                Confluence.TeamCalendars.fireEventForAnalytics("add.calendar.click.new." + Confluence.TeamCalendars.getCalendarContext());
                var subCalendarDialog = Confluence.TeamCalendars.Dialogs.getSubCalendarCreateDialog("parent", this.CalendarPlugin.getRenderedMacroCallbackHandler(this._calendarDiv));
                Util.showDialogInUpdatedHeight(subCalendarDialog);
                $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();
                $("#inline-dialog-inline-dialog-more").hide();

                event.preventDefault();

                return false;
            }
        });

        return CalendarNavigationButtonsView;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendars-in-space', location = 'com/atlassian/confluence/extra/calendar3/components/calendars-in-space/calendar-restriction-button-view.js' */
define("tc/subcalendar-restriction-button-view",
    [
        "jquery",
        "underscore",
        "tc/calendar-util"

    ],
    function (
        $,
        _,
        CalUtil
    ) {

        var CalendarRestrictionButtonsView = Backbone.View.extend({
            events: {
                "click .restrict-calendar-button" : "_onRestrictionClick"
            },

            initialize: function(options) {
                this._calendarDiv = options._calendarDiv;
                this.CalendarPlugin = options.CalendarPlugin;

                AJS.bind("calendar.loaded", _.bind(this._onCalendarLoaded, this));
            },

            render: function() {
                var hasRestriction = CalUtil.hasRestriction(this.subCalendar);

                this.$(".restrict-calendar-button.restricted").toggleClass("hidden", !hasRestriction);
                this.$(".restrict-calendar-button.no-restricted").toggleClass("hidden", hasRestriction);
            },

            _onRestrictionClick: function() {
                if(this.CalendarPlugin.getParameter(this._calendarDiv, "readOnly") !== "true" && this.subCalendar.administrable && !CalUtil.isJiraSubCalendar(this.subCalendar)) {
                    this.CalendarPlugin.getSubCalendarRestrictionsDialog(this._calendarDiv, this.subCalendar);
                }

                event.preventDefault();
            },

            _onCalendarLoaded: function(event, subCalendar) {
                if(CalUtil.isSingleCalendarView(this._calendarDiv)) {
                    this.subCalendar = subCalendar;
                    this.render();
                }
            }

        });

        return CalendarRestrictionButtonsView;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:internal-subscription-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/internal-subscription-subcalendar/internal-subscription-subcalendar.js' */
define("tc/internal-subscription-subcalendar",
    [
        "jquery",
        "tc/templates",
        "tc/calendar-util"
    ],
    function (
        $,
        Templates,
        CalUtil
    )
    {
        "use strict";
        var InternalSubscription = Backbone.View.extend({
            getDialog : function(editDialog, subCalendar, callbackHandler) {
                var helper;
                var editForm;
                var populateForm = function(helper, editForm) {
                    helper.resetFieldErrors();

                    if (helper.isNewCalendar()) {
                        helper.setFormModeCreate();
                        helper.setHeading("\u65b0\u65e5\u7a0b\u8868", editDialog);
                        helper.setSubCalendarIdField("");
                        helper.setSubscriptionIdField("");
                        helper.setNameField("");
                        helper.setDescriptionField("");
                        helper.setColorField(callbackHandler.getNextCalendarColor());
                        helper.setSpaceToDefault();
                        helper.setTimeZoneIdDisplayField("");
                    } else {
                        helper.setFormModeEdit();
                        helper.setHeading(subCalendar.name, editDialog);
                        helper.setSubCalendarIdField(subCalendar.id);
                        helper.setSubscriptionIdField(subCalendar.subscriptionId || "");
                        helper.setNameField(subCalendar.name);
                        helper.setDescriptionField(subCalendar.description);
                        helper.setColorField(subCalendar.color);
                        helper.setSpaceKeyField(subCalendar.spaceKey);
                        helper.setSpaceKeyAutocompleteField(subCalendar.spaceName);
                        helper.setTimeZoneIdDisplayField(subCalendar.timeZoneId);

                        if (!(subCalendar.restrictable && subCalendar.administrable)) {
                            $(".field-group-permissions", editForm).remove();
                        }
                    }

                    var textInputs = $("textarea[name='description'], input[name='spaceKeyAutocomplete']", editForm);
                    if (callbackHandler.isCalendarInEditMode()) {
                        textInputs.removeAttr("readonly");
                    } else {
                        helper.setFormModeReadOnly();
                        textInputs.attr("readonly", "readonly");
                    }

                    // hidden space field when create TC on space
                    if(helper.isNewCalendar() && AJS.Meta.get("space-key")) {
                        var spaceDiv = $(".field-group-space-permission", editForm);
                        spaceDiv.addClass("hidden");
                    }
                };

                return {
                    initializeForm: function(callBackCancel) {
                        editDialog.addHeader("\u65b0\u65e5\u7a0b\u8868");
                        editDialog.addPanel("\u901a\u7528", Templates.editInternalSubcalendar(), "calendar-dialog-panel");

                        editForm = $("form.sub-calendar-edit-form", editDialog.getCurrentPanel().body);
                        helper = Confluence.TeamCalendars.getEditCalendarDialogHelper(editForm, subCalendar, callbackHandler);

                        helper.initSpaceDropDown();
                        helper.initOkButton("\u786e\u5b9a", editDialog);
                        helper.initCloseButton(editDialog, callBackCancel);
                        populateForm(helper, editForm);

                        return editForm;
                    },

                    getFormDataAsAjaxData : function() {
                        var data = {
                            type : "internal-subscription",
                            subCalendarId : $("input[name='subCalendarId']", editForm).val(),
                            name : $("input[name='name']", editForm).val(),
                            description : $("textarea[name='description']", editForm).val(),
                            color : $("input[name='color']", editForm).val(),
                            spaceKey : $("input[name='spaceKeyAutocomplete']", editForm).val() ? $("input[name='spaceKey']", editForm).val() : "",
                            location: "subscription://" + $("input[name='subscriptionId']", editForm).val()
                        };

                        CalUtil.putCalendarContextParams(data);

                        return data;
                    },

                    onSubmitStart : function() {
                        helper.disableOkButton("\u6b63\u5728\u6dfb\u52a0...");
                    },

                    onSubmitEnd : function() {
                        helper.enableOkButton("\u786e\u5b9a");
                    }
                };
            },
            weight : 1000,
            typeName : "\u672a\u77e5\u7c7b\u578b"
        });

        return InternalSubscription;
    }

);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:internal-subscription-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/internal-subscription-subcalendar/internal-subscription-subcalendar.soy' */
// This file was automatically generated from internal-subscription-subcalendar.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.editInternalSubcalendar = function(opt_data, opt_ignored) {
  return '<form name="editSubCalendarForm" class="sub-calendar-edit-form aui" method="POST" action="#"><input type="hidden" name="subCalendarId" value=""><input type="hidden" name="type" value="internal-subscription"><input type="hidden" name="color" value=""><input type="hidden" name="subscriptionId" value=""><input type="hidden" name="spaceKey" value=""><div class="form-mode create"><div class="subcalendar-type subcalendar-interal-subscription"><div class="field-group field-group-name"><label for="name">' + soy.$$escapeHtml('\u540d\u79f0') + '<span class="aui-icon icon-required"></span></label><input name="name" id="name" type="text" class="text" value="" autocomplete="off"><div class="error name-error"></div></div><div class="field-group field-group-description"><label for="description">' + soy.$$escapeHtml('\u63cf\u8ff0') + '</label><textarea name="description" id="description" rows="5" class="textarea"></textarea></div><div class="field-group field-group-space-permission"><label for="spaceKeyAutocomplete">' + soy.$$escapeHtml('\u76f8\u5173\u7a7a\u95f4') + '<span class="aui-icon icon-required"></span></label><input name="spaceKeyAutocomplete" id="spaceKeyAutocomplete" type="text" class="autocomplete-space text" data-max="5" data-none-message="' + soy.$$escapeHtml('\u672a\u53d1\u73b0\u7a7a\u95f2\u65f6\u95f4') + '"><div class="description">' + soy.$$escapeHtml('\u5c06\u65e5\u7a0b\u94fe\u63a5\u81f3\u7a7a\u95f4\uff0c\u4ee5\u4fbf\u4e8e\u67e5\u627e\u3002') + '</div><div class="error spaceKeyAutocomplete-error"></div></div><div class="field-group field-group-timezone-display"><label>' + soy.$$escapeHtml('\u65f6\u533a') + '</label><span class="timeZoneIdDisplay field-value"></span></div></div></div></form>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.editInternalSubcalendar.soyTemplateName = 'Confluence.TeamCalendars.Templates.editInternalSubcalendar';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:internal-subscription-subcalendar', location = 'com/atlassian/confluence/extra/calendar3/components/internal-subscription-subcalendar/internal-subscription-subcalendar-compact.js' */
//This is here to make the existing API work.
require(["tc/internal-subscription-subcalendar"], function (InternalSubscription) {

    "use strict";
    if (!window.Confluence.TeamCalendars.subcalendar) {
        window.Confluence.TeamCalendars.subcalendar = {};
    }

    if (!window.Confluence.TeamCalendars.subcalendar["internal-subscription"]) {
        window.Confluence.TeamCalendars.subcalendar["internal-subscription"] = new InternalSubscription({});
    }

});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:infinite-list', location = 'com/atlassian/confluence/extra/calendar3/components/infinite-list/infinitelist.js' */
define("tc/infinite-list",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "exports"
    ],
    function (
        $,
        _,
        Backbone,
        exports
    ) {
        /**
         * Infinite scroll thingie. Loads more popular subscription when you scroll down in dialog.
         *
         */
        function ScrollLoader(options) {

            var $list = options.$el;
            var loadDataFunction = options.load;
            var $container = options.$container || $(window);
            var body = options.body || document.body;
            var scrollMargin = options.scrollMargin || 300;
            var isLoadMoreItems = options.isLoadMoreItems || false;

            var pageSize = $list.data("page-size");
            var startIndex = 1; // we start loading items at the page size offset

            function loadMoreItems() {
                loadDataFunction(startIndex, pageSize);
                startIndex += 1;
            }

            /**
             * Load items when we are almost scrolled to the bottom of a page and there are possibly more items
             * on the server to load (when we initially already display pageSize items).
             */
            function loadItemsMaybe() {
                var possiblyMoreItemsToLoad = isLoadMoreItems == true ? isLoadMoreItems : $list.children().length >= pageSize;
                var scrolledToTheBottom = body.scrollHeight - $container.scrollTop() - scrollMargin  <= $container.height();
                if (possiblyMoreItemsToLoad && scrolledToTheBottom) {
                    loadMoreItems();
                }
            }

            $container.bind("scroll.list", _.debounce(loadItemsMaybe, 100));
            loadItemsMaybe();

            this.destroy = function() {
                $container.off("scroll.list");
            };
        }

        // mixin events
        _.extend(ScrollLoader.prototype, Backbone.Events);

        exports.init = function(options) {
            return new ScrollLoader(options);
        };
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:non-space-calendars-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/non-space-calendars-dialog/non-space-calendar-entry-view.js' */
define("tc/non-space-calendar-entry-view",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "ajs",
        "tc/calendar-util"
    ],
    function (
        $,
        _,
        Backbone,
        AJS,
        CalUtil
    ) {

        "use strict";

        var NonSpaceCalendarEntryView = Backbone.View.extend({

            initialize: function (options) {
                this.template = Confluence.TeamCalendars.Templates.nonSpaceCalendarEntry;
                this.subCalendar = options.subCalendar;

                this.CalendarPlugin = options.CalendarPlugin;
                this._calendarDiv = options._calendarDiv;
                this.cache = options.cache;
            },

            render: function () {
                this.$el.html(this.template({subCalendar: this.subCalendar}));

                this.spaceKeyAutocompleteField = this.$("input.autocomplete-space");
                this.spaceKeyField = this.$("input.space-key");

                this.spaceKeyAutocompleteField.keypress(_.bind(function (e) {
                    if (e.which !== 13) {
                        this.spaceKeyField.val(e.which);
                    }
                }, this));

                this.spaceKeyAutocompleteField.bind("selected.autocomplete-content", _.bind(function (e, selection) {
                    this.spaceKeyField.val(selection.content.key);
                    this.spaceKeyAutocompleteField.val(selection.content.name);
                }, this));

                this.successIcon = this.$(".success-icon");
                this.errorIcon = this.$(".error-icon");
                this.spinnerIcon = this.$(".spinner");
                this.errorMessageDiv = this.$(".error-message");

                return this.$el;
            },

            getData: function () {
                return {
                    calendarId: this.subCalendar.id,
                    spaceKey: this.spaceKeyField.val()
                }
            },

            isUpdateSuccessfully: function () {
                return this.spaceKeyAutocompleteField.attr("updated") === "true";
            },

            updateSubCalendar: function () {
                if (this.isUpdateSuccessfully()) {
                    return;
                }

                var data = this.getData();
                if (!data.spaceKey) {
                    return;
                }

                this.spinnerIcon.show();

                return $.ajax({
                    cache: false,
                    data: JSON.stringify(data),
                    contentType: "application/json",

                    dataFilter: function (data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success) {
                            CalUtil.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        }
                        return subCalendarsResponseEntity;
                    },

                    dataType: "json",

                    converters: {
                        "text json": function (jsonObject) {
                            return jsonObject;
                        }
                    },

                    error: _.bind(function (XMLHttpRequest, textStatus, errorThrown) {
                        var errorMessage = JSON.parse(XMLHttpRequest.responseText)[0] || "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002";
                        this._showResult(false, errorMessage);

                        CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.one.calendar.failed");
                    }, this),

                    success: _.bind(function (responseEntity) {
                        if (responseEntity.success) {

                            this._showResult(true, "");
                            this._hide();

                            this.CalendarPlugin.setSubCalendar(data.calendarId, this._calendarDiv, responseEntity.payload);

                            CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.one.calendar.successful");
                        } else {
                            var errorMessage = (responseEntity.fieldErrors && responseEntity.fieldErrors.length) ?
                                    responseEntity.fieldErrors[0].errorMessages[0] : "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002";

                            this._showResult(false, errorMessage);

                            CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.one.calendar.failed");
                        }
                    }, this),

                    type: "POST",
                    timeout: CalUtil.ajaxTimeout,
                    url: Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendar/space")
                });
            },

            _hide: function () {
                this.$el.animate({
                    "height": 0,
                    "opacity": 0
                }, 500, function () {
                    $(this).remove();
                });
            },

            _showResult: function (success, errorMessage) {
                this.spinnerIcon.hide();

                this.successIcon.toggleClass("hidden", !success);
                this.errorIcon.toggleClass("hidden", success);
                this.errorMessageDiv.toggleClass("hidden", success);


                if (success) {
                    this.spaceKeyAutocompleteField.prop("disabled", true);
                    this.spaceKeyAutocompleteField.attr("updated", "true");
                }

                if (errorMessage) {
                    this.errorMessageDiv.text(errorMessage);
                }
            }
        });

        return NonSpaceCalendarEntryView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:non-space-calendars-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/non-space-calendars-dialog/non-space-calendars-dialog-view.js' */
define("tc/non-space-calendars-dialog-view",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "ajs",
        "tc/calendar-util",
        "tc/non-space-calendar-entry-view"
    ],
    function (
        $,
        _,
        Backbone,
        AJS,
        CalUtil,
        NonSpaceCalendarEntryView
    ) {

        "use strict";

        var dialog;

        var NonSpaceCalendarsDialogView = Backbone.View.extend({

            events: {},

            initialize: function (options) {
                this.subCalendars = options.subCalendars;
                this.nonSpaceCalendarEntryViews = [];

                this.CalendarPlugin = options.CalendarPlugin;
                this._calendarDiv = options._calendarDiv;
                this.cache = options.cache;
            },

            setSubCalendars: function (subCalendars) {
                this.subCalendars = subCalendars;
            },

            render: function () {
                if (!dialog) {
                    dialog = this.dialog = new AJS.Dialog(600, 600, "non-space-calendars-dialog");

                    var title = "\u60a8\u7684\u65e5\u5386\u9700\u8981\u4e00\u4e2a\u76f8\u5173\u7684\u7a7a\u95f4";
                    dialog.addHeader(title);

                    dialog.addPanel(
                            title,
                            Confluence.TeamCalendars.Templates.nonSpaceCalendarsDialog(),
                            "non-space-calendars-panel"
                    );

                    dialog.addSubmit("\u4fdd\u5b58", _.bind(this._onSubmit, this));

                    dialog.addCancel("\u4e0d\u662f\u73b0\u5728", _.bind(this._onCancel, this));

                    this.setElement(dialog.getCurPanel().body);
                }

                this._renderNonSpaceCalendarEntries();

                dialog.show();
            },

            _renderNonSpaceCalendarEntries: function () {
                this.nonSpaceCalendarEntryViews = [];
                this.$(".non-space-calendars-list").empty();

                _.each(this.subCalendars, _.bind(function (subCalendar) {
                    var nonSpaceCalendarEntryView = new NonSpaceCalendarEntryView({
                        subCalendar: subCalendar,
                        CalendarPlugin: this.CalendarPlugin,
                        _calendarDiv: this._calendarDiv,
                        cache: this.cache
                    });

                    this.nonSpaceCalendarEntryViews.push(nonSpaceCalendarEntryView);
                    this.$(".non-space-calendars-list").append(nonSpaceCalendarEntryView.render());

                }, this));
            },

            _onSubmit: function () {
                var defers = [];

                _.each(this.nonSpaceCalendarEntryViews, function (view) {
                    var defer = view.updateSubCalendar("onSubmit");
                    if (defer !== undefined) {
                        defers.push(defer);
                    }
                });

                // wait for all update tasks to be completed then close dialog if all task are successful
                $.when.apply($, defers).done(_.bind(function () {
                    var allDone = true;
                    _.each(this.nonSpaceCalendarEntryViews, function (view) {
                        if (!view.isUpdateSuccessfully()) {
                            allDone = false;
                        }
                    });

                    if (allDone) {
                        this.CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(this._calendarDiv);
                        dialog.hide();

                        CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.all.calendars.successful");
                    }
                }, this));

                CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.dialog.submit.click");

                return false;
            },

            _onCancel: function () {
                var isChanged = false;

                _.each(this.nonSpaceCalendarEntryViews, function (view) {
                    if (view.isUpdateSuccessfully()) {
                        isChanged = true;
                    }
                });

                if (isChanged) {
                    this.CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(this._calendarDiv);
                }

                dialog.hide();

                CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.dialog.cancel.click");

                return false;
            }

        });

        return NonSpaceCalendarsDialogView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:non-space-calendars-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/non-space-calendars-dialog/non-space-calendars-handler.js' */
define("tc/non-space-calendars-handler",
    [
        "jquery",
        "underscore",
        "tc/calendar-util",
        "tc/non-space-calendars-warning-view"
    ],
    function (
        $,
        _,
        CalUtil,
        NonSpaceCalendarsWarningView
    ) {

        "use strict";

        var warningView;

        return {
            handle: function (CalendarPlugin, calendarDiv, cache, subCalendars) {
                // only show non-space message in my calendar view
                if (CalUtil.isMyCalendarView(calendarDiv)) {
                    var nonSpaceSubCalendars = _.filter(subCalendars, function (subCalendar) {
                        return subCalendar.eventsEditable && (subCalendar.spaceKey === undefined || subCalendar.spaceKey === "");
                    });

                    if (!warningView) {
                        warningView = new NonSpaceCalendarsWarningView({
                            el: ".non-space-calendars-warning",
                            CalendarPlugin: CalendarPlugin,
                            _calendarDiv: calendarDiv,
                            cache: cache
                        });
                    }

                    warningView.render(nonSpaceSubCalendars);
                }
            }
        };
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:non-space-calendars-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/non-space-calendars-dialog/non-space-calendars-warning-view.js' */
define("tc/non-space-calendars-warning-view",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "ajs",
        "tc/calendar-util",
        "tc/non-space-calendars-dialog-view"
    ],
    function (
        $,
        _,
        Backbone,
        AJS,
        CalUtil,
        NonSpaceCalendarsDialogView
    ) {

        "use strict";

        var NonSpaceCalendarsWarningView = Backbone.View.extend({
            events: {
                "click .fix-calendars-link": "_onFixCalendarLinkClick"
            },

            initialize: function (options) {
                this.CalendarPlugin = options.CalendarPlugin;
                this._calendarDiv = options._calendarDiv;
                this.cache = options.cache;
            },

            render: function (nonSpaceCalendars) {

                this.nonSpaceCalendars = nonSpaceCalendars;
                this.$(".title strong").text(AJS.format("\u8fd9\u4e9b\u65e5\u5386\u4e2d\u6709 {0} \u4e2a\u9700\u8981\u5173\u8054\u7a7a\u95f4\u3002", this.nonSpaceCalendars.length));

                if (this.nonSpaceCalendars && this.nonSpaceCalendars.length > 0) {
                    this.show();
                } else {
                    this.hide();
                }
            },

            show: function () {
                this.$el.removeClass("hidden");
            },

            hide: function () {
                this.$el.addClass("hidden");
            },

            _onFixCalendarLinkClick: function () {
                if (!this.nonSpaceCalendarsDialogView) {
                    this.nonSpaceCalendarsDialogView = new NonSpaceCalendarsDialogView({
                        subCalendars: this.nonSpaceCalendars,
                        CalendarPlugin: this.CalendarPlugin,
                        _calendarDiv: this._calendarDiv,
                        cache: this.cache
                    });
                }

                this.nonSpaceCalendarsDialogView.setSubCalendars(this.nonSpaceCalendars);
                this.nonSpaceCalendarsDialogView.render();

                CalUtil.fireEventForAnalytics("non.space.calendars.upgrade.link.click");

                return false;
            }
        });

        return NonSpaceCalendarsWarningView;
    }
);
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:non-space-calendars-dialog', location = 'com/atlassian/confluence/extra/calendar3/components/non-space-calendars-dialog/non-space-calendars-dialog.soy' */
// This file was automatically generated from non-space-calendars-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.nonSpaceCalendarsDialog = function(opt_data, opt_ignored) {
  return '<div class="non-space-calendars-dialog"><div class="info"><span><b>' + soy.$$escapeHtml('\u4e3a\u6b64\u7c7b\u65e5\u5386\u8bbe\u7f6e\u4e00\u4e2a\u76f8\u5173\u7684\u7a7a\u95f4\uff0c\u4ee5\u5b9e\u73b0\u4fbf\u6377\u64cd\u4f5c\uff1a') + '</b></span><ul><li><b>' + soy.$$escapeHtml('\u53d1\u73b0') + '</b> \u2013 ' + soy.$$escapeHtml('\u56e2\u961f\u6216\u9879\u76ee\u7a7a\u95f4\u7684\u5de5\u4f5c\u65e5\u5386') + '</li><li><b>' + soy.$$escapeHtml('\u67e5\u770b') + '</b> \u2013 ' + soy.$$escapeHtml('\u5f53\u60a8\u5173\u6ce8\u4e00\u4e2a\u7a7a\u95f4\u65f6\uff0c\u60a8\u4f1a\u81ea\u52a8\u5173\u6ce8\u5b83\u7684\u65e5\u7a0b\u8868') + '</li><li><b>' + soy.$$escapeHtml('\u7ba1\u7406') + '</b> \u2013 ' + soy.$$escapeHtml('\u4ec5\u6709\u7a7a\u95f4\u6388\u6743\u4eba\u5458\u53ef\u67e5\u770b\u65e5\u5386') + '</li><li><b>' + soy.$$escapeHtml('\u5206\u4eab') + '</b> \u2013 ' + soy.$$escapeHtml('\u4f7f\u7528 Confluence \u9875\u9762\uff0c\u968f\u610f\u5206\u4eab\u7a7a\u95f4\u65e5\u5386') + '</li></ul></div><div class="separator"></div><form class="aui non-space-calendars-form"><div class="header"><div class="col1"><b>' + soy.$$escapeHtml('\u65e5\u7a0b\u8868') + '</b></div><div class="col2"><b>' + soy.$$escapeHtml('\u76f8\u5173\u7a7a\u95f4') + '</b></div></div><div class="non-space-calendars-list"></div></form></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.nonSpaceCalendarsDialog.soyTemplateName = 'Confluence.TeamCalendars.Templates.nonSpaceCalendarsDialog';
}


Confluence.TeamCalendars.Templates.nonSpaceCalendarEntry = function(opt_data, opt_ignored) {
  return '<div class="field-group field-group-' + soy.$$escapeHtml(opt_data.subCalendar.id) + '"><label for="spaceKeyAutocomplete-' + soy.$$escapeHtml(opt_data.subCalendar.id) + '">' + soy.$$escapeHtml(opt_data.subCalendar.name) + '</label><input name="spaceKeyAutocomplete-' + soy.$$escapeHtml(opt_data.subCalendar.id) + '" type="text" class="autocomplete-space text" data-max="5" placeholder="' + soy.$$escapeHtml('\u8f93\u5165\u7a7a\u95f4\u540d\u79f0') + '" data-none-message="' + soy.$$escapeHtml('\u672a\u53d1\u73b0\u7a7a\u95f2\u65f6\u95f4') + '" data-template="{key}" data-dropdown-target=".field-group-' + soy.$$escapeHtml(opt_data.subCalendar.id) + ' .dropdown"><div class="status-icon"><div class="spinner invisible aui-icon aui-icon-wait hidden"></div><span class="aui-icon aui-icon-error error-icon hidden"></span><span class="success aui-icon aui-icon-success success-icon hidden"></span></div><div class="spaceKeyAutocomplete-error error-message"></div><div class="dropdown"></div><input name="spaceKey-' + soy.$$escapeHtml(opt_data.subCalendar.id) + '" type="hidden" class="space-key"></input></div>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.nonSpaceCalendarEntry.soyTemplateName = 'Confluence.TeamCalendars.Templates.nonSpaceCalendarEntry';
}

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:event-type-icons', location = 'com/atlassian/confluence/extra/calendar3/templates/soy/icons.soy' */
// This file was automatically generated from icons.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Confluence.TeamCalendars.Templates.
 * @modName {EventIcons}
 * @hassoydeltemplate {eventIcon}
 * @hassoydelcall {eventIcon}
 */

if (typeof Confluence == 'undefined') { var Confluence = {}; }
if (typeof Confluence.TeamCalendars == 'undefined') { Confluence.TeamCalendars = {}; }
if (typeof Confluence.TeamCalendars.Templates == 'undefined') { Confluence.TeamCalendars.Templates = {}; }


Confluence.TeamCalendars.Templates.__deltemplate_s2_cbe40ab3 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="evenodd"><path d="M9.746 18.055a1.87 1.87 0 0 0 1.875-1.876l-3.758-.007a1.888 1.888 0 0 0 1.883 1.883zM4.879 6.695a4.712 4.712 0 0 1 1.383-3.35 4.714 4.714 0 0 1 2.406-1.29.945.945 0 0 1 .941-1.04.952.952 0 0 1 .945 1.044 4.765 4.765 0 0 1 3.806 4.654l.002.838c.002 1.107.288 2.855.638 3.901l.97 2.899c.168.498-.123.9-.651.9L3.953 15.23c-.527-.001-.819-.41-.656-.904l.96-2.894c.344-1.036.626-2.79.623-3.899l-.001-.838z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s2_cbe40ab3.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s2_cbe40ab3';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'campaign', 1, Confluence.TeamCalendars.Templates.__deltemplate_s2_cbe40ab3);


Confluence.TeamCalendars.Templates.__deltemplate_s4_624d32d2 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill-rule="evenodd"><path d="M9 14.28V9h2v5.28l2.294.764a.968.968 0 0 1 .7 1.067.996.996 0 0 1-.023.13A.968.968 0 0 1 13 17H7a.968.968 0 0 1-.97-.76.996.996 0 0 1-.024-.13.968.968 0 0 1 .7-1.066L9 14.279z" /><path d="M6.762 6L10 8.698 13.238 6H6.762zm3.878 4.768a1 1 0 0 1-1.28 0l-6-5C2.64 5.17 3.065 4 4 4h12c.935 0 1.359 1.17.64 1.768l-6 5z"  fill-rule="nonzero"/><circle  cx="15" cy="5" r="3"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s4_624d32d2.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s4_624d32d2';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'party', 1, Confluence.TeamCalendars.Templates.__deltemplate_s4_624d32d2);


Confluence.TeamCalendars.Templates.__deltemplate_s6_f29f5d11 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="nonzero"><path d="M17.43 9.52a1.001 1.001 0 1 1 .137 1.998 6.46 6.46 0 0 0-3.39 1.244l1.843 1.843a1 1 0 1 1-1.415 1.416l-1.843-1.843a6.46 6.46 0 0 0-1.245 3.389 1 1 0 1 1-1.997-.137 8.466 8.466 0 0 1 1.815-4.68L10 11.417 5.395 16.02a1.001 1.001 0 0 1-1.415-1.416L8.584 10 7.25 8.665a8.468 8.468 0 0 1-4.68 1.815 1.001 1.001 0 1 1-.136-1.998 6.46 6.46 0 0 0 3.39-1.244L3.98 5.395A1 1 0 1 1 5.395 3.98l1.843 1.843a6.455 6.455 0 0 0 1.244-3.39 1 1 0 1 1 1.998.138 8.466 8.466 0 0 1-1.815 4.68L10 8.583l4.605-4.605a1.001 1.001 0 0 1 1.415 1.416L11.416 10l1.335 1.335a8.468 8.468 0 0 1 4.68-1.815zm-7.428.48l.353-.354 4.959-4.959L10 10 7.306 7.304l-.38-.38-2.237-2.237c-.002 0 .869.872 2.612 2.615L9.998 10l-.353.354-4.959 4.959L10 10l2.695 2.695.38.38 2.236 2.237c.002 0-.869-.872-2.612-2.615L10.002 10z"/><path d="M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s6_f29f5d11.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s6_f29f5d11';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'sporting_event', 1, Confluence.TeamCalendars.Templates.__deltemplate_s6_f29f5d11);


Confluence.TeamCalendars.Templates.__deltemplate_s8_d5bd417f = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g transform="translate(3 2)"  fill-rule="evenodd"><path d="M5.542 2.833v4.475l-3.675 7.803h9.338L7.529 7.308V2.833H5.542zm7.348 11.465a1.899 1.899 0 0 1-.882 2.518c-.25.121-.525.184-.803.184H1.867A1.878 1.878 0 0 1 0 15.111c0-.281.062-.559.182-.813l3.494-7.417V.944h5.72v5.937l3.494 7.417z" fill-rule="nonzero"/><path d="M3.736 9.444h5.6l2.8 6.612H.936z"/><rect x="2.803" width="7.467" height="1.889" rx=".944"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s8_d5bd417f.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s8_d5bd417f';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'testing', 1, Confluence.TeamCalendars.Templates.__deltemplate_s8_d5bd417f);


Confluence.TeamCalendars.Templates.__deltemplate_s10_d0934dc4 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.74 13.55c.532.32 1.196.32 1.728 0l4.172-2.51v3.256c0 .591-.309 1.138-.814 1.443l-3.358 2.021c-.532.32-1.196.32-1.728 0l-3.358-2.02a1.686 1.686 0 0 1-.816-1.444v-3.257L8.74 13.55zm8.444-7.549c.505.305.816.852.816 1.445v8.322c0 .458-.39.827-.84.827a.841.841 0 0 1-.84-.827V7.502l-5.852 3.523c-.533.32-1.196.32-1.728 0L2.408 7.214a.842.842 0 0 1 0-1.444l5.469-3.29a3.35 3.35 0 0 1 3.455 0L17.184 6z"  fill-rule="evenodd"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s10_d0934dc4.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s10_d0934dc4';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'training', 1, Confluence.TeamCalendars.Templates.__deltemplate_s10_d0934dc4);


Confluence.TeamCalendars.Templates.__deltemplate_s12_bfe44f45 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="evenodd"><path d="M4.014 12.855a.647.647 0 0 0 .763.763l2.465-.505-2.724-2.723-.504 2.465zM14.252 4.752L12.88 3.379a1.292 1.292 0 0 0-1.83 0L4.735 9.693l3.203 3.203 6.313-6.314a1.294 1.294 0 0 0 0-1.83z"/><path d="M4.5 16.5a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2h-12z" fill-rule="nonzero"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s12_bfe44f45.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s12_bfe44f45';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'workshop', 1, Confluence.TeamCalendars.Templates.__deltemplate_s12_bfe44f45);


Confluence.TeamCalendars.Templates.__deltemplate_s14_f4134a47 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M16.222 3.778h.005c.98 0 1.773.795 1.773 1.772v10.678c0 .978-.793 1.772-1.773 1.772H3.773C2.793 18 2 17.205 2 16.228V5.55c0-.978.793-1.772 1.773-1.772h.005v.889c0 .988.796 1.777 1.778 1.777.988 0 1.777-.795 1.777-1.777v-.89h5.334v.89c0 .988.796 1.777 1.777 1.777.99 0 1.778-.795 1.778-1.777v-.89z M5.556 10.89h1.777V9.11H5.556zM5.556 14.445h1.777v-1.778H5.556zM9.111 10.89h1.778V9.11H9.11zM9.111 14.445h1.778v-1.778H9.11zM12.667 10.89h1.777V9.11h-1.777zM12.667 14.445h1.777v-1.778h-1.777z M13.556 3.778v-.89a.89.89 0 0 1 1.777 0v1.779a.89.89 0 0 1-1.777 0v-.89zM6.444 3.778v.889a.89.89 0 0 1-1.777 0V2.889a.89.89 0 0 1 1.777 0v.889z"></path></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s14_f4134a47.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s14_f4134a47';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'events', 1, Confluence.TeamCalendars.Templates.__deltemplate_s14_f4134a47);


Confluence.TeamCalendars.Templates.__deltemplate_s16_e056647e = function(opt_data, opt_ignored) {
  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'events', true)(opt_data);
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s16_e056647e.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s16_e056647e';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'other', 1, Confluence.TeamCalendars.Templates.__deltemplate_s16_e056647e);


Confluence.TeamCalendars.Templates.__deltemplate_s18_18f4da60 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.02 12.192h2.415c.89 0 1.337 1.078.707 1.707L13.9 18.142c-.63.63-1.707.184-1.707-.707v-2.414L9.11 11.938 4.78 17.352c-.682.854-2.043.151-1.743-.899L5.391 8.22 2.586 5.414a2 2 0 1 1 2.828-2.828L8.22 5.39l8.234-2.353c1.05-.3 1.753 1.06.9 1.743L11.937 9.11l3.083 3.082z"  fill-rule="nonzero"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s18_18f4da60.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s18_18f4da60';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'travel', 1, Confluence.TeamCalendars.Templates.__deltemplate_s18_18f4da60);


Confluence.TeamCalendars.Templates.__deltemplate_s20_01fdbda0 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.84 7.932a12.183 12.183 0 0 1 1.984 3.309c.64 1.604.992 3.803 1.084 6.624a1.5 1.5 0 1 1-2.998.1c-.082-2.505-.383-4.385-.873-5.613-.485-1.216-1.232-2.316-2.252-3.307a1.52 1.52 0 0 1-.092-.097l-.052.003c-1.722.107-3.417 1.54-5.057 4.366a.5.5 0 0 1-.931-.207c-.211-2.41.4-4.19 1.86-5.274a5.47 5.47 0 0 1 2.226-1.008C5.31 6.45 3.398 6.823.996 7.988a.5.5 0 0 1-.656-.692c1.172-2.116 2.675-3.25 4.491-3.333 1.703-.078 3.164.527 4.348 1.795.007-1.433.52-2.694 1.534-3.758C11.967.684 13.809.294 16.174.797a.5.5 0 0 1 .093.949c-2.569 1.097-4.131 2.357-4.729 3.76 1.017-.812 2.213-1.203 3.57-1.164 1.816.051 3.339 1.158 4.547 3.253a.5.5 0 0 1-.643.704c-2.966-1.375-5.175-1.576-6.647-.676-.191.117-.365.22-.525.309z"  fill-rule="nonzero"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s20_01fdbda0.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s20_01fdbda0';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'leave', 1, Confluence.TeamCalendars.Templates.__deltemplate_s20_01fdbda0);


Confluence.TeamCalendars.Templates.__deltemplate_s22_e1724cca = function(opt_data, opt_ignored) {
  return '' + soy.$$getDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'leave', true)(opt_data);
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s22_e1724cca.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s22_e1724cca';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'leaves', 1, Confluence.TeamCalendars.Templates.__deltemplate_s22_e1724cca);


Confluence.TeamCalendars.Templates.__deltemplate_s24_fd6eff36 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g transform="translate(1 1)" fill-rule="evenodd"><circle  cx="13" cy="6" r="3"/><circle  cx="5" cy="3" r="3"/><path d="M8 12c0-1.105.887-2 2-2h6c1.105 0 2 .885 2 2v3.73c0 3.027-10 3.027-10 0V12z" /><path d="M0 9h10V7H0v2zm0 6h7V8H0v7z" fill="#FFF"/><path d="M10 9h-.003A3.001 3.001 0 0 0 7 12.006v2.807c-2.946.534-7-.063-7-1.984V9.003C0 7.897.887 7 2 7h6c1.102 0 1.996.885 2 2z" /></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s24_fd6eff36.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s24_fd6eff36';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'conference', 1, Confluence.TeamCalendars.Templates.__deltemplate_s24_fd6eff36);


Confluence.TeamCalendars.Templates.__deltemplate_s26_70f0c90c = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.63463122 12.00024961c.42347959.77002165 1.05658158 1.45204083 1.86966239 2.00005629H1v-2.00005629h1.63463122zm10.62933768-1.00002812h-2.48582515c.99909375-1.05511782 1.08143305-2.62633496.19753961-3.76949635-.88389339-1.14316139-2.493473-1.5471623-3.86153148-.96923583-1.36805849.57792647-2.12228669 1.98050099-1.80946373 3.36490697.31282295 1.38440599 1.60756411 2.37388541 3.10620469 2.37385333v2.00005629c-2.3407169-.00062983-4.40309686-1.4533004-5.07154686-3.57222583-.66845001-2.11892544.21575193-4.40097153 2.17431881-5.61172235 1.95856689-1.21075083 4.52644131-1.06271625 6.31459561.3640281 1.7881543 1.42674436 2.3719952 3.79342119 1.4357085 5.81983567zm1.8093166 4.70813241c.4145048.3888615 1.0835543.3888615 1.498059 0l2.1131632-1.99705617C18.8930714 13.51429219 19 13.25828499 19 12.9992777c0-.25400714-.1048112-.51001434-.3154923-.71001996l-2.1131632-1.99605614c-.4133852-.39075245-1.0838521-.39097631-1.4975297-.00050001-.4136775.3904763-.4139145 1.02378733-.0005293 1.41453978l1.3699565 1.29303636-1.3699565 1.29403637c-.413297.3905109-.413297 1.023529 0 1.4140398z"/><path d="M8.41176471 12h8.47058819v2H8.41176471z"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s26_70f0c90c.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s26_70f0c90c';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'sprints', 1, Confluence.TeamCalendars.Templates.__deltemplate_s26_70f0c90c);


Confluence.TeamCalendars.Templates.__deltemplate_s28_968cc426 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="nonzero"><path d="M4 7.046V16c0 .31.467.783 1.444 1.202C6.616 17.704 8.247 18 10 18c1.753 0 3.384-.296 4.556-.798C15.533 16.783 16 16.31 16 16V7.046H4zm.003-2c.043.31.511.758 1.441 1.156C6.616 6.704 8.247 7 10 7c1.753 0 3.384-.296 4.556-.798.93-.398 1.398-.846 1.44-1.156H18V16c0 2.44-3.638 4-8 4s-8-1.56-8-4V5.046h2.003z"/><path d="M10 9C5.638 9 2 7.44 2 5s3.638-4 8-4 8 1.56 8 4-3.638 4-8 4zm0-2c1.753 0 3.384-.296 4.556-.798C15.533 5.783 16 5.31 16 5c0-.31-.467-.783-1.444-1.202C13.384 3.296 11.753 3 10 3c-1.753 0-3.384.296-4.556.798C4.467 4.217 4 4.69 4 5c0 .31.467.783 1.444 1.202C6.616 6.704 8.247 7 10 7z"/><path d="M17.5 8.5c0 2.049-3.386 3.5-7.5 3.5s-7.5-1.451-7.5-3.5h1C3.5 9.765 6.382 11 10 11s6.5-1.235 6.5-2.5h1z"/><path d="M17.5 11.5c0 2.049-3.386 3.5-7.5 3.5s-7.5-1.451-7.5-3.5h1c0 1.265 2.882 2.5 6.5 2.5s6.5-1.235 6.5-2.5h1z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s28_968cc426.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s28_968cc426';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'deployment', 1, Confluence.TeamCalendars.Templates.__deltemplate_s28_968cc426);


Confluence.TeamCalendars.Templates.__deltemplate_s30_43ed316d = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.518 9.794v8.004c0 .55-.456.996-1.003.996h-2.997v-4.002c0-1.1-.896-1.998-2-1.998-1.113 0-2 .894-2 1.998v4.002H4.52a.998.998 0 0 1-1.002-.996V9.794H1.51c-.549 0-.673-.32-.287-.706l7.94-7.941a.497.497 0 0 1 .706 0l7.941 7.94c.39.39.262.707-.287.707h-2.006z"  fill-rule="evenodd"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s30_43ed316d.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s30_43ed316d';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'home', 1, Confluence.TeamCalendars.Templates.__deltemplate_s30_43ed316d);


Confluence.TeamCalendars.Templates.__deltemplate_s32_b5b3f6dc = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 4h14a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2zm7.001 6.193L4.203 5.682A1 1 0 1 0 2.975 7.26l6.41 4.989a1 1 0 0 0 1.228 0l6.432-4.989a1 1 0 1 0-1.226-1.58l-5.818 4.513z"  fill-rule="nonzero"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s32_b5b3f6dc.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s32_b5b3f6dc';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'marketing_email', 1, Confluence.TeamCalendars.Templates.__deltemplate_s32_b5b3f6dc);


Confluence.TeamCalendars.Templates.__deltemplate_s34_8dd06bec = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 19a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm2-8.193H8a2 2 0 0 0-2 2.002v3.183a7.16 7.16 0 0 0 4 1.215c1.48 0 2.855-.448 4-1.215V12.81a2.001 2.001 0 0 0-2-2.002zM10 10a2.4 2.4 0 1 0 0-4.8 2.4 2.4 0 0 0 0 4.8z"  fill-rule="nonzero"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s34_8dd06bec.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s34_8dd06bec';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'meeting', 1, Confluence.TeamCalendars.Templates.__deltemplate_s34_8dd06bec);


Confluence.TeamCalendars.Templates.__deltemplate_s36_5abd3649 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 10.415v6.587c0 .549.45.998 1 .998s.999-.45.999-.998v-5.904c1.168-.349 2.387-.047 3.765.296.982.243 2.035.505 3.128.505.832 0 1.686-.152 2.545-.579.345-.172.563-.527.563-.92V3.498c0-.352-.177-.68-.469-.866a.982.982 0 0 0-.967-.053c-1.344.667-2.73.323-4.328-.074-1.728-.429-3.685-.914-5.674.074-.344.17-.562.528-.562.919v6.917z"  fill-rule="evenodd"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s36_5abd3649.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s36_5abd3649';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'milestone', 1, Confluence.TeamCalendars.Templates.__deltemplate_s36_5abd3649);


Confluence.TeamCalendars.Templates.__deltemplate_s38_38a3386e = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="evenodd"><path d="M5.938 4.458a4.844 4.844 0 0 0-.777-.063C2.356 4.396 0 6.577 0 9.43c0 2.882 2.385 5.45 5.1 5.45h.881v-1.974H5.1c-1.657 0-3.115-1.648-3.115-3.476 0-1.761 1.469-3.058 3.104-3.058.401 0 .698.05.982.148l.17.063c.605.246.875-.244.875-.244l.15-.264c.73-1.335 2.201-2.077 3.716-2.1 2.082.034 3.797 1.534 4.069 3.61l.046.337s.071.52.665.52l.277.005c1.136 0 1.976.95 1.976 2.138 0 1.196-.987 2.32-2.07 2.32h-2.964v1.975h2.964c2.16 0 4.055-2.026 4.055-4.295 0-1.98-1.312-3.629-3.138-4.036-.707-2.682-3.053-4.51-5.886-4.548-1.975.02-3.901.892-5.038 2.458z"/><path d="M9.145 14.868l-.794.018-.26.004-.104-.002c-.032-.001-.032-.001-.095-.007-.045-.005-.045-.005-.152-.029-.08-.022-.08-.022-.245-.102-.273-.16-.273-.16-.495-.864 0-.514.08-.614 3.419-4.602a1 1 0 0 1 1.533 1.284c-.773.923-1.404 1.684-1.893 2.282.25-.003.462-.004.638-.002.175.001.314.005.422.013.082.006.152.014.223.028.083.016.083.016.242.075.282.102.282.102.602.922 0 .526-.217.796-3.42 4.614a1 1 0 0 1-1.532-1.286c.802-.956 1.452-1.739 1.948-2.347h-.037z" fill-rule="nonzero"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s38_38a3386e.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s38_38a3386e';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'outage', 1, Confluence.TeamCalendars.Templates.__deltemplate_s38_38a3386e);


Confluence.TeamCalendars.Templates.__deltemplate_s40_b1d4df5f = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="nonzero"><path d="M5.134 17h9.614V9.353H5.134V17zm-1-9.647h11.614a1 1 0 0 1 1 1V18a1 1 0 0 1-1 1H4.134a1 1 0 0 1-1-1V8.353a1 1 0 0 1 1-1z"/><path d="M8.441 5.324h3v13.588h-3z"/><path d="M4.206 13.618v-3H16.22v3zM3 6.294h13.882a1 1 0 0 1 1 1v1.177a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7.294a1 1 0 0 1 1-1z"/><path d="M9.304 7.029c-1.13 1.13-3.612.235-4.89-1.044-1.142-1.14-1.264-2.94-.179-4.025C5.321.874 7.12.997 8.261 2.137c1.278 1.28 2.174 3.761 1.043 4.892zm-1.628-2.07c-.197-.544-.546-1.124-.83-1.407-.4-.4-.938-.437-1.197-.178-.258.258-.221.797.178 1.197.283.283.864.633 1.408.829.227.082.43.13.586.146a2.519 2.519 0 0 0-.145-.587z"/><path d="M10.492 7.029c-1.13-1.131-.235-3.613 1.044-4.892 1.14-1.14 2.94-1.263 4.025-.177 1.086 1.085.963 2.884-.178 4.025-1.279 1.279-3.76 2.174-4.891 1.044zm2.07-1.63c.543-.195 1.124-.545 1.407-.828.4-.4.436-.939.178-1.197-.259-.259-.798-.222-1.197.178-.283.283-.633.863-.83 1.407-.081.227-.13.43-.145.587.157-.015.36-.064.586-.146z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s40_b1d4df5f.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s40_b1d4df5f';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'birthdays', 1, Confluence.TeamCalendars.Templates.__deltemplate_s40_b1d4df5f);


Confluence.TeamCalendars.Templates.__deltemplate_s42_3e1f11d2 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g  fill-rule="evenodd"><path d="M5.143 6.286V16h9.714V6.286H5.143zM16 4.644c.518.362.857.962.857 1.642V16a2 2 0 0 1-2 2H5.143a2 2 0 0 1-2-2V6.286c0-.68.339-1.28.857-1.642v1.07h12v-1.07zM4 4v1.714h12V4H4zm0-2h12a2 2 0 0 1 2 2v1.714a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z" fill-rule="nonzero"/><path d="M7.714 8.857h4.571v2.286H7.714z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s42_3e1f11d2.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s42_3e1f11d2';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'jira_box', 1, Confluence.TeamCalendars.Templates.__deltemplate_s42_3e1f11d2);


Confluence.TeamCalendars.Templates.__deltemplate_s44_21eada66 = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g><path d="M17.3613625 2H10c0 .88651593.35010544 1.73672248.97329713 2.3635839.62319161.62686143 1.46842097.97902851 2.34974697.97902851h1.3560405v1.31691648C14.6802589 8.50393066 16.1663957 9.99881878 18 10V2.64239828C18 2.28761151 17.7140723 2 17.3613625 2z"/><path d="M13.3613624 6H6c.00117426 1.84440176 1.48731108 3.33928992 3.32091539 3.34047109h1.35604043v1.32119912C10.67930511 12.5060714 12.1663948 14.0000015 14 14V6.64239828C14 6.28761151 13.7140722 6 13.3613624 6z"/><path d="M9.36136242 10H2c0 1.84607388 1.48777755 3.3426125 3.32304417 3.3426125H6.6833422v1.3169164C6.68451239 16.502261 8.16805859 17.996459 10 18v-7.35760169C10 10.28761152 9.71407217 10 9.36136242 10z"/><path d="M13.3613624 6H6c.00117426 1.84440176 1.48731108 3.33928992 3.32091539 3.34047109h1.35604043v1.32119912C10.67930511 12.5060714 12.1663948 14.0000015 14 14V6.64239828C14 6.28761151 13.7140722 6 13.3613624 6z"/><path d="M9.36136242 10H2c0 1.84607388 1.48777755 3.3426125 3.32304417 3.3426125H6.6833422v1.3169164C6.68451239 16.502261 8.16805859 17.996459 10 18v-7.35760169C10 10.28761152 9.71407217 10 9.36136242 10z"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s44_21eada66.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s44_21eada66';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'jira', 1, Confluence.TeamCalendars.Templates.__deltemplate_s44_21eada66);


Confluence.TeamCalendars.Templates.__deltemplate_s46_a47a113e = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill-rule="evenodd"><path d="M3 8h13H3zm14 1v8c0 .5522847-.4477153 1-1 1H3c-.55228475 0-1-.4477153-1-1V9h15zM7 12v2h5v-2H7z"/><path d="M4.01759531 6.5H14.9822913l-1.2937993-3H5.31139458l-1.29379927 3zM4.65362899 2h9.69262861c.1996009 0 .3800796.11871266.4591233.30199552l2.1563321 5c.1093549.25356682-.007552.54777295-.2611188.65712781C16.6380649 7.98609012 16.5706861 8 16.5025897 8H2.49729687c-.27614238 0-.5-.22385763-.5-.5 0-.06809642.01390988-.13547517.04087667-.19800448l2.15633213-5C4.27354941 2.11871266 4.45402809 2 4.65362899 2z" fill-rule="nonzero"/></g></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s46_a47a113e.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s46_a47a113e';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'version_open', 1, Confluence.TeamCalendars.Templates.__deltemplate_s46_a47a113e);


Confluence.TeamCalendars.Templates.__deltemplate_s48_923a696e = function(opt_data, opt_ignored) {
  return '<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8h13H3zm14 1v8c0 .5522847-.4477153 1-1 1H3c-.55228475 0-1-.4477153-1-1V9h15zM7 12v2h5v-2H7zM9 2v6H2.49729687c-.27614238 0-.5-.22385763-.5-.5 0-.06809642.01390988-.13547517.04087667-.19800448l2.15633213-5C4.27354941 2.11871266 4.45402809 2 4.65362899 2H9zm1 0h4.3462576c.1996009 0 .3800796.11871266.4591233.30199552l2.1563321 5c.1093549.25356682-.007552.54777295-.2611188.65712781C16.6380649 7.98609012 16.5706861 8 16.5025897 8H10V2z" fill-rule="evenodd"/></svg>';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s48_923a696e.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s48_923a696e';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), 'version_closed', 1, Confluence.TeamCalendars.Templates.__deltemplate_s48_923a696e);


Confluence.TeamCalendars.Templates.__deltemplate_s50_ddd3f909 = function(opt_data, opt_ignored) {
  return '';
};
if (goog.DEBUG) {
  Confluence.TeamCalendars.Templates.__deltemplate_s50_ddd3f909.soyTemplateName = 'Confluence.TeamCalendars.Templates.__deltemplate_s50_ddd3f909';
}
soy.$$registerDelegateFn(soy.$$getDelTemplateId('eventIcon'), '', 1, Confluence.TeamCalendars.Templates.__deltemplate_s50_ddd3f909);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/lib/fullcalendar.js' */
/*!
 * FullCalendar v1.6.4
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2013 Adam Shaw
 */

/*
 * Use fullcalendar.css for basic styling.
 * For event drag & drop, requires jQuery UI draggable.
 * For event resizing, requires jQuery UI resizable.
 */

(function($, undefined) {


;;

/**
 * Helper class which helps to manage dependency between 3rd fullcalendar class with our code
 *
 */
var calendarDependencyHelper = {
    isDisplayTimeFormat24hour : function() {
        return AJS.Meta.get("team-calendars-display-time-format") === 'displayTimeFormat24';
    },
    getTimelineAdapter : function(_element, _calendarPlugin, _calendarDiv, _fullCalendarView) {
        return Confluence.TeamCalendars.getTimelineAdapter(_element, _calendarPlugin, _calendarDiv, _fullCalendarView);
    },
    Templates : function () {
        return Confluence.TeamCalendars.Templates;
    },
    getUserTimeZone : function () {
        return Confluence.TeamCalendars.getUserTimeZone();
    }
};

var defaults = {

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,
	weekNumberCalculation: 'iso',
	weekNumberTitle: 'W',

	// editing
	//editable: false,
	//disableDragging: false,
	//disableResizing: false,

	allDayDefault: true,
	ignoreTimezone: true,

	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',

	// time formats
	titleFormat: {
		month: 'MMMM yyyy',
		week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}",
		day: 'dddd, MMM d, yyyy'
	},
	columnFormat: {
		month: 'ddd',
		week: 'ddd M/d',
		day: 'dddd M/d'
	},
	timeFormat: { // for event elements
        //ATLASSIAN - TEAMCAL-258: change display format time
        '': calendarDependencyHelper.isDisplayTimeFormat24hour() === true ? 'HH:mm' : 'h:mm TT'
        //END ATLASSIAN - TEAMCAL-258: change display format time
	},

	// locale
	isRTL: false,
	firstDay: 0,
	monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
	monthNamesShort: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
	dayNames: ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	dayNamesShort: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
	buttonText: {
		prev: "<span class='fc-text-arrow'>&lsaquo;</span>",
		next: "<span class='fc-text-arrow'>&rsaquo;</span>",
		prevYear: "<span class='fc-text-arrow'>&laquo;</span>",
		nextYear: "<span class='fc-text-arrow'>&raquo;</span>",
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},

	// jquery-ui theming
	theme: false,
	buttonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e'
	},

	//selectable: false,
	unselectAuto: true,

	dropAccept: '*',

	handleWindowResize: true,

	//ATLASSIAN
	supportPrint: true
	//END ATLASSIAN
};

// right-to-left defaults
var rtlDefaults = {
	header: {
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonText: {
		prev: "<span class='fc-text-arrow'>&rsaquo;</span>",
		next: "<span class='fc-text-arrow'>&lsaquo;</span>",
		prevYear: "<span class='fc-text-arrow'>&raquo;</span>",
		nextYear: "<span class='fc-text-arrow'>&laquo;</span>"
	},
	buttonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w'
	}
};



;;

var fc = $.fullCalendar = { version: "1.6.4" };
var fcViews = fc.views = {};


$.fn.fullCalendar = function(options) {


	// method calling
	if (typeof options == 'string') {
		var args = Array.prototype.slice.call(arguments, 1);
		var res;
		this.each(function() {
			var calendar = $.data(this, 'fullCalendar');
			if (calendar && $.isFunction(calendar[options])) {
				var r = calendar[options].apply(calendar, args);
				if (res === undefined) {
					res = r;
				}
				if (options == 'destroy') {
					$.removeData(this, 'fullCalendar');
				}
			}
		});
		if (res !== undefined) {
			return res;
		}
		return this;
	}

	options = options || {};

	// would like to have this logic in EventManager, but needs to happen before options are recursively extended
	var eventSources = options.eventSources || [];
	delete options.eventSources;
	if (options.events) {
		eventSources.push(options.events);
		delete options.events;
	}


	options = $.extend(true, {},
		defaults,
		(options.isRTL || options.isRTL===undefined && defaults.isRTL) ? rtlDefaults : {},
		options
	);


	this.each(function(i, _element) {
		var element = $(_element);
		var calendar = new Calendar(element, options, eventSources);
		element.data('fullCalendar', calendar); // TODO: look into memory leak implications
		calendar.render();
	});


	return this;

};


// function for adding/overriding defaults
function setDefaults(d) {
	$.extend(true, defaults, d);
}



;;


function Calendar(element, options, eventSources) {
	var t = this;


	// exports
	t.options = options;
	t.render = render;
	t.destroy = destroy;
	t.refetchEvents = refetchEvents;
	t.reportEvents = reportEvents;
	t.reportEventChange = reportEventChange;
	t.rerenderEvents = rerenderEvents;
	t.changeView = changeView;
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.formatDate = function(format, date) { return formatDate(format, date, options) };
	t.formatDates = function(format, date1, date2) { return formatDates(format, date1, date2, options) };
	t.getDate = getDate;
	t.getView = getView;
	t.option = option;
	t.trigger = trigger;


	// imports
	EventManager.call(t, options, eventSources);
	var isFetchNeeded = t.isFetchNeeded;
	var fetchEvents = t.fetchEvents;


	// locals
	var _element = element[0];
	var header;
	var headerElement;
	var content;
	var tm; // for making theme classes
	var currentView;
	var elementOuterWidth;
	var suggestedViewHeight;
	var resizeUID = 0;
	var ignoreWindowResize = 0;
	var date = new Date();
	var events = [];
	var _dragElement;



	/* Main Rendering
	-----------------------------------------------------------------------------*/


	setYMD(date, options.year, options.month, options.date);


	function render(inc) {
		if (!content) {
			initialRender();
		}
		else if (elementVisible()) {
			// mainly for the public API
			calcSize();
			_renderView(inc);
		}


		//ATLASSIAN - process printing

		var calLayout = $("div.plugin-calendar .calendar-layout");
		var calPanel = $("div.plugin-calendar .calendar-panel");

		var reRenderCalendar = function(inc) {
			calcSize();
			_renderView(inc);
		};

		var beforePrint = function(widthCalendar) {
			//set cal layout with width, ignore use percent
			calLayout.css("width", widthCalendar);
			calPanel.css("margin-right", 0);
			reRenderCalendar();
	    };

	    var afterPrint = function() {
	    	//reset value
	    	calLayout.css("width", "");
	    	calPanel.css("margin-right", "");

    		//ignore for chrome browser don't render again.
    		var isChrome = navigator.userAgent.indexOf('Chrome') > -1;
    		if(!isChrome) {
    			reRenderCalendar();
    		};
	    };

	    if(options.supportPrint) {
	    	//fix for some layout > 1200px
	    	var widthCalLayout = Math.min(calLayout.width(), 1200);

            if (window.matchMedia) {
                var mediaQueryList = window.matchMedia('print');
                mediaQueryList.addListener(function(mql) {
                	if(currentView.name !== 'timeline') {
                		if (mql.matches) {
                			beforePrint(widthCalLayout);
                		} else {
                			afterPrint();
                		}
                	}
                });
            }

            //for FF,IE browser
            $(window)
	            .bind("beforeprint", function () {
	            	if(currentView.name !== 'timeline') {
	            		beforePrint(widthCalLayout*0.75);
	            	}
	            })
	            .bind("afterprint", function () {
	            	if(currentView.name !== 'timeline') {
	            		afterPrint();
	            	}
	            });
        }
		//END ATLASSIAN
	}


	function initialRender() {
		tm = options.theme ? 'ui' : 'fc';
		element.addClass('fc');
		if (options.isRTL) {
			element.addClass('fc-rtl');
		}
		else {
			element.addClass('fc-ltr');
		}
		if (options.theme) {
			element.addClass('ui-widget');
		}

		content = $("<div class='fc-content' style='position:relative'/>")
			.prependTo(element);

		header = new Header(t, options);
		headerElement = header.render();
		if (headerElement) {
			element.prepend(headerElement);
		}

		changeView(options.defaultView);

		if (options.handleWindowResize) {
			$(window).resize(windowResize);
		}

        // ATLASSIAN TEAMCAL-1306
        pollVisibility();
        // ATLASSIAN TEAMCAL-1306

		// needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
		if (!bodyVisible()) {
			lateRender();
		}
	}

    // ATLASSIAN TEAMCAL-1306
    function pollVisibility() {
        if (elementVisible()) {
            AJS.log("TC detected the width. Will go ahead !!!")
            renderView();
        } else {
            setTimeout(pollVisibility, 500);
        }
    }
    // ATLASSIAN TEAMCAL-1306

	// called when we know the calendar couldn't be rendered when it was initialized,
	// but we think it's ready now
	function lateRender() {
		setTimeout(function() { // IE7 needs this so dimensions are calculated correctly
			if (!currentView.start && bodyVisible()) { // !currentView.start makes sure this never happens more than once
				renderView();
			}
		},0);
	}


	function destroy() {

		if (currentView) {
			trigger('viewDestroy', currentView, currentView, currentView.element);
			currentView.triggerEventDestroy();
		}

		$(window).unbind('resize', windowResize);

		header.destroy();
		content.remove();
		element.removeClass('fc fc-rtl ui-widget');
	}


	function elementVisible() {
		return element.is(':visible');
	}


	function bodyVisible() {
		return $('body').is(':visible');
	}



	/* View Rendering
	-----------------------------------------------------------------------------*/


	function changeView(newViewName) {
		if (!currentView || newViewName != currentView.name) {
			_changeView(newViewName);
		}
	}


	function _changeView(newViewName) {
		ignoreWindowResize++;

		if (currentView) {
			trigger('viewDestroy', currentView, currentView, currentView.element);
			unselect();
			currentView.triggerEventDestroy(); // trigger 'eventDestroy' for each event
			freezeContentHeight();
			currentView.element.remove();
			header.deactivateButton(currentView.name);
		}

		header.activateButton(newViewName);

		currentView = new fcViews[newViewName](
			$("<div class='fc-view fc-view-" + newViewName + "' style='position:relative'/>")
				.appendTo(content),
			t // the calendar object
		);

		renderView();
		unfreezeContentHeight();

		ignoreWindowResize--;
	}


	function renderView(inc) {
		if (
			!currentView.start || // never rendered before
			inc || date < currentView.start || date >= currentView.end // or new date range
		) {
			if (elementVisible()) {
				_renderView(inc);
			}
		}
	}


	function _renderView(inc) { // assumes elementVisible
		ignoreWindowResize++;

		if (currentView.start) { // already been rendered?
			trigger('viewDestroy', currentView, currentView, currentView.element);
			unselect();
			clearEvents();
		}

		freezeContentHeight();
		currentView.render(date, inc || 0); // the view's render method ONLY renders the skeleton, nothing else
		setSize();
		unfreezeContentHeight();
		(currentView.afterRender || noop)();

		updateTitle();
		updateTodayButton();

		trigger('viewRender', currentView, currentView, currentView.element);
		currentView.trigger('viewDisplay', _element); // deprecated

		ignoreWindowResize--;

		getAndRenderEvents();
	}



	/* Resizing
	-----------------------------------------------------------------------------*/


	function updateSize() {
		if (elementVisible()) {
			unselect();
			clearEvents();
			calcSize();
			setSize();
			renderEvents();
		}
	}


	function calcSize() { // assumes elementVisible
		if (options.contentHeight) {
			suggestedViewHeight = options.contentHeight;
		}
		else if (options.height) {
			suggestedViewHeight = options.height - (headerElement ? headerElement.height() : 0) - vsides(content);
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
		}
	}


	function setSize() { // assumes elementVisible

		if (suggestedViewHeight === undefined) {
			calcSize(); // for first time
				// NOTE: we don't want to recalculate on every renderView because
				// it could result in oscillating heights due to scrollbars.
		}

		ignoreWindowResize++;
		currentView.setHeight(suggestedViewHeight);
		currentView.setWidth(content.width());
		ignoreWindowResize--;

		elementOuterWidth = element.outerWidth();
	}


	function windowResize() {
		if (!ignoreWindowResize) {
			if (currentView.start) { // view has already been rendered
				var uid = ++resizeUID;
				setTimeout(function() { // add a delay
					if (uid == resizeUID && !ignoreWindowResize && elementVisible()) {
						if (elementOuterWidth != (elementOuterWidth = element.outerWidth())) {
							ignoreWindowResize++; // in case the windowResize callback changes the height
							updateSize();
							currentView.trigger('windowResize', _element);
							ignoreWindowResize--;
						}
					}
				}, 200);
			}else{
				// calendar must have been initialized in a 0x0 iframe that has just been resized
				lateRender();
			}
		}
	}



	/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
	// TODO: going forward, most of this stuff should be directly handled by the view


	function refetchEvents() { // can be called as an API method
		clearEvents();
		fetchAndRenderEvents();
	}


	function rerenderEvents(modifiedEventID) { // can be called as an API method
		clearEvents();
		renderEvents(modifiedEventID);
	}


	function renderEvents(modifiedEventID) { // TODO: remove modifiedEventID hack
		if (elementVisible()) {
			currentView.setEventData(events); // for View.js, TODO: unify with renderEvents
			currentView.renderEvents(events, modifiedEventID); // actually render the DOM elements
			currentView.trigger('eventAfterAllRender');
		}
	}


	function clearEvents() {
		currentView.triggerEventDestroy(); // trigger 'eventDestroy' for each event
		currentView.clearEvents(); // actually remove the DOM elements
		currentView.clearEventData(); // for View.js, TODO: unify with clearEvents
	}


	function getAndRenderEvents() {
		if (!options.lazyFetching || isFetchNeeded(currentView.visStart, currentView.visEnd)) {
			fetchAndRenderEvents();
		}
		else {
			renderEvents();
		}
	}


	function fetchAndRenderEvents() {
		fetchEvents(currentView.visStart, currentView.visEnd);
			// ... will call reportEvents
			// ... which will call renderEvents
	}


	// called when event data arrives
	function reportEvents(_events) {
		events = _events;
		renderEvents();
	}


	// called when a single event's data has been changed
	function reportEventChange(eventID) {
		rerenderEvents(eventID);
	}



	/* Header Updating
	-----------------------------------------------------------------------------*/


	function updateTitle() {
		header.updateTitle(currentView.title);
	}


	function updateTodayButton() {
		var today = new Date();
		if (today >= currentView.start && today < currentView.end) {
			header.disableButton('today');
		}
		else {
			header.enableButton('today');
		}
	}



	/* Selection
	-----------------------------------------------------------------------------*/


	function select(start, end, allDay) {
		currentView.select(start, end, allDay===undefined ? true : allDay);
	}


	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}



	/* Date
	-----------------------------------------------------------------------------*/


	function prev() {
        //ATLASSIAN
        if (currentView.prev) {
            //The timeline view has it's own behavior for advancing forwards/backwards
            currentView.prev();
        } else {
            renderView(-1);
        }
        //END ATLASSIAN
	}


	function next() {
        //ATLASSIAN
        if (currentView.next) {
            //The timeline view has it's own behavior for advancing forwards/backwards
            currentView.next();
        } else {
            renderView(1);
        }
        //END ATLASSIAN
	}


	function prevYear() {
		addYears(date, -1);
		renderView();
	}


	function nextYear() {
		addYears(date, 1);
		renderView();
	}


	function today() {
        //ATLASSIAN
        if (currentView.gotoToday) {
            currentView.gotoToday();
        } else {
            date = new Date();
            renderView();
        }
        //END ATLASSIAN
	}


	function gotoDate(year, month, dateOfMonth) {
		if (year instanceof Date) {
			date = cloneDate(year); // provided 1 argument, a Date
		}else{
			setYMD(date, year, month, dateOfMonth);
		}
		renderView();
	}


	function incrementDate(years, months, days) {
		if (years !== undefined) {
			addYears(date, years);
		}
		if (months !== undefined) {
			addMonths(date, months);
		}
		if (days !== undefined) {
			addDays(date, days);
		}
		renderView();
	}


	function getDate() {
		return cloneDate(date);
	}



	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	function freezeContentHeight() {
		content.css({
			width: '100%',
			height: content.height(),
			overflow: 'hidden'
		});
	}


	function unfreezeContentHeight() {
		content.css({
			width: '',
			height: '',
			overflow: ''
		});
	}



	/* Misc
	-----------------------------------------------------------------------------*/


	function getView() {
		return currentView;
	}


	function option(name, value) {
		if (value === undefined) {
			return options[name];
		}
		if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
			options[name] = value;
			updateSize();
		}
	}


	function trigger(name, thisObj) {
		if (options[name]) {
			return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
		}
	}



	/* External Dragging
	------------------------------------------------------------------------*/

	if (options.droppable) {
		$(document)
			.bind('dragstart', function(ev, ui) {
				var _e = ev.target;
				var e = $(_e);
				if (!e.parents('.fc').length) { // not already inside a calendar
					var accept = options.dropAccept;
					if ($.isFunction(accept) ? accept.call(_e, e) : e.is(accept)) {
						_dragElement = _e;
						currentView.dragStart(_dragElement, ev, ui);
					}
				}
			})
			.bind('dragstop', function(ev, ui) {
				if (_dragElement) {
					currentView.dragStop(_dragElement, ev, ui);
					_dragElement = null;
				}
			});
	}


}

;;

function Header(calendar, options) {
	var t = this;


	// exports
	t.render = render;
	t.destroy = destroy;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;


	// locals
	var element = $([]);
	var tm;



	function render() {
		tm = options.theme ? 'ui' : 'fc';
		var sections = options.header;
		if (sections) {
			element = $("<table class='fc-header' style='width:100%'/>")
				.append(
					$("<tr/>")
						.append(renderSection('left'))
						.append(renderSection('center'))
						.append(renderSection('right'))
				);
			return element;
		}
	}


	function destroy() {
		element.remove();
	}


	function renderSection(position) {
		var e = $("<td class='fc-header-" + position + "'/>");
		var buttonStr = options.header[position];
		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				if (i > 0) {
					e.append("<span class='fc-header-space'/>");
				}
				var prevButton;
				$.each(this.split(','), function(j, buttonName) {
					if (buttonName == 'title') {
						e.append("<span class='fc-header-title'><h2>&nbsp;</h2></span>");
						if (prevButton) {
							prevButton.addClass(tm + '-corner-right');
						}
						prevButton = null;
					}else{
						var buttonClick;
						if (calendar[buttonName]) {
							buttonClick = calendar[buttonName]; // calendar method
						}
						else if (fcViews[buttonName]) {
							buttonClick = function() {
								button.removeClass(tm + '-state-hover'); // forget why
								calendar.changeView(buttonName);
							};
						}
						if (buttonClick) {
							var icon = options.theme ? smartProperty(options.buttonIcons, buttonName) : null; // why are we using smartProperty here?
							var text = smartProperty(options.buttonText, buttonName); // why are we using smartProperty here?
							var button = $(
								"<span class='fc-button fc-button-" + buttonName + " " + tm + "-state-default'>" +
									(icon ?
										"<span class='fc-icon-wrap'>" +
											"<span class='ui-icon ui-icon-" + icon + "'/>" +
										"</span>" :
										text
										) +
								"</span>"
								)
								.click(function() {
									if (!button.hasClass(tm + '-state-disabled')) {
										buttonClick();
									}
								})
								.mousedown(function() {
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down');
									}
								)
								.appendTo(e);
							disableTextSelection(button);
							if (!prevButton) {
								button.addClass(tm + '-corner-left');
							}
							prevButton = button;
						}
					}
				});
				if (prevButton) {
					prevButton.addClass(tm + '-corner-right');
				}
			});
		}
		return e;
	}


	function updateTitle(html) {
		element.find('h2')
			.html(html);
	}


	function activateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-active');
	}


	function deactivateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-active');
	}


	function disableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-disabled');
	}


	function enableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-disabled');
	}


}

;;

fc.sourceNormalizers = [];
fc.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager(options, _sources) {
	var t = this;


	// exports
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.updateEvent = updateEvent;
	t.renderEvent = renderEvent;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.normalizeEvent = normalizeEvent;


	// imports
	var trigger = t.trigger;
	var getView = t.getView;
	var reportEvents = t.reportEvents;


	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var currentFetchID = 0;
	var pendingSourceCnt = 0;
	var loadingLevel = 0;
	var cache = [];


	for (var i=0; i<_sources.length; i++) {
		_addEventSource(_sources[i]);
	}



	/* Fetching
	-----------------------------------------------------------------------------*/


	function isFetchNeeded(start, end) {
		return !rangeStart || start < rangeStart || end > rangeEnd;
	}


	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		cache = [];
		var fetchID = ++currentFetchID;
		var len = sources.length;
		pendingSourceCnt = len;
		for (var i=0; i<len; i++) {
			fetchEventSource(sources[i], fetchID);
		}
	}


	function fetchEventSource(source, fetchID) {
		_fetchEventSource(source, function(events) {
			if (fetchID == currentFetchID) {
				if (events) {

					if (options.eventDataTransform) {
						events = $.map(events, options.eventDataTransform);
					}
					if (source.eventDataTransform) {
						events = $.map(events, source.eventDataTransform);
					}
					// TODO: this technique is not ideal for static array event sources.
					//  For arrays, we'll want to process all events right in the beginning, then never again.

					for (var i=0; i<events.length; i++) {
						events[i].source = source;
						normalizeEvent(events[i]);
					}
					cache = cache.concat(events);
				}
				/*pendingSourceCnt--;
				if (!pendingSourceCnt) {
					reportEvents(cache);
				}*/
                // TEAMCAL-3194: render events after fetch events (experiment)
                reportEvents(cache);
			}
		});
	}


	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = fc.sourceFetchers;
		var res;
		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i](source, rangeStart, rangeEnd, callback);
			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}
		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				pushLoading();
				events(cloneDate(rangeStart), cloneDate(rangeEnd), function(events) {
					callback(events);
					popLoading();
				});
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, options.startParam);
				var endParam = firstDefined(source.endParam, options.endParam);
				if (startParam) {
					data[startParam] = Math.round(+rangeStart / 1000);
				}
				if (endParam) {
					data[endParam] = Math.round(+rangeEnd / 1000);
				}

				pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}



	/* Sources
	-----------------------------------------------------------------------------*/


	function addEventSource(source) {
		source = _addEventSource(source);
		if (source) {
			pendingSourceCnt++;
			fetchEventSource(source, currentFetchID); // will eventually call reportEvents
		}
	}


	function _addEventSource(source) {
		if ($.isFunction(source) || $.isArray(source)) {
			source = { events: source };
		}
		else if (typeof source == 'string') {
			source = { url: source };
		}
		if (typeof source == 'object') {
			normalizeSource(source);
			sources.push(source);
			return source;
		}
	}


	function removeEventSource(source) {
		sources = $.grep(sources, function(src) {
			return !isSourcesEqual(src, source);
		});
		// remove all client events from that source
		cache = $.grep(cache, function(e) {
			return !isSourcesEqual(e.source, source);
		});
		reportEvents(cache);
	}



	/* Manipulation
	-----------------------------------------------------------------------------*/


	function updateEvent(event) { // update an existing event
		var i, len = cache.length, e,
			defaultEventEnd = getView().defaultEventEnd, // getView???
			startDelta = event.start - event._start,
			endDelta = event.end ?
				(event.end - (event._end || defaultEventEnd(event))) // event._end would be null if event.end
				: 0;                                                      // was null and event was just resized
		for (i=0; i<len; i++) {
			e = cache[i];
			if (e._id == event._id && e != event) {
				e.start = new Date(+e.start + startDelta);
				if (event.end) {
					if (e.end) {
						e.end = new Date(+e.end + endDelta);
					}else{
						e.end = new Date(+defaultEventEnd(e) + endDelta);
					}
				}else{
					e.end = null;
				}
				e.title = event.title;
				e.url = event.url;
				e.allDay = event.allDay;
				e.className = event.className;
				e.editable = event.editable;
				e.color = event.color;
				e.backgroundColor = event.backgroundColor;
				e.borderColor = event.borderColor;
				e.textColor = event.textColor;
				normalizeEvent(e);
			}
		}
		normalizeEvent(event);
		reportEvents(cache);
	}


	function renderEvent(event, stick) {
		normalizeEvent(event);
		if (!event.source) {
			if (stick) {
				stickySource.events.push(event);
				event.source = stickySource;
			}
			cache.push(event);
		}
		reportEvents(cache);
	}


	function removeEvents(filter) {
		if (!filter) { // remove all
			cache = [];
			// clear all array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = [];
				}
			}
		}else{
			if (!$.isFunction(filter)) { // an event ID
				var id = filter + '';
				filter = function(e) {
					return e._id == id;
				};
			}
			cache = $.grep(cache, filter, true);
			// remove events from array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = $.grep(sources[i].events, filter, true);
				}
			}
		}
		reportEvents(cache);
	}


	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter) { // an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}



	/* Loading State
	-----------------------------------------------------------------------------*/


	function pushLoading() {
		if (!loadingLevel++) {
			trigger('loading', null, true, getView());
		}
	}


	function popLoading() {
		if (!--loadingLevel) {
			trigger('loading', null, false, getView());
		}
	}



	/* Event Normalization
	-----------------------------------------------------------------------------*/


	function normalizeEvent(event) {
		var source = event.source || {};
		var ignoreTimezone = firstDefined(source.ignoreTimezone, options.ignoreTimezone);
		event._id = event._id || (event.id === undefined ? '_fc' + eventGUID++ : event.id + '');
		if (event.date) {
			if (!event.start) {
				event.start = event.date;
			}
			delete event.date;
		}
		event._start = cloneDate(event.start = parseDate(event.start, ignoreTimezone));
		event.end = parseDate(event.end, ignoreTimezone);
		if (event.end && event.end <= event.start) {
			event.end = null;
		}
		event._end = event.end ? cloneDate(event.end) : null;
		if (event.allDay === undefined) {
			event.allDay = firstDefined(source.allDayDefault, options.allDayDefault);
		}
		if (event.className) {
			if (typeof event.className == 'string') {
				event.className = event.className.split(/\s+/);
			}
		}else{
			event.className = [];
		}
		// TODO: if there is no start date, return false to indicate an invalid event
	}



	/* Utils
	------------------------------------------------------------------------------*/


	function normalizeSource(source) {
		if (source.className) {
			// TODO: repeat code, same code for event classNames
			if (typeof source.className == 'string') {
				source.className = source.className.split(/\s+/);
			}
		}else{
			source.className = [];
		}
		var normalizers = fc.sourceNormalizers;
		for (var i=0; i<normalizers.length; i++) {
			normalizers[i](source);
		}
	}


	function isSourcesEqual(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}


	function getSourcePrimitive(source) {
		return ((typeof source == 'object') ? (source.events || source.url) : '') || source;
	}


}

;;


fc.addDays = addDays;
fc.cloneDate = cloneDate;
fc.parseDate = parseDate;
fc.parseISO8601 = parseISO8601;
fc.parseTime = parseTime;
fc.formatDate = formatDate;
fc.formatDates = formatDates;



/* Date Math
-----------------------------------------------------------------------------*/

var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
	DAY_MS = 86400000,
	HOUR_MS = 3600000,
	MINUTE_MS = 60000;


function addYears(d, n, keepTime) {
	d.setFullYear(d.getFullYear() + n);
	if (!keepTime) {
		clearTime(d);
	}
	return d;
}


function addMonths(d, n, keepTime) { // prevents day overflow/underflow
	if (+d) { // prevent infinite looping on invalid dates
		var m = d.getMonth() + n,
			check = cloneDate(d);
		check.setDate(1);
		check.setMonth(m);
		d.setMonth(m);
		if (!keepTime) {
			clearTime(d);
		}
		while (d.getMonth() != check.getMonth()) {
			d.setDate(d.getDate() + (d < check ? 1 : -1));
		}
	}
	return d;
}


function addDays(d, n, keepTime) { // deals with daylight savings
	if (+d) {
		var dd = d.getDate() + n,
			check = cloneDate(d);
		check.setHours(9); // set to middle of day
		check.setDate(dd);
		d.setDate(dd);
		if (!keepTime) {
			clearTime(d);
		}
		fixDate(d, check);
	}
	return d;
}


function fixDate(d, check) { // force d to be on check's YMD, for daylight savings purposes
	if (+d) { // prevent infinite looping on invalid dates
		while (d.getDate() != check.getDate()) {
			d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
		}
	}
}


function addMinutes(d, n) {
	d.setMinutes(d.getMinutes() + n);
	return d;
}


function clearTime(d) {
	d.setHours(0);
	d.setMinutes(0);
	d.setSeconds(0);
	d.setMilliseconds(0);
	return d;
}


function cloneDate(d, dontKeepTime) {
	if (dontKeepTime) {
		return clearTime(new Date(+d));
	}
	return new Date(+d);
}


function zeroDate() { // returns a Date with time 00:00:00 and dateOfMonth=1
	var i=0, d;
	do {
		d = new Date(1970, i++, 1);
	} while (d.getHours()); // != 0
	return d;
}


function dayDiff(d1, d2) { // d1 - d2
	return Math.round((cloneDate(d1, true) - cloneDate(d2, true)) / DAY_MS);
}


function setYMD(date, y, m, d) {
	if (y !== undefined && y != date.getFullYear()) {
		date.setDate(1);
		date.setMonth(0);
		date.setFullYear(y);
	}
	if (m !== undefined && m != date.getMonth()) {
		date.setDate(1);
		date.setMonth(m);
	}
	if (d !== undefined) {
		date.setDate(d);
	}
}



/* Date Parsing
-----------------------------------------------------------------------------*/


function parseDate(s, ignoreTimezone) { // ignoreTimezone defaults to true
	if (typeof s == 'object') { // already a Date object
		return s;
	}
	if (typeof s == 'number') { // a UNIX timestamp
		return new Date(s * 1000);
	}
	if (typeof s == 'string') {
		if (s.match(/^\d+(\.\d+)?$/)) { // a UNIX timestamp
			return new Date(parseFloat(s) * 1000);
		}
		if (ignoreTimezone === undefined) {
			ignoreTimezone = true;
		}
		return parseISO8601(s, ignoreTimezone) || (s ? new Date(s) : null);
	}
	// TODO: never return invalid dates (like from new Date(<string>)), return null instead
	return null;
}


function parseISO8601(s, ignoreTimezone) { // ignoreTimezone defaults to false
	// derived from http://delete.me.uk/2005/03/iso8601.html
	// TODO: for a know glitch/feature, read tests/issue_206_parseDate_dst.html
	var m = s.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
	if (!m) {
		return null;
	}
    // ATLASSIAN: https://jira.atlassian.com/browse/TEAMCAL-2611
	var date = new Date(m[1], 0, 1, 9, 0);
	if (ignoreTimezone || !m[13]) {
		var check = new Date(m[1], 0, 1, 9, 0);
		if (m[3]) {
			date.setMonth(m[3] - 1);
			check.setMonth(m[3] - 1);
		}
		if (m[5]) {
			date.setDate(m[5]);
			check.setDate(m[5]);
		}
		fixDate(date, check);
		if (m[7]) {
			date.setHours(m[7]);
		}
		if (m[8]) {
			date.setMinutes(m[8]);
		}
		if (m[10]) {
			date.setSeconds(m[10]);
		}
		if (m[12]) {
			date.setMilliseconds(Number("0." + m[12]) * 1000);
		}
		fixDate(date, check);
	}else{
		date.setUTCFullYear(
			m[1],
			m[3] ? m[3] - 1 : 0,
			m[5] || 1
		);
		date.setUTCHours(
			m[7] || 0,
			m[8] || 0,
			m[10] || 0,
			m[12] ? Number("0." + m[12]) * 1000 : 0
		);
		if (m[14]) {
			var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
			offset *= m[15] == '-' ? 1 : -1;
			date = new Date(+date + (offset * 60 * 1000));
		}
	}
	return date;
}


function parseTime(s) { // returns minutes since start of day
	if (typeof s == 'number') { // an hour
		return s * 60;
	}
	if (typeof s == 'object') { // a Date object
		return s.getHours() * 60 + s.getMinutes();
	}
	var m = s.match(/(\d+)(?::(\d+))?\s*(\w+)?/);
	if (m) {
		var h = parseInt(m[1], 10);
		if (m[3]) {
			h %= 12;
			if (m[3].toLowerCase().charAt(0) == 'p') {
				h += 12;
			}
		}
		return h * 60 + (m[2] ? parseInt(m[2], 10) : 0);
	}
}



/* Date Formatting
-----------------------------------------------------------------------------*/
// TODO: use same function formatDate(date, [date2], format, [options])


function formatDate(date, format, options) {
	return formatDates(date, null, format, options);
}


function formatDates(date1, date2, format, options) {
	options = options || defaults;
	var date = date1,
		otherDate = date2,
		i, len = format.length, c,
		i2, formatter,
		res = '';
	for (i=0; i<len; i++) {
		c = format.charAt(i);
		if (c == "'") {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == "'") {
					if (date) {
						if (i2 == i+1) {
							res += "'";
						}else{
							res += format.substring(i+1, i2);
						}
						i = i2;
					}
					break;
				}
			}
		}
		else if (c == '(') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ')') {
					var subres = formatDate(date, format.substring(i+1, i2), options);
					if (parseInt(subres.replace(/\D/, ''), 10)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '[') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ']') {
					var subformat = format.substring(i+1, i2);
					var subres = formatDate(date, subformat, options);
					if (subres != formatDate(otherDate, subformat, options)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '{') {
			date = date2;
			otherDate = date1;
		}
		else if (c == '}') {
			date = date1;
			otherDate = date2;
		}
		else {
			for (i2=len; i2>i; i2--) {
				if (formatter = dateFormatters[format.substring(i, i2)]) {
					if (date) {
						res += formatter(date, options);
					}
					i = i2 - 1;
					break;
				}
			}
			if (i2 == i) {
				if (date) {
					res += c;
				}
			}
		}
	}
	return res;
};


var dateFormatters = {
	s	: function(d)	{ return d.getSeconds() },
	ss	: function(d)	{ return zeroPad(d.getSeconds()) },
	m	: function(d)	{ return d.getMinutes() },
	mm	: function(d)	{ return zeroPad(d.getMinutes()) },
	h	: function(d)	{ return d.getHours() % 12 || 12 },
	hh	: function(d)	{ return zeroPad(d.getHours() % 12 || 12) },
	H	: function(d)	{ return d.getHours() },
	HH	: function(d)	{ return zeroPad(d.getHours()) },
	d	: function(d)	{ return d.getDate() },
	dd	: function(d)	{ return zeroPad(d.getDate()) },
	ddd	: function(d,o)	{ return o.dayNamesShort[d.getDay()] },
	dddd: function(d,o)	{ return o.dayNames[d.getDay()] },
	M	: function(d)	{ return d.getMonth() + 1 },
	MM	: function(d)	{ return zeroPad(d.getMonth() + 1) },
	MMM	: function(d,o)	{ return o.monthNamesShort[d.getMonth()] },
	MMMM: function(d,o)	{ return o.monthNames[d.getMonth()] },
	yy	: function(d)	{ return (d.getFullYear()+'').substring(2) },
	yyyy: function(d)	{ return d.getFullYear() },
	t	: function(d)	{ return d.getHours() < 12 ? 'a' : 'p' },
	tt	: function(d)	{ return d.getHours() < 12 ? 'am' : 'pm' },
	T	: function(d)	{ return d.getHours() < 12 ? 'A' : 'P' },
	TT	: function(d)	{ return d.getHours() < 12 ? 'AM' : 'PM' },
	u	: function(d)	{ return formatDate(d, "yyyy-MM-dd'T'HH:mm:ss'Z'") },
	S	: function(d)	{
		var date = d.getDate();
		if (date > 10 && date < 20) {
			return 'th';
		}
		return ['st', 'nd', 'rd'][date%10-1] || 'th';
	},
	w   : function(d, o) { // local
		return o.weekNumberCalculation(d);
	},
	W   : function(d) { // ISO
		return iso8601Week(d);
	}
};
fc.dateFormatters = dateFormatters;


/* thanks jQuery UI (https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js)
 *
 * Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
 * `date` - the date to get the week for
 * `number` - the number of the week within the year that contains this date
 */
function iso8601Week(date) {
	var time;
	var checkDate = new Date(date.getTime());

	// Find Thursday of this week starting on Monday
	checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

	time = checkDate.getTime();
	checkDate.setMonth(0); // Compare with Jan 1
	checkDate.setDate(1);
	return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
}


;;

fc.applyAll = applyAll;


/* Event Date Math
-----------------------------------------------------------------------------*/


function exclEndDay(event) {
	if (event.end) {
		return _exclEndDay(event.end, event.allDay);
	}else{
		return addDays(cloneDate(event.start), 1);
	}
}


function _exclEndDay(end, allDay) {
	end = cloneDate(end);
	return allDay || end.getHours() || end.getMinutes() ? addDays(end, 1) : clearTime(end);
	// why don't we check for seconds/ms too?
}



/* Event Element Binding
-----------------------------------------------------------------------------*/


function lazySegBind(container, segs, bindHandlers) {
	container.unbind('mouseover').mouseover(function(ev) {
		var parent=ev.target, e,
			i, seg;
		while (parent != this) {
			e = parent;
			parent = parent.parentNode;
		}
		if ((i = e._fci) !== undefined) {
			e._fci = undefined;
			seg = segs[i];
			bindHandlers(seg.event, seg.element, seg);
			$(ev.target).trigger(ev);
		}
		ev.stopPropagation();
	});
}



/* Element Dimensions
-----------------------------------------------------------------------------*/


function setOuterWidth(element, width, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.width(Math.max(0, width - hsides(e, includeMargins)));
	}
}


function setOuterHeight(element, height, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.height(Math.max(0, height - vsides(e, includeMargins)));
	}
}


function hsides(element, includeMargins) {
	return hpadding(element) + hborders(element) + (includeMargins ? hmargins(element) : 0);
}


function hpadding(element) {
	return (parseFloat($.css(element[0], 'paddingLeft', true)) || 0) +
	       (parseFloat($.css(element[0], 'paddingRight', true)) || 0);
}


function hmargins(element) {
	return (parseFloat($.css(element[0], 'marginLeft', true)) || 0) +
	       (parseFloat($.css(element[0], 'marginRight', true)) || 0);
}


function hborders(element) {
	return (parseFloat($.css(element[0], 'borderLeftWidth', true)) || 0) +
	       (parseFloat($.css(element[0], 'borderRightWidth', true)) || 0);
}


function vsides(element, includeMargins) {
	return vpadding(element) +  vborders(element) + (includeMargins ? vmargins(element) : 0);
}


function vpadding(element) {
	return (parseFloat($.css(element[0], 'paddingTop', true)) || 0) +
	       (parseFloat($.css(element[0], 'paddingBottom', true)) || 0);
}


function vmargins(element) {
	return (parseFloat($.css(element[0], 'marginTop', true)) || 0) +
	       (parseFloat($.css(element[0], 'marginBottom', true)) || 0);
}


function vborders(element) {
	return (parseFloat($.css(element[0], 'borderTopWidth', true)) || 0) +
	       (parseFloat($.css(element[0], 'borderBottomWidth', true)) || 0);
}



/* Misc Utils
-----------------------------------------------------------------------------*/


//TODO: arraySlice
//TODO: isFunction, grep ?


function noop() { }


function dateCompare(a, b) {
	return a - b;
}


function arrayMax(a) {
	return Math.max.apply(Math, a);
}


function zeroPad(n) {
	return (n < 10 ? '0' : '') + n;
}


function smartProperty(obj, name) { // get a camel-cased/namespaced property of an object
	if (obj[name] !== undefined) {
		return obj[name];
	}
	var parts = name.split(/(?=[A-Z])/),
		i=parts.length-1, res;
	for (; i>=0; i--) {
		res = obj[parts[i].toLowerCase()];
		if (res !== undefined) {
			return res;
		}
	}
	return obj[''];
}


function htmlEscape(s) {
	return s.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function disableTextSelection(element) {
	element
		.attr('unselectable', 'on')
		.css('MozUserSelect', 'none')
		.bind('selectstart.ui', function() { return false; });
}


/*
function enableTextSelection(element) {
	element
		.attr('unselectable', 'off')
		.css('MozUserSelect', '')
		.unbind('selectstart.ui');
}
*/


function markFirstLast(e) {
	e.children()
		.removeClass('fc-first fc-last')
		.filter(':first-child')
			.addClass('fc-first')
		.end()
		.filter(':last-child')
			.addClass('fc-last');
}


function setDayID(cell, date) {
	cell.each(function(i, _cell) {
		_cell.className = _cell.className.replace(/^fc-\w*/, 'fc-' + dayIDs[date.getDay()]);
		// TODO: make a way that doesn't rely on order of classes
	});
}


function getSkinCss(event, opt) {
	var source = event.source || {};
	var eventColor = event.color;
	var sourceColor = source.color;
	var optionColor = opt('eventColor');
	var backgroundColor =
		event.backgroundColor ||
		eventColor ||
		source.backgroundColor ||
		sourceColor ||
		opt('eventBackgroundColor') ||
		optionColor;
	var borderColor =
		event.borderColor ||
		eventColor ||
		source.borderColor ||
		sourceColor ||
		opt('eventBorderColor') ||
		optionColor;
	var textColor =
		event.textColor ||
		source.textColor ||
		opt('eventTextColor');
	var statements = [];
	if (backgroundColor) {
		statements.push('background-color:' + backgroundColor);
	}
	if (borderColor) {
		statements.push('border-color:' + borderColor);
	}
	if (textColor) {
		statements.push('color:' + textColor);
	}
	return statements.join(';');
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}

//ATLASSIAN - "plugin point" for the timeline view
fcViews.timeline = TimelineView;

function TimelineView(element, calendar) {

    var t = this;
    t.name = "timeline";
    t.render = render;
    t.title = "";

    var timeline = calendarDependencyHelper.getTimelineAdapter(element, calendar.options._calendarPlugin, calendar.options._calendarDiv, t);

    function render(date, delta) {
        timeline.setDate(date);
    }

    t.update = function() {
        calendar.refetchEvents(true);
    };

    t.unselect = function() {
        //Do nothing.
    };

    t.setHeight = function() {
        //Do nothing.
    };

    t.setWidth = function() {
        //Do nothing.
    };

    t.clearEvents = function() {
        //Do nothing.
    };

    t.renderEvents = function(events) {
        timeline.renderEvents(events);
    };

    t.trigger = function(name, thisObj) {
        return calendar.trigger.apply(
            calendar,
            [name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
        );
    };

    t.next = function() {
        timeline.next();
    };

    t.prev = function() {
        timeline.prev();
    };

    t.gotoDate = function(date) {
        calendar.gotoDate(date);
    };

    t.triggerEventDestroy = function() {
        //Do nothing.
    };

    t.clearEventData = function() {
        //Do nothing.
    };

    t.setEventData = function(events) {
        timeline.renderEvents(events);
    };

    t.element = $(".fc-view-timeline");
}

///////////// END ATLASSIAN


fcViews.month = MonthView;

function MonthView(element, calendar) {
	var t = this;


	// exports
	t.render = render;


	// imports
	BasicView.call(t, element, calendar, 'month');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDate = calendar.formatDate;


	function render(date, delta) {

		if (delta) {
			addMonths(date, delta);
			date.setDate(1);
		}

		var firstDay = opt('firstDay');

		var start = cloneDate(date, true);
		start.setDate(1);

		var end = addMonths(cloneDate(start), 1);

		var visStart = cloneDate(start);
		addDays(visStart, -((visStart.getDay() - firstDay + 7) % 7));
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		addDays(visEnd, (7 - visEnd.getDay() + firstDay) % 7);
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();
		var rowCnt = Math.round(dayDiff(visEnd, visStart) / 7); // should be no need for Math.round

		if (opt('weekMode') == 'fixed') {
			addDays(visEnd, (6 - rowCnt) * 7); // add weeks to make up for it
			rowCnt = 6;
		}

		t.title = formatDate(start, opt('titleFormat'));

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		renderBasic(rowCnt, colCnt, true);
	}


}

;;

fcViews.basicWeek = BasicWeekView;

function BasicWeekView(element, calendar) {
	var t = this;


	// exports
	t.render = render;


	// imports
	BasicView.call(t, element, calendar, 'basicWeek');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDates = calendar.formatDates;


	function render(date, delta) {

		if (delta) {
			addDays(date, delta * 7);
		}

		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);

		var visStart = cloneDate(start);
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);

		renderBasic(1, colCnt, false);
	}


}

;;

fcViews.basicDay = BasicDayView;


function BasicDayView(element, calendar) {
	var t = this;


	// exports
	t.render = render;

    //for times load this function
    var timesLoadRenderEventsInternal = 0;

    // ATLASSIAN - TEAMCAL-2280
    var isAlreadyHasEvent = false;
    // END ATLASSIAN - TEAMCAL-2280

	// imports
	BasicView.call(t, element, calendar, 'basicDay');
	var opt = t.opt,
        renderBasic = t.renderBasic,
        skipHiddenDays = t.skipHiddenDays,
        formatDate = calendar.formatDate,
        //ATLASSIAN - Start hijacking basic day view for list view
        calendarDiv = calendar.options._calendarDiv,
        CalendarPlugin = calendar.options._calendarPlugin,
        dayMillis = 1000 * 60 * 60 * 24,
        visDaysSpan = parseInt(CalendarPlugin.getParameter(calendarDiv, "maxUpcomingDays")),
        eventsListContainer = $("<div/>").appendTo(element),
        autoAdjustUpcomingEventsHeight = CalendarPlugin.getParameter(calendarDiv, "autoAdjustUpcomingEventsHeight") === "true",
        hideMoreEventsButtonInUpcomingEventsOnClick = CalendarPlugin.getParameter(calendarDiv, "hideMoreEventsButtonInUpcomingEventsOnClick") === "true",
        adjustHeight = function() {
            if (autoAdjustUpcomingEventsHeight)
                element.css({
                    "height": ($(".events-container", eventsListContainer).height() + 5) + "px", // Adding 5px so the bottom border of the more button doesn't get cropped off.
                    "overflow": "hidden"
                });
        },
        stopCreatingToggleableEvents = false,
        daysMore = visDaysSpan;

    var renderEventsInternal = function(someEvents, visStart, visEnd) {

        if (someEvents.length) {
            // TEAMCAL-2280
            eventsListContainer.empty();
            isAlreadyHasEvent = true;
            // END TEAMCAL-2280


            var fillingEvents = [],
                currentStart = new Date(),
                currentEnd = new Date();

            element.removeClass("no-event");

            $.each(someEvents, function(baseEventIdx, baseEvent) {
                var isAllDayEvent = baseEvent.allDay;

                if (baseEvent.expandDates && baseEvent.end && baseEvent.end.getTime() - baseEvent.start.getTime() >= dayMillis) {
                    var baseEnd = baseEvent.end;

                    currentStart.setTime(baseEvent.start.getTime() + dayMillis);
                    if (isAllDayEvent) {
                        // End date is inclusive for all day events
                        while (currentStart <= baseEnd) {
                            currentEnd.setTime(currentStart.getTime() + dayMillis);

                            if (currentStart >= visStart && currentEnd <= visEnd)
                                fillingEvents.push($.extend({}, baseEvent, {
                                    "start" : new Date(currentStart.getTime()),
                                    "end" : new Date(currentEnd.getTime()),
                                    "expanded" : true
                                }));

                            currentStart.setTime(currentEnd.getTime());
                        }
                    } else {
                        // End date is exclusive for non all day events
                        while (currentStart < baseEnd) {
                            currentEnd.setTime(currentStart.getTime() + Math.min(baseEnd.getTime() - currentStart.getTime(), dayMillis));

                            if (currentStart >= visStart && currentEnd <= visEnd)
                                fillingEvents.push($.extend({}, baseEvent, {
                                    "start" : new Date(currentStart.getTime()),
                                    "end" : new Date(currentEnd.getTime()),
                                    "allDay" : currentEnd.getTime() - currentStart.getTime() >= dayMillis,
                                    "showLastIndicator" : currentEnd >= baseEnd,
                                    "expanded" : true
                                }));

                            currentStart.setTime(currentEnd.getTime());
                        }
                    }
                }
            });

            $.each(fillingEvents, function(fillEventIdx, fillEvent) {
                someEvents.push(fillEvent);
            });

            someEvents.sort(function(leftEvent, rightEvent) {
                var result = leftEvent.expanded === rightEvent.expanded ? 0 : (leftEvent.expanded ? 1 : -1); // Start of events go first
                if (0 == result)
                    result = leftEvent.allDay === rightEvent.allDay ? 0 : (leftEvent.allDay ? 1 : -1);
                if (0 === result)
                    result = leftEvent.start.getTime() - rightEvent.start.getTime();
                if (0 == result)
                    result = leftEvent.title > rightEvent.title ? 1 : (rightEvent.title > leftEvent.title ? -1 : 0);
                if (0 == result)
                    result = leftEvent.subCalendarId > rightEvent.subCalendarId ? 1 : (rightEvent.subCalendarId > leftEvent.subCalendarId ? -1 : 0);

                return result;
            });

            someEvents = $.grep(someEvents, function(someEvent) {
                return someEvent.start >= visStart;
            });

            var eventGroups = {};

            // Group events based on start date.
            $.each(someEvents, function(eventIdx, anEvent) {
                var todayDate = formatDate(new Date(), "yyyyMMdd"),
                    groupKey = formatDate(anEvent.start, "yyyyMMdd"),
                    eventGroup = eventGroups[groupKey],
                    groupEvents;

                if (!eventGroups[groupKey]) {
                    eventGroup = {
                        "today": groupKey === todayDate,
                        "groupKey" : groupKey,
                        "groupDay" : groupKey.substring(6),
                        "dateFormatKey" : groupKey.substring(6) + groupKey.substring(4, 6) + groupKey.substring(0, 4),
                        "events": [ anEvent ]
                    };
                    eventGroups[groupKey] = eventGroup;
                } else {
                    groupEvents = eventGroup.events;
                    groupEvents.push(anEvent);
                }
            });

            // Display only up to X number of events a day.
            var maxEventsPerDay = parseInt(CalendarPlugin.getParameter(calendarDiv, "maxEventsPerUpcomingDay")),
                eventIdMap = {},
                subCalendarsMap = {};

            $.each(eventGroups, function(groupKey, eventGroup) {
                var events = eventGroup.events;
                if (events && events.length && events.length > maxEventsPerDay) {
                    eventGroup.hiddenEventsCount = events.length - maxEventsPerDay;
                    eventGroup.events = events.slice(0, maxEventsPerDay);
                }
                eventGroup.events = $.map(eventGroup.events, function(anEvent) {
                    var subCalendar = subCalendarsMap[anEvent.subCalendarId] || CalendarPlugin.getSubCalendar(calendarDiv, anEvent.subCalendarId),
                        parentSubCalendar = subCalendarsMap[subCalendar.parentId] || CalendarPlugin.getSubCalendar(calendarDiv, subCalendar.parentId),
                        mappedEvent = $.extend(
                        {
                            "subCalendar" : subCalendar,
                            "parentSubCalendar" : parentSubCalendar
                        },
                        anEvent);

                    subCalendarsMap[subCalendar.id] = subCalendar;
                    if (parentSubCalendar)
                        subCalendarsMap[parentSubCalendar.id] = parentSubCalendar;

                    eventIdMap[mappedEvent.id] = mappedEvent;
                    return mappedEvent;
                });
            });

            // Create an array that will be used as a guide to process event groups in ascending order.
            var groupKeys = [];
            $.each(eventGroups, function(groupKey) {
                groupKeys.push(groupKey);
            });
            groupKeys.sort(function(leftGroupKey, rightGroupKey) {
               return leftGroupKey > rightGroupKey ? 1 :  (rightGroupKey > leftGroupKey ? -1 : 0);
            });

            var upcomingEventsContainer = $("<div/>").html(
                calendarDependencyHelper.Templates().upcomingEvents({
                    "eventGroups" :$.map(groupKeys, function(groupKey) { return eventGroups[groupKey]; })
                })
            ), moreEventsButton = $(".more-events", upcomingEventsContainer).click(function() {
                var eventsContainer = $(".events-container", upcomingEventsContainer),
                    moreEventsButtonTopOffset = moreEventsButton.offset().top - eventsContainer.offset().top + eventsContainer.scrollTop(),
                    toggleables = $(".toggleable", upcomingEventsContainer);

                if (toggleables.length) {
                    toggleables.removeClass("hidden toggleable");
                    element.animate({ "scrollTop" : moreEventsButtonTopOffset });
                    if (hideMoreEventsButtonInUpcomingEventsOnClick) {
                        moreEventsButton.addClass("hidden");
                        element.css("overflow", "auto");
                    } else {
                        adjustHeight();
                    }
                } else {
                    moreEventsButton.prop("disabled", "disabled").text("\u6b63\u5728\u52a0\u8f7d...");

                    $.ajax({
                        cache: false,
                        converters : {
                            "text json" : function(jsonObject) {
                                return jsonObject;
                            }
                        },
                        data : {
                            "subCalendarIds" : (function() {
                                return $.map(
                                    $(".child-subcalendar", calendarDiv).filter(function() {
                                        return !$(this).hasClass("subcalendar-disabled");
                                    }),
                                    function(childSubCalendarElem) {
                                        return $(childSubCalendarElem).data("subCalendarId");
                                    }
                                );
                            })(),
                            "userTimeZoneId" : calendarDependencyHelper.getUserTimeZone(),
                            "start" : formatDate(visStart, "u"),
                            "daysMore" : daysMore += visDaysSpan
                        },
                        dataFilter : function(eventsUnnormalizedJson) {
                            var normalizedEvents = $.parseJSON(eventsUnnormalizedJson || "[]");

                            $.each(normalizedEvents, function(eventIndex, event) {
                                calendar.normalizeEvent(event);
                            });

                            return normalizedEvents;
                        },
                        dataType : "json",
                        error : function(jqXHR, textStatus, errorThrown) {
                            CalendarPlugin.showAjaxError(calendarDiv, jqXHR, textStatus, errorThrown);
                        },
                        success: function(events) {
                            events = CalendarPlugin.getEventsTruncated(calendarDiv, events || [], true);

                            var _visEnd = new Date(visStart.getTime() + (daysMore * dayMillis));
                            renderEventsInternal(events, visStart, _visEnd);
                            $(".more-events", eventsListContainer).before(
                                $("<div/>", {
                                    "class": "showing-events-till",
                                    "text" : AJS.format(
                                        "\u663e\u793a\u76f4\u5230{0}\u4e3a\u6b62\u7684\u4e8b\u5b9c",
                                        formatDate(_visEnd, "dd MMM yyyy")
                                    )
                                })
                            );
                            adjustHeight();
                        },
                        type: "GET",
                        url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/events/multiplexed.json")
                    });
                }

                // So we won't hide events the next time the events are rendered.
                return !(stopCreatingToggleableEvents = true);
            });

            // Render!
            eventsListContainer.append(upcomingEventsContainer);
            // Ellipsis on event description needs to be done after the elements are rendered in the browser.
            $(".event-description", upcomingEventsContainer).ThreeDots({ max_rows: 1 });

            $(".events li", upcomingEventsContainer).each(function(indexOfEventElement) {
                var eventElement = $(this);
                if (!stopCreatingToggleableEvents && indexOfEventElement >= 10 && !eventElement.prev().length) {
                    var eventGroup = eventElement.closest(".event-group");
                    if (!eventGroup.hasClass("toggleable"))
                        eventGroup.addClass("toggleable");
                }

                CalendarPlugin.getEventDetailsDialog(
                    calendarDiv,
                    eventIdMap[$(this).attr("data-event-id")],
                    eventElement.hover(
                            function() { eventElement.addClass("highlighted"); CalendarPlugin.hideInlineAuiDialogs(); },
                            function() { eventElement.removeClass("highlighted"); }
                    ),
                    {
                        hideDelay : 10000,
                        noBind : false
                    }
                );
            });

            var toggleables = $(".toggleable", upcomingEventsContainer).addClass("hidden");
            if (toggleables.length || !hideMoreEventsButtonInUpcomingEventsOnClick)
                moreEventsButton.removeClass("hidden");

            adjustHeight();
            // Format dates
            var formatDateDisplay = function(pattern, aDateDisplay) {
                var groupDate = aDateDisplay.attr("data-group-date");
                aDateDisplay.text(formatDate(
                    new Date(parseInt(groupDate.substring(4)), parseInt(groupDate.substring(2, 4), 10) - 1, parseInt(groupDate.substring(0, 2), 10)),
                    pattern
                ));
            };
            $(".other-days", upcomingEventsContainer).each(function() {
                formatDateDisplay("dddd", $(this));
            });
            $(".day", upcomingEventsContainer).each(function() {
                formatDateDisplay("dd", $(this));
            });
            $(".month", upcomingEventsContainer).each(function() {
                formatDateDisplay("MMM", $(this));
            });
        } else {
            if (timesLoadRenderEventsInternal > 1 && !isAlreadyHasEvent) {
                // ATLASSIAN TEAMCAL-2280
                eventsListContainer.empty();
                // END ATLASSIAN TEAMCAL-2280
                $("<div/>", { "text" : AJS.format("\u672a\u6765{0}\u5929\u5185\u6ca1\u6709\u5f85\u529e\u4e8b\u5b9c", visDaysSpan) }).appendTo(eventsListContainer.empty());
            } else {
                if (!isAlreadyHasEvent) {
                    // ATLASSIAN TEAMCAL-2280
                    eventsListContainer.empty();
                    timesLoadRenderEventsInternal = timesLoadRenderEventsInternal + 1;
                    window.setTimeout(function () {
                        t.renderEvents([]);
                    }, 1000);

                    $("<span class='calendar-upcoming-spinner aui-icon aui-icon-wait'>Loading...</span>").appendTo(eventsListContainer.empty());
                    // END ATLASSIAN TEAMCAL-2280
                }
            }
        }
    };

    $("<div/>", { "class" : "no-events-message", "text" : "\u6b63\u5728\u52a0\u8f7d..." }).appendTo(eventsListContainer);

    t.renderEvents = function(events) {
        // Make text in view selectable.
        element.css("MozUserSelect", "text").attr("unselectable", "off").unbind("selectstart.ui");
        var visEnd = new Date(t.visStart.getTime() + dayMillis * (daysMore = visDaysSpan));
        renderEventsInternal(
                (function(_events, rangeStart, rangeEnd) {
                    var filteredEvents = [];
                    var isInViewRange = function(_event) {
                        if (_event.allDay) {
                            return (_event.start >= rangeStart && _event.start < rangeEnd)
                                    || (_event.start < rangeStart && _event.end >= rangeStart)
                                    || (_event.start >= rangeEnd && _event.start < rangeEnd);
                        } else {
                            return (_event.start >= rangeStart && _event.start < rangeEnd)
                                    || (_event.start < rangeStart && _event.end > rangeStart)
                                    || (_event.start >= rangeEnd && _event.start < rangeEnd);
                        }
                    };

                    $.each(_events, function(eventIdx, event) {
                        if (isInViewRange(event))
                            filteredEvents.push(event);
                    });

                    return filteredEvents;
                })(events, t.visStart, visEnd),
                t.visStart,
                visEnd
        );
    };
    //END ATLASSIAN


	function render(date, delta) {

		if (delta) {
			addDays(date, delta);
		}
		skipHiddenDays(date, delta < 0 ? -1 : 1);

		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);

		t.title = formatDate(date, opt('titleFormat'));

		t.start = t.visStart = start;
		t.end = t.visEnd = end;

		renderBasic(1, 1, false);
	}


}

;;

setDefaults({
	weekMode: 'fixed'
});


function BasicView(element, calendar, viewName) {
	var t = this;


	// exports
	t.renderBasic = renderBasic;
	t.setHeight = setHeight;
	t.setWidth = setWidth;
	t.renderDayOverlay = renderDayOverlay;
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // for selection (kinda hacky)
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	t.defaultEventEnd = defaultEventEnd;
	t.getHoverListener = function() { return hoverListener };
	t.colLeft = colLeft;
	t.colRight = colRight;
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getIsCellAllDay = function() { return true };
	t.allDayRow = allDayRow;
	t.getRowCnt = function() { return rowCnt };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getDaySegmentContainer = function() { return daySegmentContainer };


	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	BasicEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var daySelectionMousedown = t.daySelectionMousedown;
	var cellToDate = t.cellToDate;
	var dateToCell = t.dateToCell;
	var rangeToSegments = t.rangeToSegments;
	var formatDate = calendar.formatDate;


	// locals

	var table;
	var head;
	var headCells;
	var body;
	var bodyRows;
	var bodyCells;
	var bodyFirstCells;
	var firstRowCellInners;
	var firstRowCellContentInners;
	var daySegmentContainer;

	var viewWidth;
	var viewHeight;
	var colWidth;
	var weekNumberWidth;

	var rowCnt, colCnt;
	var showNumbers;
	var coordinateGrid;
	var hoverListener;
	var colPositions;
	var colContentPositions;

	var tm;
	var colFormat;
	var showWeekNumbers;
	var weekNumberTitle;
	var weekNumberFormat;



	/* Rendering
	------------------------------------------------------------*/


	disableTextSelection(element.addClass('fc-grid'));


	function renderBasic(_rowCnt, _colCnt, _showNumbers) {
		rowCnt = _rowCnt;
		colCnt = _colCnt;
		showNumbers = _showNumbers;
		updateOptions();

		if (!body) {
			buildEventContainer();
		}

		buildTable();
	}


	function updateOptions() {
		tm = opt('theme') ? 'ui' : 'fc';
		colFormat = opt('columnFormat');

		// week # options. (TODO: bad, logic also in other views)
		showWeekNumbers = opt('weekNumbers');
		weekNumberTitle = opt('weekNumberTitle');
		if (opt('weekNumberCalculation') != 'iso') {
			weekNumberFormat = "w";
		}
		else {
			weekNumberFormat = "W";
		}
	}


	function buildEventContainer() {
		daySegmentContainer =
			$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(element);
	}


	function buildTable() {
		var html = buildTableHTML();

		if (table) {
			table.remove();
		}
		table = $(html).appendTo(element);

		head = table.find('thead');
		headCells = head.find('.fc-day-header');
		body = table.find('tbody');
		bodyRows = body.find('tr');
		bodyCells = body.find('.fc-day');
		bodyFirstCells = bodyRows.find('td:first-child');

		firstRowCellInners = bodyRows.eq(0).find('.fc-day > div');
		firstRowCellContentInners = bodyRows.eq(0).find('.fc-day-content > div');

		markFirstLast(head.add(head.find('tr'))); // marks first+last tr/th's
		markFirstLast(bodyRows); // marks first+last td's
		bodyRows.eq(0).addClass('fc-first');
		bodyRows.filter(':last').addClass('fc-last');

		bodyCells.each(function(i, _cell) {
			var date = cellToDate(
				Math.floor(i / colCnt),
				i % colCnt
			);
			trigger('dayRender', t, date, $(_cell));
		});

		dayBind(bodyCells);
	}



	/* HTML Building
	-----------------------------------------------------------*/


	function buildTableHTML() {
		var html =
			"<table class='fc-border-separate' style='width:100%' cellspacing='0'>" +
			buildHeadHTML() +
			buildBodyHTML() +
			"</table>";

		return html;
	}


	function buildHeadHTML() {
		var headerClass = tm + "-widget-header";
		var html = '';
		var col;
		var date;

		html += "<thead><tr>";

		if (showWeekNumbers) {
			html +=
				"<th class='fc-week-number " + headerClass + "'>" +
				htmlEscape(weekNumberTitle) +
				"</th>";
		}

		for (col=0; col<colCnt; col++) {
			date = cellToDate(0, col);
			html +=
				"<th class='fc-day-header fc-" + dayIDs[date.getDay()] + " " + headerClass + "'>" +
				htmlEscape(formatDate(date, colFormat)) +
				"</th>";
		}

		html += "</tr></thead>";

		return html;
	}


	function buildBodyHTML() {
		var contentClass = tm + "-widget-content";
		var html = '';
		var row;
		var col;
		var date;

		html += "<tbody>";

		for (row=0; row<rowCnt; row++) {

			html += "<tr class='fc-week'>";

			if (showWeekNumbers) {
				date = cellToDate(row, 0);
				html +=
					"<td class='fc-week-number " + contentClass + "'>" +
					"<div>" +
					htmlEscape(formatDate(date, weekNumberFormat)) +
					"</div>" +
					"</td>";
			}

			for (col=0; col<colCnt; col++) {
				date = cellToDate(row, col);
				html += buildCellHTML(date);
			}

			html += "</tr>";
		}

		html += "</tbody>";

		return html;
	}


	function buildCellHTML(date) {
		var contentClass = tm + "-widget-content";
		var month = t.start.getMonth();
		var today = clearTime(new Date());
		var html = '';
		var classNames = [
			'fc-day',
			'fc-' + dayIDs[date.getDay()],
			contentClass
		];

		if (date.getMonth() != month) {
			classNames.push('fc-other-month');
		}
		if (+date == +today) {
			classNames.push(
				'fc-today',
				tm + '-state-highlight'
			);
		}
		else if (date < today) {
			classNames.push('fc-past');
		}
		else {
			classNames.push('fc-future');
		}

		html +=
			"<td" +
			" class='" + classNames.join(' ') + "'" +
			" data-date='" + formatDate(date, 'yyyy-MM-dd') + "'" +
			">" +
			"<div>";

		if (showNumbers) {
			html += "<div class='fc-day-number'>" + date.getDate() + "</div>";
		}

		html +=
			"<div class='fc-day-content'>" +
			"<div style='position:relative'>&nbsp;</div>" +
			"</div>" +
			"</div>" +
			"</td>";

		return html;
	}



	/* Dimensions
	-----------------------------------------------------------*/


	function setHeight(height) {
		viewHeight = height;

		var bodyHeight = viewHeight - head.height();
		var rowHeight;
		var rowHeightLast;
		var cell;

		if (opt('weekMode') == 'variable') {
			rowHeight = rowHeightLast = Math.floor(bodyHeight / (rowCnt==1 ? 2 : 6));
		}else{
			rowHeight = Math.floor(bodyHeight / rowCnt);
			rowHeightLast = bodyHeight - rowHeight * (rowCnt-1);
		}

		bodyFirstCells.each(function(i, _cell) {
			if (i < rowCnt) {
				cell = $(_cell);
				cell.find('> div').css(
					'min-height',
					(i==rowCnt-1 ? rowHeightLast : rowHeight) - vsides(cell)
				);
			}
		});

	}


	function setWidth(width) {
		viewWidth = width;
		colPositions.clear();
		colContentPositions.clear();

		weekNumberWidth = 0;
		if (showWeekNumbers) {
			weekNumberWidth = head.find('th.fc-week-number').outerWidth();
		}

		colWidth = Math.floor((viewWidth - weekNumberWidth) / colCnt);
		setOuterWidth(headCells.slice(0, -1), colWidth);
	}



	/* Day clicking and binding
	-----------------------------------------------------------*/


	function dayBind(days) {
		days.click(dayClick)
			.mousedown(daySelectionMousedown);
	}


	function dayClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var date = parseISO8601($(this).data('date'));
			trigger('dayClick', this, date, true, ev);
		}
	}



	/* Semi-transparent Overlay Helpers
	------------------------------------------------------*/
	// TODO: should be consolidated with AgendaView's methods


	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive

		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}

		var segments = rangeToSegments(overlayStart, overlayEnd);

		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			dayBind(
				renderCellOverlay(
					segment.row,
					segment.leftCol,
					segment.row,
					segment.rightCol
				)
			);
		}
	}


	function renderCellOverlay(row0, col0, row1, col1) { // row1,col1 is inclusive
		var rect = coordinateGrid.rect(row0, col0, row1, col1, element);
		return renderOverlay(rect, element);
	}



	/* Selection
	-----------------------------------------------------------------------*/


	function defaultSelectionEnd(startDate, allDay) {
		return cloneDate(startDate);
	}


	function renderSelection(startDate, endDate, allDay) {
		renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true); // rebuild every time???
	}


	function clearSelection() {
		clearOverlays();
	}


	function reportDayClick(date, allDay, ev) {
		var cell = dateToCell(date);
		var _element = bodyCells[cell.row*colCnt + cell.col];
		trigger('dayClick', _element, date, allDay, ev);
	}



	/* External Dragging
	-----------------------------------------------------------------------*/


	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
			}
		}, ev);
	}


	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			var d = cellToDate(cell);
			trigger('drop', _dragElement, d, true, ev, ui);
		}
	}



	/* Utilities
	--------------------------------------------------------*/


	function defaultEventEnd(event) {
		return cloneDate(event.start);
	}


	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		headCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		bodyRows.each(function(i, _e) {
			if (i < rowCnt) {
				e = $(_e);
				n = e.offset().top;
				if (i) {
					p[1] = n;
				}
				p = [n];
				rows[i] = p;
			}
		});
		p[1] = n + e.outerHeight();
	});


	hoverListener = new HoverListener(coordinateGrid);

	colPositions = new HorizontalPositionCache(function(col) {
		return firstRowCellInners.eq(col);
	});

	colContentPositions = new HorizontalPositionCache(function(col) {
		return firstRowCellContentInners.eq(col);
	});


	function colLeft(col) {
		return colPositions.left(col);
	}


	function colRight(col) {
		return colPositions.right(col);
	}


	function colContentLeft(col) {
		return colContentPositions.left(col);
	}


	function colContentRight(col) {
		return colContentPositions.right(col);
	}


	function allDayRow(i) {
		return bodyRows.eq(i);
	}

}

;;

function BasicEventRenderer() {
	var t = this;


	// exports
	t.renderEvents = renderEvents;
	t.clearEvents = clearEvents;


	// imports
	DayEventRenderer.call(t);


	function renderEvents(events, modifiedEventId) {
		t.renderDayEvents(events, modifiedEventId);
	}


	function clearEvents() {
		t.getDaySegmentContainer().empty();
	}


	// TODO: have this class (and AgendaEventRenderer) be responsible for creating the event container div

}

;;

fcViews.agendaWeek = AgendaWeekView;

function AgendaWeekView(element, calendar) {
	var t = this;


	// exports
	t.render = render;


	// imports
	AgendaView.call(t, element, calendar, 'agendaWeek');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDates = calendar.formatDates;


	function render(date, delta) {

		if (delta) {
			addDays(date, delta * 7);
		}

		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);

		var visStart = cloneDate(start);
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();

		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		renderAgenda(colCnt);
	}

}

;;

fcViews.agendaDay = AgendaDayView;


function AgendaDayView(element, calendar) {
	var t = this;


	// exports
	t.render = render;


	// imports
	AgendaView.call(t, element, calendar, 'agendaDay');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var skipHiddenDays = t.skipHiddenDays;
	var formatDate = calendar.formatDate;


	function render(date, delta) {

		if (delta) {
			addDays(date, delta);
		}
		skipHiddenDays(date, delta < 0 ? -1 : 1);

		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);

		t.title = formatDate(date, opt('titleFormat'));

		t.start = t.visStart = start;
		t.end = t.visEnd = end;

		renderAgenda(1);
	}


}

;;

setDefaults({
	allDaySlot: true,
	allDayText: 'all-day',
	firstHour: 6,
	slotMinutes: 30,
	defaultEventMinutes: 30, //TEAMCAL-543 to display in view week mode 30mins if don't have end field
    //ATLASSIAN - TEAMCAL-258: change display format time
    axisFormat: calendarDependencyHelper.isDisplayTimeFormat24hour() === true ? 'HH:mm' : 'h(:mm)tt',
    //END ATLASSIAN - TEAMCAL-258: change display format time
	timeFormat: {
         //ATLASSIAN - TEAMCAL-258: change display format time
        agenda: calendarDependencyHelper.isDisplayTimeFormat24hour() === true ? 'HH:mm{ - HH:mm}' : 'h:mm{ - h:mm}'
        //END ATLASSIAN - TEAMCAL-258: change display format time
	},
	dragOpacity: {
		agenda: .5
	},
	minTime: 0,
	maxTime: 24,
	slotEventOverlap: true
});


// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6


function AgendaView(element, calendar, viewName) {
	var t = this;


	// exports
	t.renderAgenda = renderAgenda;
	t.setWidth = setWidth;
	t.setHeight = setHeight;
	t.afterRender = afterRender;
	t.defaultEventEnd = defaultEventEnd;
	t.timePosition = timePosition;
	t.getIsCellAllDay = getIsCellAllDay;
	t.allDayRow = getAllDayRow;
	t.getCoordinateGrid = function() { return coordinateGrid }; // specifically for AgendaEventRenderer
	t.getHoverListener = function() { return hoverListener };
	t.colLeft = colLeft;
	t.colRight = colRight;
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	t.getSlotSegmentContainer = function() { return slotSegmentContainer };
	t.getMinMinute = function() { return minMinute };
	t.getMaxMinute = function() { return maxMinute };
	t.getSlotContainer = function() { return slotContainer };
	t.getRowCnt = function() { return 1 };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getSnapHeight = function() { return snapHeight };
	t.getSnapMinutes = function() { return snapMinutes };
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderDayOverlay = renderDayOverlay;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // selection mousedown hack
	t.dragStart = dragStart;
	t.dragStop = dragStop;


	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	AgendaEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var reportSelection = t.reportSelection;
	var unselect = t.unselect;
	var daySelectionMousedown = t.daySelectionMousedown;
	var slotSegHtml = t.slotSegHtml;
	var cellToDate = t.cellToDate;
	var dateToCell = t.dateToCell;
	var rangeToSegments = t.rangeToSegments;
	var formatDate = calendar.formatDate;


	// locals

	var dayTable;
	var dayHead;
	var dayHeadCells;
	var dayBody;
	var dayBodyCells;
	var dayBodyCellInners;
	var dayBodyCellContentInners;
	var dayBodyFirstCell;
	var dayBodyFirstCellStretcher;
	var slotLayer;
	var daySegmentContainer;
	var allDayTable;
	var allDayRow;
	var slotScroller;
	var slotContainer;
	var slotSegmentContainer;
	var slotTable;
	var selectionHelper;

	var viewWidth;
	var viewHeight;
	var axisWidth;
	var colWidth;
	var gutterWidth;
	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)

	var snapMinutes;
	var snapRatio; // ratio of number of "selection" slots to normal slots. (ex: 1, 2, 4)
	var snapHeight; // holds the pixel hight of a "selection" slot

	var colCnt;
	var slotCnt;
	var coordinateGrid;
	var hoverListener;
	var colPositions;
	var colContentPositions;
	var slotTopCache = {};

	var tm;
	var rtl;
	var minMinute, maxMinute;
	var colFormat;
	var showWeekNumbers;
	var weekNumberTitle;
	var weekNumberFormat;



	/* Rendering
	-----------------------------------------------------------------------------*/


	disableTextSelection(element.addClass('fc-agenda'));


	function renderAgenda(c) {
		colCnt = c;
		updateOptions();

		if (!dayTable) { // first time rendering?
			buildSkeleton(); // builds day table, slot area, events containers
		}
		else {
			buildDayTable(); // rebuilds day table
		}
	}


	function updateOptions() {

		tm = opt('theme') ? 'ui' : 'fc';
		rtl = opt('isRTL')
		minMinute = parseTime(opt('minTime'));
		maxMinute = parseTime(opt('maxTime'));
		colFormat = opt('columnFormat');

		// week # options. (TODO: bad, logic also in other views)
		showWeekNumbers = opt('weekNumbers');
		weekNumberTitle = opt('weekNumberTitle');
		if (opt('weekNumberCalculation') != 'iso') {
			weekNumberFormat = "w";
		}
		else {
			weekNumberFormat = "W";
		}

		snapMinutes = opt('snapMinutes') || opt('slotMinutes');
	}



	/* Build DOM
	-----------------------------------------------------------------------*/


	function buildSkeleton() {
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var s;
		var d;
		var i;
		var maxd;
		var minutes;
		var slotNormal = opt('slotMinutes') % 15 == 0;

		buildDayTable();

		slotLayer =
			$("<div style='position:absolute;z-index:2;left:0;width:100%'/>")
				.appendTo(element);

		if (opt('allDaySlot')) {

			daySegmentContainer =
				$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
					.appendTo(slotLayer);

			s =
				"<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
				"<tr>" +
				"<th class='" + headerClass + " fc-agenda-axis'>" + opt('allDayText') + "</th>" +
				"<td>" +
				"<div class='fc-day-content'><div style='position:relative'/></div>" +
				"</td>" +
				"<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
				"</tr>" +
				"</table>";
			allDayTable = $(s).appendTo(slotLayer);
			allDayRow = allDayTable.find('tr');

			dayBind(allDayRow.find('td'));

			slotLayer.append(
				"<div class='fc-agenda-divider " + headerClass + "'>" +
				"<div class='fc-agenda-divider-inner'/>" +
				"</div>"
			);

		}else{

			daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()

		}

		slotScroller =
			$("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>")
				.appendTo(slotLayer);

		slotContainer =
			$("<div style='position:relative;width:100%;overflow:hidden'/>")
				.appendTo(slotScroller);

		slotSegmentContainer =
			$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(slotContainer);

		s =
			"<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
			"<tbody>";
		d = zeroDate();
		maxd = addMinutes(cloneDate(d), maxMinute);
		addMinutes(d, minMinute);
		slotCnt = 0;
		for (i=0; d < maxd; i++) {
			minutes = d.getMinutes();
			s +=
				"<tr class='fc-slot" + i + ' ' + (!minutes ? '' : 'fc-minor') + "'>" +
				"<th class='fc-agenda-axis " + headerClass + "'>" +
				((!slotNormal || !minutes) ? formatDate(d, opt('axisFormat')) : '&nbsp;') +
				"</th>" +
				"<td class='" + contentClass + "'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</td>" +
				"</tr>";
			addMinutes(d, opt('slotMinutes'));
			slotCnt++;
		}
		s +=
			"</tbody>" +
			"</table>";
		slotTable = $(s).appendTo(slotContainer);

		slotBind(slotTable.find('td'));
	}



	/* Build Day Table
	-----------------------------------------------------------------------*/


	function buildDayTable() {
		var html = buildDayTableHTML();

		if (dayTable) {
			dayTable.remove();
		}
		dayTable = $(html).appendTo(element);

		dayHead = dayTable.find('thead');
		dayHeadCells = dayHead.find('th').slice(1, -1); // exclude gutter
		dayBody = dayTable.find('tbody');
		dayBodyCells = dayBody.find('td').slice(0, -1); // exclude gutter
		dayBodyCellInners = dayBodyCells.find('> div');
		dayBodyCellContentInners = dayBodyCells.find('.fc-day-content > div');

		dayBodyFirstCell = dayBodyCells.eq(0);
		dayBodyFirstCellStretcher = dayBodyCellInners.eq(0);

		markFirstLast(dayHead.add(dayHead.find('tr')));
		markFirstLast(dayBody.add(dayBody.find('tr')));

		// TODO: now that we rebuild the cells every time, we should call dayRender
	}


	function buildDayTableHTML() {
		var html =
			"<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>" +
			buildDayTableHeadHTML() +
			buildDayTableBodyHTML() +
			"</table>";

		return html;
	}


	function buildDayTableHeadHTML() {
		var headerClass = tm + "-widget-header";
		var date;
		var html = '';
		var weekText;
		var col;

		html +=
			"<thead>" +
			"<tr>";

		if (showWeekNumbers) {
			date = cellToDate(0, 0);
			weekText = formatDate(date, weekNumberFormat);
			if (rtl) {
				weekText += weekNumberTitle;
			}
			else {
				weekText = weekNumberTitle + weekText;
			}
			html +=
				"<th class='fc-agenda-axis fc-week-number " + headerClass + "'>" +
				htmlEscape(weekText) +
				"</th>";
		}
		else {
			html += "<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		}

		for (col=0; col<colCnt; col++) {
			date = cellToDate(0, col);
			html +=
				"<th class='fc-" + dayIDs[date.getDay()] + " fc-col" + col + ' ' + headerClass + "'>" +
				htmlEscape(formatDate(date, colFormat)) +
				"</th>";
		}

		html +=
			"<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
			"</tr>" +
			"</thead>";

		return html;
	}


	function buildDayTableBodyHTML() {
		var headerClass = tm + "-widget-header"; // TODO: make these when updateOptions() called
		var contentClass = tm + "-widget-content";
		var date;
		var today = clearTime(new Date());
		var col;
		var cellsHTML;
		var cellHTML;
		var classNames;
		var html = '';

		html +=
			"<tbody>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";

		cellsHTML = '';

		for (col=0; col<colCnt; col++) {

			date = cellToDate(0, col);

			classNames = [
				'fc-col' + col,
				'fc-' + dayIDs[date.getDay()],
				contentClass
			];
			if (+date == +today) {
				classNames.push(
					tm + '-state-highlight',
					'fc-today'
				);
			}
			else if (date < today) {
				classNames.push('fc-past');
			}
			else {
				classNames.push('fc-future');
			}

			cellHTML =
				"<td class='" + classNames.join(' ') + "'>" +
				"<div>" +
				"<div class='fc-day-content'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</div>" +
				"</div>" +
				"</td>";

			cellsHTML += cellHTML;
		}

		html += cellsHTML;
		html +=
			"<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
			"</tr>" +
			"</tbody>";

		return html;
	}


	// TODO: data-date on the cells



	/* Dimensions
	-----------------------------------------------------------------------*/


	function setHeight(height) {
		if (height === undefined) {
			height = viewHeight;
		}
		viewHeight = height;
		slotTopCache = {};

		var headHeight = dayBody.position().top;
		var allDayHeight = slotScroller.position().top; // including divider
		var bodyHeight = Math.min( // total body height, including borders
			height - headHeight,   // when scrollbars
			slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
		);

		dayBodyFirstCellStretcher
			.height(bodyHeight - vsides(dayBodyFirstCell));

		slotLayer.css('top', headHeight);

		slotScroller.height(bodyHeight - allDayHeight - 1);

		// the stylesheet guarantees that the first row has no border.
		// this allows .height() to work well cross-browser.
		slotHeight = slotTable.find('tr:first').height() + 1; // +1 for bottom border

		snapRatio = opt('slotMinutes') / snapMinutes;
		snapHeight = slotHeight / snapRatio;
	}


	function setWidth(width) {
		viewWidth = width;
		colPositions.clear();
		colContentPositions.clear();

		var axisFirstCells = dayHead.find('th:first');
		if (allDayTable) {
			axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
		}
		axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));

		axisWidth = 0;
		setOuterWidth(
			axisFirstCells
				.width('')
				.each(function(i, _cell) {
					axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
				}),
			axisWidth
		);

		var gutterCells = dayTable.find('.fc-agenda-gutter');
		if (allDayTable) {
			gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));
		}

		var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)

		gutterWidth = slotScroller.width() - slotTableWidth;
		if (gutterWidth) {
			setOuterWidth(gutterCells, gutterWidth);
			gutterCells
				.show()
				.prev()
				.removeClass('fc-last');
		}else{
			gutterCells
				.hide()
				.prev()
				.addClass('fc-last');
		}

		colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
		setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
	}



	/* Scrolling
	-----------------------------------------------------------------------*/


	function resetScroll() {
		var d0 = zeroDate();
		var scrollDate = cloneDate(d0);
		scrollDate.setHours(opt('firstHour'));
		var top = timePosition(d0, scrollDate) + 1; // +1 for the border
		function scroll() {
			slotScroller.scrollTop(top);
		}
		scroll();
		setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
	}


	function afterRender() { // after the view has been freshly rendered and sized
		resetScroll();
	}



	/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/


	function dayBind(cells) {
		cells.click(slotClick)
			.mousedown(daySelectionMousedown);
	}


	function slotBind(cells) {
		cells.click(slotClick)
			.mousedown(slotSelectionMousedown);
	}


	function slotClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var col = Math.min(colCnt-1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
			var date = cellToDate(0, col);
			var rowMatch = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
			if (rowMatch) {
				var mins = parseInt(rowMatch[1]) * opt('slotMinutes');
				var hours = Math.floor(mins/60);
				date.setHours(hours);
				date.setMinutes(mins%60 + minMinute);
				trigger('dayClick', dayBodyCells[col], date, false, ev);
			}else{
				trigger('dayClick', dayBodyCells[col], date, true, ev);
			}
		}
	}



	/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
	// TODO: should be consolidated with BasicView's methods


	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive

		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}

		var segments = rangeToSegments(overlayStart, overlayEnd);

		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			dayBind(
				renderCellOverlay(
					segment.row,
					segment.leftCol,
					segment.row,
					segment.rightCol
				)
			);
		}
	}


	function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
		var rect = coordinateGrid.rect(row0, col0, row1, col1, slotLayer);
		return renderOverlay(rect, slotLayer);
	}


	function renderSlotOverlay(overlayStart, overlayEnd) {
		for (var i=0; i<colCnt; i++) {
			var dayStart = cellToDate(0, i);
			var dayEnd = addDays(cloneDate(dayStart), 1);
			var stretchStart = new Date(Math.max(dayStart, overlayStart));
			var stretchEnd = new Date(Math.min(dayEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var rect = coordinateGrid.rect(0, i, 0, i, slotContainer); // only use it for horizontal coords
				var top = timePosition(dayStart, stretchStart);
				var bottom = timePosition(dayStart, stretchEnd);
				rect.top = top;
				rect.height = bottom - top;
				slotBind(
					renderOverlay(rect, slotContainer)
				);
			}
		}
	}



	/* Coordinate Utilities
	-----------------------------------------------------------------------------*/


	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		dayHeadCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		if (opt('allDaySlot')) {
			e = allDayRow;
			n = e.offset().top;
			rows[0] = [n, n+e.outerHeight()];
		}
		var slotTableTop = slotContainer.offset().top;
		var slotScrollerTop = slotScroller.offset().top;
		var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
		function constrain(n) {
			return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
		}
		for (var i=0; i<slotCnt*snapRatio; i++) { // adapt slot count to increased/decreased selection slot count
			rows.push([
				constrain(slotTableTop + snapHeight*i),
				constrain(slotTableTop + snapHeight*(i+1))
			]);
		}
	});


	hoverListener = new HoverListener(coordinateGrid);

	colPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellInners.eq(col);
	});

	colContentPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellContentInners.eq(col);
	});


	function colLeft(col) {
		return colPositions.left(col);
	}


	function colContentLeft(col) {
		return colContentPositions.left(col);
	}


	function colRight(col) {
		return colPositions.right(col);
	}


	function colContentRight(col) {
		return colContentPositions.right(col);
	}


	function getIsCellAllDay(cell) {
		return opt('allDaySlot') && !cell.row;
	}


	function realCellToDate(cell) { // ugh "real" ... but blame it on our abuse of the "cell" system
		var d = cellToDate(0, cell.col);
		var slotIndex = cell.row;
		if (opt('allDaySlot')) {
			slotIndex--;
		}
		if (slotIndex >= 0) {
			addMinutes(d, minMinute + slotIndex * snapMinutes);
		}
		return d;
	}


	// get the Y coordinate of the given time on the given day (both Date objects)
	function timePosition(day, time) { // both date objects. day holds 00:00 of current day
		day = cloneDate(day, true);
		if (time < addMinutes(cloneDate(day), minMinute)) {
			return 0;
		}
		if (time >= addMinutes(cloneDate(day), maxMinute)) {
			return slotTable.height();
		}
		var slotMinutes = opt('slotMinutes'),
			minutes = time.getHours()*60 + time.getMinutes() - minMinute,
			slotI = Math.floor(minutes / slotMinutes),
			slotTop = slotTopCache[slotI];
		if (slotTop === undefined) {
			slotTop = slotTopCache[slotI] =
				slotTable.find('tr').eq(slotI).find('td div')[0].offsetTop;
				// .eq() is faster than ":eq()" selector
				// [0].offsetTop is faster than .position().top (do we really need this optimization?)
				// a better optimization would be to cache all these divs
		}
		return Math.max(0, Math.round(
			slotTop - 1 + slotHeight * ((minutes % slotMinutes) / slotMinutes)
		));
	}


	function getAllDayRow(index) {
		return allDayRow;
	}


	function defaultEventEnd(event) {
		var start = cloneDate(event.start);
		if (event.allDay) {
			return start;
		}
		return addMinutes(start, opt('defaultEventMinutes'));
	}



	/* Selection
	---------------------------------------------------------------------------------*/


	function defaultSelectionEnd(startDate, allDay) {
		if (allDay) {
			return cloneDate(startDate);
		}
		return addMinutes(cloneDate(startDate), opt('slotMinutes'));
	}


	function renderSelection(startDate, endDate, allDay) { // only for all-day
		if (allDay) {
			if (opt('allDaySlot')) {
				renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true);
			}
		}else{
			renderSlotSelection(startDate, endDate);
		}
	}


	function renderSlotSelection(startDate, endDate) {
		var helperOption = opt('selectHelper');
		coordinateGrid.build();
		if (helperOption) {
			var col = dateToCell(startDate).col;
			if (col >= 0 && col < colCnt) { // only works when times are on same day
				var rect = coordinateGrid.rect(0, col, 0, col, slotContainer); // only for horizontal coords
				var top = timePosition(startDate, startDate);
				var bottom = timePosition(startDate, endDate);
				if (bottom > top) { // protect against selections that are entirely before or after visible range
					rect.top = top;
					rect.height = bottom - top;
					rect.left += 2;
					rect.width -= 5;
					if ($.isFunction(helperOption)) {
						var helperRes = helperOption(startDate, endDate);
						if (helperRes) {
							rect.position = 'absolute';
							selectionHelper = $(helperRes)
								.css(rect)
								.appendTo(slotContainer);
						}
					}else{
						rect.isStart = true; // conside rect a "seg" now
						rect.isEnd = true;   //
						selectionHelper = $(slotSegHtml(
							{
								title: '',
								start: startDate,
								end: endDate,
								className: ['fc-select-helper'],
								editable: false
							},
							rect
						));
						selectionHelper.css('opacity', opt('dragOpacity'));
					}
					if (selectionHelper) {
						slotBind(selectionHelper);
						slotContainer.append(selectionHelper);
						setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
						setOuterHeight(selectionHelper, rect.height, true);
					}
				}
			}
		}else{
			renderSlotOverlay(startDate, endDate);
		}
	}


	function clearSelection() {
		clearOverlays();
		if (selectionHelper) {
			selectionHelper.remove();
			selectionHelper = null;
		}
	}


	function slotSelectionMousedown(ev) {
		if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
			unselect(ev);
			var dates;
			hoverListener.start(function(cell, origCell) {
				clearSelection();
				if (cell && cell.col == origCell.col && !getIsCellAllDay(cell)) {
					var d1 = realCellToDate(origCell);
					var d2 = realCellToDate(cell);
					dates = [
						d1,
						addMinutes(cloneDate(d1), snapMinutes), // calculate minutes depending on selection slot minutes
						d2,
						addMinutes(cloneDate(d2), snapMinutes)
					].sort(dateCompare);
					renderSlotSelection(dates[0], dates[3]);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], false, ev);
					}
					reportSelection(dates[0], dates[3], false, ev);
				}
			});
		}
	}


	function reportDayClick(date, allDay, ev) {
		trigger('dayClick', dayBodyCells[dateToCell(date).col], date, allDay, ev);
	}



	/* External Dragging
	--------------------------------------------------------------------------------*/


	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				if (getIsCellAllDay(cell)) {
					renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
				}else{
					var d1 = realCellToDate(cell);
					var d2 = addMinutes(cloneDate(d1), opt('defaultEventMinutes'));
					renderSlotOverlay(d1, d2);
				}
			}
		}, ev);
	}


	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			trigger('drop', _dragElement, realCellToDate(cell), getIsCellAllDay(cell), ev, ui);
		}
	}


}

;;

function AgendaEventRenderer() {
	var t = this;


	// exports
	t.renderEvents = renderEvents;
	t.clearEvents = clearEvents;
	t.slotSegHtml = slotSegHtml;


	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var eventElementHandlers = t.eventElementHandlers;
	var setHeight = t.setHeight;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getSlotSegmentContainer = t.getSlotSegmentContainer;
	var getHoverListener = t.getHoverListener;
	var getMaxMinute = t.getMaxMinute;
	var getMinMinute = t.getMinMinute;
	var timePosition = t.timePosition;
	var getIsCellAllDay = t.getIsCellAllDay;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var cellToDate = t.cellToDate;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var getSnapHeight = t.getSnapHeight;
	var getSnapMinutes = t.getSnapMinutes;
	var getSlotContainer = t.getSlotContainer;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var renderDayEvents = t.renderDayEvents;
	var calendar = t.calendar;
	var formatDate = calendar.formatDate;
	var formatDates = calendar.formatDates;


	// overrides
	t.draggableDayEvent = draggableDayEvent;



	/* Rendering
	----------------------------------------------------------------------------*/


	function renderEvents(events, modifiedEventId) {
		var i, len=events.length,
			dayEvents=[],
			slotEvents=[];
		for (i=0; i<len; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}else{
				slotEvents.push(events[i]);
			}
		}

		if (opt('allDaySlot')) {
			renderDayEvents(dayEvents, modifiedEventId);
			setHeight(); // no params means set to viewHeight
		}

		renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId);
	}


	function clearEvents() {
		getDaySegmentContainer().empty();
		getSlotSegmentContainer().empty();
	}


	function compileSlotSegs(events) {
		var colCnt = getColCnt(),
			minMinute = getMinMinute(),
			maxMinute = getMaxMinute(),
			d,
			visEventEnds = $.map(events, slotEventEnd),
			i,
			j, seg,
			colSegs,
			segs = [];

		for (i=0; i<colCnt; i++) {

			d = cellToDate(0, i);
			addMinutes(d, minMinute);

			colSegs = sliceSegs(
				events,
				visEventEnds,
				d,
				addMinutes(cloneDate(d), maxMinute-minMinute)
			);

			colSegs = placeSlotSegs(colSegs); // returns a new order

			for (j=0; j<colSegs.length; j++) {
				seg = colSegs[j];
				seg.col = i;
				segs.push(seg);
			}
		}

		return segs;
	}


	function sliceSegs(events, visEventEnds, start, end) {
		var segs = [],
			i, len=events.length, event,
			eventStart, eventEnd,
			segStart, segEnd,
			isStart, isEnd;
		for (i=0; i<len; i++) {
			event = events[i];
			eventStart = event.start;
			eventEnd = visEventEnds[i];
			if (eventEnd > start && eventStart < end) {
				if (eventStart < start) {
					segStart = cloneDate(start);
					isStart = false;
				}else{
					segStart = eventStart;
					isStart = true;
				}
				if (eventEnd > end) {
					segEnd = cloneDate(end);
					isEnd = false;
				}else{
					segEnd = eventEnd;
					isEnd = true;
				}
				segs.push({
					event: event,
					start: segStart,
					end: segEnd,
					isStart: isStart,
					isEnd: isEnd
				});
			}
		}
		return segs.sort(compareSlotSegs);
	}


	function slotEventEnd(event) {
		if (event.end) {
			return cloneDate(event.end);
		}else{
			return addMinutes(cloneDate(event.start), opt('defaultEventMinutes'));
		}
	}


	// renders events in the 'time slots' at the bottom
	// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
	// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)

	function renderSlotSegs(segs, modifiedEventId) {

		var i, segCnt=segs.length, seg,
			event,
			top,
			bottom,
			columnLeft,
			columnRight,
			columnWidth,
			width,
			left,
			right,
			html = '',
			eventElements,
			eventElement,
			triggerRes,
			titleElement,
			height,
			slotSegmentContainer = getSlotSegmentContainer(),
			isRTL = opt('isRTL');

		// calculate position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			top = timePosition(seg.start, seg.start);
			bottom = timePosition(seg.start, seg.end);
			columnLeft = colContentLeft(seg.col);
			columnRight = colContentRight(seg.col);
			columnWidth = columnRight - columnLeft;

			// shave off space on right near scrollbars (2.5%)
			// TODO: move this to CSS somehow
			columnRight -= columnWidth * .025;
			columnWidth = columnRight - columnLeft;

			width = columnWidth * (seg.forwardCoord - seg.backwardCoord);

			if (opt('slotEventOverlap')) {
				// double the width while making sure resize handle is visible
				// (assumed to be 20px wide)
				width = Math.max(
					(width - (20/2)) * 2,
					width // narrow columns will want to make the segment smaller than
						// the natural width. don't allow it
				);
			}

			if (isRTL) {
				right = columnRight - seg.backwardCoord * columnWidth;
				left = right - width;
			}
			else {
				left = columnLeft + seg.backwardCoord * columnWidth;
				right = left + width;
			}

			// make sure horizontal coordinates are in bounds
			left = Math.max(left, columnLeft);
			right = Math.min(right, columnRight);
			width = right - left;

			seg.top = top;
			seg.left = left;
			seg.outerWidth = width;
			seg.outerHeight = bottom - top;
			html += slotSegHtml(event, seg);
		}

		slotSegmentContainer[0].innerHTML = html; // faster than html()
		eventElements = slotSegmentContainer.children();

		// retrieve elements, run through eventRender callback, bind event handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			eventElement = $(eventElements[i]); // faster than eq()
			triggerRes = trigger('eventRender', event, event, eventElement);
			if (triggerRes === false) {
				eventElement.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					eventElement.remove();
					eventElement = $(triggerRes)
						.css({
							position: 'absolute',
							top: seg.top,
							left: seg.left
						})
						.appendTo(slotSegmentContainer);
				}
				seg.element = eventElement;
				if (event._id === modifiedEventId) {
					bindSlotSeg(event, eventElement, seg);
				}else{
					eventElement[0]._fci = i; // for lazySegBind
				}
				reportEventElement(event, eventElement);
			}
		}

		lazySegBind(slotSegmentContainer, segs, bindSlotSeg);

		// record event sides and title positions
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				seg.vsides = vsides(eventElement, true);
				seg.hsides = hsides(eventElement, true);
				titleElement = eventElement.find('.fc-event-title');
				if (titleElement.length) {
					seg.contentTop = titleElement[0].offsetTop;
				}
			}
		}

		// set all positions/dimensions at once
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
				height = Math.max(0, seg.outerHeight - seg.vsides);
				eventElement[0].style.height = height + 'px';
				event = seg.event;
				if (seg.contentTop !== undefined && height - seg.contentTop < 10) {
					// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
					eventElement.find('div.fc-event-time')
						.text(formatDate(event.start, opt('timeFormat')) + ' - ' + event.title);
					eventElement.find('div.fc-event-title')
						.remove();
				}
				trigger('eventAfterRender', event, event, eventElement);
			}
		}

	}


	function slotSegHtml(event, seg) {
		var html = "<";
		var url = event.url;
		var skinCss = getSkinCss(event, opt);
		var classes = ['fc-event', 'fc-event-vert'];
		if (isEventDraggable(event)) {
			classes.push('fc-event-draggable');
		}
		if (seg.isStart) {
			classes.push('fc-event-start');
		}
		if (seg.isEnd) {
			classes.push('fc-event-end');
		}
		classes = classes.concat(event.className);
		if (event.source) {
			classes = classes.concat(event.source.className || []);
		}
		if (url) {
			html += "a href='" + htmlEscape(event.url) + "'";
		}else{
			html += "div";
		}
		html +=
			" class='" + classes.join(' ') + "'" +
			" style=" +
				"'" +
				"position:absolute;" +
				"top:" + seg.top + "px;" +
				"left:" + seg.left + "px;" +
				skinCss +
				"'" +
			">" +
			calendarDependencyHelper.Templates().renderCustomImagePrinting({
					"eventType": event.eventType !== "custom" ? event.eventType : event.className[0]
			}) +
			"<div class='fc-event-inner'>" +
			"<div class='fc-event-time'>" +
			htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
			"</div>" +
			"<div class='fc-event-title'>" +
			htmlEscape(event.title || '') +
			"</div>" +
			"</div>" +
			"<div class='fc-event-bg'></div>";
		if (seg.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-s'>=</div>";
		}
		html +=
			"</" + (url ? "a" : "div") + ">";
		return html;
	}


	function bindSlotSeg(event, eventElement, seg) {
		var timeElement = eventElement.find('div.fc-event-time');
		if (isEventDraggable(event)) {
			draggableSlotEvent(event, eventElement, timeElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableSlotEvent(event, eventElement, timeElement);
		}
		eventElementHandlers(event, eventElement);
	}



	/* Dragging
	-----------------------------------------------------------------------------------*/


	// when event starts out FULL-DAY
	// overrides DayEventRenderer's version because it needs to account for dragging elements
	// to and from the slot area.

	function draggableDayEvent(event, eventElement, seg) {
		var isStart = seg.isStart;
		var origWidth;
		var revert;
		var allDay = true;
		var dayDelta;
		var hoverListener = getHoverListener();
		var colWidth = getColWidth();
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();
		var minMinute = getMinMinute();
		eventElement.draggable({
			opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origWidth = eventElement.width();
				hoverListener.start(function(cell, origCell) {
					clearOverlays();
					if (cell) {
						revert = false;
						var origDate = cellToDate(0, origCell.col);
						var date = cellToDate(0, cell.col);
						dayDelta = dayDiff(date, origDate);
						if (!cell.row) {
							// on full-days
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
							resetElement();
						}else{
							// mouse is over bottom slots
							if (isStart) {
								if (allDay) {
									// convert event to temporary slot-event
									eventElement.width(colWidth - 10); // don't use entire width
									setOuterHeight(
										eventElement,
										snapHeight * Math.round(
											(event.end ? ((event.end - event.start) / MINUTE_MS) : opt('defaultEventMinutes')) /
												snapMinutes
										)
									);
									eventElement.draggable('option', 'grid', [colWidth, 1]);
									allDay = false;
								}
							}else{
								revert = true;
							}
						}
						revert = revert || (allDay && !dayDelta);
					}else{
						resetElement();
						revert = true;
					}
					eventElement.draggable('option', 'revert', revert);
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (revert) {
					// hasn't moved or is out of bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}else{
					// changed!
					var minuteDelta = 0;
					if (!allDay) {
						minuteDelta = Math.round((eventElement.offset().top - getSlotContainer().offset().top) / snapHeight)
							* snapMinutes
							+ minMinute
							- (event.start.getHours() * 60 + event.start.getMinutes());
					}
					eventDrop(this, event, dayDelta, minuteDelta, allDay, ev, ui);
				}
			}
		});
		function resetElement() {
			if (!allDay) {
				eventElement
					.width(origWidth)
					.height('')
					.draggable('option', 'grid', null);
				allDay = true;
			}
		}
	}


	// when event starts out IN TIMESLOTS

	function draggableSlotEvent(event, eventElement, timeElement) {
		var coordinateGrid = t.getCoordinateGrid();
		var colCnt = getColCnt();
		var colWidth = getColWidth();
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();

		// states
		var origPosition; // original position of the element, not the mouse
		var origCell;
		var isInBounds, prevIsInBounds;
		var isAllDay, prevIsAllDay;
		var colDelta, prevColDelta;
		var dayDelta; // derived from colDelta
		var minuteDelta, prevMinuteDelta;

		eventElement.draggable({
			scroll: false,
			grid: [ colWidth, snapHeight ],
			axis: colCnt==1 ? 'y' : false,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
                // Atlassian TEAMCAL : fixed ticket TEAMCAL-1887
                _fixUIEvent(ev);
                // End Atlassian TEAMCAL


				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);

				coordinateGrid.build();

				// initialize states
				origPosition = eventElement.position();
				origCell = coordinateGrid.cell(ev.pageX, ev.pageY);
				isInBounds = prevIsInBounds = true;
				isAllDay = prevIsAllDay = getIsCellAllDay(origCell);
				colDelta = prevColDelta = 0;
				dayDelta = 0;
				minuteDelta = prevMinuteDelta = 0;

			},
			drag: function(ev, ui) {
                // Atlassian TEAMCAL : fixed ticket TEAMCAL-1887
                _fixUIEvent(ev);
                // End Atlassian TEAMCAL

				// NOTE: this `cell` value is only useful for determining in-bounds and all-day.
				// Bad for anything else due to the discrepancy between the mouse position and the
				// element position while snapping. (problem revealed in PR #55)
				//
				// PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
				// We should overhaul the dragging system and stop relying on jQuery UI.
				var cell = coordinateGrid.cell(ev.pageX, ev.pageY);

				// update states
				isInBounds = !!cell;
				if (isInBounds) {
					isAllDay = getIsCellAllDay(cell);

					// calculate column delta
					colDelta = Math.round((ui.position.left - origPosition.left) / colWidth);
					if (colDelta != prevColDelta) {
						// calculate the day delta based off of the original clicked column and the column delta
						var origDate = cellToDate(0, origCell.col);
						var col = origCell.col + colDelta;
						col = Math.max(0, col);
						col = Math.min(colCnt-1, col);
						var date = cellToDate(0, col);
						dayDelta = dayDiff(date, origDate);
					}

					// calculate minute delta (only if over slots)
					if (!isAllDay) {
						minuteDelta = Math.round((ui.position.top - origPosition.top) / snapHeight) * snapMinutes;
					}
				}

				// any state changes?
				if (
					isInBounds != prevIsInBounds ||
					isAllDay != prevIsAllDay ||
					colDelta != prevColDelta ||
					minuteDelta != prevMinuteDelta
				) {

					updateUI();

					// update previous states for next time
					prevIsInBounds = isInBounds;
					prevIsAllDay = isAllDay;
					prevColDelta = colDelta;
					prevMinuteDelta = minuteDelta;
				}

				// if out-of-bounds, revert when done, and vice versa.
				eventElement.draggable('option', 'revert', !isInBounds);

			},
			stop: function(ev, ui) {
                // Atlassian TEAMCAL : fixed ticket TEAMCAL-1887
                _fixUIEvent(ev);
                // End Atlassian TEAMCAL

				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);

				if (isInBounds && (isAllDay || dayDelta || minuteDelta)) { // changed!
					eventDrop(this, event, dayDelta, isAllDay ? 0 : minuteDelta, isAllDay, ev, ui);
				}
				else { // either no change or out-of-bounds (draggable has already reverted)

					// reset states for next time, and for updateUI()
					isInBounds = true;
					isAllDay = false;
					colDelta = 0;
					dayDelta = 0;
					minuteDelta = 0;

					updateUI();
					eventElement.css('filter', ''); // clear IE opacity side-effects

					// sometimes fast drags make event revert to wrong position, so reset.
					// also, if we dragged the element out of the area because of snapping,
					// but the *mouse* is still in bounds, we need to reset the position.
					eventElement.css(origPosition);

					showEvents(event, eventElement);
				}
			}
		});

		function updateUI() {
			clearOverlays();
			if (isInBounds) {
				if (isAllDay) {
					timeElement.hide();
					eventElement.draggable('option', 'grid', null); // disable grid snapping
					renderDayOverlay(
						addDays(cloneDate(event.start), dayDelta),
						addDays(exclEndDay(event), dayDelta)
					);
				}
				else {
					updateTimeText(minuteDelta);
					timeElement.css('display', ''); // show() was causing display=inline
					eventElement.draggable('option', 'grid', [colWidth, snapHeight]); // re-enable grid snapping
				}
			}
		}

		function updateTimeText(minuteDelta) {
			var newStart = addMinutes(cloneDate(event.start), minuteDelta);
			var newEnd;
			if (event.end) {
				newEnd = addMinutes(cloneDate(event.end), minuteDelta);
			}
			timeElement.text(formatDates(newStart, newEnd, opt('timeFormat')));
		}

	}



	/* Resizing
	--------------------------------------------------------------------------------------*/


	function resizableSlotEvent(event, eventElement, timeElement) {
		var snapDelta, prevSnapDelta;
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();
		eventElement.resizable({
			handles: {
				s: '.ui-resizable-handle'
			},
			grid: snapHeight,
            // ATLASSIAN - TEAMCAL-2193
            minHeight: snapHeight,
            // ATLASSIAN - TEAMCAL-2193
			start: function(ev, ui) {
				snapDelta = prevSnapDelta = 0;
				trigger('eventResizeStart', this, event, ev, ui);
			},
			resize: function(ev, ui) {
				// don't rely on ui.size.height, doesn't take grid into account
				snapDelta = Math.round((Math.max(snapHeight, eventElement.height()) - ui.originalSize.height) / snapHeight);
				if (snapDelta != prevSnapDelta) {
					timeElement.text(
						formatDates(
							event.start,
							(!snapDelta && !event.end) ? null : // no change, so don't display time range
								addMinutes(eventEnd(event), snapMinutes*snapDelta),
							opt('timeFormat')
						)
					);
					prevSnapDelta = snapDelta;
				}
			},
			stop: function(ev, ui) {
				trigger('eventResizeStop', this, event, ev, ui);
				if (snapDelta) {
					eventResize(this, event, 0, snapMinutes*snapDelta, ev, ui);
				}
			}
		});
	}


}



/* Agenda Event Segment Utilities
-----------------------------------------------------------------------------*/


// Sets the seg.backwardCoord and seg.forwardCoord on each segment and returns a new
// list in the order they should be placed into the DOM (an implicit z-index).
function placeSlotSegs(segs) {
	var levels = buildSlotSegLevels(segs);
	var level0 = levels[0];
	var i;

	computeForwardSlotSegs(levels);

	if (level0) {

		for (i=0; i<level0.length; i++) {
			computeSlotSegPressures(level0[i]);
		}

		for (i=0; i<level0.length; i++) {
			computeSlotSegCoords(level0[i], 0, 0);
		}
	}

	return flattenSlotSegLevels(levels);
}


// Builds an array of segments "levels". The first level will be the leftmost tier of segments
// if the calendar is left-to-right, or the rightmost if the calendar is right-to-left.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a "series", which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
function computeSlotSegCoords(seg, seriesBackwardPressure, seriesBackwardCoord) {
	var forwardSegs = seg.forwardSegs;
	var i;

	if (seg.forwardCoord === undefined) { // not already computed

		if (!forwardSegs.length) {

			// if there are no forward segments, this segment should butt up against the edge
			seg.forwardCoord = 1;
		}
		else {

			// sort highest pressure first
			forwardSegs.sort(compareForwardSlotSegs);

			// this segment's forwardCoord will be calculated from the backwardCoord of the
			// highest-pressure forward segment.
			computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
			seg.forwardCoord = forwardSegs[0].backwardCoord;
		}

		// calculate the backwardCoord from the forwardCoord. consider the series
		seg.backwardCoord = seg.forwardCoord -
			(seg.forwardCoord - seriesBackwardCoord) / // available width for series
			(seriesBackwardPressure + 1); // # of segments in the series

		// use this segment's coordinates to computed the coordinates of the less-pressurized
		// forward segments
		for (i=0; i<forwardSegs.length; i++) {
			computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
		}
	}
}


// Outputs a flat array of segments, from lowest to highest level
function flattenSlotSegLevels(levels) {
	var segs = [];
	var i, level;
	var j;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			segs.push(level[j]);
		}
	}

	return segs;
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.end > seg2.start && seg1.start < seg2.end;
}


// A cmp function for determining which forward segment to rely on more when computing coordinates.
function compareForwardSlotSegs(seg1, seg2) {
	// put higher-pressure first
	return seg2.forwardPressure - seg1.forwardPressure ||
		// put segments that are closer to initial edge first (and favor ones with no coords yet)
		(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
		// do normal sorting...
		compareSlotSegs(seg1, seg2);
}


// A cmp function for determining which segment should be closer to the initial edge
// (the left edge on a left-to-right calendar).
function compareSlotSegs(seg1, seg2) {
	return seg1.start - seg2.start || // earlier start time goes first
		(seg2.end - seg2.start) - (seg1.end - seg1.start) || // tie? longer-duration goes first
		(seg1.event.title || '').localeCompare(seg2.event.title); // tie? alphabetically by title
}


;;


function View(element, calendar, viewName) {
	var t = this;


	// exports
	t.element = element;
	t.calendar = calendar;
	t.name = viewName;
	t.opt = opt;
	t.trigger = trigger;
	t.isEventDraggable = isEventDraggable;
	t.isEventResizable = isEventResizable;
	t.setEventData = setEventData;
	t.clearEventData = clearEventData;
	t.eventEnd = eventEnd;
	t.reportEventElement = reportEventElement;
	t.triggerEventDestroy = triggerEventDestroy;
	t.eventElementHandlers = eventElementHandlers;
	t.showEvents = showEvents;
	t.hideEvents = hideEvents;
	t.eventDrop = eventDrop;
	t.eventResize = eventResize;
	// t.title
	// t.start, t.end
	// t.visStart, t.visEnd


	// imports
	var defaultEventEnd = t.defaultEventEnd;
	var normalizeEvent = calendar.normalizeEvent; // in EventManager
	var reportEventChange = calendar.reportEventChange;


	// locals
	var eventsByID = {}; // eventID mapped to array of events (there can be multiple b/c of repeating events)
	var eventElementsByID = {}; // eventID mapped to array of jQuery elements
	var eventElementCouples = []; // array of objects, { event, element } // TODO: unify with segment system
	var options = calendar.options;



	function opt(name, viewNameOverride) {
		var v = options[name];
		if ($.isPlainObject(v)) {
			return smartProperty(v, viewNameOverride || viewName);
		}
		return v;
	}


	function trigger(name, thisObj) {
		return calendar.trigger.apply(
			calendar,
			[name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
		);
	}



	/* Event Editable Boolean Calculations
	------------------------------------------------------------------------------*/


	function isEventDraggable(event) {
		var source = event.source || {};
		return firstDefined(
				event.startEditable,
				source.startEditable,
				opt('eventStartEditable'),
				event.editable,
				source.editable,
				opt('editable')
			)
			&& !opt('disableDragging'); // deprecated
	}


	function isEventResizable(event) { // but also need to make sure the seg.isEnd == true
		var source = event.source || {};
		return firstDefined(
				event.durationEditable,
				source.durationEditable,
				opt('eventDurationEditable'),
				event.editable,
				source.editable,
				opt('editable')
			)
			&& !opt('disableResizing'); // deprecated
	}



	/* Event Data
	------------------------------------------------------------------------------*/


	function setEventData(events) { // events are already normalized at this point
		eventsByID = {};
		var i, len=events.length, event;
		for (i=0; i<len; i++) {
			event = events[i];
			if (eventsByID[event._id]) {
				eventsByID[event._id].push(event);
			}else{
				eventsByID[event._id] = [event];
			}
		}
	}


	function clearEventData() {
		eventsByID = {};
		eventElementsByID = {};
		eventElementCouples = [];
	}


	// returns a Date object for an event's end
	function eventEnd(event) {
		return event.end ? cloneDate(event.end) : defaultEventEnd(event);
	}



	/* Event Elements
	------------------------------------------------------------------------------*/


	// report when view creates an element for an event
	function reportEventElement(event, element) {
		eventElementCouples.push({ event: event, element: element });
		if (eventElementsByID[event._id]) {
			eventElementsByID[event._id].push(element);
		}else{
			eventElementsByID[event._id] = [element];
		}
	}


	function triggerEventDestroy() {
		$.each(eventElementCouples, function(i, couple) {
			t.trigger('eventDestroy', couple.event, couple.event, couple.element);
		});
	}


	// attaches eventClick, eventMouseover, eventMouseout
	function eventElementHandlers(event, eventElement) {
		eventElement
			.click(function(ev) {
				if (!eventElement.hasClass('ui-draggable-dragging') &&
					!eventElement.hasClass('ui-resizable-resizing')) {
						return trigger('eventClick', this, event, ev);
					}
			})
			.hover(
				function(ev) {
					trigger('eventMouseover', this, event, ev);
				},
				function(ev) {
					trigger('eventMouseout', this, event, ev);
				}
			);
		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
		// TODO: same for resizing
	}


	function showEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'show');
	}


	function hideEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'hide');
	}


	function eachEventElement(event, exceptElement, funcName) {
		// NOTE: there may be multiple events per ID (repeating events)
		// and multiple segments per event
		var elements = eventElementsByID[event._id],
			i, len = elements.length;
		for (i=0; i<len; i++) {
			if (!exceptElement || elements[i][0] != exceptElement[0]) {
				elements[i][funcName]();
			}
		}
	}



	/* Event Modification Reporting
	---------------------------------------------------------------------------------*/


	function eventDrop(e, event, dayDelta, minuteDelta, allDay, ev, ui) {
		var oldAllDay = event.allDay;
		var eventId = event._id;
		moveEvents(eventsByID[eventId], dayDelta, minuteDelta, allDay);
		trigger(
			'eventDrop',
			e,
			event,
			dayDelta,
			minuteDelta,
			allDay,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				moveEvents(eventsByID[eventId], -dayDelta, -minuteDelta, oldAllDay);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}


	function eventResize(e, event, dayDelta, minuteDelta, ev, ui) {
		var eventId = event._id;
		elongateEvents(eventsByID[eventId], dayDelta, minuteDelta);
		trigger(
			'eventResize',
			e,
			event,
			dayDelta,
			minuteDelta,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				elongateEvents(eventsByID[eventId], -dayDelta, -minuteDelta);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}



	/* Event Modification Math
	---------------------------------------------------------------------------------*/


	function moveEvents(events, dayDelta, minuteDelta, allDay) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			if (allDay !== undefined) {
				e.allDay = allDay;
			}
			addMinutes(addDays(e.start, dayDelta, true), minuteDelta);
			if (e.end) {
				e.end = addMinutes(addDays(e.end, dayDelta, true), minuteDelta);
			}
			normalizeEvent(e, options);
		}
	}


	function elongateEvents(events, dayDelta, minuteDelta) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			e.end = addMinutes(addDays(eventEnd(e), dayDelta, true), minuteDelta);
			normalizeEvent(e, options);
		}
	}



	// ====================================================================================================
	// Utilities for day "cells"
	// ====================================================================================================
	// The "basic" views are completely made up of day cells.
	// The "agenda" views have day cells at the top "all day" slot.
	// This was the obvious common place to put these utilities, but they should be abstracted out into
	// a more meaningful class (like DayEventRenderer).
	// ====================================================================================================


	// For determining how a given "cell" translates into a "date":
	//
	// 1. Convert the "cell" (row and column) into a "cell offset" (the # of the cell, cronologically from the first).
	//    Keep in mind that column indices are inverted with isRTL. This is taken into account.
	//
	// 2. Convert the "cell offset" to a "day offset" (the # of days since the first visible day in the view).
	//
	// 3. Convert the "day offset" into a "date" (a JavaScript Date object).
	//
	// The reverse transformation happens when transforming a date into a cell.


	// exports
	t.isHiddenDay = isHiddenDay;
	t.skipHiddenDays = skipHiddenDays;
	t.getCellsPerWeek = getCellsPerWeek;
	t.dateToCell = dateToCell;
	t.dateToDayOffset = dateToDayOffset;
	t.dayOffsetToCellOffset = dayOffsetToCellOffset;
	t.cellOffsetToCell = cellOffsetToCell;
	t.cellToDate = cellToDate;
	t.cellToCellOffset = cellToCellOffset;
	t.cellOffsetToDayOffset = cellOffsetToDayOffset;
	t.dayOffsetToDate = dayOffsetToDate;
	t.rangeToSegments = rangeToSegments;


	// internals
	var hiddenDays = opt('hiddenDays') || []; // array of day-of-week indices that are hidden
	var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
	var cellsPerWeek;
	var dayToCellMap = []; // hash from dayIndex -> cellIndex, for one week
	var cellToDayMap = []; // hash from cellIndex -> dayIndex, for one week
	var isRTL = opt('isRTL');


	// initialize important internal variables
	(function() {

		if (opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		// Loop through a hypothetical week and determine which
		// days-of-week are hidden. Record in both hashes (one is the reverse of the other).
		for (var dayIndex=0, cellIndex=0; dayIndex<7; dayIndex++) {
			dayToCellMap[dayIndex] = cellIndex;
			isHiddenDayHash[dayIndex] = $.inArray(dayIndex, hiddenDays) != -1;
			if (!isHiddenDayHash[dayIndex]) {
				cellToDayMap[cellIndex] = dayIndex;
				cellIndex++;
			}
		}

		cellsPerWeek = cellIndex;
		if (!cellsPerWeek) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

	})();


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Date object
	function isHiddenDay(day) {
		if (typeof day == 'object') {
			day = day.getDay();
		}
		return isHiddenDayHash[day];
	}


	function getCellsPerWeek() {
		return cellsPerWeek;
	}


	// Keep incrementing the current day until it is no longer a hidden day.
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	function skipHiddenDays(date, inc, isExclusive) {
		inc = inc || 1;
		while (
			isHiddenDayHash[ ( date.getDay() + (isExclusive ? inc : 0) + 7 ) % 7 ]
		) {
			addDays(date, inc);
		}
	}


	//
	// TRANSFORMATIONS: cell -> cell offset -> day offset -> date
	//

	// cell -> date (combines all transformations)
	// Possible arguments:
	// - row, col
	// - { row:#, col: # }
	function cellToDate() {
		var cellOffset = cellToCellOffset.apply(null, arguments);
		var dayOffset = cellOffsetToDayOffset(cellOffset);
		var date = dayOffsetToDate(dayOffset);
		return date;
	}

	// cell -> cell offset
	// Possible arguments:
	// - row, col
	// - { row:#, col:# }
	function cellToCellOffset(row, col) {
		var colCnt = t.getColCnt();

		// rtl variables. wish we could pre-populate these. but where?
		var dis = isRTL ? -1 : 1;
		var dit = isRTL ? colCnt - 1 : 0;

		if (typeof row == 'object') {
			col = row.col;
			row = row.row;
		}
		var cellOffset = row * colCnt + (col * dis + dit); // column, adjusted for RTL (dis & dit)

		return cellOffset;
	}

	// cell offset -> day offset
	function cellOffsetToDayOffset(cellOffset) {
		var day0 = t.visStart.getDay(); // first date's day of week
		cellOffset += dayToCellMap[day0]; // normlize cellOffset to beginning-of-week
		return Math.floor(cellOffset / cellsPerWeek) * 7 // # of days from full weeks
			+ cellToDayMap[ // # of days from partial last week
				(cellOffset % cellsPerWeek + cellsPerWeek) % cellsPerWeek // crazy math to handle negative cellOffsets
			]
			- day0; // adjustment for beginning-of-week normalization
	}

	// day offset -> date (JavaScript Date object)
	function dayOffsetToDate(dayOffset) {
		var date = cloneDate(t.visStart);
		addDays(date, dayOffset);
		return date;
	}


	//
	// TRANSFORMATIONS: date -> day offset -> cell offset -> cell
	//

	// date -> cell (combines all transformations)
	function dateToCell(date) {
		var dayOffset = dateToDayOffset(date);
		var cellOffset = dayOffsetToCellOffset(dayOffset);
		var cell = cellOffsetToCell(cellOffset);
		return cell;
	}

	// date -> day offset
	function dateToDayOffset(date) {
		return dayDiff(date, t.visStart);
	}

	// day offset -> cell offset
	function dayOffsetToCellOffset(dayOffset) {
		var day0 = t.visStart.getDay(); // first date's day of week
		dayOffset += day0; // normalize dayOffset to beginning-of-week
		return Math.floor(dayOffset / 7) * cellsPerWeek // # of cells from full weeks
			+ dayToCellMap[ // # of cells from partial last week
				(dayOffset % 7 + 7) % 7 // crazy math to handle negative dayOffsets
			]
			- dayToCellMap[day0]; // adjustment for beginning-of-week normalization
	}

	// cell offset -> cell (object with row & col keys)
	function cellOffsetToCell(cellOffset) {
		var colCnt = t.getColCnt();

		// rtl variables. wish we could pre-populate these. but where?
		var dis = isRTL ? -1 : 1;
		var dit = isRTL ? colCnt - 1 : 0;

		var row = Math.floor(cellOffset / colCnt);
		var col = ((cellOffset % colCnt + colCnt) % colCnt) * dis + dit; // column, adjusted for RTL (dis & dit)
		return {
			row: row,
			col: col
		};
	}


	//
	// Converts a date range into an array of segment objects.
	// "Segments" are horizontal stretches of time, sliced up by row.
	// A segment object has the following properties:
	// - row
	// - cols
	// - isStart
	// - isEnd
	//
	function rangeToSegments(startDate, endDate) {
		var rowCnt = t.getRowCnt();
		var colCnt = t.getColCnt();
		var segments = []; // array of segments to return

		// day offset for given date range
		var rangeDayOffsetStart = dateToDayOffset(startDate);
		var rangeDayOffsetEnd = dateToDayOffset(endDate); // exclusive

		// first and last cell offset for the given date range
		// "last" implies inclusivity
		var rangeCellOffsetFirst = dayOffsetToCellOffset(rangeDayOffsetStart);
		var rangeCellOffsetLast = dayOffsetToCellOffset(rangeDayOffsetEnd) - 1;

		// loop through all the rows in the view
		for (var row=0; row<rowCnt; row++) {

			// first and last cell offset for the row
			var rowCellOffsetFirst = row * colCnt;
			var rowCellOffsetLast = rowCellOffsetFirst + colCnt - 1;

			// get the segment's cell offsets by constraining the range's cell offsets to the bounds of the row
			var segmentCellOffsetFirst = Math.max(rangeCellOffsetFirst, rowCellOffsetFirst);
			var segmentCellOffsetLast = Math.min(rangeCellOffsetLast, rowCellOffsetLast);

			// make sure segment's offsets are valid and in view
			if (segmentCellOffsetFirst <= segmentCellOffsetLast) {

				// translate to cells
				var segmentCellFirst = cellOffsetToCell(segmentCellOffsetFirst);
				var segmentCellLast = cellOffsetToCell(segmentCellOffsetLast);

				// view might be RTL, so order by leftmost column
				var cols = [ segmentCellFirst.col, segmentCellLast.col ].sort();

				// Determine if segment's first/last cell is the beginning/end of the date range.
				// We need to compare "day offset" because "cell offsets" are often ambiguous and
				// can translate to multiple days, and an edge case reveals itself when we the
				// range's first cell is hidden (we don't want isStart to be true).
				var isStart = cellOffsetToDayOffset(segmentCellOffsetFirst) == rangeDayOffsetStart;
				var isEnd = cellOffsetToDayOffset(segmentCellOffsetLast) + 1 == rangeDayOffsetEnd; // +1 for comparing exclusively

				segments.push({
					row: row,
					leftCol: cols[0],
					rightCol: cols[1],
					isStart: isStart,
					isEnd: isEnd
				});
			}
		}

		return segments;
	}


}

;;

function DayEventRenderer() {
	var t = this;


	// exports
	t.renderDayEvents = renderDayEvents;
	t.draggableDayEvent = draggableDayEvent; // made public so that subclasses can override
	t.resizableDayEvent = resizableDayEvent; // "


	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEventElement = t.reportEventElement;
	var eventElementHandlers = t.eventElementHandlers;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var allDayRow = t.allDayRow; // TODO: rename
	var colLeft = t.colLeft;
	var colRight = t.colRight;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var dateToCell = t.dateToCell;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var formatDates = t.calendar.formatDates;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var clearSelection = t.clearSelection;
	var getHoverListener = t.getHoverListener;
	var rangeToSegments = t.rangeToSegments;
	var cellToDate = t.cellToDate;
	var cellToCellOffset = t.cellToCellOffset;
	var cellOffsetToDayOffset = t.cellOffsetToDayOffset;
	var dateToDayOffset = t.dateToDayOffset;
	var dayOffsetToCellOffset = t.dayOffsetToCellOffset;


	// Render `events` onto the calendar, attach mouse event handlers, and call the `eventAfterRender` callback for each.
	// Mouse event will be lazily applied, except if the event has an ID of `modifiedEventId`.
	// Can only be called when the event container is empty (because it wipes out all innerHTML).
	function renderDayEvents(events, modifiedEventId) {

		// do the actual rendering. Receive the intermediate "segment" data structures.
		var segments = _renderDayEvents(
			events,
			false, // don't append event elements
			true // set the heights of the rows
		);

		// report the elements to the View, for general drag/resize utilities
		segmentElementEach(segments, function(segment, element) {
			reportEventElement(segment.event, element);
		});

		// attach mouse handlers
		attachHandlers(segments, modifiedEventId);

		// call `eventAfterRender` callback for each event
		segmentElementEach(segments, function(segment, element) {
			trigger('eventAfterRender', segment.event, segment.event, element);
		});
	}


	// Render an event on the calendar, but don't report them anywhere, and don't attach mouse handlers.
	// Append this event element to the event container, which might already be populated with events.
	// If an event's segment will have row equal to `adjustRow`, then explicitly set its top coordinate to `adjustTop`.
	// This hack is used to maintain continuity when user is manually resizing an event.
	// Returns an array of DOM elements for the event.
	function renderTempDayEvent(event, adjustRow, adjustTop) {

		// actually render the event. `true` for appending element to container.
		// Recieve the intermediate "segment" data structures.
		var segments = _renderDayEvents(
			[ event ],
			true, // append event elements
			false // don't set the heights of the rows
		);

		var elements = [];

		// Adjust certain elements' top coordinates
		segmentElementEach(segments, function(segment, element) {
			if (segment.row === adjustRow) {
				element.css('top', adjustTop);
			}
			elements.push(element[0]); // accumulate DOM nodes
		});

		return elements;
	}


	// Render events onto the calendar. Only responsible for the VISUAL aspect.
	// Not responsible for attaching handlers or calling callbacks.
	// Set `doAppend` to `true` for rendering elements without clearing the existing container.
	// Set `doRowHeights` to allow setting the height of each row, to compensate for vertical event overflow.
	function _renderDayEvents(events, doAppend, doRowHeights) {

		// where the DOM nodes will eventually end up
		var finalContainer = getDaySegmentContainer();

		// the container where the initial HTML will be rendered.
		// If `doAppend`==true, uses a temporary container.
		var renderContainer = doAppend ? $("<div/>") : finalContainer;

		var segments = buildSegments(events);
		var html;
		var elements;

		// calculate the desired `left` and `width` properties on each segment object
		calculateHorizontals(segments);

		// build the HTML string. relies on `left` property
		html = buildHTML(segments);

		// render the HTML. innerHTML is considerably faster than jQuery's .html()
		renderContainer[0].innerHTML = html;

		// retrieve the individual elements
		elements = renderContainer.children();

		// if we were appending, and thus using a temporary container,
		// re-attach elements to the real container.
		if (doAppend) {
			finalContainer.append(elements);
		}

		// assigns each element to `segment.event`, after filtering them through user callbacks
		resolveElements(segments, elements);

		// Calculate the left and right padding+margin for each element.
		// We need this for setting each element's desired outer width, because of the W3C box model.
		// It's important we do this in a separate pass from acually setting the width on the DOM elements
		// because alternating reading/writing dimensions causes reflow for every iteration.
		segmentElementEach(segments, function(segment, element) {
			segment.hsides = hsides(element, true); // include margins = `true`
		});

		// Set the width of each element
		segmentElementEach(segments, function(segment, element) {
			element.width(
				Math.max(0, segment.outerWidth - segment.hsides)
			);
		});

		// Grab each element's outerHeight (setVerticals uses this).
		// To get an accurate reading, it's important to have each element's width explicitly set already.
		segmentElementEach(segments, function(segment, element) {
			segment.outerHeight = element.outerHeight(true); // include margins = `true`
		});

		// Set the top coordinate on each element (requires segment.outerHeight)
		setVerticals(segments, doRowHeights);

		return segments;
	}


	// Generate an array of "segments" for all events.
	function buildSegments(events) {
		var segments = [];
		for (var i=0; i<events.length; i++) {
			var eventSegments = buildSegmentsForEvent(events[i]);
			segments.push.apply(segments, eventSegments); // append an array to an array
		}
		return segments;
	}


	// Generate an array of segments for a single event.
	// A "segment" is the same data structure that View.rangeToSegments produces,
	// with the addition of the `event` property being set to reference the original event.
	function buildSegmentsForEvent(event) {
		var startDate = event.start;
		var endDate = exclEndDay(event);
		var segments = rangeToSegments(startDate, endDate);
		for (var i=0; i<segments.length; i++) {
			segments[i].event = event;
		}
		return segments;
	}


	// Sets the `left` and `outerWidth` property of each segment.
	// These values are the desired dimensions for the eventual DOM elements.
	function calculateHorizontals(segments) {
		var isRTL = opt('isRTL');
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];

			// Determine functions used for calulating the elements left/right coordinates,
			// depending on whether the view is RTL or not.
			// NOTE:
			// colLeft/colRight returns the coordinate butting up the edge of the cell.
			// colContentLeft/colContentRight is indented a little bit from the edge.
			var leftFunc = (isRTL ? segment.isEnd : segment.isStart) ? colContentLeft : colLeft;
			var rightFunc = (isRTL ? segment.isStart : segment.isEnd) ? colContentRight : colRight;

			var left = leftFunc(segment.leftCol);
			var right = rightFunc(segment.rightCol);
			segment.left = left;
			segment.outerWidth = right - left;
		}
	}


	// Build a concatenated HTML string for an array of segments
	function buildHTML(segments) {
		var html = '';
		for (var i=0; i<segments.length; i++) {
			html += buildHTMLForSegment(segments[i]);
		}
		return html;
	}


	// Build an HTML string for a single segment.
	// Relies on the following properties:
	// - `segment.event` (from `buildSegmentsForEvent`)
	// - `segment.left` (from `calculateHorizontals`)
	function buildHTMLForSegment(segment) {
		var html = '';
		var isRTL = opt('isRTL');
		var event = segment.event;
		var url = event.url;

		// generate the list of CSS classNames
		var classNames = [ 'fc-event', 'fc-event-hori' ];
		if (isEventDraggable(event)) {
			classNames.push('fc-event-draggable');
		}
		if (segment.isStart) {
			classNames.push('fc-event-start');
		}
		if (segment.isEnd) {
			classNames.push('fc-event-end');
		}
		// use the event's configured classNames
		// guaranteed to be an array via `normalizeEvent`
		classNames = classNames.concat(event.className);
		if (event.source) {
			// use the event's source's classNames, if specified
			classNames = classNames.concat(event.source.className || []);
		}

		// generate a semicolon delimited CSS string for any of the "skin" properties
		// of the event object (`backgroundColor`, `borderColor` and such)
		var skinCss = getSkinCss(event, opt);

		if (url) {
			html += "<a href='" + htmlEscape(url) + "'";
		}else{
			html += "<div";
		}
		html +=
			" class='" + classNames.join(' ') + "'" +
			" style=" +
				"'" +
				"position:absolute;" +
				"left:" + segment.left + "px;" +
				skinCss +
				"'" +
			">" +
			"<div class='fc-event-inner'>";
		if (!event.allDay && segment.isStart) {
			html +=
				"<span class='fc-event-time'>" +
				htmlEscape(
					formatDates(event.start, event.end, opt('timeFormat'))
				) +
				"</span>";
		}
		html +=
			"<span class='fc-event-title'>" +
			htmlEscape(event.title || '') +
			"</span>" +
			"</div>";
		if (segment.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-" + (isRTL ? 'w' : 'e') + "'>" +
				"&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
				"</div>";
		}
		html += "</" + (url ? "a" : "div") + ">";

		// TODO:
		// When these elements are initially rendered, they will be briefly visibile on the screen,
		// even though their widths/heights are not set.
		// SOLUTION: initially set them as visibility:hidden ?

		return html;
	}


	// Associate each segment (an object) with an element (a jQuery object),
	// by setting each `segment.element`.
	// Run each element through the `eventRender` filter, which allows developers to
	// modify an existing element, supply a new one, or cancel rendering.
	function resolveElements(segments, elements) {
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			var event = segment.event;
			var element = elements.eq(i);

			// call the trigger with the original element
			var triggerRes = trigger('eventRender', event, event, element);

			if (triggerRes === false) {
				// if `false`, remove the event from the DOM and don't assign it to `segment.event`
				element.remove();
			}
			else {
				if (triggerRes && triggerRes !== true) {
					// the trigger returned a new element, but not `true` (which means keep the existing element)

					// re-assign the important CSS dimension properties that were already assigned in `buildHTMLForSegment`
					triggerRes = $(triggerRes)
						.css({
							position: 'absolute',
							left: segment.left
						});

					element.replaceWith(triggerRes);
					element = triggerRes;
				}

				segment.element = element;
			}
		}
	}



	/* Top-coordinate Methods
	-------------------------------------------------------------------------------------------------*/


	// Sets the "top" CSS property for each element.
	// If `doRowHeights` is `true`, also sets each row's first cell to an explicit height,
	// so that if elements vertically overflow, the cell expands vertically to compensate.
	function setVerticals(segments, doRowHeights) {
		var rowContentHeights = calculateVerticals(segments); // also sets segment.top
		var rowContentElements = getRowContentElements(); // returns 1 inner div per row
		var rowContentTops = [];

		// Set each row's height by setting height of first inner div
		if (doRowHeights) {
			for (var i=0; i<rowContentElements.length; i++) {
				rowContentElements[i].height(rowContentHeights[i]);
			}
		}

		// Get each row's top, relative to the views's origin.
		// Important to do this after setting each row's height.
		for (var i=0; i<rowContentElements.length; i++) {
			rowContentTops.push(
				rowContentElements[i].position().top
			);
		}

		// Set each segment element's CSS "top" property.
		// Each segment object has a "top" property, which is relative to the row's top, but...
		segmentElementEach(segments, function(segment, element) {
			element.css(
				'top',
				rowContentTops[segment.row] + segment.top // ...now, relative to views's origin
			);
		});
	}


	// Calculate the "top" coordinate for each segment, relative to the "top" of the row.
	// Also, return an array that contains the "content" height for each row
	// (the height displaced by the vertically stacked events in the row).
	// Requires segments to have their `outerHeight` property already set.
	function calculateVerticals(segments) {
		var rowCnt = getRowCnt();
		var colCnt = getColCnt();
		var rowContentHeights = []; // content height for each row
		var segmentRows = buildSegmentRows(segments); // an array of segment arrays, one for each row

		for (var rowI=0; rowI<rowCnt; rowI++) {
			var segmentRow = segmentRows[rowI];

			// an array of running total heights for each column.
			// initialize with all zeros.
			var colHeights = [];
			for (var colI=0; colI<colCnt; colI++) {
				colHeights.push(0);
			}

			// loop through every segment
			for (var segmentI=0; segmentI<segmentRow.length; segmentI++) {
				var segment = segmentRow[segmentI];

				// find the segment's top coordinate by looking at the max height
				// of all the columns the segment will be in.
				segment.top = arrayMax(
					colHeights.slice(
						segment.leftCol,
						segment.rightCol + 1 // make exclusive for slice
					)
				);

				// adjust the columns to account for the segment's height
				for (var colI=segment.leftCol; colI<=segment.rightCol; colI++) {
					colHeights[colI] = segment.top + segment.outerHeight;
				}
			}

			// the tallest column in the row should be the "content height"
			rowContentHeights.push(arrayMax(colHeights));
		}

		return rowContentHeights;
	}


	// Build an array of segment arrays, each representing the segments that will
	// be in a row of the grid, sorted by which event should be closest to the top.
	function buildSegmentRows(segments) {
		var rowCnt = getRowCnt();
		var segmentRows = [];
		var segmentI;
		var segment;
		var rowI;

		// group segments by row
		for (segmentI=0; segmentI<segments.length; segmentI++) {
			segment = segments[segmentI];
			rowI = segment.row;
			if (segment.element) { // was rendered?
				if (segmentRows[rowI]) {
					// already other segments. append to array
					segmentRows[rowI].push(segment);
				}
				else {
					// first segment in row. create new array
					segmentRows[rowI] = [ segment ];
				}
			}
		}

		// sort each row
		for (rowI=0; rowI<rowCnt; rowI++) {
			segmentRows[rowI] = sortSegmentRow(
				segmentRows[rowI] || [] // guarantee an array, even if no segments
			);
		}

		return segmentRows;
	}


	// Sort an array of segments according to which segment should appear closest to the top
	function sortSegmentRow(segments) {
		var sortedSegments = [];

		// build the subrow array
		var subrows = buildSegmentSubrows(segments);

		// flatten it
		for (var i=0; i<subrows.length; i++) {
			sortedSegments.push.apply(sortedSegments, subrows[i]); // append an array to an array
		}

		return sortedSegments;
	}


	// Take an array of segments, which are all assumed to be in the same row,
	// and sort into subrows.
	function buildSegmentSubrows(segments) {

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		segments.sort(compareDaySegments);

		var subrows = [];
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];

			// loop through subrows, starting with the topmost, until the segment
			// doesn't collide with other segments.
			for (var j=0; j<subrows.length; j++) {
				if (!isDaySegmentCollision(segment, subrows[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			if (subrows[j]) {
				subrows[j].push(segment);
			}
			else {
				subrows[j] = [ segment ];
			}
		}

		return subrows;
	}


	// Return an array of jQuery objects for the placeholder content containers of each row.
	// The content containers don't actually contain anything, but their dimensions should match
	// the events that are overlaid on top.
	function getRowContentElements() {
		var i;
		var rowCnt = getRowCnt();
		var rowDivs = [];
		for (i=0; i<rowCnt; i++) {
			rowDivs[i] = allDayRow(i)
				.find('div.fc-day-content > div');
		}
		return rowDivs;
	}



	/* Mouse Handlers
	---------------------------------------------------------------------------------------------------*/
	// TODO: better documentation!


	function attachHandlers(segments, modifiedEventId) {
		var segmentContainer = getDaySegmentContainer();

		segmentElementEach(segments, function(segment, element, i) {
			var event = segment.event;
			if (event._id === modifiedEventId) {
				bindDaySeg(event, element, segment);
			}else{
				element[0]._fci = i; // for lazySegBind
			}
		});

		lazySegBind(segmentContainer, segments, bindDaySeg);
	}


	function bindDaySeg(event, eventElement, segment) {

		if (isEventDraggable(event)) {
			t.draggableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
		}

		if (
			segment.isEnd && // only allow resizing on the final segment for an event
			isEventResizable(event)
		) {
			t.resizableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
		}

		// attach all other handlers.
		// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
		eventElementHandlers(event, eventElement);
	}


	function draggableDayEvent(event, eventElement) {
		var hoverListener = getHoverListener();
		var dayDelta;
		eventElement.draggable({
			delay: 50,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
					clearOverlays();
					if (cell) {
						var origDate = cellToDate(origCell);
						var date = cellToDate(cell);
						dayDelta = dayDiff(date, origDate);
						renderDayOverlay(
							addDays(cloneDate(event.start), dayDelta),
							addDays(exclEndDay(event), dayDelta)
						);
					}else{
						dayDelta = 0;
					}
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (dayDelta) {
					eventDrop(this, event, dayDelta, 0, event.allDay, ev, ui);
				}else{
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}
			}
		});
	}


	function resizableDayEvent(event, element, segment) {
		var isRTL = opt('isRTL');
		var direction = isRTL ? 'w' : 'e';
		var handle = element.find('.ui-resizable-' + direction); // TODO: stop using this class because we aren't using jqui for this
		var isResizing = false;

		// TODO: look into using jquery-ui mouse widget for this stuff
		disableTextSelection(element); // prevent native <a> selection for IE
		element
			.mousedown(function(ev) { // prevent native <a> selection for others
				ev.preventDefault();
			})
			.click(function(ev) {
				if (isResizing) {
					ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
					ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
					                               // (eventElementHandlers needs to be bound after resizableDayEvent)
				}
			});

		handle.mousedown(function(ev) {
			if (ev.which != 1) {
				return; // needs to be left mouse button
			}
			isResizing = true;
			var hoverListener = getHoverListener();
			var rowCnt = getRowCnt();
			var colCnt = getColCnt();
			var elementTop = element.css('top');
			var dayDelta;
			var helpers;
			var eventCopy = $.extend({}, event);
			var minCellOffset = dayOffsetToCellOffset( dateToDayOffset(event.start) );
			clearSelection();
			$('body')
				.css('cursor', direction + '-resize')
				.one('mouseup', mouseup);
			trigger('eventResizeStart', this, event, ev);
			hoverListener.start(function(cell, origCell) {
				if (cell) {

					var origCellOffset = cellToCellOffset(origCell);
					var cellOffset = cellToCellOffset(cell);

					// don't let resizing move earlier than start date cell
					cellOffset = Math.max(cellOffset, minCellOffset);

					dayDelta =
						cellOffsetToDayOffset(cellOffset) -
						cellOffsetToDayOffset(origCellOffset);

					if (dayDelta) {
						eventCopy.end = addDays(eventEnd(event), dayDelta, true);
						var oldHelpers = helpers;

						helpers = renderTempDayEvent(eventCopy, segment.row, elementTop);
						helpers = $(helpers); // turn array into a jQuery object

						helpers.find('*').css('cursor', direction + '-resize');
						if (oldHelpers) {
							oldHelpers.remove();
						}

						hideEvents(event);
					}
					else {
						if (helpers) {
							showEvents(event);
							helpers.remove();
							helpers = null;
						}
					}
					clearOverlays();
					renderDayOverlay( // coordinate grid already rebuilt with hoverListener.start()
						event.start,
						addDays( exclEndDay(event), dayDelta )
						// TODO: instead of calling renderDayOverlay() with dates,
						// call _renderDayOverlay (or whatever) with cell offsets.
					);
				}
			}, ev);

			function mouseup(ev) {
				trigger('eventResizeStop', this, event, ev);
				$('body').css('cursor', '');
				hoverListener.stop();
				clearOverlays();
				if (dayDelta) {
					eventResize(this, event, dayDelta, 0, ev);
					// event redraw will clear helpers
				}
				// otherwise, the drag handler already restored the old events

				setTimeout(function() { // make this happen after the element's click event
					isResizing = false;
				},0);
			}
		});
	}


}



/* Generalized Segment Utilities
-------------------------------------------------------------------------------------------------*/


function isDaySegmentCollision(segment, otherSegments) {
	for (var i=0; i<otherSegments.length; i++) {
		var otherSegment = otherSegments[i];
		if (
			otherSegment.leftCol <= segment.rightCol &&
			otherSegment.rightCol >= segment.leftCol
		) {
			return true;
		}
	}
	return false;
}


function segmentElementEach(segments, callback) { // TODO: use in AgendaView?
	for (var i=0; i<segments.length; i++) {
		var segment = segments[i];
		var element = segment.element;
		if (element) {
			callback(segment, element, i);
		}
	}
}


// A cmp function for determining which segments should appear higher up
function compareDaySegments(a, b) {
	return (b.rightCol - b.leftCol) - (a.rightCol - a.leftCol) || // put wider events first
		b.event.allDay - a.event.allDay || // if tie, put all-day events first (booleans cast to 0/1)
		a.event.start - b.event.start || // if a tie, sort by event start date
		(a.event.title || '').localeCompare(b.event.title) // if a tie, sort by event title
}


;;

//BUG: unselect needs to be triggered when events are dragged+dropped

function SelectionManager() {
	var t = this;


	// exports
	t.select = select;
	t.unselect = unselect;
	t.reportSelection = reportSelection;
	t.daySelectionMousedown = daySelectionMousedown;


	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var defaultSelectionEnd = t.defaultSelectionEnd;
	var renderSelection = t.renderSelection;
	var clearSelection = t.clearSelection;


	// locals
	var selected = false;



	// unselectAuto
	if (opt('selectable') && opt('unselectAuto')) {
		$(document).mousedown(function(ev) {
			var ignore = opt('unselectCancel');
			if (ignore) {
				if ($(ev.target).parents(ignore).length) { // could be optimized to stop after first match
					return;
				}
			}
			unselect(ev);
		});
	}


	function select(startDate, endDate, allDay) {
		unselect();
		if (!endDate) {
			endDate = defaultSelectionEnd(startDate, allDay);
		}
		renderSelection(startDate, endDate, allDay);
		reportSelection(startDate, endDate, allDay);
	}


	function unselect(ev) {
		if (selected) {
			selected = false;
			clearSelection();
			trigger('unselect', null, ev);
		}
	}


	function reportSelection(startDate, endDate, allDay, ev) {
		selected = true;
		trigger('select', null, startDate, endDate, allDay, ev);
	}


	function daySelectionMousedown(ev) { // not really a generic manager method, oh well
		var cellToDate = t.cellToDate;
		var getIsCellAllDay = t.getIsCellAllDay;
		var hoverListener = t.getHoverListener();
		var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
		if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
			unselect(ev);
			var _mousedownElement = this;
			var dates;
			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
				clearSelection();
				if (cell && getIsCellAllDay(cell)) {
					dates = [ cellToDate(origCell), cellToDate(cell) ].sort(dateCompare);
					renderSelection(dates[0], dates[1], true);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], true, ev);
					}
					reportSelection(dates[0], dates[1], true, ev);
				}
			});
		}
	}


}

;;

function OverlayManager() {
	var t = this;


	// exports
	t.renderOverlay = renderOverlay;
	t.clearOverlays = clearOverlays;


	// locals
	var usedOverlays = [];
	var unusedOverlays = [];


	function renderOverlay(rect, parent) {
		var e = unusedOverlays.shift();
		if (!e) {
			e = $("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>");
		}
		if (e[0].parentNode != parent[0]) {
			e.appendTo(parent);
		}
		usedOverlays.push(e.css(rect).show());
		return e;
	}


	function clearOverlays() {
		var e;
		while (e = usedOverlays.shift()) {
			unusedOverlays.push(e.hide().unbind());
		}
	}


}

;;

function CoordinateGrid(buildFunc) {

	var t = this;
	var rows;
	var cols;


	t.build = function() {
		rows = [];
		cols = [];
		buildFunc(rows, cols);
	};


	t.cell = function(x, y) {
		var rowCnt = rows.length;
		var colCnt = cols.length;
		var i, r=-1, c=-1;
		for (i=0; i<rowCnt; i++) {
			if (y >= rows[i][0] && y < rows[i][1]) {
				r = i;
				break;
			}
		}
		for (i=0; i<colCnt; i++) {
			if (x >= cols[i][0] && x < cols[i][1]) {
				c = i;
				break;
			}
		}
		return (r>=0 && c>=0) ? { row:r, col:c } : null;
	};


	t.rect = function(row0, col0, row1, col1, originElement) { // row1,col1 is inclusive
		var origin = originElement.offset();
		return {
			top: rows[row0][0] - origin.top,
			left: cols[col0][0] - origin.left,
			width: cols[col1][1] - cols[col0][0],
			height: rows[row1][1] - rows[row0][0]
		};
	};

}

;;

function HoverListener(coordinateGrid) {


	var t = this;
	var bindType;
	var change;
	var firstCell;
	var cell;


	t.start = function(_change, ev, _bindType) {
		change = _change;
		firstCell = cell = null;
		coordinateGrid.build();
		mouse(ev);
		bindType = _bindType || 'mousemove';
		$(document).bind(bindType, mouse);
	};


	function mouse(ev) {
		_fixUIEvent(ev); // see below
		var newCell = coordinateGrid.cell(ev.pageX, ev.pageY);
		if (!newCell != !cell || newCell && (newCell.row != cell.row || newCell.col != cell.col)) {
			if (newCell) {
				if (!firstCell) {
					firstCell = newCell;
				}
				change(newCell, firstCell, newCell.row-firstCell.row, newCell.col-firstCell.col);
			}else{
				change(newCell, firstCell);
			}
			cell = newCell;
		}
	}


	t.stop = function() {
		$(document).unbind(bindType, mouse);
		return cell;
	};


}



// this fix was only necessary for jQuery UI 1.8.16 (and jQuery 1.7 or 1.7.1)
// upgrading to jQuery UI 1.8.17 (and using either jQuery 1.7 or 1.7.1) fixed the problem
// but keep this in here for 1.8.16 users
// and maybe remove it down the line

function _fixUIEvent(event) { // for issue 1168
	if (event.pageX === undefined) {
		event.pageX = event.originalEvent.pageX;
		event.pageY = event.originalEvent.pageY;
	}
}
;;

function HorizontalPositionCache(getElement) {

	var t = this,
		elements = {},
		lefts = {},
		rights = {};

	function e(i) {
		return elements[i] = elements[i] || getElement(i);
	}

	t.left = function(i) {
		return lefts[i] = lefts[i] === undefined ? e(i).position().left : lefts[i];
	};

	t.right = function(i) {
		return rights[i] = rights[i] === undefined ? t.left(i) + e(i).width() : rights[i];
	};

	t.clear = function() {
		elements = {};
		lefts = {};
		rights = {};
	};

}

;;

})(jQuery);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/calendar-data-cache.js' */
/*
This code maintains a cache of calendar data, so we do not need to refetch data from the server unnecessarily,
especially when the user is scrolling quickly through the timeline view. The cache for each calendar contains a
start and end date that defines the range of data that is held by the cache. More data can be added to the cache
for a particular calendar by calling addDataToCalendar(), which will make sure to check for duplicate events, and
update the start and end dates for that cache.

NOTE: as the cache only maintains a single range it is possible to create gaps in the cache by pressing the 'Today'
button, therefore all caches must be removed when the 'Today' button is pressed.

Whenever a calendar is modified, e.g. an event is moved, deleted etc then the cache for that calendar should be
removed by calling removeCalendar().
 */

define("tc/calendar-cache", ["jquery"], function ($) {
    function CalendarCache() {
        var calendarCache = [];

        function appendDataToCalendar(calendar, data) {
            var dupe = false;
            //We need to filter out any duplicate events
            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < calendarCache[calendar].data.length; j++) {
                    if (data[i].id === calendarCache[calendar].data[j].id) {
                        dupe = true;
                        break;
                    }
                }

                if (!dupe) {
                    calendarCache[calendar].data.push(data[i]);
                }

                dupe = false;
            }
        }

        return {
            hasCalendar: function(calendarId) {
                return calendarCache[calendarId];
            },

            getCalendarStart: function(calendarId) {
                if (calendarCache[calendarId]) {
                    return calendarCache[calendarId].start;
                }

                return null;
            },

            getCalendarEnd: function(calendarId) {
                if (calendarCache[calendarId]) {
                    return calendarCache[calendarId].end;
                }

                return null;
            },

            addDataToCalendar: function(calendarId, data, start, end) {

                if (!calendarCache[calendarId]) {
                    calendarCache[calendarId] = {"data": data};
                } else {
                    appendDataToCalendar(calendarId, data);
                }

                if (!calendarCache[calendarId].start || start.getTime() < calendarCache[calendarId].start.getTime()) {
                    calendarCache[calendarId].start = start;
                }

                if (!calendarCache[calendarId].end || end.getTime() > calendarCache[calendarId].end.getTime()) {
                    calendarCache[calendarId].end = end;
                }
            },

            removeCalendar: function(calendarId) {
                if ($.isArray(calendarId)) {
                    var self = this;
                    $.each(calendarId, function(idIdx, calendarId) {
                        if ($.isPlainObject(calendarId) && calendarId.id && typeof calendarId.id === "string") { // A child sub-calendar object
                            self.removeCalendar(calendarId.id);
                        } else {
                            self.removeCalendar(calendarId.toString());
                        }
                    });
                } else {
                    delete calendarCache[calendarId];
                }
            },

            removeAllCalendars: function() {
                calendarCache = [];
            },

            getCalendarData: function(calendarId) {
                if (!calendarCache[calendarId]) {
                    return null;
                }

                return calendarCache[calendarId].data;
            }
        };
    }

    return CalendarCache;
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-remove-dialog/calendar-remove-dialog.js' */
define("tc/calendar-remove-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util",
        "tc/util"
    ], function
    (
        $,
        _,
        Backbone,
        Templates,
        CalUtil,
        Util
    )
    {
        "use strict";
        var CalendarRemoveDialog = Backbone.View.extend({
            removeSubCalendarDialog : null,
            _calendarDiv: null,
            subCalendar: null,
            _calendarPlugin : null,
            initialize: function(options){
                this._calendarDiv = options._calendarDiv;
                this.subCalendar = options.subCalendar;
                this._calendarPlugin = options._calendarPlugin;

                this.removeSubCalendarDialog = $('#remove-calendar-dialog');
            },
            render: function() {
                var that = this;
                var height;
                var inSpace = AJS.Meta.get("space-key") !== undefined || $("meta[name='ajs-page-id']").length >= 1;

                if (this.removeSubCalendarDialog) {
                    this.removeSubCalendarDialog.remove();
                }

                height = CalUtil.isPDLEnabled() ? 230: 200;
                this.removeSubCalendarDialog = new AJS.Dialog({
                    width : 512,
                    height : height,
                    id : 'remove-calendar-dialog'
                });

                this.removeSubCalendarDialog.addHeader("\u5220\u9664\u65e5\u7a0b\u8868",
                    "subcalendar-remove-header calendar-dialog-panel");
                this.removeSubCalendarDialog.addPanel(
                    "subcalendar-remove-calendar",
                    Templates.removeSubCalendar({inSpace: inSpace}),
                    "remove-subcalendar-form");

                // TEAMCAL-1608 will using css to create ellipsis for subCalendar.name
                var calendarToRemoveSpan = $('.calendar-to-remove', this.removeSubCalendarDialog.getPanel());
                calendarToRemoveSpan.attr("title", this.subCalendar.name);
                calendarToRemoveSpan.text(this.subCalendar.name);

                this.removeSubCalendarDialog.addButton("\u786e\u5b9a", function() {
                    if ($('#deletecalendaroption:checked', that.removeSubCalendarDialog.getPanel()).length) {
                        that._calendarPlugin.deleteSubCalendar(that._calendarDiv, that.subCalendar);
                    }
                    else { //otherwise we want to remove the calendar from our view
                        that._calendarPlugin.unsubscribeFromSubcalendar(that._calendarDiv, that.subCalendar);
                    }
                    that.removeSubCalendarDialog.hide();
                });

                this.removeSubCalendarDialog.addLink("\u53d6\u6d88", function(){
                    that.removeSubCalendarDialog.hide();
                });

                this.removeSubCalendarDialog.show();
            }

        });

        return CalendarRemoveDialog;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-feature-discovery-dialog/calendar-feature-discovery-dialog.js' */
define("tc/calendar-feature-discovery-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/dialogs",
        "tc/calendar-util",
        "tc/util"
    ], function
    (
        $,
        _,
        Backbone,
        Templates,
        Dialogs,
        CalUtil,
        Util
    )
    {
        "use strict";

        var CalendarFeatureDiscoveryDialog = Backbone.View.extend({
            featureDiscoveryDialog : null,
            _calendarDiv: null,
            subCalendar: null,
            _calendarPlugin : null,
            initialize: function(options){
                this._calendarDiv = options._calendarDiv;
                this.subCalendar = options.subCalendar;
                this._calendarPlugin = options._calendarPlugin;

                this.featureDiscoveryDialog = $('#team-calendars-feature-discovery-dialog');
            },
            render: function() {
                var that = this;

                if (this.featureDiscoveryDialog) {
                    this.featureDiscoveryDialog.remove();
                }

                var height = CalUtil.isPDLEnabled() ? 385 : 340,
                    discoveryDialog = new AJS.Dialog({width: 596, height: height, id: "team-calendars-feature-discovery-dialog"});

                discoveryDialog.addHeader("\u606d\u559c\uff0c\u60a8\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u7684\u65e5\u7a0b\u8868\uff01");
                discoveryDialog.addPanel(
                    "",
                    Templates.subCalendarFeatures(
                        {
                            "autoConvertSupported" : CalUtil.getParameter(this._calendarDiv, "autoConvertSupported") === "true",
                            "subCalendar" : this.subCalendar
                        }),
                    "setup-calendar-panel"
                );

                var dialogBody = discoveryDialog.getCurrentPanel().body;

                //Add event panel
                $(".add-event", dialogBody).click(function() {
                    discoveryDialog.remove();
                    var dialog = Dialogs.getEditEventDialog(
                        {
                            start : new Date(),
                            localizedStartTime : that._calendarPlugin.getDefaultStartTime(that._calendarDiv),
                            localizedEndTime : that._calendarPlugin.getDefaultEndTime(that._calendarDiv),
                            allDay : (that._calendarDiv.data(that._calendarPlugin.PREF_LAST_ALL_DAY_USED) || "true") === "true",
                            subCalendarId : that.subCalendar.id
                        },
                        that.subCalendar,
                        that._calendarPlugin,
                        that._calendarDiv
                    );
                    dialog.show();

                    return false;
                });

                //Restrictions panel
                $(".restrict", dialogBody).click(function() {
                    discoveryDialog.remove();
                    that._calendarPlugin.getSubCalendarRestrictionsDialog(that._calendarDiv, that.subCalendar).show();
                    return false;
                });

                //Share panel
                $(".embed, .embed-or-share, .share", dialogBody).click(function() {
                    discoveryDialog.remove();
                    var shareDialog = that._calendarPlugin.getSubCalendarShareDialog(that._calendarDiv, that.subCalendar);
                    shareDialog.show();
                    $(".share-address-field", shareDialog.getCurrentPanel().body).focus().select();

                    return false;
                });

                discoveryDialog.addLink("\u53d6\u6d88", function() {
                    discoveryDialog.remove();
                });

                discoveryDialog.show();
            }
        });

        return CalendarFeatureDiscoveryDialog;
    });
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-subcalendar-subscribe-dialog/calendar-subcalendar-subscribe-dialog.js' */
define("tc/calendar-subcalendar-subscribe-dialog",
    [
        "jquery",
        "underscore",
        "tc-backbone",
        "tc/templates",
        "tc/calendar-util",
        "tc/util",
        "tc/infinite-list",
        "tc/form-state-control"
    ], function
        (
            $,
            _,
            Backbone,
            Templates,
            CalUtil,
            Util,
            infiniteList,
            FormStateControl
            )
    {
        "use strict";
        var SubCalendarSubscibeDialog = Backbone.View.extend({
            subCalendarSubscibeDialog : null,
            callbackHandler: null,
            options: null,
            initialize: function(options){
                this.options = options;
                this.callbackHandler = options.callbackHandler
                this.subCalendarSubscibeDialog = $(this.options.id !== undefined ? this.options.id : "internal-subscription-calendar-dialog");
            },
            render: function() {
                var that = this;
                if (this.subCalendarSubscibeDialog) {
                    this.subCalendarSubscibeDialog.remove();
                }

                var searchSubCalendars = function(dialog, data, urlPath, noResultsFunction, resultsRenderedFunction, isInfiniteList) {
                    var resultsContainer = $(".results", dialog.getCurrentPanel().body);
                    $.ajax({
                        cache: false,
                        converters : {
                            "text json" : function(jsonObject) {
                                return jsonObject;
                            }
                        },
                        data : data,
                        dataFilter : function(data) {
                            var subCalendarsResponseEntity = $.parseJSON(data);
                            if (subCalendarsResponseEntity.success)
                                Confluence.TeamCalendars.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                            return subCalendarsResponseEntity.payload;
                        },
                        dataType: "json",
                        error : function(obj, status, error) {
                            if (noResultsFunction)
                                noResultsFunction(data, resultsContainer);
                        },
                        success : function(searchResults) {
                            if(!isInfiniteList) {
                                resultsContainer.empty();
                            }
                            if (searchResults && searchResults.length) {
                                var resultsTable = $(Templates.calendarSearchResultTable()),
                                    resultsBody = isInfiniteList ? $("tbody",$(resultsContainer)) : $("tbody", resultsTable),

                                    appendResultRow = function(matchingSubCalendar) {
                                        resultsBody.append(
                                            $(Templates.calendarSearchResult({
                                                "name" : matchingSubCalendar.name,
                                                "description" : matchingSubCalendar.description || "",
                                                "relatedSpace" : matchingSubCalendar.spaceName || "",
                                                "numSubscribers" : matchingSubCalendar.subscriberCount
                                            })).click(function() {
                                                var tableRow = $(this),
                                                    removeSelection = tableRow.hasClass("active");

                                                if (removeSelection) {
                                                    tableRow.removeClass("active");
                                                    $(".subcalendar-select", tableRow).removeAttr("checked");
                                                } else {
                                                    tableRow.addClass("active");
                                                    $(".subcalendar-select", tableRow).attr("checked", "checked");
                                                }

                                                var allUnwatchable = true,
                                                    selectedRows = $("tr.active", resultsBody);

                                                selectedRows.each(function() {
                                                    if ($(this).data("subCalendar").watchable) {
                                                        allUnwatchable = false;
                                                        return false;
                                                    }
                                                });

                                                if (selectedRows.length) {
                                                    enableAddButton();
                                                    enableWatchCheckbox();
                                                } else {
                                                    disableAddButton();
                                                    disableWatchCheckbox();
                                                }

                                                if (!selectedRows.length || allUnwatchable)
                                                    disableWatchCheckbox();
                                                else if (!allUnwatchable && !removeSelection)
                                                    enableWatchCheckbox();

                                            }).data("subCalendar", matchingSubCalendar)
                                        );
                                    };

                                $.each(searchResults, function(index, searchResult) {
                                    if (Confluence.TeamCalendars.isDummySubscriptionParentSubCalendar(searchResult)) {
                                        $.each(searchResult.childSubCalendars || [], function(subscriptionIdx, subscriptionSubCalendar) {
                                            appendResultRow(subscriptionSubCalendar);
                                        });
                                    } else {
                                        appendResultRow(searchResult);
                                    }
                                });

                                if(!isInfiniteList) {
                                    resultsContainer.append(resultsTable);
                                }

                                $(".ellipsedColumn", resultsTable).each(function() {
                                    var calDesc = $(this);
                                    var calDescText = calDesc.text();
                                    calDesc.attr("title", calDescText).addClass("relative").ThreeDots({ max_rows: 1 }).removeClass("relative");
                                });

                                if (resultsRenderedFunction) {
                                    resultsRenderedFunction(searchResults);
                                }

                            } else {
                                if (noResultsFunction)
                                    noResultsFunction(data, resultsContainer);
                            }
                        },
                        timeout : Confluence.TeamCalendars.ajaxTimeout,
                        url : Confluence.TeamCalendars.getCalendarServiceBaseUrl(urlPath)
                    });
                };

                var subCalendarSubscribeDialog = (function() {
                    var idSubscribeDialog = that.options.id !== undefined ? that.options.id : "internal-subscription-calendar-dialog";
                    var subscribeDialog = new AJS.Dialog({width : 800, height : 400, id : idSubscribeDialog});

                    subscribeDialog.addHeader("\u6dfb\u52a0\u73b0\u6709\u7684\u56e2\u961f\u65e5\u7a0b\u8868");

                    subscribeDialog.addPanel(
                        "",
                        Templates.subscribeDialog(),
                        "subscribe-to-subcalendars-panel"
                    );

                    var dialogBody = subscribeDialog.getCurrentPanel().body;

                    $("#subscribe-intro", dialogBody).append("\u4e3a\u4e86\u5e2e\u52a9\u60a8\u5f00\u59cb\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u65e5\u7a0b\u5217\u8868\uff0c\u9009\u62e9\u60a8\u5e0c\u671b\u8ba2\u9605\u7684\u65e5\u7a0b\uff0c\u5982\u679c\u6ca1\u6709\u60a8\u5e0c\u671b\u8ba2\u9605\u7684\u65e5\u7a0b\uff0c\u53ef\u4ee5\u81ea\u5df1 \u003ca class=\u0022create-your-subcalendar\u0022 href=\u0022#\u0022\u003e\u521b\u5efa\u4e00\u4e2a\u65e5\u7a0b\u003c/a\u003e\u3002");

                    $(".create-your-subcalendar", dialogBody).click(function() {
                        subscribeDialog.remove();

                        var subCalendarDialog = Confluence.TeamCalendars.Dialogs.getSubCalendarCreateDialog("parent", that.callbackHandler);
                        Util.showDialogInUpdatedHeight(subCalendarDialog);
                        $("input[name='name']", subCalendarDialog.getCurrentPanel().body).focus();

                        return false;
                    });

                    var searchContainer = $(".search", dialogBody);
                    $(".form", searchContainer).submit(function() {
                        // This form isn't to be submitted...
                        return false;
                    });


                    var searchRequestTimeout;
                    $("textarea[name='query']", searchContainer).text("\u641c\u7d22").addClass("blank-search").keydown(function(jsEvent) {
                        if (jsEvent.keyCode === 13)
                            return false;

                        var queryInput = $(this),
                            currentQuery = queryInput.hasClass("blank-search") ? queryInput.removeClass("blank-search").val("").val() : queryInput.val();

                        if (searchRequestTimeout !== undefined){
                            clearTimeout(searchRequestTimeout);
                        }

                        searchRequestTimeout = setTimeout(function() {
                            var actualQuery = queryInput.val();
                            if (!queryInput.hasClass("blank-search") && actualQuery && actualQuery !== currentQuery) {
                                var inSpaceOrPage = AJS.Meta.get("space-key") !== undefined || $("meta[name='ajs-page-id']").length >= 1;
                                searchContainer.addClass("searching");
                                searchSubCalendars(
                                    subscribeDialog,
                                    $.extend(
                                        {
                                            term : actualQuery,
                                            startIndex: 0,
                                            pageSize: 10,
                                            showSubscriberCount : true,
                                            showSubCalendarsInView: inSpaceOrPage
                                        },
                                        that.options.searchParams || {}
                                    ),
                                    "/search/subcalendars.json",
                                    function(data, resultsContainer) {
                                        searchContainer.removeClass("searching");
                                        disableAddButton();
                                        disableWatchCheckbox();
                                        resultsContainer.empty().append(
                                            $(document.createElement("span")).addClass("no-subcalendars-found").text(
                                                AJS.format("\u672a\u627e\u5230\u6709\u5173{0}\u7684\u7ed3\u679c", data.term)
                                            )
                                        );
                                    }, function() {
                                        searchContainer.removeClass("searching");
                                        enableAddButton();
                                        initScrollLoader();
                                    }
                                );
                            }

                        }, 500);
                    }).blur(function() {
                        var queryInput = $(this);
                        if (!$.trim(queryInput.val()))
                            queryInput.addClass("blank-search").val("\u641c\u7d22");
                    });

                    if (subscribeDialog.addHelpText && $.isFunction(subscribeDialog.addHelpText)) {
                        subscribeDialog.addHelpText(
                            $(document.createElement("span")).addClass("show-popular").html(
                                "\u60a8\u8fd8\u53ef\u4ee5\u6d4f\u89c8\u003ca href=\u0022#\u0022\u003e\u70ed\u95e8\u65e5\u7a0b\u8868\u003c/a\u003e \u3002"
                            )
                        );
                        // In Confluence 4, it appears that something would be bound to the link. If that is not unbound, a new window would popup
                        $("span.show-popular a", subscribeDialog.getCurrentPanel().page.buttonpanel).unbind("click").click(function() {
                            subscribeDialog.remove();
                            Confluence.TeamCalendars.Dialogs.getSubCalendarSubscribeDialog({
                                callbackHandler : that.callbackHandler,
                                heading: "\u70ed\u95e8\u56e2\u961f\u65e5\u7a0b\u8868"
                            }).show();
                            return false;
                        });

                        subscribeDialog.addHelpText(
                            $(document.createElement("span")).addClass("show-search").html(
                                "\u60a8\u8fd8\u53ef\u4ee5\u003ca href=\u0022#\u0022\u003e\u641c\u7d22\u65e5\u7a0b\u8868\u003c/a\u003e \u3002"
                            )
                        );

                        var showSearchPanel = function() {
                            subscribeDialog.remove();
                            Confluence.TeamCalendars.Dialogs.getSubCalendarSubscribeDialog(
                                $.extend(
                                    $.extend({}, that.options),
                                    {
                                        callbackHandler : that.callbackHandler,
                                        heading: "\u6dfb\u52a0\u73b0\u6709\u7684\u56e2\u961f\u65e5\u7a0b\u8868",
                                        showSearch: true
                                    }
                                )
                            ).show();
                            return false;
                        };
                        $("#" + subscribeDialog.id).find("span.show-search a").unbind("click").click(showSearchPanel);

                    }

                    var buttonPanel = $(".dialog-button-panel", subscribeDialog.popup.element);

                    if (!that.options.disableWatching) {
                        $(document.createElement("input")).attr({
                            type: "checkbox",
                            name: "watch"
                        }).addClass("watch-selected-subcalendars").appendTo(buttonPanel);
                        $(document.createElement("span")).addClass("watch-select-subcalendars-label").text("\u67e5\u770b\u9009\u5b9a\u7684\u65e5\u7a0b\u8868").appendTo(buttonPanel);
                    }

                    $("<span class='spinner hidden aui-icon aui-icon-wait'>Loading...</span>").appendTo(buttonPanel);

                    subscribeDialog.addButton("\u6dfb\u52a0", function() {
                        var selectedSubCalendars = $("tr.active", dialogBody);

                        if (selectedSubCalendars.length && !that.callbackHandler.isProcessingSubCalendar()) {
                            that.callbackHandler.setProcessingSubCalendar(true);
                            var spinnerDefer = that.callbackHandler.setSubCalendarSpinnerIconVisible();
                            disableAddButton();
                            disableWatchCheckbox();
                            showSpinner();

                            $.ajax({
                                cache: false,
                                converters : {
                                    "text json" : function(jsonObject) {
                                        return jsonObject;
                                    }
                                },
                                data: (function() {
                                    var requestData = {
                                        color: that.callbackHandler.getNextCalendarColor(),
                                        watchSubCalendars: $(".watch-selected-subcalendars", subscribeDialog.popup.element).is(":checked")
                                    };

                                    var subCalendarIds = [];
                                    selectedSubCalendars.each(function() {
                                        subCalendarIds.push($(this).data("subCalendar").id);
                                    });
                                    requestData.subCalendarIds = subCalendarIds;

                                    if (that.callbackHandler.getIncludedCalendars())
                                        requestData.include = that.callbackHandler.getIncludedCalendars();

                                    CalUtil.putCalendarContextParams(requestData);

                                    return requestData;
                                })(),
                                dataFilter : function(data) {
                                    var subCalendarsResponseEntity = $.parseJSON(data);
                                    if (subCalendarsResponseEntity.success)
                                        Confluence.TeamCalendars.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                                    return subCalendarsResponseEntity;
                                },
                                dataType : "json",
                                error: function(XMLHttpRequest, textStatus, errorThrown) {
                                    Confluence.TeamCalendars.showAjaxError(dialogBody, XMLHttpRequest, textStatus, errorThrown, "error-subcalendar-refresh");
                                    that.callbackHandler.setProcessingSubCalendar(false);
                                    enableAddButton();
                                    enableWatchCheckbox();
                                    hideSpinner();
                                },
                                success : function(responseEntity) {

                                    if(!responseEntity.success) {
                                        CalUtil.setGenericErrors(dialogBody, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", "error-subcalendar-refresh");
                                        return;
                                    }

                                    that.callbackHandler.setSubCalendars(
                                        AJS.$.map(selectedSubCalendars, function(each){return $(each).data("subCalendar").id}).toString(),
                                        responseEntity.payload);
                                    that.callbackHandler.updateAvailableSubCalendarsInSubCalendarPanel();
                                    //TODO How about a reset method?!
                                    CalUtil.setGenericErrors(dialogBody, null, "error-subcalendar-refresh");
                                    subscribeDialog.remove();
                                    that.callbackHandler.setProcessingSubCalendar(false);
                                },
                                complete: function(){
                                    if (spinnerDefer) spinnerDefer.resolve();
                                },
                                type: "PUT",
                                timeout : Confluence.TeamCalendars.ajaxTimeout,
                                url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendars/subscribe.json")
                            });
                        } else {
                            subscribeDialog.remove();
                        }
                    }, "subscribe-to-subcalendar-button");

                    subscribeDialog.addLink("\u53d6\u6d88", function() {
                        subscribeDialog.remove();
                        return false;
                    });

                    return subscribeDialog;
                })();


                var hideSpinnerAfterInfiniteScroll = function() {
                    var spinner =mergedOptions.showSearch ?  $(".subscribe-to-subcalendars-panel.search .spinner"): $(".subscribe-to-subcalendars-panel.popular .spinner");
                    $(spinner).css('display','none');
                };

                var showSpinnerWhenInfiniteScroll = function() {
                    var spinner = mergedOptions.showSearch ?  $(".subscribe-to-subcalendars-panel.search .spinner"): $(".subscribe-to-subcalendars-panel.popular .spinner");
                    $(spinner).css('display','inline-block');
                };

                var destroyInfinitive = function() {
                    hideSpinnerAfterInfiniteScroll();
                    scrollLoader.destroy();
                };

                var getPopularSubscribePaging = function(startIndex, pageSize) {
                    showSpinnerWhenInfiniteScroll();
                    searchSubCalendars(
                        subCalendarSubscribeDialog,
                        $.extend({ startIndex: startIndex, pageSize: pageSize }, that.options.searchParams || {}),
                        "/search/subcalendars/popular",
                        destroyInfinitive,
                        function() {
                            hideSpinnerAfterInfiniteScroll();
                        },
                        true
                    );
                };

                var getSearchSubscribePaging = function(startIndex, pageSize) {
                    var searchName = $("textarea[name='query']", $(".subscribe-to-subcalendars-panel.search")).val();
                    showSpinnerWhenInfiniteScroll();
                    searchSubCalendars(
                        subCalendarSubscribeDialog,
                        $.extend({
                            startIndex: startIndex,
                            pageSize: pageSize,
                            term : searchName,
                            showSubscriberCount : true,
                            showSubCalendarsInView: $("meta[name='ajs-page-id']").length >= 1
                        }, that.options.searchParams || {}),
                        "/search/subcalendars.json",
                        destroyInfinitive,
                        function() {
                            hideSpinnerAfterInfiniteScroll();
                        },
                        true
                    );
                }

                var scrollLoader = null;
                function initScrollLoader() {
                    if (scrollLoader) {
                        scrollLoader.destroy();
                    }

                    scrollLoader = infiniteList.init({
                        $el: $(".tc-subscription-result"),
                        load: mergedOptions.showSearch ? getSearchSubscribePaging : getPopularSubscribePaging,
                        $container: $(".subscribe-to-subcalendars-panel .tc-table-content"),
                        body: $(".subscribe-to-subcalendars-panel .tc-subscription-result")[0],
                        scrollMargin: 30,
                        isLoadMoreItems: mergedOptions.showSearch ? true : false
                    });
                }

                var dialogPanel = subCalendarSubscribeDialog.getCurrentPanel();

                var dialogPanelBody = dialogPanel.body;

                var disableAddButton = function() {
                    $(".subscribe-to-subcalendar-button", "#internal-subscription-calendar-dialog")
                        .attr("disabled", "disabled")
                        .addClass("ui-state-disabled");
                };

                var enableAddButton = function() {
                    $(".subscribe-to-subcalendar-button", "#internal-subscription-calendar-dialog")
                        .removeAttr("disabled", "disabled")
                        .removeClass("ui-state-disabled");
                };

                var disableWatchCheckbox = function() {
                    FormStateControl.disableElement($(".watch-selected-subcalendars", "#internal-subscription-calendar-dialog"));
                };

                var enableWatchCheckbox = function() {
                    FormStateControl.enableElement($(".watch-selected-subcalendars", "#internal-subscription-calendar-dialog"));
                };

                var showSpinner = function() {
                    $(".spinner", "#internal-subscription-calendar-dialog").removeClass("hidden");
                };

                var hideSpinner = function() {
                    $(".spinner", "#internal-subscription-calendar-dialog").addClass("hidden");
                };

                var mergedOptions = $.extend({
                    heading: "\u6dfb\u52a0\u73b0\u6709\u7684\u56e2\u961f\u65e5\u7a0b\u8868"
                }, this.options);

                var header = dialogPanel.page.header;

                header.empty().text(mergedOptions.heading);

                if (mergedOptions.showSearch) {
                    header.removeClass("welcome-heading-with-logo");
                } else {
                    header.addClass("welcome-heading-with-logo");
                }


                if (Confluence.TeamCalendars.isPDLEnabled()) {
                    if (mergedOptions.showSearch) {
                        dialogPanelBody.removeClass("popular").addClass("search");
                    } else {
                        dialogPanelBody.removeClass("search").addClass("popular");
                    }
                }

                $(".results", dialogPanelBody).empty();
                $(".mode", dialogPanelBody).removeClass().addClass("mode" + (mergedOptions.showSearch ? "" : " new-user"));

                var watchSubCalendarsCheckbox = $(".watch-selected-subcalendars");
                disableWatchCheckbox();

                if (that.callbackHandler.isAutoWatchSet()) {
                    watchSubCalendarsCheckbox.attr("checked", "checked");
                } else {
                    watchSubCalendarsCheckbox.removeAttr("checked");
                }

                disableAddButton();
                disableWatchCheckbox();

                if (mergedOptions.showSearch) {
                    if (Confluence.TeamCalendars.isCalendarSearchDisabled) {
                        $("#tc-subscribe-no-search-warning", dialogPanelBody).removeClass("hidden");
                        $(".search", dialogPanelBody).addClass("hidden");

                        searchSubCalendars(
                            subCalendarSubscribeDialog,
                            {},
                            "/search/subcalendars/all",
                            hideSpinner,
                            function() {
                                $("#tc-subscribe-no-search-warning .spinner", dialogPanelBody).addClass("hidden");
                            });
                    }

                    $("input[name='query']", dialogPanelBody).val("");
                    $(".dialog-tip .show-popular", dialogPanel.page.buttonpanel).removeClass("hidden");
                    $(".dialog-tip .show-search", dialogPanel.page.buttonpanel).addClass("hidden");
                } else {
                    var preamble = $(".preamble", dialogPanelBody).addClass("loading");
                    var hideSpinner = function() {
                        preamble.removeClass("loading");
                    };

                    searchSubCalendars(
                        subCalendarSubscribeDialog,
                        $.extend({ startIndex: 0, pageSize: 10 }, that.options.searchParams || {}),
                        "/search/subcalendars/popular",
                        hideSpinner,
                        function() {
                            hideSpinner();
                            initScrollLoader();
                        }
                    );

                    $(".dialog-tip .show-popular", dialogPanel.page.buttonpanel).addClass("hidden");
                    $(".dialog-tip .show-search", dialogPanel.page.buttonpanel).removeClass("hidden");
                }

                that.subCalendarSubscibeDialog = subCalendarSubscribeDialog;
                subCalendarSubscribeDialog.show();
                return subCalendarSubscribeDialog;
            }

        });

        return SubCalendarSubscibeDialog;
    });

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/components/calendar-subcalendar-subscribe-dialog/calendar-subcalendar-subscribe-dialog-compat.js' */
//This is here to make the existing API work.
require(["tc/calendar-subcalendar-subscribe-dialog"], function (SubCalendarSubscibeDialog) {
    //HACK
    if (!Confluence.TeamCalendars.Dialogs) {
        Confluence.TeamCalendars.Dialogs = {};
    }

    Confluence.TeamCalendars.Dialogs.getSubCalendarSubscribeDialog = function (dialogOptions) {
        return new SubCalendarSubscibeDialog(dialogOptions).render();
    };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/add-from-macro-dialog.js' */
(function($) {
    Confluence.TeamCalendars.Dialogs.getAddDialogForMacro = function(macro) {
        var existingMacroCals = macro.params ? macro.params.id : "";

        var callbackHandler = {
            //Define a callback handler to handle callbacks from the create calendar dialogs
            isProcessingSubCalendar : function() {
                return false;
            },

            setProcessingSubCalendar : function (aBool) {
                //do nothing
            },

            setSubCalendarSpinnerIconVisible : function(aBool) {
                //do nothing
            },

            getIncludedCalendars : function() {
                return existingMacroCals ? existingMacroCals.split(",") : [];
            },

            showAjaxUpdateError : function(XMLHttpRequest, textStatus, errorThrown){
                Confluence.TeamCalendars.showAjaxError($("#editor-messages"), XMLHttpRequest, textStatus, errorThrown, "error-subcalendar-update");
            },

            showAjaxError : function(XMLHttpRequest, textStatus, errorThrown, errorClass) {
                Confluence.TeamCalendars.showAjaxError($("#editor-messages"), XMLHttpRequest, textStatus, errorThrown, errorClass);
            },

            setGenericErrors : function(message, errorClass) {
                Confluence.TeamCalendars.setGenericErrors($("#editor-messages"), null, errorClass)
            },

            setGenericUpdateError : function() {
                Confluence.TeamCalendars.setGenericErrors($("#editor-messages"), null, "error-subcalendar-update")
            },

            setSubCalendars : function(newCalendars) {
                if (!existingMacroCals) {
                    Confluence.TeamCalendars.fireEventForAnalytics("subcalendar.parent.embedded");
                }

                var calIds = newCalendars + (existingMacroCals ? "," + existingMacroCals : "");

                macro.params = $.extend(macro.params, {id : calIds});
                macro.body = '';

                //Make sure something is selected in IE
                AJS.Rte.BookmarkManager.restoreBookmark();
                var promise = tinymce.confluence.MacroUtils.insertMacro({macro : macro, contentId : Confluence.Editor.getContentId()});

                //Show a help tip after the node is created
                $.when(promise).done(function(node) {
                    if (node) { //node seems to be null on some older versions of confluence. Not much we can do, so give up.
                        var helptip = new Confluence.TeamCalendars.HelpTip({
                            body: "\u003ch3\u003e\u65e5\u7a0b\u8868\u5df2\u6dfb\u52a0\uff0c\u4e0b\u4e00\u6b65\u505a\u4ec0\u4e48\uff1f\u003c/h3\u003e \u003cp\u003e\u5d4c\u5165\u5176\u4ed6\u65e5\u7a0b\u8868, \u6216\u4fee\u6539\u5b83\u4eec\u7684\u5916\u89c2, \u53ea\u8981\u70b9\u51fb \u003cstrong\u003e\u0027\u7f16\u8f91\u0027\u003c/strong\u003e \u5e76\u9009\u5b9a\u4e4b\u3002\u003c/p\u003e\u003cp\u003e\u60a8\u51c6\u5907\u597d\u4e4b\u540e\uff0c\u4fdd\u5b58\u597d\u60a8\u7684\u9875\u9762\uff0c\u5e76\u5f00\u59cb\u589e\u52a0\u4e8b\u5b9c\uff01\u003c/p\u003e",
                            anchor: $(node),
                            id: "first-calendar-help-tip"
                        });

                        helptip.show();
                    }
                });
            },

            setParameter : function(configKey, value) {
                //do nothing
            },

            getParameter : function(configKey) {
                // Return null - does nothing
            },

            reloadSubCalendar : function(subCalendarId) {
                //Do nothing, not needed in the editor
            },

            getSubCalendars : function() {
                return macro.params;
            },

            updateAvailableSubCalendarsInSubCalendarPanel : function() {
                //Do nothing. Not needed in editor
            },

            getNextCalendarColor : function() {
                return ""; //We let the server pick a color for us
            },

            isAutoWatchSet : function() {
                return false;
            },

            refreshCachedSubCalendars : function(successHandler, errorHandler) {
                //Do nothing, not needed in the editor
            },

            handleImport : function(subcalendarId) {
                this.setSubCalendars(subcalendarId);
            },

            isCalendarInEditMode : function() {
                //You cannot edit calendars from the editor, only create them, so they are always in edit mode
                return true;
            },

            suppressMessage : function(messageKey, successCallback) {
                Confluence.TeamCalendars.suppressMessage($("#editor-messages"), messageKey, successCallback)
            },

            showCalendarWizard : function() {
                Confluence.TeamCalendars.Dialogs.getAddDialog(callbackHandler);
            },

            getSubCalendarsWhichCanAddEvents : function() {
                return []; // It doesn't make sense to be able to add a JIRA event series from the editor.
            }
        };

        if (Confluence.TeamCalendars.shouldShowTimezoneSetup()) {
            Confluence.TeamCalendars.Dialogs.getTimeZoneSetupDialog(callbackHandler).show();
        } else {
            AJS.Rte.BookmarkManager.storeBookmark();
            Confluence.TeamCalendars.Dialogs.getAddDialog(callbackHandler, { "title" : "\u63d2\u5165\u65e5\u7a0b\u8868" });
        }
    };
}(AJS.$));

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/calendar-edit-dialog.js' */
(function($) {
    var FormStateControl = require('tc/form-state-control');

    /**
     * Returns a helper object that contains functionality common to subcalendar edit dialogs.
     */
    Confluence.TeamCalendars.getEditCalendarDialogHelper = function(editForm, subCalendar, callbackHandler) {
        var okButton,
            formMode = $(".form-mode", editForm),
            spaceKeyField = $("input[name='spaceKey']", editForm),
            spaceKeyAutocompleteField = $("input[name='spaceKeyAutocomplete']", editForm);

        return {
            initSpaceDropDown : function() {
                spaceKeyAutocompleteField.keypress(function(e) {
                    if (e.which !== 13) {
                        spaceKeyField.val(e.which);
                    }
                });

                spaceKeyAutocompleteField.bind("selected.autocomplete-content", function(e, selection) {
                    spaceKeyField.val(selection.content.key);
                    $(this).val(selection.content.name);
                    $(".spaceKeyAutocomplete-error", editForm).empty();
                });
            },

            initTimeZoneSelect : function() {
                $("select[name='timeZoneIdSelect']", editForm).change(function() {
                    $("input[name='timeZoneId']", editForm).val($("option:selected", this).val());
                });
            },

            initCloseButton : function(dialog, callBackCancel) {
                dialog.addLink(
                        "\u53d6\u6d88",
                        function() {
                            if(typeof callBackCancel === "function") {
                                callBackCancel();
                            }
                            dialog.remove();
                            return false;
                        }
                );
            },

            initOkButton : function(label, dialog) {
                dialog.addButton(
                    label,
                    function() {
                        editForm.submit();
                        return false;
                    },
                    "submit"
                );

                okButton = dialog.popup.element.find(".submit");
            },

            populateTimeZoneDropDown : function(editPanel) {
                var timeZoneToSelect = subCalendar ? subCalendar.timeZoneId : Confluence.TeamCalendars.getUserTimeZone();
                var timeZoneIdSelect = $("#timeZoneIdSelect", editPanel.body);

                FormStateControl.disableElement(okButton);

                Confluence.TeamCalendars.populateTimeZoneDropDown(
                        timeZoneIdSelect,
                        timeZoneToSelect,
                        function() {
                            FormStateControl.enableElement(okButton);
                            timeZoneIdSelect.addClass("ready");
                        },
                        function(XMLHttpRequest, textStatus, errorThrown) {
                            callbackHandler.showAjaxError(XMLHttpRequest, textStatus, errorThrown);
                        });
            },

            disableOkButton : function(label) {
                okButton.text(label)
                    .attr("disabled", "disabled").addClass("ui-state-disabled");
            },

            enableOkButton : function(label) {
                okButton.text(label)
                    .removeAttr("disabled").removeClass("ui-state-disabled");
            },

            isNewCalendar : function() {
                return subCalendar ? false : true;
            },

            resetFieldErrors : function() {
                Confluence.TeamCalendars.setFieldErrors(editForm, null);
            },

            setFormModeEdit : function() {
                formMode.removeClass().addClass("form-mode edit");
            },

            setFormModeCreate : function() {
                formMode.removeClass().addClass("form-mode create");
            },

            setFormModeReadOnly : function() {
                formMode.removeClass().addClass("form-mode read-only");
            },

            setHeading : function(heading, dialog) {
                return dialog.getCurrentPanel().page.header.empty().text(heading).addClass("calendar-heading");
            },

            setSubCalendarIdField : function(id) {
                $("input[name='subCalendarId']", editForm).val(id);
            },

            setNameField : function(name) {
                $("input[name='name']", editForm).val(name);
            },

            setDescriptionField : function(description) {
                $("textarea[name='description']", editForm).val(description);
            },

            setColorField : function(color) {
                $("input[name='color']", editForm).val(color);
            },

            setSpaceKeyField : function(spaceKey) {
                spaceKeyField.val(spaceKey);
            },

            setSpaceKeyAutocompleteField : function(spaceName) {
                spaceKeyAutocompleteField.val(spaceName);
            },

            setTimeZoneIdField : function(timeZoneId) {
                $("input[name='timeZoneId']", editForm).val(timeZoneId);
            },

            setTimeZoneIdDisplayField : function(timeZoneId) {
                $(".timeZoneIdDisplay", editForm).text(timeZoneId);
            },

            setSubscriptionIdField : function(subscriptionId) {
                $("input[name='subscriptionId']", editForm).val(subscriptionId);
            },

            setLocationField : function(location) {
                $("input[name='location']", editForm).val(location);
            },

            setUserNameField : function(userName) {
                $("input[name='username']", editForm).val(userName);
            },

            setSpaceToDefault : function() {
                //If we are in a space set the space field to the current space, otherwise blank
                spaceKeyField.val(AJS.Meta.get("space-key") || "");
                spaceKeyAutocompleteField.val(AJS.Meta.get("space-name") || "");
            }
        }
    };

    Confluence.TeamCalendars.Dialogs.getSubCalendarCreateDialog = function(subCalendar, callbackHandler) {
        var Util = require("tc/util"),
            subCalendarType = (typeof subCalendar === "string") ? subCalendar : subCalendar.type,
            editForm,
            subCalendarTypeObj = Confluence.TeamCalendars.subcalendar[subCalendarType],
            editDialog = new AJS.ConfluenceDialog ({
                    width : subCalendarTypeObj.dialogWidth || 521,
                    height : "auto",
                    onSubmit : function() {
                        editForm.submit();
                        return false;
                    },
                    id : "create-calendar-dialog"
                }
            ),
            subCalendarTypeHandler = subCalendarTypeObj.getDialog(
                editDialog,
                $.isPlainObject(subCalendar) ? subCalendar : null,
                callbackHandler
            );

        //Make overflow visible so that the JQL autocomplete etc are not cut off
        editDialog.popup.element.css("overflow", "visible");
        editForm = subCalendarTypeHandler.initializeForm();

        editForm.submit(function() {
           if (callbackHandler.isProcessingSubCalendar())
               return false;

           callbackHandler.setProcessingSubCalendar(true);
           var spinnerDefer = callbackHandler.setSubCalendarSpinnerIconVisible(true);
           subCalendarTypeHandler.onSubmitStart();

           var requestData = subCalendarTypeHandler.getFormDataAsAjaxData();
           if (callbackHandler.getIncludedCalendars())
               requestData.include = callbackHandler.getIncludedCalendars();

           var subCalendarId = requestData.subCalendarId;

           $.ajax({
               cache : false,
               converters : {
                   "text json" : function(jsonObject) {
                       return jsonObject;
                   }
               },
               data : requestData,
               dataFilter : function(data) {
                   var subCalendarsResponseEntity = $.parseJSON(data);
                   if (subCalendarsResponseEntity.success)
                       Confluence.TeamCalendars.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                   return subCalendarsResponseEntity;
               },
               dataType : "json",
               error : function(XMLHttpRequest, textStatus, errorThrown) {
                   callbackHandler.showAjaxUpdateError(XMLHttpRequest, textStatus, errorThrown);
                   subCalendarTypeHandler.onSubmitEnd();
                   callbackHandler.setProcessingSubCalendar(false);
               },
               success : function(responseEntity) {
                   callbackHandler.setGenericUpdateError();

                   if (responseEntity.success) {
                       Confluence.TeamCalendars.setFieldErrors(editForm, null);

                       var subCalendarEdited = subCalendarId;
                       if (subCalendarEdited) {
                           //TODO: rename this
                           callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                           callbackHandler.reloadSubCalendar(subCalendarId);
                       } else {
                           subCalendarId = responseEntity.modifiedSubCalendarId;
                           $("input[name='subCalendarId']", editForm).val(subCalendarId);
                           callbackHandler.setSubCalendars(subCalendarId, responseEntity.payload);
                       }

                       callbackHandler.updateAvailableSubCalendarsInSubCalendarPanel();
                       subCalendarTypeHandler.onSubmitEnd();
                       editDialog.remove();

                       if (!subCalendarEdited) {
                           // start the calendar tour for new calendar
                           Confluence.TeamCalendars.CalendarTour().start(subCalendarId);
                       }
                   } else {
                       Confluence.TeamCalendars.setFieldErrors(editForm, responseEntity.fieldErrors);
                       subCalendarTypeHandler.onSubmitEnd();

                       if (!subCalendarTypeObj.dynamicDialogHeight) {
                           Util.showDialogInUpdatedHeight(editDialog);
                       }
                   }

                   callbackHandler.setProcessingSubCalendar(false);
               },
               complete: function(){
                   if (spinnerDefer) spinnerDefer.resolve();
               },
               type : "PUT",
               timeout: Confluence.TeamCalendars.ajaxTimeout,
               url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendars.json")
           });

           return false;
        });

        return editDialog;
    };
}(AJS.$));

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/calendar-plugin.js' */
define(
    'tc/calendar-plugin',
    [
        "jquery",
        "underscore",
        "ajs",
        "tc/calendar-cache",
        "tc/util",
        "tc/calendar-util",
        "tc/manage-event",
        "tc/manage-i18n-text",
        "tc/full-calendar-option",
        "tc/subcalendar-panel",
        "tc/auto-complete-search-helper",
        "tc/calendar-remove-dialog",
        "tc/calendar-feature-discovery-dialog",
        "tc/calendar-share-dialog",
        "tc/calendar-restriction-dialog",
        "tc/myCalendarTour",
        "tc/subcalendar-navigation-buttons-view",
        "tc/subcalendar-restriction-button-view",
        "tc/load-favicon",
        "tc/calendar-caldav-subscribe-model",
        "tc/subcalendar-subscribe-dialog",
        "tc/calendar-caldav-subscribe-service"
    ],
    function(
        $,
        _,
        AJS,
        CalendarCache,
        Util,
        CalUtil,
        ManageEvent,
        ManageI18nText,
        FullCalendarOption,
        SubCalendarPanel,
        AutoCompleteSearchHelper,
        CalendarRemoveDialog,
        CalendarFeatureDiscoveryDialog,
        CalendarShareDialog,
        RestrictionDialog,
        CalendarTour,
        CalendarNavigationButtonsView,
        CalendarRestrictionButtonsView,
        Favicon,
        CalendarSubscribeModel,
        CalendarSubscribeDialog,
        CalendarSubscribeService
    )
    {
        "use strict";
        var cache = new CalendarCache();

        var CalendarPlugin = {
            spinnerDeferTasks : [],
            ajaxTimeout : Confluence.TeamCalendars.ajaxTimeout,
            i18nMessages : null,
            dialogSequence : 0,
            ERROR_CLASS_EVENT_UPDATE : "error-event-update",
            ERROR_CLASS_EVENT_DELETE : "error-event-delete",
            ERROR_CLASS_SUB_CALENDAR_LIST : "error-subcalendar-refresh",
            ERROR_CLASS_SUB_CALENDAR_DELETE : "error-subcalendar-delete",
            ERROR_CLASS_SUB_CALENDAR_UPDATE : "error-subcalendar-update",
            ERROR_CLASS_SUB_CALENDAR_WATCH : "error-subcalendar-watch",
            ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS : "error-subcalendar-list-events-",
            ERROR_CLASS_SUB_CALENDAR_TOGGLE_EVENTS : "error-subcalendar-toggle-events-",
            ERROR_CLASS_CONFIG_UPDATE : "error-config-update",
            ERROR_CLASS_PRIVATE_URL : "error-private-url",
            ERROR_CLASS_RESET_PRIVATE_URLS : "error-reset-private-urls",
            PREF_LAST_ALL_DAY_USED : "pref-all-day-event-default",

            init : function(calendarDiv) {
                var fullCalendarOptions = new FullCalendarOption(CalendarPlugin, calendarDiv, cache);

                if (CalendarPlugin.getParameter(calendarDiv, "width")) {
                    calendarDiv.parent().css("width", CalendarPlugin.getParameter(calendarDiv, "width") + "px");
                }

                if (CalendarPlugin.getParameter(calendarDiv, "height")) {
                    fullCalendarOptions.height = parseInt(CalendarPlugin.getParameter(calendarDiv, "height"));
                } else {
                    fullCalendarOptions.aspectRatio = 1.9;
                }

                if(CalendarPlugin.getParameter(calendarDiv, "displayWeekNumber"))
                {
                    fullCalendarOptions.weekNumbers = (CalendarPlugin.getParameter(calendarDiv, "displayWeekNumber") === "true");
                }

                this.getCalendarPanel(calendarDiv).fullCalendar(fullCalendarOptions);
                this.initCalendarDiv(calendarDiv);
            },

            getEventTypeNames : function (key){
                return ManageI18nText(this.i18nMessages).getEventTypeNames(key);
            },

            getMonthNames : function() {
                return ManageI18nText(this.i18nMessages).getMonthNames();
            },

            getMonthNamesShort : function() {
                return ManageI18nText(this.i18nMessages).getMonthNamesShort();
            },

            getDayNames : function() {
                return ManageI18nText(this.i18nMessages).getDayNames();
            },

            getDayNamesShort : function() {
                return ManageI18nText(this.i18nMessages).getDayNamesShort();
            },

            hideInlineAuiDialogs : function() {
                $("body").trigger("click");
            },

            isEventToolTipSuppressed : function(calendarDiv) {
                return calendarDiv.data("shouldSuppressEventToolTip");
            },

            setSuppressEventToolTip: function(calendarDiv, shouldSuppressEventToolTip) {
                calendarDiv.data("shouldSuppressEventToolTip", shouldSuppressEventToolTip);
            },

            setEventTooltipVisible : function(calendarDiv, event, jsEvent, visible) {
                if (visible && (this.isEventEditable(calendarDiv, event) || event.workingUrl)) {
                    var toolTip = $("body > .event-tooltip").length
                        ? $("body > .event-tooltip")
                        : $("<div/>", { "class" : "event-tooltip"}).appendTo($("body"));
                    $("p", toolTip).remove();

                    if (this.isEventEditable(calendarDiv, event))
                        toolTip.append($("<p/>", { "text" : "\u6309\u4f4fShift\u7136\u540e\u70b9\u51fb\u9f20\u6807\u6765\u5f39\u51fa\u7f16\u8f91\u5bf9\u8bdd\u6846" }));

                    if (event.workingUrl)
                        toolTip.append(
                            $("<p/>", { "class" : "follow-hint", "text" : AJS.format("ctrl/command+\u70b9\u51fb \u524d\u5f80{0}", event.workingUrl) })
                        );

                    toolTip.css({
                        "left": jsEvent.pageX + "px",
                        "top" : (jsEvent.pageY + 5) + "px"
                    }).show();

                } else {
                    $("body > .event-tooltip").hide();
                }
            },

            getParameter : function(calendarDiv, configKey) {
                return CalUtil.getParameter(calendarDiv, configKey);
            },

            getParameters : function(calendarDiv) {
                return CalUtil.getParameters(calendarDiv);
            },

            setParameter : function(calendarDiv, configKey, value) {
                CalUtil.setParameter(calendarDiv, configKey, value);
            },

            getCalendarPanel : function(calendarDiv) {
                return $(".calendar-panel .calendar", calendarDiv);
            },

            getTimelineHeight : function(calendarDiv) {
                return CalendarPlugin.getParameter(calendarDiv, "timelineHeight");
            },

            getMaxMonthToDisplayTimelineCalendar : function(calendarDiv) {
                return CalendarPlugin.getParameter(calendarDiv, "maxMonthToDisplayTimelineCalendar");
            },

            getDefaultStartTime : function(calendarDiv) {
                return this.getParameter(calendarDiv, "timeSuggestion")[16];
            },

            getDefaultEndTime : function(calendarDiv) {
                return this.getParameter(calendarDiv, "timeSuggestion")[18];
            },

            reloadSubCalendar : function(calendarDiv, subCalendarIds) {
                if (!subCalendarIds) {
                    return;
                }

                subCalendarIds = $.isArray(subCalendarIds) ? subCalendarIds : [ subCalendarIds ];

                $(".sub-calendar-panel .subcalendar-item", calendarDiv).each(function() {

                    var subCalendarEntry = $(this),
                        parentSubCalendarId = subCalendarEntry.data("subCalendarId"),
                        childSubCalendarEntries = $(".child-subcalendar", subCalendarEntry),
                        subCalendarObject = CalendarPlugin.getSubCalendar(calendarDiv, parentSubCalendarId),
                        childSubCalendarIds = $.map(childSubCalendarEntries, function(childSubCalendarEntryElem) {
                            return $(childSubCalendarEntryElem).data("subCalendarId");
                        });

                    if ($.inArray(parentSubCalendarId, subCalendarIds) !== -1) {

                        var checkSubCalendarIsEnable = function(subCalendarId) {
                            for(var i = 0; i < childSubCalendarEntries.length; i++) {
                                if($(childSubCalendarEntries[i]).data("sub-calendar-id") === subCalendarId) {
                                    return !$(childSubCalendarEntries[i]).hasClass("subcalendar-disabled");
                                }
                            }
                            return false;
                        };

                        if (Confluence.TeamCalendars.isSubscriptionSubCalendar(subCalendarObject)) {
                            cache.removeCalendar(parentSubCalendarId);
                            CalendarPlugin.removeSubCalendarEventSource(calendarDiv, parentSubCalendarId);
                            CalendarPlugin.addSubCalendarEventSource(calendarDiv, parentSubCalendarId);
                        }

                        CalendarPlugin.removeSubCalendarEventSource(calendarDiv, $.map(
                            childSubCalendarIds,
                            function(childSubCalendarId) {
                                cache.removeCalendar(childSubCalendarId);
                                return childSubCalendarId;
                            }
                        ));

                        if(subCalendarObject.childSubCalendars !== undefined) {
                            var childSubCalendarIdsInObject = $.map(subCalendarObject.childSubCalendars, function(childSubCalendar) {
                                if(checkSubCalendarIsEnable(childSubCalendar.id) || !childSubCalendar.eventsHidden) {
                                    return childSubCalendar.id;
                                }
                            });
                            CalendarPlugin.addSubCalendarEventSource(calendarDiv, childSubCalendarIdsInObject);
                        }
                    }    else {
                        // Reload a particular child sub-calendar
                        var childSubCalendarIdsToEnable = [];

                        childSubCalendarEntries.filter(function() {
                            return $.inArray($(this).data("subCalendarId"), subCalendarIds) !== -1;
                        }).each(function() {
                            var childSubCalendarEntry = $(this),
                                childSubCalendarId = childSubCalendarEntry.data("subCalendarId");

                            cache.removeCalendar(childSubCalendarId);
                            if (childSubCalendarEntry.hasClass("subcalendar-disabled")) {
                                childSubCalendarEntry.removeClass("subcalendar-disabled");
                                childSubCalendarEntry.find(".child-subcalendar-checkbox").prop("checked", true);
                            } else {
                                CalendarPlugin.removeSubCalendarEventSource(calendarDiv, childSubCalendarId);
                            }

                            CalendarPlugin.addSubCalendarEventSource(calendarDiv, childSubCalendarId);
                            childSubCalendarIdsToEnable.push(childSubCalendarId);
                        });

                        if (childSubCalendarIdsToEnable.length) {
                            var subCalendarIdsToEnable = childSubCalendarIdsToEnable;
                            var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, parentSubCalendarId);
                            if (!CalUtil.isDummySubscriptionParentSubCalendar(subCalendar)) {
                                subCalendarIdsToEnable.push(subCalendar.id);
                            }
                            CalendarPlugin.setSubCalendarEventsHidden(calendarDiv, subCalendarIdsToEnable, false, subCalendarEntry);
                        }
                    }
                });
            },

            makeAutoCompleteSearch : function(calendarDiv, searchField, searchOptions, suggestionsContainer, suggestionClickHandler, resultFilter) {
                AutoCompleteSearchHelper.makeAutoCompleteSearch(calendarDiv, searchField, searchOptions, suggestionsContainer, suggestionClickHandler, resultFilter);
            },

            isProcessingEvent : function(calendarDiv) {
                return calendarDiv.data("processingEvent");
            },

            setProcessingEvent : function(calendarDiv, processing, eventForm) {
                if (eventForm) {
                    if (processing) {
                        if (eventForm.disableOkButton) {
                            eventForm.disableOkButton();
                        }
                    } else {
                        if (eventForm.enableOkButton) {
                            eventForm.enableOkButton();
                        }
                    }
                }
                calendarDiv.data("processingEvent", processing);
            },

            showAjaxError : function(container, XMLHttpRequest, textStatus, errorThrown, errorClass, subCalendar) {
                // http://stackoverflow.com/questions/699941/handle-ajax-error-when-a-user-clicks-refresh
                if (!CalendarPlugin.isPageUnloading) {
                    Confluence.TeamCalendars.showAjaxError(container, XMLHttpRequest, textStatus, errorThrown, errorClass, subCalendar);
                }
            },

            showHTMLGenericError: function(container, messageResponse, errorClass) {
                if (!CalendarPlugin.isPageUnloading) {
                    Confluence.TeamCalendars.showHTMLGenericError(container, messageResponse, errorClass);
                }
            },

            showRestrictedCalendarsWarning : function(calendarDiv) {
                $(".restricted-calendars-warning", calendarDiv).removeClass("hidden");
            },

            deleteEvent : function(calendarDiv, params, errorCallback, successCallback) {
                ManageEvent(CalendarPlugin, cache).deleteEvent(calendarDiv, params, errorCallback, successCallback);
            },

            getCalendarServiceBaseUrl : function(calendarDiv, relativePath) {
                return Confluence.TeamCalendars.getCalendarServiceBaseUrl(relativePath);
            },

            getSubCalendars : function(calendarDiv, filterFunction) {
                var subCalendars = calendarDiv.data("subCalendars") || [];
                if (filterFunction) {
                    var filteredSubCalendars = [];
                    $.each(subCalendars, function(index, aSubCalendar) {
                        if (filterFunction(aSubCalendar)) {
                            filteredSubCalendars.push(aSubCalendar);
                        }
                    });

                    return filteredSubCalendars;
                }

                return subCalendars;
            },

            isSubCalendarDeletable : function(calendarDiv, aSubCalendar) {
                return this.isCalendarInEditMode(calendarDiv) && aSubCalendar.deletable;
            },

            isSubCalendarAdministratable : function(calendarDiv, aSubCalendar) {
                return this.isCalendarInEditMode(calendarDiv) && aSubCalendar.administrable;
            },

            isSubCalendarEventsUpdatable : function(calendarDiv, aSubCalendar) {
                return this.isCalendarInEditMode(calendarDiv) && aSubCalendar.eventsEditable;
            },

            canAddEventsToSubcalendar : function(calendarDiv, aSubCalendar) {
                return this.isSubCalendarEventsUpdatable(calendarDiv, aSubCalendar) && !Confluence.TeamCalendars.isJiraSubCalendar(aSubCalendar);
            },

            doesSubCalendarHaveRestrictions : function(subCalendar) {
                return subCalendar.usersPermittedToView.length ||
                    subCalendar.groupsPermittedToView.length ||
                    subCalendar.usersPermittedToEdit.length ||
                    subCalendar.groupsPermittedToEdit.length;
            },

            getSubCalendarsWhichCanAddEvents : function(calendarDiv) {
                return this.getSubCalendars(calendarDiv, function(aSubCalendar) {
                    return CalendarPlugin.canAddEventsToSubcalendar(calendarDiv, aSubCalendar);
                });
            },

            /**
             * This method only get parent calendar by using parent calendar id or child sub calendar id
             * @param calendarDiv
             * @param subCalendarIdOrChildrenCalendarId
             * @returns {*}
             */
            getParentSubCalendar : function(calendarDiv, subCalendarIdOrChildrenCalendarId) {
                var theSubCalendar = null;

                $.each(this.getSubCalendars(calendarDiv), function(subCalendarIdx, subCalendar) {
                    if (subCalendar.id === subCalendarIdOrChildrenCalendarId) {
                        theSubCalendar = subCalendar;
                        return false;
                    } else {
                        var theChildSubCalendar = $.grep(subCalendar.childSubCalendars || [], function(childSubCalendar) {
                            return childSubCalendar.id == subCalendarIdOrChildrenCalendarId;
                        });

                        if ((theSubCalendar = theChildSubCalendar && theChildSubCalendar.length ? subCalendar : null))
                            return false; // Stop iterating
                    }
                });

                return theSubCalendar;
            },

            getSubCalendar : function(calendarDiv, subCalendarId) {
                var theSubCalendar = null;

                $.each(this.getSubCalendars(calendarDiv), function(subCalendarIdx, subCalendar) {
                    if (subCalendar.id === subCalendarId) {
                        theSubCalendar = subCalendar;
                        return false;
                    } else {
                        theSubCalendar = $.grep(subCalendar.childSubCalendars || [], function(childSubCalendar) {
                            return childSubCalendar.id == subCalendarId;
                        });

                        if ((theSubCalendar = theSubCalendar && theSubCalendar.length ? theSubCalendar[0] : null))
                            return false; // Stop iterating
                    }
                });

                return theSubCalendar;
            },

            getSanboxEventTypeRemindersFromSubCalendar: function(calendarDiv, subCalendarId) {
                var theSubCalendar =  this.getSubCalendar(calendarDiv, subCalendarId);
                if(theSubCalendar) {
                    return theSubCalendar.sanboxEventTypeReminders;
                }
            },

            getCurrentReminderForEventType: function(calendarDiv, eventEditDialog) {
                var eventTypeReminder = null;
                var subCalendarIdSelected = eventEditDialog.getSelectedSubCalendarId();
                var eventTypeSelected = eventEditDialog.getSelectedEventType();

                if (CalUtil.isCustomEventType(eventTypeSelected)) {
                    var customEventTypes = this.getCustomEventTypeFromSubCalendar(calendarDiv, subCalendarIdSelected);
                    if(customEventTypes) {
                        $.each(customEventTypes, function(idx, customEventTypeItem) {
                            if(customEventTypeItem.customEventTypeId === eventTypeSelected && customEventTypeItem.periodInMins > 0) {
                                eventTypeReminder = customEventTypeItem;
                                return false;
                            }
                        });
                    }
                } else {
                    var eventTypeReminders = this.getSanboxEventTypeRemindersFromSubCalendar(calendarDiv, subCalendarIdSelected);
                    if(eventTypeReminders) {
                        $.each(eventTypeReminders, function(idx, eventTypeReminderItem) {
                            if(eventTypeReminderItem.eventTypeId === eventTypeSelected || eventTypeReminderItem.eventTypeId === eventTypeSelected + "-calendar") {
                                eventTypeReminder = eventTypeReminderItem;
                                return false;
                            }
                        });
                    }
                }

                return eventTypeReminder;
            },

            getCustomEventTypeFromSubCalendar: function(calendarDiv, subCalendarId) {
                var theSubCalendar =  this.getSubCalendar(calendarDiv, subCalendarId);
                if(theSubCalendar) {
                    return theSubCalendar.customEventTypes;
                }
            },

            setSubCalendar: function(subCalendarId, calendarDiv, payload) {
                var subCalendars = calendarDiv.data("subCalendars");
                for(var i = 0; i < subCalendars.length; i++) {
                    if(subCalendars[i].id === subCalendarId) {
                        subCalendars[i] = $.isArray(payload) ? payload[0] : payload;
                    }
                }
                calendarDiv.data("subCalendars", subCalendars);
            },

            setSubCalendars : function(calendarDiv, subCalendars) {
                // filter restricted calendars in space view
                if(CalUtil.isSpaceCalendarView(calendarDiv)) {
                    subCalendars = _.filter(subCalendars, function(subcalendar){
                        return subcalendar.eventsViewable || CalUtil.isDummySubscriptionParentSubCalendar(subcalendar);
                    });
                }
                calendarDiv.data("subCalendars", $.isArray(subCalendars) ? subCalendars : (subCalendars ? [ subCalendars ] : null));
            },

            showSubCalendarEdit: function(calendarDiv, subCalendar) {
                var subCalendarEditDialog;
                //Jira is a special case. We show it in the edit event dialog.
                if (Confluence.TeamCalendars.isJiraSubCalendar(subCalendar)){
                    var isInternalSubscribe = Confluence.TeamCalendars.isInternalSubscriptionSubCalendar(subCalendar);

                    subCalendarEditDialog = Confluence.TeamCalendars.Dialogs.getEditEventDialog(
                        {   //Dummy event since we are abusing the edit event dialog
                            "title" : isInternalSubscribe ? subCalendar.sourceSubCalendar.name : subCalendar.name,
                            "eventType" : (isInternalSubscribe ? subCalendar.sourceSubCalendar.type : subCalendar.type) + "-calendar", //Add "-calendar" to the name so we know this is for editing a calendar, and not one of it's events.
                            "subCalendarId" : subCalendar.id
                            //"subCalendarId" : isInternalSubscribe ? subCalendar.sourceSubCalendar.id : subCalendar.id
                        },
                        subCalendar,
                        CalendarPlugin,
                        calendarDiv).show();
                } else {
                    var editDialogView = Confluence.TeamCalendars.Dialogs.getSubCalendarEditDialog(
                        subCalendar,
                        CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                        calendarDiv,
                        CalendarPlugin,
                        cache);

                    subCalendarEditDialog = editDialogView.render();

                    // show error message
                    var dialogContent = subCalendarEditDialog.getCurrentPanel().body;

                    Confluence.TeamCalendars.setFieldErrors(dialogContent, null);

                    subCalendarEditDialog.show();
                    //always show edit subcalendar dialog when edit
                    subCalendarEditDialog.gotoPanel(CalUtil.panelEditCalendar.GENERAL_PANEL);
                    $("input[name='name']", dialogContent).focus();

                    // HACK : don't know how to pass the view out hic
                    subCalendarEditDialog.belongedView = editDialogView;

                    // if Tour is running then go to add custom event type dialog
                    if (CalendarTour.isShowCustomEventTypeFrom(subCalendar.id)) {
                        editDialogView.showAddEventTypeForm();
                    }

                    //disable panel button edit/custom event type if don't have permission
                    if(!this.isSubCalendarAdministratable(calendarDiv, subCalendar)) {
                        $(subCalendarEditDialog.getPanel(CalUtil.panelEditCalendar.GENERAL_PANEL).button).addClass("hidden"); //disable general panel
                        $(subCalendarEditDialog.getPanel(CalUtil.panelEditCalendar.EVENT_TYPE_PANEL).button).addClass("hidden"); //disable custom event type
                        $(subCalendarEditDialog.getPanel(CalUtil.panelEditCalendar.RESTRICTION_PANEL).button).addClass("hidden"); //disable restriction
                    } else if(CalUtil.isSubscriptionSubCalendar(subCalendar)) {
                        $(subCalendarEditDialog.getPanel(CalUtil.panelEditCalendar.EVENT_TYPE_PANEL).button).addClass("hidden"); //can't add events to subscription calendars
                    }

                    //process behaviour when event type panel active
                    subCalendarEditDialog.getCurrentPanel().onselect = function() {
                        $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");
                    };
                }
                return subCalendarEditDialog;
            },
            showCustomEventEditForm : function (calendarDiv, subCalendar, eventTypeId, editEventDialog) {
                var subCalendarEditDialog = this.showSubCalendarEdit(calendarDiv, subCalendar);

                if ( !(!Confluence.TeamCalendars.isInternalSubscriptionSubCalendar(subCalendar) && Confluence.TeamCalendars.isJiraSubCalendar(subCalendar))) {
                    var editDialogView = subCalendarEditDialog.belongedView;
                    if(eventTypeId) {
                        // edit existed custom event
                        eventTypeId = Confluence.TeamCalendars.isJiraType(eventTypeId) ? eventTypeId + "-calendar" : eventTypeId;
                        editDialogView.selectCustomEvent(eventTypeId);
                    } else {
                        // add new custom event
                        editDialogView.showAddEventTypeForm();
                    }
                }
                subCalendarEditDialog.gotoPanel(CalUtil.panelEditCalendar.EVENT_TYPE_PANEL);
                return subCalendarEditDialog;
            },
            updateCustomEventType: function(calendarDiv, subCalendarId, customEventTypeData) {
                var dataSubcalendars = this.getSubCalendars(calendarDiv);

                for (var i = 0; i < dataSubcalendars.length; i++) {
                    if(dataSubcalendars[i].id === subCalendarId) {
                        var existCustomEventType = false;
                        for(var j = 0; j < dataSubcalendars[i].customEventTypes.length; j++) {
                            if(dataSubcalendars[i].customEventTypes[j].customEventTypeId === customEventTypeData.customEventTypeData) {
                                dataSubcalendars[i].customEventTypes[j] = customEventTypeData;
                                existCustomEventType = true;
                                break;
                            }
                        }
                        if(!existCustomEventType) {
                            dataSubcalendars[i].customEventTypes.push(customEventTypeData);
                        }
                        break;
                    }
                }

                calendarDiv.data("subCalendars", dataSubcalendars);
            },

            refreshCachedSubCalendars : function(calendarDiv, successCallback, errorCallback) {
                var requestData = { }; // Empty

                if (CalendarPlugin.getParameter(calendarDiv, "include")) {
                    requestData.include = CalendarPlugin.getParameter(calendarDiv, "include");
                }

                CalUtil.putCalendarContextParams(requestData);

                $.ajax({
                    cache : false,
                    converters : {
                        "text json" : function(jsonObject) {
                            return jsonObject;
                        }
                    },
                    data : requestData,
                    dataFilter : function(data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success)
                            CalendarPlugin.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        return subCalendarsResponseEntity;
                    },
                    dataType : "json",
                    error : function(XMLHttpRequest, textStatus, errorThrown) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                        if (errorCallback)
                            errorCallback(XMLHttpRequest, textStatus, errorThrown);
                    },
                    success : function(responseEntity) {
                        if (responseEntity.success) {
                            CalendarPlugin.setSubCalendars(calendarDiv, responseEntity.payload);
                            if (successCallback)
                                successCallback(responseEntity.payload);
                            CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                        } else {
                            CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST);
                        }
                    },
                    type: "GET",
                    timeout: CalendarPlugin.ajaxTimeout,
                    url : Confluence.TeamCalendars.getCalendarServiceBaseUrl("/subcalendars.json")
                });
            },

            mergeSubCalendarObjectsToArray : function(arrayWithSubCalendarObject) {
                return Confluence.TeamCalendars.mergeSubCalendarObjectsToArray(arrayWithSubCalendarObject);
            },

            setGenericErrors : function(container, message, errorClass) {
                Confluence.TeamCalendars.setGenericErrors(container, message, errorClass);
            },

            shouldShowFeatureDiscoveryDialog : function(calendarDiv, subCalendarId) {
                // fixed ticket TEAMCAL-1797
                return CalendarPlugin.getParameter(calendarDiv, "showCalendarDiscoveryDialog") === "true";
            },

            setSubCalendarEventsHidden : function(calendarDiv, subCalendarId, hidden, theEntry) {
                subCalendarId = $.isArray(subCalendarId) ? subCalendarId : subCalendarId;

                return $.ajax({
                    cache: false,
                    data: {
                        subCalendarId: subCalendarId
                    },
                    dataType: "json",
                    type: hidden ? "PUT" : "DELETE",
                    error: function(jqXHR, textStatus, errorThrown) {
                        $.each(subCalendarId, function(subCalendarIdIdx, _subCalendarId) {
                            CalendarPlugin.showAjaxError(
                                calendarDiv, jqXHR, textStatus, errorThrown,
                                CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_TOGGLE_EVENTS + CalendarPlugin.getStringAsHex(_subCalendarId)
                            );
                        });
                    },
                    success: function() {
                        $.each(subCalendarId, function(subCalendarIdIdx, _subCalendarId) {
                            //set status event when hidden
                            CalendarPlugin.getSubCalendar(calendarDiv, _subCalendarId).eventsHidden = hidden;
                            CalendarPlugin.checkCalendarHasAllChildDisable(theEntry);
                            CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_TOGGLE_EVENTS + CalendarPlugin.getStringAsHex(_subCalendarId));
                        });
                    },
                    timeout: CalendarPlugin.ajaxTimeout,
                    url: CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/preferences/events/hidden.json")
                });
            },

            checkCalendarHasAllChildDisable : function(subCalendarChecked) {
                $(subCalendarChecked).filter(function(){
                    var childs = $('li.child-subcalendar', subCalendarChecked);
                    var childEnables = $('li.child-subcalendar:not(.subcalendar-disabled)', subCalendarChecked);
                    if(childs.length !== 0 && childEnables.length === 0) {
                        subCalendarChecked.addClass("allchildsubcalendar-disabled").addClass("subcalendar-disabled");
                    } else {
                        subCalendarChecked.removeClass("allchildsubcalendar-disabled").removeClass("subcalendar-disabled");
                    }
                });
            },

            updateAvailableSubCalendarsInSubCalendarPanel : function(calendarDiv) {
                SubCalendarPanel(CalendarPlugin, calendarDiv, cache).updateAvailableSubCalendarsInSubCalendarPanel();
            },

            unsubscribeFromSubcalendar : function(calendarDiv, subCalendar) {
                if (!CalendarPlugin.isProcessingSubCalendar(calendarDiv)) {
                    CalendarPlugin.setProcessingSubCalendar(calendarDiv, true);
                    var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, true);
                    var resolveSpinner = function(){
                        if (spinnerDefer) spinnerDefer.resolve();
                    };

                    if (subCalendar.subscriptionId) {
                        CalendarPlugin._deleteSubCalendarInternal(calendarDiv, subCalendar.id,
                            function(XMLHttpRequest, textStatus, errorThrown) {
                                CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                resolveSpinner();
                                CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                            },
                            function(responseEntity) {
                                if (responseEntity.success) {
                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);

                                    // Clear all errors related to loading events of a sub-calendar (and its children).
                                    $.each($.merge([ subCalendar ], subCalendar.childSubCalendars || []), function(subCalendarIdx, subCalendar) {
                                        CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendar.id));
                                    });

                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendar.id);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendar.childSubCalendars);
                                    CalendarPlugin.setSubCalendars(calendarDiv, responseEntity.payload);
                                    CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                                } else {
                                    CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                }

                                resolveSpinner();
                                CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                            });
                    } else {
                        $.ajax({
                            cache: false,
                            converters : {
                                "text json" : function(jsonObject) {
                                    return jsonObject;
                                }
                            },
                            data: (function() {
                                var ajaxData = { subCalendarId : subCalendar.id };
                                if (CalendarPlugin.getParameter(calendarDiv, "include"))
                                    ajaxData.include = CalendarPlugin.getParameter(calendarDiv, "include");

                                CalUtil.putCalendarContextParams(ajaxData);

                                return ajaxData;
                            })(),
                            dataType: "json",
                            dataFilter : function(data) {
                                var subCalendarsResponseEntity = $.parseJSON(data);
                                if (subCalendarsResponseEntity.success)
                                    CalendarPlugin.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                                return subCalendarsResponseEntity;
                            },
                            error: function(jqXHR, textStatus, errorThrown) {
                                CalendarPlugin.showAjaxError(calendarDiv, jqXHR, textStatus, errorThrown);
                                CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                            },
                            success : function(responseEntity) {
                                // when delete/remove calendar in single view => redirect to current space calendars
                                if(CalUtil.isSingleCalendarView(calendarDiv)) {
                                    window.location.href = AJS.contextPath() + "/display/" + encodeURIComponent(AJS.Meta.get("space-key")) + "/calendars";
                                } else {
                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendar.id);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendar.childSubCalendars);
                                    CalendarPlugin.setSubCalendars(calendarDiv, responseEntity.payload);
                                    CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                                    CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                                }
                                AJS.trigger("calendar.removed");
                            },
                            complete: function(){
                                resolveSpinner();
                            },
                            type : "DELETE",
                            timeout : CalendarPlugin.ajaxTimeout,
                            url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/subcalendars/preferences.json")
                        });
                    }

                }
            },

            getNextUnusedSubCalendarColor : function(calendarDiv) {
                var subCalendars = CalendarPlugin.getSubCalendars(calendarDiv);
                var subCalendarColorClasses = CalendarPlugin.getParameter(calendarDiv, "subCalendarColorClass");
                for (var colorClassIndex = 0; colorClassIndex < subCalendarColorClasses.length; ++colorClassIndex) {
                    var colorClass = subCalendarColorClasses[colorClassIndex];
                    var colorClassUsed = false;

                    for (var subCalendarIndex = 0; subCalendarIndex < subCalendars.length; ++subCalendarIndex) {
                        if (colorClass === subCalendars[subCalendarIndex].color) {
                            colorClassUsed = true;
                            break;
                        }
                    }

                    if (!colorClassUsed)
                        return colorClass;
                }

                return subCalendars.length ? subCalendarColorClasses[subCalendars.length % subCalendarColorClasses.length] : "subcalendar-blue";
            },

            setProcessingSubCalendar : function(calendarDiv, processing) {
                calendarDiv.data("processingSubCalendar", processing);
            },

            isProcessingSubCalendar : function(calendarDiv) {
                return calendarDiv.data("processingSubCalendar");
            },

            getDeleteSubCalendarConfirmationDialog : function(calendarDiv, subCalendar, subscriberCount) {
                var deleteSubCalendarConfirmationDialog = this.createDeleteSubCalendarConfirmationDialog(calendarDiv, subCalendar, subscriberCount);
                $("input[name='subCalendarId']", deleteSubCalendarConfirmationDialog.getCurrentPanel().body).val(subCalendar.id);
                return deleteSubCalendarConfirmationDialog;
            },

            createDeleteSubCalendarConfirmationDialog : function(calendarDiv, subCalendar, subscriberCount) {
                var deleteConfirmationDialog = new AJS.Dialog({
                    height : 290,
                    width : 550,
                    id : "delete-calendar-dialog"
                });

                deleteConfirmationDialog.addHeader(Confluence.TeamCalendars.isJiraSubCalendar(subCalendar) ? "\u5220\u9664\u4e8b\u5b9c" : "\u5220\u9664\u65e5\u7a0b\u8868");
                deleteConfirmationDialog.addPanel(
                    "\u5220\u9664\u65e5\u7a0b\u8868",
                    Confluence.TeamCalendars.Templates.confirmRemoveSubCalendar({
                        "subCalendar" : subCalendar,
                        "subscriberCount" : subscriberCount
                    }),
                    "delete-subcalendar-confirmation-panel");

                var dialogContent = deleteConfirmationDialog.getCurrentPanel().body;

                $("form.sub-calendar-delete-confirm", dialogContent).submit(function() {
                    return false;
                });

                var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, true);
                deleteConfirmationDialog.addButton(Confluence.TeamCalendars.isJiraSubCalendar(subCalendar) ? "\u5220\u9664\u4e8b\u4ef6" : "\u5220\u9664\u65e5\u7a0b\u8868", function() {
                    if (!CalendarPlugin.isProcessingSubCalendar(calendarDiv)) {
                        CalendarPlugin.setProcessingSubCalendar(calendarDiv, true);

                        var subCalendarToDelete = CalendarPlugin.getSubCalendar(calendarDiv, $("input[name='subCalendarId']", dialogContent).val());
                        CalendarPlugin._deleteSubCalendarInternal(calendarDiv, subCalendarToDelete.subscriptionId || subCalendarToDelete.id,
                            function(XMLHttpRequest, textStatus, errorThrown) {
                                CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                deleteConfirmationDialog.remove();
                                spinnerDefer.resolve();
                                CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                            },
                            function(responseEntity) {
                                if (responseEntity.success) {
                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);

                                    // Clear all errors related to loading events of a sub-calendar (and its children).
                                    $.each($.merge([ subCalendarToDelete ], subCalendarToDelete.childSubCalendars || []), function(subCalendarIdx, subCalendar) {
                                        CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendar.id));
                                    });

                                    CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendarToDelete.id);
                                    CalendarPlugin.removeSubCalendarEventSource(calendarDiv, subCalendarToDelete.childSubCalendars);
                                    CalendarPlugin.setSubCalendars(calendarDiv, responseEntity.payload);
                                    CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                                } else {
                                    CalendarPlugin.setGenericErrors(calendarDiv, "\u55ef\u54e6\u3002\u53ef\u80fd\u70b9\u513f\u5c0f\u610f\u5916\u3002\u4f55\u4e0d\u770b\u770bConfluence\u7684\u65e5\u5fd7\u6587\u4ef6\u3002", CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                                }

                                deleteConfirmationDialog.remove();
                                spinnerDefer.resolve();
                                CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                            });
                    }

                    return false;
                });

                deleteConfirmationDialog.addLink("\u53d6\u6d88", function() {
                    deleteConfirmationDialog.remove();
                    spinnerDefer.resolve();
                    return false;
                });

                return deleteConfirmationDialog;
            },
            deleteSubCalendar : function(calendarDiv, subCalendar) {
                if (!CalendarPlugin.isProcessingSubCalendar(calendarDiv)) {
                    CalendarPlugin.setProcessingSubCalendar(calendarDiv, true);
                    var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, true);
                    var data = {subCalendarId: subCalendar.subscriptionId || subCalendar.id};
                    CalUtil.putCalendarContextParams(data);

                    $.ajax({
                        cache : false,
                        data : data,

                        dataType : "json",
                        error : function(XMLHttpRequest, textStatus, errorThrown) {
                            CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                            CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                        },
                        success : function(responseEntity) {
                            var subCalendarEditDialog = calendarDiv.data("subCalendarEditFormDialog");

                            if (subCalendarEditDialog)
                                subCalendarEditDialog.hide();

                            var deleteSubCalendarConfirmationDialog = CalendarPlugin.getDeleteSubCalendarConfirmationDialog(calendarDiv, subCalendar, responseEntity.subscriptionCount),
                                dialogContent = deleteSubCalendarConfirmationDialog.getCurrentPanel().body,
                                calendarToDeleteSpan = $(".calendar-to-delete", dialogContent);

                            //If we do not remove this attribute ThreeDots will revert to the old text when we try to
                            //call ThreeDots() or update()
                            calendarToDeleteSpan.removeAttr("ThreeDots").empty().append(
                                $(document.createElement("span")).addClass("ellipsis_text").text(subCalendar.name));

                            CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);

                            var escapeKeyListener = function(jsEvent) {
                                if (27 === jsEvent.keyCode) {
                                    CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                                    spinnerDefer.resolve();
                                    $(document).unbind("keypress", escapeKeyListener);
                                }
                            };
                            $(document).keypress(escapeKeyListener);

                            deleteSubCalendarConfirmationDialog.show();
                            calendarToDeleteSpan.ThreeDots();
                        },
                        complete: function(){
                            if (spinnerDefer) spinnerDefer.resolve();
                        },
                        type : "GET",
                        timeout : CalendarPlugin.ajaxTimeout,
                        url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/subcalendars/links.json")
                    });
                }
            },

            _deleteSubCalendarInternal : function(calendarDiv, subCalendarId, errorCallback, successCallback) {
                var requestData = {
                    subCalendarId : subCalendarId
                };

                if (CalendarPlugin.getParameter(calendarDiv, "include"))
                    requestData.include = CalendarPlugin.getParameter(calendarDiv, "include");

                CalUtil.putCalendarContextParams(requestData);

                $.ajax({
                    cache : false,
                    converters : {
                        "text json" : function(jsonObject) {
                            return jsonObject;
                        }
                    },
                    data : requestData,
                    dataFilter: function(data) {
                        var subCalendarsResponseEntity = $.parseJSON(data);
                        if (subCalendarsResponseEntity.success) {
                            CalendarPlugin.mergeSubCalendarObjectsToArray(subCalendarsResponseEntity.payload);
                        }

                        return subCalendarsResponseEntity;
                    },
                    dataType : "json",
                    error : function(XMLHttpRequest, textStatus, errorThrown) {
                        if (errorCallback)
                            errorCallback(XMLHttpRequest, textStatus, errorThrown);
                    },
                    success : function(responseEntity) {
                        // when delete/remove calendar in single view => redirect to current space calendars
                        if(CalUtil.isSingleCalendarView(calendarDiv)) {
                            window.location.href = AJS.contextPath() + "/display/" + encodeURIComponent(AJS.Meta.get("space-key")) + "/calendars";
                        } else {
                            if (successCallback)
                                successCallback(responseEntity);
                        }

                        AJS.trigger("calendar.removed");
                    },
                    type : "DELETE",
                    timeout : CalendarPlugin.ajaxTimeout,
                    url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/subcalendars.json")
                });
            },

            addSubCalendarEventSource : function(calendarDiv, subCalendarId) {
                if (!subCalendarId)
                    return;

                var subCalendarIds = Confluence.TeamCalendars.getAsArray(subCalendarId),
                    visibleEventSources = calendarDiv.data("visibleEventSources") || {};

                $.each(subCalendarIds, function(idIdx, aSubCalendarId) {
                    if (!visibleEventSources[aSubCalendarId]) {
                        visibleEventSources[aSubCalendarId] = CalendarPlugin.getSubCalendarEventSource(calendarDiv, aSubCalendarId);
                        CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("addEventSource", visibleEventSources[aSubCalendarId]);
                    }
                });

                calendarDiv.data("visibleEventSources", visibleEventSources);
            },

            removeSubCalendarEventSource : function(calendarDiv, subCalendarId) {
                if (!subCalendarId)
                    return;

                var subCalendarIds = Confluence.TeamCalendars.getAsArray(subCalendarId),
                    visibleEventSources = calendarDiv.data("visibleEventSources") || {};

                $.each(subCalendarIds, function(idIdx, aSubCalendarId) {
                    if (visibleEventSources[aSubCalendarId]) {
                        CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("removeEventSource", visibleEventSources[aSubCalendarId]);
                        visibleEventSources[aSubCalendarId] = null;
                    }
                });

                calendarDiv.data("visibleEventSources", visibleEventSources);
            },

            isHttpsServer : function(calendarDiv) {
                return CalendarPlugin.getParameter(calendarDiv, "baseUrl").substring(5,0).toLowerCase() != "https";
            },

            getSubCalendarEventSource : function(calendarDiv, subCalendarId) {
                var eventSources = calendarDiv.data("eventSources") || {},

                    getSubCalendarEventsRetrieveQueue = function(_calendarDiv, _subCalendarId) {
                        var retrieveEventsQueue = _calendarDiv.data("retrieveEventsQueue") || {};
                        if (!retrieveEventsQueue[_subCalendarId])
                            retrieveEventsQueue[_subCalendarId] = [];

                        _calendarDiv.data("retrieveEventsQueue", retrieveEventsQueue);

                        return retrieveEventsQueue[_subCalendarId];
                    },

                    eventSource = eventSources[subCalendarId] || function(startDate, endDate, reportEventsAndPopCallback) {
                            // Sometimes FullCalendar passes in invalid dates?!
                            if (!(isNaN(startDate.getTime()) || isNaN(endDate.getTime()))) {
                                //Check if the data is in the cache
                                if (cache.hasCalendar(subCalendarId)
                                    && cache.getCalendarStart(subCalendarId).getTime() < startDate.getTime()
                                    && cache.getCalendarEnd(subCalendarId).getTime() > endDate.getTime()) {
                                    var truncatedEvents = CalendarPlugin.getEventsTruncated(calendarDiv, cache.getCalendarData(subCalendarId));
                                    reportEventsAndPopCallback(truncatedEvents);
                                    return;
                                }

                                var subCalendarEventsRetrieveQueue = getSubCalendarEventsRetrieveQueue(calendarDiv, subCalendarId);
                                for (var getEventsRequestIndex = 0; getEventsRequestIndex < subCalendarEventsRetrieveQueue.length; ++getEventsRequestIndex) {
                                    var aRequest = subCalendarEventsRetrieveQueue.shift();
                                    if (!aRequest.aborted && aRequest.xhr.readyState !== 4) {
                                        try
                                        {
                                            aRequest.xhr.abort();
                                        }
                                        catch (err) {
                                            // Most likely because of http://dev.jquery.com/ticket/6498
                                        }
                                        aRequest.xhr.aborted = true;
                                    }
                                }

                                var startDateWithOffset = new Date(startDate.getTime() - (1000 * 60 * 60 * 24 * 30)),
                                    endDateWithOffset = new Date(endDate.getTime() + (1000 * 60 * 60 * 24 * 30)),

                                    ajaxData = {
                                        subCalendarId: subCalendarId,
                                        userTimeZoneId: Confluence.TeamCalendars.getUserTimeZone(),
                                        start: $.fullCalendar.formatDate(startDateWithOffset, "u"),
                                        end : $.fullCalendar.formatDate(endDateWithOffset, "u")
                                    },

                                    parentSubCalendar = CalendarPlugin.getSubCalendars(calendarDiv, function(aSubCalendar) {
                                        if (!aSubCalendar.childSubCalendar)
                                            return false;

                                        var foundParent = false;
                                        $.each(aSubCalendar.childSubCalendar, function(childIdx, childSubCalendar) {
                                            if (childSubCalendar.id === subCalendarId) {
                                                foundParent = true;
                                                return false; // Stop iterating
                                            }
                                        });

                                        return foundParent;
                                    });

                                if (parentSubCalendar.length)
                                    ajaxData.parentSubCalendarId = parentSubCalendar[0].id;


                                var xhr = $.ajax({
                                    cache : false,
                                    data : ajaxData,
                                    dataType : "json",
                                    error : function(XMLHttpRequest, textStatus, errorThrown) {
                                        if (Confluence.TeamCalendars.isRequireOauth(XMLHttpRequest)) {
                                            var responseEntity = $.parseJSON(XMLHttpRequest.responseText),
                                                jiraOauthErrorsContainer = $(".jira-calendars-oauth-warnings", calendarDiv),
                                                oAuthUrl = responseEntity.oAuthUrl,
                                                oAuthApproveMessageContainer = $("div", jiraOauthErrorsContainer).filter(function() {
                                                    return oAuthUrl === $(this).data("oAuthUrl");
                                                }),

                                                createNewOAuthDanceMessage = function() {
                                                    jiraOauthErrorsContainer.append(
                                                        Confluence.TeamCalendars.Templates.requireOauthMessage({
                                                            "oAuthUrl" : oAuthUrl,
                                                            "subCalendarIdsArrayJson" : JSON.stringify([ subCalendarId ]),
                                                            "subCalendarNamesArrayJson" : JSON.stringify([ responseEntity.subCalendarName ]),
                                                            "subCalendarName" : $("<div/>", { text : responseEntity.subCalendarName }).html()
                                                        })
                                                    ).find(".approve-dance").click(function() {
                                                        AppLinks.authenticateRemoteCredentials(
                                                            responseEntity.oAuthUrl,
                                                            function() {
                                                                var theOauthApproveMessageContainer = $("div", jiraOauthErrorsContainer).filter(function() {
                                                                    return oAuthUrl === $(this).data("oAuthUrl");
                                                                });

                                                                CalendarPlugin.reloadSubCalendar(calendarDiv, theOauthApproveMessageContainer.data("subCalendarIds"));
                                                                theOauthApproveMessageContainer.remove();
                                                            },
                                                            function() {
                                                                alert("\u672a\u6210\u529f\u83b7\u5f97\u5ba1\u6279\u3002 \u53ef\u4ee5\u7684\u8bdd\uff0c\u60a8\u8fd8\u60f3\u518d\u8bd5\u4e00\u6b21\u5417\uff1f");
                                                            }
                                                        );

                                                        return false;
                                                    });
                                                },

                                                appendSubCalendarsToOAuthMessage = function() {
                                                    var subCalendarIds = oAuthApproveMessageContainer.data("subCalendarIds");
                                                    if ($.inArray(subCalendarId, subCalendarIds) === -1)
                                                        subCalendarIds.push(subCalendarId);

                                                    var newSubCalendarNames = oAuthApproveMessageContainer.data("subCalendarNames");
                                                    if ($.inArray(responseEntity.subCalendarName, newSubCalendarNames) === -1)
                                                        newSubCalendarNames.push(responseEntity.subCalendarName);

                                                    $("span.subcalendar-names", oAuthApproveMessageContainer.data("subCalendarIds", subCalendarIds).data("subCalendarNames", newSubCalendarNames)).text(newSubCalendarNames.join(", "));
                                                };

                                            if (!oAuthApproveMessageContainer.length) {
                                                createNewOAuthDanceMessage();
                                            } else {
                                                appendSubCalendarsToOAuthMessage();
                                            }

                                        } else if (XMLHttpRequest.status == 403) {
                                            if (CalendarPlugin.getParameter(calendarDiv, "showHiddenSubCalendars") === "true") {
                                                CalendarPlugin.showRestrictedCalendarsWarning(calendarDiv);
                                            } else {
                                                // Do not display "restricted calendar error" in space calendar
                                                // just hide them
                                                if(!CalUtil.isSpaceCalendarView(calendarDiv)) {
                                                    CalendarPlugin.showAjaxError(
                                                        calendarDiv,
                                                        XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendarId)
                                                    );
                                                }
                                            }

                                        } else if (textStatus !== "abort") {
                                            var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, subCalendarId);
                                            CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendarId), subCalendar);
                                            //bind event click in information error
                                            $(calendarDiv).find("#calendar-change-jql").click(function() {
                                                var that = this;
                                                var jiraCalendarId = $(that).parent().data("jiraCalendarId");
                                                if(jiraCalendarId) {
                                                    var jiraSubCalendar = CalendarPlugin.getSubCalendar(calendarDiv, jiraCalendarId);
                                                    if(jiraSubCalendar && jiraSubCalendar.eventsEditable) {
                                                        CalendarPlugin.showSubCalendarEdit(calendarDiv, jiraSubCalendar);
                                                        //process behaviour when event type panel active
                                                        $("#edit-calendar-dialog").find(".button-panel-button.submit").removeClass("hidden");
                                                    }
                                                }
                                            });
                                        }

                                        reportEventsAndPopCallback([]);
                                    },
                                    success : function(response, status) {
                                        var events = response.events;
                                        var truncatedEvents = [];
                                        CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendarId));
                                        events = $.map(events || [], function(anEvent) {
                                            /* HACK alert: Make GH sprint dates appear as all day events, but preserve some information indiciating it is not
                                             /* when we display the event details in the event details popout */
                                            if (anEvent.className === "greenhopper-sprint" && !anEvent.allDay) {
                                                anEvent.allDay = !anEvent.allDay;
                                                anEvent.allDayFlipped = true;
                                            }

                                            return anEvent;
                                        });

                                        // Under some circumstances of aborting this AJAX call, the status could be success and events null.
                                        if (status === "success" && events) {
                                            truncatedEvents = CalendarPlugin.getEventsTruncated(calendarDiv, events);
                                        }

                                        reportEventsAndPopCallback(truncatedEvents);
                                        cache.addDataToCalendar(subCalendarId, truncatedEvents, startDateWithOffset, endDateWithOffset);

                                        var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, subCalendarId);
                                        if (subCalendar.warnings && subCalendar.warnings.length)
                                            CalendarPlugin.setGenericErrors(calendarDiv, subCalendar.warnings, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_LIST_EVENTS + CalendarPlugin.getStringAsHex(subCalendarId));

                                        var editSubCalendarId = CalendarPlugin.getParameter(calendarDiv, "editSubCalendarId"), editEventUid = CalendarPlugin.getParameter(calendarDiv, "editEventUid");
                                        if (editSubCalendarId && editEventUid) {
                                            var eventsMatching = CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("clientEvents", function(anEvent) {
                                                return anEvent.subCalendarId === editSubCalendarId && anEvent.id === editEventUid;
                                            });
                                            if (eventsMatching.length) {
                                                CalendarPlugin.setParameter(calendarDiv, "editSubCalendarId" ,"");
                                                CalendarPlugin.setParameter(calendarDiv, "editEventUid" ,"");

                                                $("#calendar-dialog-panel").remove(); // Hide any event edit dialog, just in case.
                                                Confluence.TeamCalendars.Dialogs.getEditEventDialog(eventsMatching[0], subCalendar, CalendarPlugin, calendarDiv).show();
                                            }
                                        }
                                    },
                                    type : "GET",
                                    timeout : CalendarPlugin.ajaxTimeout,
                                    url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/events.json")
                                });

                                subCalendarEventsRetrieveQueue.push({ xhr: xhr });
                            }
                        };

                eventSources[subCalendarId] = eventSource;
                calendarDiv.data("eventSources", eventSources);
                return eventSource;
            },

            getEventsTruncated : function(calendarDiv, events, reset) {
                var currentView = this.getCalendarPanel(calendarDiv).fullCalendar("getView");
                var maxEventsToDisplayPerCalendar = parseInt(this.getParameter(calendarDiv, "maxEventsToDisplayPerCalendar"));

                // Group events based on sub-calendar
                var eventsMap = {};
                $.each(events, function(eventIdx, anEvent) {
                    if (!eventsMap[anEvent.subCalendarId])
                        eventsMap[anEvent.subCalendarId] = [];

                    eventsMap[anEvent.subCalendarId].push(anEvent);
                });

                // Function to sort events by date
                var sortEvents = function(_eventsArray) {
                    _eventsArray.sort(function(leftEvent, rightEvent) {
                        var leftDate = leftEvent._start || $.fullCalendar.parseISO8601(leftEvent.start, true);
                        var rightDate = rightEvent._start || $.fullCalendar.parseISO8601(rightEvent.start, true);

                        return leftDate.getTime() - rightDate.getTime();
                    });
                };

                // function filter event arr if number of event in current view larger than the limit
                var filterEvents = function(eventArr, visStart, visEnd) {
                    // only sort a small set of event after filter by current view => reduce amount of time to process
                    sortEvents(eventArr);
                    var filteredEventArray;
                    var idxOfFirstEventInVisStart = -1;
                    $.each(eventArr, function(eventIdx, anEvent) {
                        var startDate = anEvent._start || $.fullCalendar.parseISO8601(anEvent.start, true);
                        if (startDate >= visStart) {
                            idxOfFirstEventInVisStart = eventIdx;
                            return false; // Stop iterating
                        }
                    });

                    if (-1 === idxOfFirstEventInVisStart) {
                        // If no events start within the visualization range, just take the last ones
                        filteredEventArray = eventArr.slice(-maxEventsToDisplayPerCalendar);
                    } else {
                        // Take range from the first event viewable
                        filteredEventArray = eventArr.slice(idxOfFirstEventInVisStart, Math.min(idxOfFirstEventInVisStart + maxEventsToDisplayPerCalendar, eventArr.length));
                    }

                    // TEAMCAL-3855 we only need to push parent calendar name in truncatedSubCalendarNames. Child sub calendar name in here does not make sense
                    truncatedSubCalendarNames.push(CalendarPlugin.getParentSubCalendar(calendarDiv, eventArr[0].subCalendarId).name);
                    return filteredEventArray;
                };

                var truncatedSubCalendarNames = [];
                var finalEventsMap = {};
                $.each(eventsMap, function(subCalendarId, eventArray) {
                    var visStart = currentView.visStart;
                    var visEnd = currentView.visEnd;
                    var finalEventArray = [];

                    // only filter if number of event in current view larger than maxEventsToDisplayPerCalendar
                    $.each(eventArray, function(eventIdx, anEvent){
                        var startDate = anEvent._start || $.fullCalendar.parseISO8601(anEvent.start, true);
                        // if we don't have end date => it means end date and start date are the same
                        var endDate = anEvent._end || (anEvent.end ? $.fullCalendar.parseISO8601(anEvent.end, true) : startDate);

                        if ((startDate >= visStart && startDate <= visEnd) || (endDate >= visStart && endDate <= visEnd)) {
                            finalEventArray.push(anEvent);
                        }

                        if (finalEventArray.length > maxEventsToDisplayPerCalendar) {
                            finalEventArray = filterEvents(eventArray, visStart, visEnd);
                            // we don't need to loop through all item in eventArray because we already have enough event to show
                            return;
                        }
                    });

                    finalEventsMap[subCalendarId] = finalEventArray;
                });

                if (truncatedSubCalendarNames.length) {
                    var eventsTruncatedMessageContainer = $(".events-truncated-message-container", calendarDiv);
                    var sortStringArray = function(stringArray) {
                        stringArray.sort(function(nameLeft, nameRight) {
                            return nameLeft > nameRight ? 1 : (nameRight > nameLeft ? -1 : 0);
                        });
                    };
                    var generateTruncatedSubCalendarNamesList = function(subCalendarNamesArray) {
                        var subCalendarNamesList = $(document.createElement("ul"));
                        $.each(subCalendarNamesArray, function(subCalendarNameIdx, subCalendarName) {
                            subCalendarNamesList.append($(document.createElement("li")).text(subCalendarName));
                        });

                        return subCalendarNamesList;
                    };

                    var truncatedSubCalendarNamesList;
                    if (reset) {
                        sortStringArray(truncatedSubCalendarNames);
                        truncatedSubCalendarNamesList = generateTruncatedSubCalendarNamesList(truncatedSubCalendarNames);
                    } else {
                        var existingSubCalendarNames = [];

                        var existingTruncatedSubCalendarNames = $.map($("ul li", eventsTruncatedMessageContainer), function(subCalendarNameListItem) {
                            return $(subCalendarNameListItem).text();
                        });

                        var subCalendarNames = $.map(this.getSubCalendars(calendarDiv), function(subCalendar) {
                            return subCalendar.name;
                        });

                        $.each(existingTruncatedSubCalendarNames, function(existingTruncatedSubCalendarNameIdx, existingTruncatedSubCalendarName) {
                            if ($.inArray(existingTruncatedSubCalendarName, subCalendarNames) > -1 )
                                existingSubCalendarNames.push(existingTruncatedSubCalendarName);
                        });

                        $.each(truncatedSubCalendarNames, function(truncatedSubCalendarNameIdx, truncatedSubCalendarName) {
                            if (-1 === $.inArray(truncatedSubCalendarName, existingSubCalendarNames))
                                existingSubCalendarNames.push(truncatedSubCalendarName);
                        });

                        sortStringArray(existingSubCalendarNames);
                        truncatedSubCalendarNamesList = generateTruncatedSubCalendarNamesList(existingSubCalendarNames);
                    }

                    AJS.messages.warning(eventsTruncatedMessageContainer.empty(), {
                        title: "\u56e0\u6761\u76ee\u8fc7\u591a\uff0c\u65e5\u7a0b\u8868\u4e2d\u7684\u82e5\u5e72\u4e8b\u5b9c\u5e76\u672a\u5728\u4e0b\u65b9\u5448\u73b0",
                        body: $(document.createElement("div")).append(truncatedSubCalendarNamesList).html()
                    });

                    CalendarTour.start();

                    var finalEvents = [];
                    $.each(finalEventsMap, function(subCalendarId, eventsArray) {
                        $.merge(finalEvents, eventsArray);
                    });
                    return finalEvents;
                } else {
                    return events;
                }
            },

            isCalendarInEditMode : function(calendarDiv) {
                return this.getParameter(calendarDiv, "readOnly") !== "true";
            },

            isEventEditable : function(calendarDiv, event) {
                return this.isCalendarInEditMode(calendarDiv)
                    && this.isSubCalendarEventsUpdatable(calendarDiv, this.getSubCalendar(calendarDiv, event.subCalendarId))
                    && event.editable;
            },

            isEventDeletable : function(calendarDiv, event) {
                var subCalendar = CalendarPlugin.getSubCalendar(calendarDiv, event.subCalendarId);
                return CalendarPlugin.isEventEditable(calendarDiv, event) && !Confluence.TeamCalendars.isJiraSubCalendar(subCalendar);
            },

            getEventDetailsDialog : function(calendarDiv, event, target, inlineDialogOptions) {
                return ManageEvent(CalendarPlugin, cache).getEventDetailsDialog(calendarDiv, event, target, inlineDialogOptions);
            },

            updateEvent : function(calendarDiv, data, errorCallback, successCallback) {
                ManageEvent(CalendarPlugin, cache).updateEvent(calendarDiv, data, errorCallback, successCallback);
            },

            setSubCalendarSpinnerIconVisible : function(calendarDiv, visible) {
                var deferred = $.Deferred();
                var that = this;
                this.spinnerDeferTasks.push(deferred.promise());

                var toggleSpinner = function (shouldVisible) {
                    var spinnerImage = $(".calendar-panel .right-controls .spinner, .calendar-toolbar .spinner", calendarDiv);
                    if (shouldVisible)
                        spinnerImage.removeClass("invisible");
                    else
                        spinnerImage.addClass("invisible");

                    // TEAMCAL-2753
                    that._toggleEnableButton($(".page-prev", calendarDiv), !shouldVisible);
                    that._toggleEnableButton($(".page-next", calendarDiv), !shouldVisible);
                };

                if (visible)
                {
                    // we trust the caller to open the spinner
                    toggleSpinner(visible);
                }

                // when every promise in array are done then should turn off spinner
                $.when.apply($, this.spinnerDeferTasks).done(function(){
                    toggleSpinner(false);
                    this.spinnerDeferTasks = [];
                });

                // Sometime caller might forget to resolve. Should't trust them in this case
                var timeoutId = setTimeout(function(){
                    deferred.resolve();
                }, 10 * 1000);

                return {
                    resolve: function(){
                        deferred.resolve();
                        clearTimeout(timeoutId);
                    }
                }
            },

            _toggleEnableButton: function ($el, isEnable) {
                $el.attr('aria-disabled', !isEnable);

                if (isEnable) {
                    $el.removeAttr('disabled');
                } else {
                    $el.attr('disabled', 'disabled');
                }
            },

            reloadSubCalendarDisableEvent: function(calendarDiv, data) {
                if(data.uid && (data.originalEventType !== data.eventType || data.originalSubCalendarId !== data.subCalendarId))
                {
                    var disableEventTypes = CalendarPlugin.getSubCalendar(calendarDiv, data.subCalendarId).disableEventTypes;
                    for (var i = 0; i < disableEventTypes.length; i++) {
                        if(disableEventTypes[i] === data.eventType) {
                            disableEventTypes.splice(i, 1);
                            break;
                        }
                    }

                    CalendarPlugin.getSubCalendar(calendarDiv, data.subCalendarId).disableEventTypes = disableEventTypes;
                }
            },

            initCalendarToolbar : function(calendarDiv) {
                var that = this;

                $(".feedback-form-trigger", calendarDiv).click(function() {
                    var feedbackDialog = new AJS.Dialog(700, 512);

                    feedbackDialog.addHeader("\u56e2\u961f\u65e5\u7a0b\u8868\u63d2\u4ef6\u53cd\u9988");
                    feedbackDialog.addPanel("", "<div class='loading-message'></div><iframe src='https://atlassian.wufoo.com/forms/team-calendars-feedback/' frameborder='0'></iframe>", "calendar-feedback-dialog-panel");

                    var feedbackDialogContent = feedbackDialog.getCurrentPanel().body;
                    var loadingMessageDiv = $(".loading-message", feedbackDialogContent).text("\u6b63\u5728\u52a0\u8f7d...");
                    $("iframe", feedbackDialogContent).load(function() {
                        loadingMessageDiv.remove();
                    });

                    feedbackDialog.addCancel("\u53d6\u6d88", function() {
                        feedbackDialog.hide();
                        return false;
                    });
                    feedbackDialog.show();

                    return false;
                });

                $(".change-view", calendarDiv).click(function() {
                    that.hideInlineAuiDialogs();

                    var changeViewButton = $(this);

                    CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("changeView", changeViewButton.data("viewName"));

                    var context = CalUtil.getCalendarContext(calendarDiv);

                    Confluence.TeamCalendars.fireEventForAnalytics("view." + changeViewButton.data("analyticsViewName") + ".render." + context);

                    return false;
                });

                $(".today", calendarDiv).click(function() {
                    that.hideInlineAuiDialogs();

                    cache.removeAllCalendars(); //We need to invalidate the cache when we go to today. See calendar-data-cache.js for details.
                    CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("today");

                    return false;
                });

                $(".page-prev", calendarDiv).click(function() {
                    that.hideInlineAuiDialogs();

                    var calendarPanel = CalendarPlugin.getCalendarPanel(calendarDiv);

                    delete calendarPanel.fullCalendar("getView").daysMore;

                    if (calendarPanel.fullCalendar("getView").name === "basicDay")
                        calendarPanel.fullCalendar("incrementDate", 0, 0, -parseInt(CalendarPlugin.getParameter(calendarDiv, "maxUpcomingDays")));
                    else
                        calendarPanel.fullCalendar("prev");

                    return false;
                });

                $(".page-next", calendarDiv).click(function() {
                    that.hideInlineAuiDialogs();

                    var calendarPanel = CalendarPlugin.getCalendarPanel(calendarDiv);

                    delete calendarPanel.fullCalendar("getView").daysMore;

                    if (calendarPanel.fullCalendar("getView").name === "basicDay")
                        calendarPanel.fullCalendar("incrementDate", 0, 0, parseInt(CalendarPlugin.getParameter(calendarDiv, "maxUpcomingDays")));
                    else
                        calendarPanel.fullCalendar("next");

                    return false;
                });
            },

            getStringAsHex : function(aString) {
                var hashString = "";
                if (aString) {
                    var stringLength = aString.length;
                    for (var charIndex = 0; charIndex < stringLength; ++charIndex) {
                        var hashStringOfChar = aString.charCodeAt(charIndex);
                        hashString += hashStringOfChar.length > 1 ? hashStringOfChar : "0" + hashStringOfChar;
                    }
                }

                return hashString
            },

            formatDate : function(calendarDiv, date, format, formattedCallback) {
                if (formattedCallback) {
                    var isDateArray = $.isArray(date);
                    if (isDateArray && !date.length) {
                        formattedCallback();
                        return;
                    }

                    var data = {
                        date: $.map(isDateArray ? date : [ date ], function(dateToFormat) {
                            return $.fullCalendar.formatDate(dateToFormat, "ddMMyyyyHHmm");
                        }),
                        pattern : format
                    };

                    $.ajax({
                        cache: false,
                        data: data,
                        dataType: "json",
                        error: function() {
                            formattedCallback(AJS.format("\u65e0\u6cd5\u5c06{0}\u683c\u5f0f\u5316\u4e3a\u65e5\u671f\u6216\u65f6\u95f4", data.date.join(", ")));
                        },
                        success: function(formattedDates) {
                            formattedCallback(isDateArray ? formattedDates : formattedDates[0]);
                        },
                        timeout: CalendarPlugin.ajaxTimeout,
                        url: CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/util/format/date.json")
                    });
                }
            },

            initWhatsNew : function(calendarDiv) {
                var whatsNewContainer = $(".whatsnew");

                if (whatsNewContainer.length) {
                    whatsNewContainer.removeClass("hidden");

                    var dismissWhatsNew = function(dismissedCallback) {
                        Confluence.TeamCalendars.suppressMessage(
                            calendarDiv,
                            "MESSAGE_KEY_PREFIX_WHATSNEW_" + CalendarPlugin.getParameter(calendarDiv, "pluginVersion"),
                            function() {
                                if ($.isFunction(dismissedCallback))
                                    dismissedCallback();
                            }
                        );
                    };

                    $("button", whatsNewContainer).click(function() {
                        window.open($(this).data("url"), "_blank");
                        return false;
                    });

                    $(".aui-iconfont-close-dialog", whatsNewContainer).click(function() {
                        dismissWhatsNew(function() {
                            whatsNewContainer.addClass("hidden");
                        });
                    });
                }
            },

            initButtons: function(calendarDiv) {
                new CalendarNavigationButtonsView({
                    el: "#navigation",
                    _calendarDiv: calendarDiv,
                    CalendarPlugin: this

                }).render();

                new CalendarRestrictionButtonsView({
                    el: "#calendar-restriction-buttons",
                    _calendarDiv: calendarDiv,
                    CalendarPlugin: this
                });
            },

            getSubCalendarRestrictionsDialog : function(calendarDiv, subCalendar) {
                var subCalendarEditDialog = this.showSubCalendarEdit(calendarDiv, subCalendar);
                var editDialogView = subCalendarEditDialog.belongedView;
                editDialogView.showRestrictionOption();
                return subCalendarEditDialog;
            },

            removeSubCalendarDialog : function(calendarDiv, subCalendar) {
                var calendarRemoveDialog = new CalendarRemoveDialog({_calendarPlugin : this, _calendarDiv: calendarDiv, subCalendar: subCalendar});
                calendarRemoveDialog.render();
            },

            getSubCalendarFeatureDiscoveryDialog : function(calendarDiv, subCalendar) {

                var calendarFeatureDiscoveryDialog = new CalendarFeatureDiscoveryDialog({_calendarPlugin : this,
                    _calendarDiv: calendarDiv, subCalendar: subCalendar});

                return {
                    show : function() {
                        calendarFeatureDiscoveryDialog.render();
                    }
                };
            },

            isAutoConvertSupported : function(calendarDiv) {
                return this.getParameter(calendarDiv, "autoConvertSupported") === "true";
            },

            getSubCalendarShareDialog : function(calendarDiv, subCalendar) {
                var subCalendarEditDialog = this.showSubCalendarEdit(calendarDiv, subCalendar);
                var editDialogView = subCalendarEditDialog.belongedView;
                editDialogView.showShareOption();
                return subCalendarEditDialog;
            },

            getCalendarSubscribeDialog : function(calendarDiv, subCalendars, subCalendar) {
                var service = new CalendarSubscribeService(CalendarPlugin, calendarDiv);
                var model = new CalendarSubscribeModel({
                    subCalendars: subCalendars,
                    selectedSubCalId: subCalendar.id,
                    baseUrl: CalUtil.getParameter(calendarDiv, "baseUrl"),
                    isPrivateUrlsEnabled: CalendarPlugin.getParameter(calendarDiv, "privateUrlsEnabled"),
                    privateUrlProvider: _.bind(service.getPrivateUrlProvider, service)
                });
                var subscribeDialogView = new CalendarSubscribeDialog({
                    calendarPlugin: CalendarPlugin,
                    calendarDiv: calendarDiv,
                    model: model
                });
                subscribeDialogView.render();
                return subscribeDialogView;
            },

            initCalendarDiv : function(calendarDiv) {
                var callbackHandler = CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv);
                this.initCalendarToolbar(calendarDiv);
                //init calendar panel
                SubCalendarPanel(CalendarPlugin, calendarDiv).initSubCalendarPanel();

                this.initWhatsNew(calendarDiv);
                this.initButtons(calendarDiv);

                $(document).keydown(function(event) {
                    if (event.keyCode === 27) {
                        CalendarPlugin.getCalendarPanel(calendarDiv).fullCalendar("unselect");
                    }
                });

                if (Confluence.TeamCalendars.shouldShowTimezoneSetup()) {
                    Confluence.TeamCalendars.Dialogs.getTimeZoneSetupDialog(callbackHandler).show();
                } else {
                    callbackHandler.showCalendarWizard();
                }
            },


            getRenderedMacroCallbackHandler : function(calendarDiv) {
                return {
                    isProcessingSubCalendar : function() {
                        return CalendarPlugin.isProcessingSubCalendar(calendarDiv);
                    },

                    setProcessingSubCalendar : function (aBool) {
                        return CalendarPlugin.setProcessingSubCalendar(calendarDiv, aBool);
                    },

                    setSubCalendarSpinnerIconVisible : function(aBool) {
                        return CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, aBool);
                    },

                    getIncludedCalendars : function() {
                        return CalendarPlugin.getParameter(calendarDiv, "include");
                    },

                    mergeSubCalendarObjectsToArray : function(arrayWithSubCalendarObject) {
                        return CalendarPlugin.mergeSubCalendarObjectsToArray(arrayWithSubCalendarObject);
                    },

                    showAjaxUpdateError : function(XMLHttpRequest, textStatus, errorThrown) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                    },

                    showAjaxError : function(XMLHttpRequest, textStatus, errorThrown, errorClass) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, errorClass)
                    },

                    showHTMLGenericError: function(container, messageResponse, errorClass) {
                        CalendarPlugin.showHTMLGenericError(container, messageResponse, errorClass);
                    },

                    setGenericUpdateError : function() {
                        CalendarPlugin.setGenericErrors(calendarDiv, null, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                    },

                    setGenericErrors : function(message, errorClass) {
                        Confluence.TeamCalendars.setGenericErrors(calendarDiv, null, errorClass)
                    },

                    setParameter : function(configKey, value) {
                        CalendarPlugin.setParameter(calendarDiv, configKey, value)
                    },

                    getParameter : function(configKey) {
                        return CalendarPlugin.getParameter(calendarDiv, configKey);
                    },

                    setSubCalendar: function(subCalendarId, payload) {
                        CalendarPlugin.setSubCalendar(subCalendarId, calendarDiv, payload);
                    },

                    setSubCalendars : function(newCalendars, payload) {
                        CalendarPlugin.setSubCalendars(calendarDiv, payload);
                    },

                    reloadSubCalendar : function(subCalendarId) {
                        CalendarPlugin.reloadSubCalendar(calendarDiv, subCalendarId);
                    },

                    getSubCalendars : function() {
                        return CalendarPlugin.getSubCalendars(calendarDiv)
                    },

                    updateAvailableSubCalendarsInSubCalendarPanel : function() {
                        CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                    },

                    // for single calendar page => update description and name of calendar
                    refreshCalendarInfo: function(subCalendars) {
                        if(CalUtil.isSingleCalendarView(calendarDiv) && subCalendars.length) {
                            $("#title-text span").text(subCalendars[0].name);
                            $(".calendar-description p").text(subCalendars[0].description);
                        }
                    },

                    shouldShowFeatureDiscoveryDialog : function(subCalendarId) {
                        return CalendarPlugin.shouldShowFeatureDiscoveryDialog(calendarDiv, subCalendarId);
                    },

                    getSubCalendarFeatureDiscoveryDialog : function(subCalendarId) {
                        CalendarPlugin.getSubCalendarFeatureDiscoveryDialog(calendarDiv, CalendarPlugin.getSubCalendar(calendarDiv, subCalendarId)).show();
                    },

                    getNextCalendarColor : function() {
                        return CalendarPlugin.getNextUnusedSubCalendarColor(calendarDiv);
                    },

                    isAutoWatchSet : function() {
                        return CalendarPlugin.getParameter(calendarDiv, "autowatch") === "true";
                    },

                    refreshCachedSubCalendars : function(successCallback, errorCallback) {
                        CalendarPlugin.refreshCachedSubCalendars(calendarDiv, successCallback, errorCallback);
                    },

                    handleImport : function(subcalendarId) {
                        this.refreshCachedSubCalendars(function() {
                            CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                            if (CalendarPlugin.shouldShowFeatureDiscoveryDialog(calendarDiv)) {
                                CalendarPlugin.getSubCalendarFeatureDiscoveryDialog(calendarDiv, CalendarPlugin.getSubCalendar(calendarDiv, subcalendarId)).show();
                            }
                        }, function(XMLHttpRequest, textStatus, errorThrown) {
                            CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_UPDATE);
                        });

                        CalendarTour.start(subcalendarId);
                    },

                    isCalendarInEditMode : function() {
                        return CalendarPlugin.isCalendarInEditMode(calendarDiv);
                    },

                    suppressMessage : function(messageKey, successCallback) {
                        Confluence.TeamCalendars.suppressMessage(calendarDiv, messageKey, successCallback)
                    },

                    showCalendarWizard : function() {
                        var showPopularWelcomeDialog = function() {
                            Confluence.TeamCalendars.Dialogs.getSubCalendarSubscribeDialog({
                                heading: "\u6b22\u8fce\u4f7f\u7528\u56e2\u961f\u65e5\u7a0b\u8868\uff01",
                                callbackHandler : CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                                id: "welcome-to-popular-dialog"
                            }).show();
                        };

                        var showCalendarDialog = function() {
                            Confluence.TeamCalendars.Dialogs.getAddDialog(
                                CalendarPlugin.getRenderedMacroCallbackHandler(calendarDiv),
                                {
                                    title : "\u6b22\u8fce\u4f7f\u7528\u56e2\u961f\u65e5\u7a0b\u8868\uff01",
                                    addClass : "create-calendar-first-time"
                                }
                            )
                        };

                        var isBlueprint = AJS.Meta.get("space-key") ? (CalUtil.getParamsFromUrl()["openAddCalDialog"] === "true") : false;

                        if (isBlueprint) {
                            if (CalUtil.isValidLicense()) {
                                showCalendarDialog();
                            }
                        } else if ("true" === CalendarPlugin.getParameter(calendarDiv, "isShowCalendarWizard")) {
                            Confluence.TeamCalendars.showCalendarPopupHaveAnEmptySubcalendar(showPopularWelcomeDialog, showCalendarDialog)
                        }
                    },

                    getSubCalendarsWhichCanAddEvents : function() {
                        return CalendarPlugin.getSubCalendarsWhichCanAddEvents(calendarDiv);
                    },

                    updateCustomEventType: function(subCalendarId, customEventTypeData) {
                        CalendarPlugin.updateCustomEventType(calendarDiv, subCalendarId, customEventTypeData);
                    }
                }
            },

            onTeamCalendarsLoaded : function() {
                // Only render favicon on user calendar and space calendar pages.
                if ($('.user-calendar, .space-calendar').length > 0) {
                    Favicon.render();
                }
                $("div.plugin-calendar:not(.init-started)").each(function() {
                    var calendarDiv = $(this);
                    calendarDiv.addClass('init-started');

                    var displayWeekNumber = $("#team-calendars-display-week-number").attr("content");
                    CalendarPlugin.setParameter(calendarDiv, "displayWeekNumber", displayWeekNumber);

                    if (!CalendarPlugin.getParameter(calendarDiv, "defaultView")) {
                        var calendarPanel = CalendarPlugin.getCalendarPanel(calendarDiv).text("\u6b63\u5728\u52a0\u8f7d...");
                        $.ajax({
                            cache : false,
                            dataType : "json",
                            error : function() {
                                calendarPanel.empty();
                                CalendarPlugin.init(calendarDiv);
                            },
                            success : function(userPreference) {
                                // In the past, there was basicDay view. Now that it has been removed, we need to switch the user's view accordingly.
                                CalendarPlugin.setParameter(calendarDiv, "defaultView", userPreference.view === "agendaDay" ? "basicDay" : userPreference.view);
                                calendarPanel.empty();
                                CalendarPlugin.init(calendarDiv);
                            },
                            timeout: CalendarPlugin.ajaxTimeout,
                            url : CalendarPlugin.getCalendarServiceBaseUrl(calendarDiv, "/preferences.json")
                        });
                    } else {
                        var isInDashboardAsUpcomingEvents = calendarDiv.closest(".dashboard-calendar-container");
                        if (isInDashboardAsUpcomingEvents) {
                            var delayedCalendarInit = setInterval(function() {
                                CalendarPlugin.init(calendarDiv);
                                clearInterval(delayedCalendarInit);
                            }, 100);
                        } else {
                            CalendarPlugin.init(calendarDiv);
                        }
                    }
                });

                //resize calendar when user drags the splitter
                var splitter = $(".ia-splitter-handle-highlight");
                splitter.mousedown(function(){
                        splitter.on("mousemove", function () {
                            $(window).trigger("resize");
                        });
                    })
                    .mouseup(function(){
                        $(window).trigger("resize");
                        splitter.off("mousemove")
                    });

                //resize calendar when user collapses side bar
                $(".expand-collapse-trigger").click(function(){
                    $(window).trigger("resize");
                });
            }
        };

        $(function() {
            CalendarPlugin.isPageUnloading = false;

            AJS.$(window).bind('beforeunload', function() {
                CalendarPlugin.isPageUnloading = true;
            });

            // For the ability to delete an event pressing backspace/delete while the event details callout is visible
            $(document).keydown(function(jsEvent) {
                var doNotPreventDefault = true;

                $(".aui-inline-dialog:visible:first .event-details-popup").each(function() {
                    if (jsEvent.keyCode === 8 || jsEvent.keyCode === 46) {
                        $(".event-delete", this).click();
                        doNotPreventDefault = false;
                    }
                });

                return doNotPreventDefault;
            });

            //resize calendar when user uses [ shortcut
            $("body").keyup(function(event){
                if((event.keyCode ? event.keyCode : event.which) === 219) {
                    $(window).trigger("resize");
                }
            });
        });

        return CalendarPlugin;
    }
);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/child-subcalendars.js' */
(function($) {
    if (!window.Confluence.TeamCalendars.subcalendar)
        window.Confluence.TeamCalendars.subcalendar = {};

    window.Confluence.TeamCalendars.subcalendar["other"] = {
        "getDialog" : function() {AJS.log("Tried to call getDialog on child calendar type. This should not happen.")},
        "weight" : 1,
        "typeName" : "\u4e8b\u5b9c\u65e5\u7a0b\u8868"
    };

    window.Confluence.TeamCalendars.subcalendar["travel"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 2,
        "typeName" : "\u51fa\u5dee"
    });

    window.Confluence.TeamCalendars.subcalendar["leaves"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 3,
        "typeName" : "\u4f11\u5047"
    });

    window.Confluence.TeamCalendars.subcalendar["birthdays"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 4,
        "typeName" : "\u751f\u65e5"
    });

    window.Confluence.TeamCalendars.subcalendar["jira-agile-sprint"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 6,
        "typeName" : "Jira Agile Sprints"
    });

    window.Confluence.TeamCalendars.subcalendar["jira-project-releases"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 7,
        "typeName" : "Jira \u9879\u76ee\u53d1\u5e03"
    });

    window.Confluence.TeamCalendars.subcalendar["jira-issue-dates"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 8,
        "typeName" : "Jira \u95ee\u9898\u65e5\u671f"
    });

    window.Confluence.TeamCalendars.subcalendar["custom"] = $.extend({}, window.Confluence.TeamCalendars.subcalendar.other, {
        "weight" : 9,
        "typeName" : "custom_name"
    });
})(AJS.$);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/parent-subcalendar.js' */
(function($) {
    if (!window.Confluence.TeamCalendars.subcalendar)
        window.Confluence.TeamCalendars.subcalendar = {};

    if (!window.Confluence.TeamCalendars.subcalendar.parent) {
        var CalUtil = require("tc/calendar-util");

        window.Confluence.TeamCalendars.subcalendar.parent = {
            getDialog : function(editDialog, subCalendar, callbackHandler) {
                var editForm,
                    helper;

                var populateForm = function() {
                    var editPanel = editDialog.getCurrentPanel();

                    helper.resetFieldErrors();
                    helper.populateTimeZoneDropDown(editPanel);

                    var timeZoneSelect = $("select[name='timeZoneIdSelect']", editForm);

                    if (helper.isNewCalendar()) {
                        helper.setFormModeCreate();
                        helper.setHeading("\u521b\u5efa\u65e5\u7a0b\u8868", editDialog);
                        helper.setSubCalendarIdField("");
                        helper.setNameField("");
                        helper.setDescriptionField("");
                        helper.setColorField(callbackHandler.getNextCalendarColor());
                        helper.setSpaceToDefault();
                        helper.setTimeZoneIdField("");
                    } else {
                        helper.setFormModeEdit();
                        helper.setHeading(subCalendar.name, editDialog);
                        helper.setSubCalendarIdField(subCalendar.id);
                        helper.setNameField(subCalendar.name);
                        helper.setDescriptionField(subCalendar.description);
                        helper.setColorField(subCalendar.color);
                        helper.setSpaceKeyField(subCalendar.spaceKey);
                        helper.setSpaceKeyAutocompleteField(subCalendar.spaceName);
                        helper.setTimeZoneIdField(subCalendar.timeZoneId);
                    }

                    var textInputs = $("input[name='name'], textarea[name='description'], input[name='spaceKeyAutocomplete']", editForm);
                    if (callbackHandler.isCalendarInEditMode()) {
                        textInputs.removeAttr("readonly");
                        timeZoneSelect.removeAttr("disabled");
                    } else {
                        helper.setFormModeReadOnly();
                        textInputs.attr("readonly", "readonly");
                        timeZoneSelect.attr("disabled", "disabled");
                    }

                    // hidden space field when create TC on space
                    if(helper.isNewCalendar() && AJS.Meta.get("space-key")) {
                        var spaceDiv = $(".field-group-space-permission", editForm);
                        spaceDiv.addClass("hidden");
                    }
                };

                return {
                    initializeForm: function(callBackCancel) {
                        editDialog.addHeader("\u521b\u5efa\u65e5\u7a0b\u8868");
                        editDialog.addPanel("\u901a\u7528", Confluence.TeamCalendars.Templates.editLocalCalendar(), "calendar-dialog-panel create-calendar-dialog");

                        editForm = $("form.sub-calendar-edit-form", editDialog.getCurrentPanel().body);
                        helper = Confluence.TeamCalendars.getEditCalendarDialogHelper(editForm, subCalendar, callbackHandler);

                        helper.initSpaceDropDown();
                        helper.initTimeZoneSelect();
                        helper.initOkButton("\u786e\u5b9a", editDialog);
                        helper.initCloseButton(editDialog, callBackCancel);
                        populateForm();
                        return editForm;
                    },

                    getFormDataAsAjaxData : function() {
                        var data = {
                            type : "parent",
                            subCalendarId : $("input[name='subCalendarId']", editForm).val(),
                            name : $("input[name='name']", editForm).val(),
                            description : $("textarea[name='description']", editForm).val(),
                            color : $("input[name='color']", editForm).val(),
                            spaceKey : $("input[name='spaceKeyAutocomplete']", editForm).val() ? $("input[name='spaceKey']", editForm).val() : "",
                            timeZoneId : $("input[name='timeZoneId']", editForm).val() || $("select[name='timeZoneIdSelect'] option:selected", editForm).val()
                        };

                        CalUtil.putCalendarContextParams(data);

                        return data;
                    },

                    onSubmitStart : function() {
                        helper.disableOkButton("\u6b63\u5728\u6dfb\u52a0...");
                    },

                    onSubmitEnd : function() {
                        helper.enableOkButton("\u786e\u5b9a");
                    }
                }
            },
            weight : 1,
            typeName : "\u65e5\u7a0b\u8868"
        };
    }
})(jQuery);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/jira-subcalendar.js' */
(function($) {
    if (!window.Confluence.TeamCalendars.subcalendar)
        window.Confluence.TeamCalendars.subcalendar = {};

    if (!window.Confluence.TeamCalendars.subcalendar.jira) {

        window.Confluence.TeamCalendars.subcalendar.jira = {
            weight : 5,
            typeName : "Jira\u65e5\u7a0b\u8868",
            getDialog : function() {
                AJS.log("Confluence.TeamCalendars.subcalendar.jira.should never be called");
            }
        }
    }
})(AJS.$);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/subscription-subcalendar.js' */
(function($) {
    if (!window.Confluence.TeamCalendars.subcalendar)
        window.Confluence.TeamCalendars.subcalendar = {};

    if (!window.Confluence.TeamCalendars.subcalendar.subscription) {
        var CalUtil = require("tc/calendar-util");

        window.Confluence.TeamCalendars.subcalendar.subscription = {
            getDialog : function(editDialog, subCalendar, callbackHandler) {
                var helper,
                    editForm;

                var populateForm = function() {
                    helper.resetFieldErrors();

                    var createHelpLink = function() {
                        return $(document.createElement("div")).addClass("calendar-dialog-help-link").append(
                                $(document.createElement("a"))
                                        .attr("href", "http://confluence.atlassian.com/x/YQ1cDg")
                                        .attr("target", "_blank")
                                        .text("\u5e2e\u52a9")
                        )
                    };

                    if (helper.isNewCalendar()) {
                        helper.setFormModeCreate();
                        helper.setHeading("\u8ba2\u9605", editDialog).append(createHelpLink());
                        helper.setSubCalendarIdField("");
                        helper.setNameField("");
                        helper.setDescriptionField("");
                        helper.setColorField(callbackHandler.getNextCalendarColor());
                        helper.setSpaceToDefault();
                        helper.setLocationField("");
                        helper.setUserNameField("");
                        helper.setTimeZoneIdDisplayField("");
                    } else {
                        helper.setFormModeEdit();
                        helper.setHeading(subCalendar.name, editDialog).append(createHelpLink());
                        helper.setSubCalendarIdField(subCalendar.id);
                        helper.setNameField(subCalendar.name);
                        helper.setDescriptionField(subCalendar.description);
                        helper.setColorField(subCalendar.color);
                        helper.setSpaceKeyField(subCalendar.spaceKey);
                        helper.setSpaceKeyAutocompleteField(subCalendar.spaceName);
                        helper.setLocationField(subCalendar.sourceLocation);
                        helper.setUserNameField(subCalendar.userName || "");
                        helper.setTimeZoneIdDisplayField(subCalendar.timeZoneId);
                    }

                    var textInputs = $("input[name='name'], textarea[name='description'], input[name='spaceKeyAutocomplete'], input[name='location'], input[name='username'], input[name='password']", editForm);
                    if (callbackHandler.isCalendarInEditMode()) {
                        textInputs.removeAttr("readonly");
                    } else {
                        helper.setFormModeReadOnly();
                        textInputs.attr("readonly", "readonly");
                    }

                    //hidden space field when TC on space
                    if(AJS.Meta.get("space-key")) {
                        var spaceDiv = $(".field-group-space-permission", editForm);
                        spaceDiv.css("display", "none");
                    }
                };

                return {
                    initializeForm: function() {
                        editDialog.addHeader("\u8ba2\u9605");
                        editDialog.addPanel("\u901a\u7528", Confluence.TeamCalendars.Templates.editSubscriptionSubcalendar(), "calendar-dialog-panel subscribe-dialog");

                        editForm = $("form.sub-calendar-edit-form", editDialog.getCurrentPanel().body);
                        helper = Confluence.TeamCalendars.getEditCalendarDialogHelper(editForm, subCalendar, callbackHandler);

                        helper.initSpaceDropDown();
                        helper.initOkButton("\u8ba2\u9605", editDialog);
                        helper.initCloseButton(editDialog);

                        populateForm();

                        return editForm;
                    },

                    getFormDataAsAjaxData : function() {
                        var data = {
                            type: "subscription",
                            subCalendarId: $("input[name='subCalendarId']", editForm).val(),
                            name: $("input[name='name']", editForm).val(),
                            description: $("textarea[name='description']", editForm).val(),
                            color: $("input[name='color']", editForm).val(),
                            spaceKey: !!$("input[name='spaceKeyAutocomplete']", editForm).val() ? $("input[name='spaceKey']", editForm).val() : "",
                            location: $("input[name='location']", editForm).val(),
                            userName: $("input[name='username']", editForm).val(),
                            password: $("input[name='password']", editForm).val()
                        };

                        CalUtil.putCalendarContextParams(data);

                        return data;

                    },

                    onSubmitStart : function() {
                        helper.disableOkButton("\u6b63\u5728\u8ba2\u9605");
                    },

                    onSubmitEnd : function() {
                        helper.enableOkButton("\u8ba2\u9605");
                    }
                }
            },
            weight : 6,
            typeName : "\u8ba2\u9605"
        }
    }
})(jQuery);

}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/remove-jira-events-dialog.js' */
(function($) {
    Confluence.TeamCalendars.getRemoveJiraEventsDialog = function(CalendarPlugin, calendarDiv, childSubCalendar) {
        var dialog;

        dialog = new AJS.Dialog(400, 250);

        dialog.addHeader("\u5220\u9664 Jira \u4e8b\u4ef6?");

        dialog.addPanel(
                "",
                Confluence.TeamCalendars.Templates.confirmRemoveJiraEvents({
                    childName : childSubCalendar.name,
                    parentName : CalendarPlugin.getSubCalendar(calendarDiv, childSubCalendar.parentId).name
                }),
                "remove-jira-events-confirmation-panel");

        dialog.addButton(
                "\u5220\u9664",
                function() {
                    removeJiraEvents();
                    dialog.remove();
                });

        dialog.addCancel(
                "\u53d6\u6d88",
                function() {
                    dialog.remove();
                });

        dialog.show();

        function removeJiraEvents() {
            var spinnerDefer = CalendarPlugin.setSubCalendarSpinnerIconVisible(calendarDiv, true);
            var resolveSpinner = function(){
                if (spinnerDefer) spinnerDefer.resolve();
            };
            CalendarPlugin.setProcessingSubCalendar(calendarDiv, true);
            CalendarPlugin._deleteSubCalendarInternal(
                    calendarDiv,
                    childSubCalendar.subscriptionId || childSubCalendar.id,
                    function (XMLHttpRequest, textStatus, errorThrown) {
                        CalendarPlugin.showAjaxError(calendarDiv, XMLHttpRequest, textStatus, errorThrown, CalendarPlugin.ERROR_CLASS_SUB_CALENDAR_DELETE);
                        resolveSpinner();
                        CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                    },
                    function (responseEntity) {
                        CalendarPlugin.removeSubCalendarEventSource(calendarDiv, childSubCalendar.id);
                        CalendarPlugin.setSubCalendars(calendarDiv, responseEntity.payload);
                        CalendarPlugin.updateAvailableSubCalendarsInSubCalendarPanel(calendarDiv);
                        resolveSpinner();
                        CalendarPlugin.setProcessingSubCalendar(calendarDiv, false);
                    }
            );
        }
    };
}(AJS.$));
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/components/load-favicon/load-favicon.js' */
define("tc/load-favicon",
    [
        "jquery"

    ],
    function (
        $
    )
    {
        "use strict";
        return {
            render: function ()
            {
                var currentDay = (new Date()).getDate() + '';
                this._loadFaviconCalendar(currentDay);
            },
            _loadFaviconCalendar: function (day) {
                var canvas = $('<canvas />'),
                // create image node
                    image = $('<img />'),
                // clone current favicon link node
                    links = $("link[rel~='icon']");

                // set the number/text you want to overlay your icon
                // browser check, only create image and new link node if
                //        browser supports canvas node operations
                if (typeof canvas.get(0).getContext === 'function')
                {

                    if (!links)
                    {
                        links = document.createElement("link");
                        links.setAttribute("rel", "shortcut icon");
                        links.type = "image/x-icon";
                        document.head.appendChild(links);
                    }

                    canvas.attr({
                        width: 32, // set width
                        height: 32 // set height
                    });

                    // get the canvas context
                    var context = canvas.get(0).getContext('2d');
                    var realContextPath = AJS.Meta.get("static-resource-url-prefix") || Confluence.getContextPath();

                    // add an on load event handler for the image will
                    // get triggered when you set the src attribute//
                    // of your favicon image, and its this image that will
                    // have a number overlayed it
                    image.load(function ()
                    {
                        // draw a copy of the orignal image
                        context.drawImage(this, 0, 0);
                        context.font = 'bold 17px "helvetica", sans-serif';
                        context.textAlign = 'center';
                        context.fillStyle = '#42526E';
                        context.fillText(day, 16, 25);

                        //is IE 11 load default icon calendar
                        var IE11 = !!navigator.userAgent.match(/Trident\/7.0/) &&
                            !!navigator.userAgent.match(/.NET4.0E/);
                        // set the href attribute of the cloned link tag
                        // to the data url of the newly generated image

                        links.each(function () {
                            if (IE11) {
                                this.href = realContextPath +
                                '/download/resources/com.atlassian.confluence.extra.team-calendars:calendar-resources/img/logo_16.png';
                            } else  {
                                this.href = canvas.get(0).toDataURL('image/png');
                            }
                        });

                        // append the new link tag to the bottom of the head,
                        // which will override the existing favicon link node
                        $('head').append(links);
                    });

                    // trigger the load the new image by setting the src
                    // attribute to the image you want to overlay your text with
                    image.attr({
                        src: realContextPath +
                            '/download/resources/com.atlassian.confluence.extra.team-calendars:calendar-resources/img/calendar-favicon.png'
                    });
                }
            }
        };
});
}catch(e){WRMCB(e)};
;
try {
/* module-key = 'com.atlassian.confluence.extra.team-calendars:calendar-resources', location = 'com/atlassian/confluence/extra/calendar3/js/upcoming-events.js' */

jQuery(function($) {

    if ($("#dashboard-get-started").length > 0)
    {
        $("#dashboard-get-started").parent().after($(".dashboard-calendar-container").children());
    }
    else
    {
        $(".welcome-message").after($(".dashboard-calendar-container").children());
    }


    var UpcomingEvents = {
        initializeAddLater : function(dashboardCalendar, fadeSpeed) {
            var suppressShowingLargeSadCalendar = function() {
                $.ajax({
                    cache: false,
                    data: {
                        messageKey : "MESSAGE_KEY_FULL_SIZED_EMPTY_UPCOMING_EVENTS"
                    },
                    error: function() {
                        $(".show-small-sad-calendar-error", dashboardCalendar).removeClass("hidden");
                    },
                    type: "DELETE",
                    timeout: Confluence.TeamCalendars.ajaxTimeout,
                    url : $("#confluence-context-path").attr("content") + "/rest/calendar-services/1.0/calendar/preferences/messagekey.json"
                });
            };

            $(".add-later", dashboardCalendar).click(function() {
                var sadCalendar = $(".sad-calendar", dashboardCalendar);
                sadCalendar.fadeTo(fadeSpeed, 0, function() {
                    sadCalendar.addClass("small-sad-calendar").fadeTo(fadeSpeed, 1);
                    suppressShowingLargeSadCalendar();
                });

                return false;
            });
        },

        initialize : function(dashboardCalendar) {
            this.initializeAddLater(dashboardCalendar, "fast");
        }
    };

    $(".dashboard-calendar").each(function() {
        UpcomingEvents.initialize($(this));
    });
});

}catch(e){WRMCB(e)};