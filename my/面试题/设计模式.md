---
typora-root-url: ../../../typora
---

[TOC]

# 单例模式

单例模式就是一个类在任何情况下决绝只有一个实例，并且提供一个全局访问点来获取这样一个实例。

实现单例最少满足两个点:

1. 私有化构造方法：防止被外部实例化造成多个实例。
2. 提供一个静态方法作为全局访问点。



单例模式的实现方式：

- 饿汉模式
- 懒汉模式
- 双重检查
- 静态内部类
- 枚举



懒汉模式：在类加载时就触发了类的实例化，避免多线程同步的问题。

```java
public class Singleton{
   private static Singleton instance = new Singleton();
   private Singleton(){}
   public static Singleton getInstance(){
     return instance;
   }
}
```



在静态块里实例化：与懒汉模式原理是一样的。

```java
public class Singleton{
   private static Singleton instance;
   static {
     instance=new Singleton();
   }
   private Singleton(){}
   public static Singleton getInstance(){
     return instance;
   }
}
```



静态内部类：由于静态内部类，只有在调用静态内部方法时，才会加载静态内部类。所以 Singleton 加载时不会加载 SingletonHolder，从而到达延迟加载的效果。

```java
public class Singleton{
  public static class SingletonHolder{
    private static final Singleton INSTANCE = new Singleton();
  }
   private Singleton(){}
   public static Singleton getInstance(){
     return SingletonHolder.INSTANCE;
   }
}
```



饿汉模式：延迟加载，使用 synchronized 同步。问题：每次获取实例都需要加锁，效率低下。

```java
public class Singleton{
   private static Singleton instance;
   private Singleton(){}
   public static synchronized Singleton getInstance(){
     if(instance==null){
       instance = new Singleton();
     }
     return instance;
   }
}
```



双重检查：通过双重检查，减少锁的范围来提升性能。

```java
public class Singleton{
   private static Singleton instance;
   private Singleton(){}
   public static Singleton getInstance(){
     if(instance==null){
       synchronized(Singleton.class){
         if(instance ==null){
           instance = new Singleton();
         }
       }
     }
     return instance;
   }
}
```



枚举：既能避免多线程的同步问题，又能防止反序列化重新创建新的对象。这也是一个比较好的方案。

```java
public enum Singleton{
  INSTANCE;
  public void doSomeThing(){
    
  }
}
```



