---
typora-root-url: ../images
---

[TOC]

# 背景

![](/sb/8a82e956-c9e5-41bb-bb96-8497f2cc50b4.png)

在综合搜索页，Query 等于标的名或者标的 Symbol 占总搜索的 78.5%，而 Query 个数约为 2.5 万。

此场景的特点：

1. Query 占比高（用户需求高）
2. Query 个数少（Query 固定）



因此，我们可以离线准备好已模型排序的帖子列表，并推到线上。

此方案好处：

1. 对于此场景，性能极好，在线服务只需要从缓存读取。
2. 由于 Query 个数少，缓存占用不大。
3. 可以尝试复杂的排序模型，不需要考虑性能问题，为用户提供更好的排序效果。
4. 满足用户 78.5% 的搜索需求。



# 架构图



![](/sb/9e885ba4-c9d8-4bb3-af8b-2611078e2387.png)

**search-konwing-query 项目职责**

1. 提供 GRPC 服务，供线上搜索使用
2. MQ 通知 Search-query-stock-task 更新缓存



**search-knowing-query-task 项目职责**

1. 接受 MQ 消息，从 ES 召回帖子，并调用 search-rank 进行模型排序，将排序结果写入 Redis



# 项目定位

search-knowing-query 定位是预加载系统。在雪球很多场景下，可以提前加载好数据，等用户访问时直接返回。从而提高用户体验，优化了服务的性能，确保了服务的稳定。



优点

1. 提升服务性能
   1. 算法可以尝试复杂的排序模型和更多的特征，不需要考虑性能问题，为用户提供更好的排序效果

1. 提升服务稳定性
   1. Knowing-query 在一定程度上可以做灾备。

缺点

1. 时效性差：由于使用缓存技术，提高服务性能（10分钟）

   1. 未来不适合承接：实时性特征

   

# 畅想未来承接场景

**承接条件**

1. 业务场景适合预加载
2. 耗时严重，需要性能提升。或者业务重要，需要兜底。



**畅想**

1. 帖子召回 + 模型排序

   1. 时效性差的解决方案

   ![](/sb/1280X1280.png)

2. 雪球 VS 百度效果

1.  业务特点：query 是长尾。

2.  长尾 query redis 时间太短，命中离低。

3.  爬百度结果容易失败。即使爬百度成功了，redis 失效了，下一次爬虫又可能失败了。

4.  导致：服务不稳定，影响效果评估。

5. 

![](/sb/1280X1280 (1).png)

![](/sb/1280X1280 (2).png)



1. ES 集群挂了，Knowing-query 可以做灾备

1. 根据用户超前行为，预加载数据

用户登录 --> 加载首页推荐数据



# VS 前置缓存

前置缓存的使命：用户在综合搜索第一页命中缓存时，非常快。

**前置缓存特点：**

1. 只缓存第一页数据，缓存接口所有字段。

1. 缓存被动失效，失效后再加载数据，此时的性能让线上服务承担。

1. 缓存时机是最后一步，不能灵活缓存中间步骤的结果。

![](/sb/1280X1280 (3).png)



![](/sb/img_v2_049897b2-cf43-4644-8542-3bb5d9b92d2g.jpg)