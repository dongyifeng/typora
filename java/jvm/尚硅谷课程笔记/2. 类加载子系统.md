---
typora-root-url: ../../../../typora
---

[TOC]

![](/images/java/screenshot-20221118-112451.png)



# 类的加载过程

## 加载

1. 通过一个类的<font color=orange>全限定名</font>获取定义此类的二进制字节流。
2. 将这个字节流所代表的<font color=orange>静态存储结构转化为方法区</font>的运行时数据结构。
3. <font color=red>在内存中生产一个代表这个类 java.lang.Class 对象</font>，作为方法区这个类的各种数据的访问入口。



加在 .class 文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景：web Applet
- 从 zip 压缩包中读取，成为日后 jar，war 格式的基础。
- 运行时计算生产，使用最多的是：动态代理技术
- 由其他文件生成，典型场景：JSP 应用
- 从专有数据库中提取 .class 文件，比较少见
- 从加密文件中获取，典型的防 Class 文件被反编译的保护措施。

## 链接

### 验证（Verify）

目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，**保证被加载类的正确性。**

四种验证

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

![](/images/java/screenshot-20221118-221813.png)

cafe babe 就是字节码文件的魔术码。



### 准备（Prepare）

为类变量（静态变量）分配内存并且设置该类变量的默认初始值，即零值。

这里不包含用 final 修饰的 static 字段，因为 <font color=red>final 在**编译**的时候就会分配了</font>，准备阶段会显示初始化。

这里不会为实例变量分配初始化，类变量（静态变量）会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。此时是类的加载过程，还没到实例创建的。



```java
public class Prepare {
    // 在 prepare 阶段 a 被赋值为默认值：0
    // 在 initialization 阶段才被赋值为：1
    private static int a = 1;

<<<<<<< HEAD
## 解析（Resolve）
=======
    public static void main(String[] args) {
        System.out.println(a);
    }
}
```

 

### 解析（Resolve）

<font color=green>将常量池内的符号引用转换为直接引用的过程。</font>

事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。

一个类代码很短，但是要运行起来，它需要引入很多其他类，这些引用在字节码文件中是以符号引用的形式存在。在解析这个阶段，将其装换成直接引用（被引用的类优先加载，这就牵涉到类的加载顺序），这也是这个大阶段为什么叫：链接（Linking）。

![](/images/java/screenshot-20221124-100615.png)



## 初始化

类对象（java.lang.Class 对象）的初始化阶段就是：<font color=green>执行类构造器方法`<clinit>()` 的过程。</font>

`<clinit>()` 是 javac 编译器自动收集类中的所有类变量（静态变量）的赋值动作和静态代码块中的语句合并而来。

`<clinit>()` 中指令按语句在源文件中出现的顺序执行。

```java
public class InitTest {
    static {
        num = 20;
        // 报错：非法前向引用。
//      System.out.println(num); 
    }

    // linking 的 prepare: num = 0
    // initialization num = 20; --> num = 10
    private static int num = 10;

    public static void main(String[] args) {
        System.out.println(num);
    }
}
```

![](/images/java/screenshot-20221124-110855.png)



注意：如果类中没有静态变量和静态块，javac 不会生成 `<clinit>()` 方法。

```java
public class InitTest2 {
    private int num = 10;
    public InitTest2() {
        num = 20;
    }
}
```

![](/images/java/screenshot-20221124-112402.png)



如果该类有父类，JVM 会保证子类的 `<clinit>()`  执行前，父类的 `<clinit>()`  已经执行完毕了。

```java
public class InitTest3 {
    static class Father {
        static {
            A = 2;
        }

        public static int A = 1;
    }

    static class Son extends Father {
        public static int B = A;
    }

    public static void main(String[] args) {
        // 加载 Son 之前，要先加载 Father（ loding --> linking --> initialization 全流程），此时 Father.A = 1
        // 加载 Son；Son.B = Father.A = 1
        System.out.println(Son.B);
    }
}
```

![](/images/java/screenshot-20221124-113429.png)



虚拟机必须保证一个类的 `<clinit>()` 方法在多线程下被同步加锁。



```java
public class DeadThreadTest {
    public static void main(String[] args) {
        Runnable r = () -> {
            System.out.println(Thread.currentThread().getName() + "开始");
            DeadThread deadThread = new DeadThread();
            System.out.println(Thread.currentThread().getName() + "结束");
        };

        Thread t1 = new Thread(r, "线程1");
        Thread t2 = new Thread(r, "线程2");

        t1.start();
        t2.start();
    }

    static class DeadThread {
        static {
            if (true) {
              // 只会被执行一次
                System.out.println(Thread.currentThread().getName() + "初始化当前类");
                while (true) {

                }
            }
        }
    }
}
```



# 类加载器的分类

JVM 的分类：

- 引导类加载器（Bootstrap ClassLoader）：使用 C/C++ 实现的，嵌套在 JVM 内部。
- 自定义类加载器（User-Definded ClassLoader）：所有派生于抽象类 ClassLoader 的类加载器，使用 Java 实现





日常开发中常见的类加载器：

根据 JVM 分类，蓝色方框内类加载器都是自定义类加载器。

<font color=red>**注意：下图四者之间包含关系（优先级关系），而不是子父类的继承关系。**</font>

![](/images/java/screenshot-20221125-101413.png)



AppClassLoader 和 ExtClassLoader 都间接继承 ClassLoader 都是自定义类加载器。

![](/images/java/screenshot-20221124-121832.png)



![](/images/java/screenshot-20221124-121658.png)



```java
public static void main(String[] args) {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);
        // sun.misc.Launcher$AppClassLoader@18b4aac2

        // 获取其上层：扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);
        //sun.misc.Launcher$ExtClassLoader@355da254

        // 获取其上层：获取不到引导类加载器
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);
        // null

        // 用户自定义类的类加载器：默认使用系统类加载器
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);
        //sun.misc.Launcher$AppClassLoader@18b4aac2

        // String 类使用引导类加载器进行加载
        // Java 的核心类库都是使用引导类加载器进行加载
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1);
        // null
    }
```



## JVM 自带的加载器

### Bootstrap ClassLoader

Bootstrap ClassLoader 为什么不用 Java 实现？

Bootstrap ClassLoader 用户加载 Java 的核心类库，只有这些核心类库加载了，JVM 环境准备好了，才能运行 Java 程序，如果 Bootstrap ClassLoader 用 Java 实现，Bootstrap ClassLoader 运行时 JVM 还没准备好，无法运行Java 程序，就像一个人无法薅着自己的头发，将自己提起。因此 Bootstrap ClassLoader 必须找一个脱离 JVM 也可以运行的程序实现。所以 Bootstrap ClassLoader 并不继承 java.Lang.ClassLoader。

<font color=green>Bootstrap ClassLoader 加载Java 的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或者 sun.boot.class.path 路径下的内容）。用于提供 JVM 自身需要的类。</font>



扩展类加载器是由：Bootstrap ClassLoader 加载，并指定为父类加载器。

处于安全考虑：Bootstrap ClassLoader 只加载包名 java、javax、sum等开头的类。





### 扩展类加载器（Extension ClassLoader）

-  Java 语言编写，sun.misc.Launcher$ExtClassLoader
- 派生于 ClassLoader 类
- 父类加载器为：Bootstrap ClassLoader
- 从 java.ext.dirs 系统属性指定的目录中加载器类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动有扩展类加载器加载。



### 应用程序类加载器（系统类加载器，AppClassLoader）

-  Java 语言编写，sun.misc.Launcher$AppClassLoader
- 派生于 ClassLoader 类
- 父类加载器为：扩展类加载器
- 它负责加载环境变量：classpath 或者系统属性 java.class.path 指定路径下的类库。
- <font color=red>该类加载时程序中默认的类加载器，</font>一般来说，Java 应用的类都是由它来完成加载。
- 通过 ClassLoader.getSystemClassLoader() 获取该类加载器。

 

```java
    public static void main(String[] args) {
        // 获取 BootstrapClassLoader 能够加载的 api 的路径
        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
        for (URL url : urLs) {
            System.out.println(url.toExternalForm());
        }
        /*
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/sunrsasign.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar
        file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/classes
         */

        // 从上面的路径中随意选择一个类
        ClassLoader classLoader = Provider.class.getClassLoader();
        System.out.println(classLoader);
        // null


        System.out.println("----------------------");

        // 扩展类加载器
        String property = System.getProperty("java.ext.dirs");
        for (String path : property.split(":")) {
            System.out.println(path);
        }
        /*
        /Users/dongyf/Library/Java/Extensions
        /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext
        /Library/Java/Extensions
        /Network/Library/Java/Extensions
        /System/Library/Java/Extensions
        /usr/lib/java
         */

        // 从上面的路径中随意选择一个类
        ClassLoader classLoader1 = CurveDB.class.getClassLoader();
        System.out.println(classLoader1);
        // sun.misc.Launcher$ExtClassLoader@27c170f0
    }
```



## 用户自定义类加载器

需要用户自定义类加载器的场景

- 隔离加载类：根据不同场景加载不同的类。 
- 修改类的加载的方式
- 扩展加载源：动态加载 jar，热修复线上 bug。
- 防止源码泄漏：防止字节码文件被反编译和篡改，对字节码文件加密，解密后再加载。



步骤：

通过继承抽象类：java.lang.ClassLoader 类的方式，重写 findClass 方法

```java
public class CustomClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] result = getClassFromCustomPath(name);
            if (result == null) {
                throw new FileNotFoundException();
            } else {
                return defineClass(name, result, 0, result.length);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 从自定义路径中加载指定字节码文件
    private byte[] getClassFromCustomPath(String name) {
        // 如果指定路径的字节码文件进行了加密，在此处解密
        return null;
    }
}
```



直接继承 URLClassLoader 类，这样避免编写 findClass() 方法以及获取字节码流的方式。代码更简洁。

```java
```





## 关于 ClassLoader

- 一个抽象类

| 方法名                                             | 描述                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| getParent()                                        | 返回该类加载器的超类加载器                                   |
| loadClass(String name)                             | 查找名称 name 的类，返回结果为 java.lang.Class 类的实例      |
| findClass(String name)                             | 查找名称 name 的类，返回结果为 java.lang.Class 类的实例      |
| findLoadedClass(String name)                       | 查找名称 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例 |
| defineClass(String name,byte[] b, int off,int len) | 把字节数组 b 中的内容转换为一个 Java 类，返回结果为 Java.lang.Class 类的实例 |
| resolveClass(Class<?> e)                           | 连接指定一个 Java 类                                         |



sun.misc.Launcher 是 java 虚拟机的入口应用。

![](/images/java/screenshot-20221124-163858.png)



获取 ClassLoader 的途径

- clazz.getClassLoader：获取当前类的 ClassLoader

```java
    public static void main(String[] args) {
        try {
            ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
            System.out.println(classLoader);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
```



- Thread.currentThread().getContextClassLoader()：获取当前线程上下文的 ClassLoader
- ClassLoader.getSystemClassLoader()：获取系统的 ClassLoader
- DriverManager.getCallerClassLoader()：获取调用者的 ClassLoader





# 双亲委派机制

Java 虚拟机对 class 文件采用的是<font color=red>**按需加载**</font>的方式，也就是当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而加载某个类的class 文件时，Java 虚拟机采用的是<font color=red>**双亲委派模式**</font>。



## 双亲委派机制的工作原理

1. 如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把把这个请求委托给父类的加载器去执行。
2. 如果父类加载器还存在其父类加载器，则进一步上向委托，依次递归，请求最终将到达顶层的启动类加载器。
3. 如果父类加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。



![](/images/java/screenshot-20221124-191345.png)



**例一**

自定义 String，有个静态代码块，如果自定义的 String 类被加载，那么静态代码块一定会执行。

```java
package java.lang;

public class String {
    static {
        System.out.println("我是自定义的 String 类的静态代码块");
    }
}
```



下边代码中需要加载 String 类，系统类加载器会委托给扩展类加载器，再向上委托给启动类加载器。启动类加载器一看是加载 String 类，是自己的本质工作，就完成了加载（加载了系统的 String 类，而不是自定义的 String 类），所以自定义 String 类中静态代码块没有执行。

而 StringTest 类的加载，系统类加载器一路委托给启动类加载器，再有启动类加载器一路下放给系统类加载器。

```java
public class StringTest {
    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();
        System.out.println("Hello world!");
  			System.out.println(StringTest.class.getClassLoader());
    }
}
// 执行结果：
// Hello world!
// sun.misc.Launcher$AppClassLoader@18b4aac2
// 说明自定义 String 类没有加载。
```



如下图：由于启动类加载器加载了系统 String 类，而系统 String 类没有 main 方法，所以报下边的错误。

![](/images/java/screenshot-20221124-192652.png)



**例二**

SPI 接口属于核心API，SPI 的接口有启动类加载进行加载，而 SPI 接口的具体的实现类，需要使用系统类加载器进行加载。

![](/images/java/screenshot-20221124-194432.png)



## 优势

- 避免类的重复加载
- 保护程序安全，防止核心 API 被随意篡改。



启动类加载器看到 DyfString 类，认为此类归它加载，但是加载失败了。

![](/images/java/screenshot-20221124-195130.png)



## 沙箱安全机制

自定义 String 类，在加载自定义 String 类的时候会率先使用引导类加载器，而引导类加载器在加载过程中会优先加载 jdk 自带的文件（rt.jar 包中 java.lang.String.class），报错信息说没有 main 方法，就是英文加载的是 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是<font color=red>**沙箱安全机制**</font>。



![](/images/java/screenshot-20221124-192652.png)





# 其他

在 JVM 中表示两个 Class 对象是否为同一个类，两个必要条件

- 类的完整类名必须一致，包括包名。
- 加载这个类的 CLassLoader（指 ClassLoader 实例对象）必须相同。



如果一个类型是由用户类加载器加载的，那么 JVM 会<font color=red>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</font>当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。


>>>>>>> 9c7504573601d8e5e3e126772ee892bf2cfe895e



Java 程序对类的使用方式

- 主动使用
- 被动使用

主动使用

- 创建类的实例
- 访问某个类或类的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（比如：Class.forName(“java.lang.String”)）
- 初始化一个类的子类
- Java 虚拟机启动时被标明为启动类
- JDK 7 开始支持的动态语言支持：Java.lang.invoke.MethodHandle 实例的解析结果



除了以上七种情况，其他使用 Java 类的方式都被看作是对<font color=red>**类的被动使用，都不会导致类的初始化**。</font>

