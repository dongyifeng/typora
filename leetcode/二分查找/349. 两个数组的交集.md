难度：<font color=green>简单</font>

> 给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```python
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```



**示例 2：**

```python
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
```



**思路一：作弊，使用交集函数**

**代码：**

```python
def intersection(nums1, nums2):
    return set(nums1) & set(nums2)
```



**思路二：使用 set**

时间复杂度：O(n)

空间复杂度：O(n)

**代码：**

```python
def intersection2(nums1, nums2):
    nums1_set = set(nums1)
    return set([item for item in nums2 if item in nums1_set])
```



**思路三：使用 bitArray**

时间复杂度：O(n)

空间复杂度：O(1)

**代码：**

```python
class BloomFilter:
    def __init__(self, nums):
        self.data = 0
        for num in nums:
            self.add(num)

    def contains(self, num):
        return (self.data >> (num - 1)) & 1 == 1

    def add(self, num):
        self.data |= 1 << (num - 1)


def intersection2_1(nums1, nums2):
    bloom_filter = BloomFilter(nums1)
    return set([item for item in nums2 if bloom_filter.contains(item)])
```



**思路四：排序 + 双指针**

时间复杂度：O(nlogn)

空间复杂度：O(1)

```python
def intersection3(nums1, nums2):
    nums1.sort()
    nums2.sort()
    index1 = 0
    index2 = 0
    result = set()
    while index1 < len(nums1) and index2 < len(nums2):
        if nums1[index1] == nums2[index2]:
            result.add(nums2[index2])
            index2 += 1
            index1 += 1
        elif nums1[index1] > nums2[index2]:
            index2 += 1
        elif nums1[index1] < nums2[index2]:
            index1 += 1
    return result
```

